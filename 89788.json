{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#stateVersionParamTest().mjava","sourceNew":"  private void stateVersionParamTest() throws Exception {\n    CloudSolrClient client = createCloudClient(null);\n    try {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName);\n\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, collectionName+\":\"+ (coll.getZNodeVersion() -1)); //an older version expect error\n\n      HttpSolrClient.RemoteSolrException sse = null;\n      try {\n        solrClient.query(q);\n        log.info(\"expected query error\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      solrClient.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \", sse.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n      solrClient = new HttpSolrClient(theNode + \"/\"+collectionName);\n\n      q.setParam(CloudSolrClient.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n\n      try {\n        solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      solrClient.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n    } finally {\n      client.shutdown();\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      HttpSolrServer httpSolrServer = new HttpSolrServer(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName);\n\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n\n      log.info(\"should work query, result {}\", httpSolrServer.query(q));\n      //no problem\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", httpSolrServer.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+ (coll.getZNodeVersion() -1)); //an older version expect error\n\n      HttpSolrServer.RemoteSolrException sse = null;\n      try {\n        httpSolrServer.query(q);\n        log.info(\"expected query error\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n      httpSolrServer = new HttpSolrServer(theNode + \"/\"+collectionName);\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n\n      try {\n        httpSolrServer.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n    } finally {\n      client.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      try (HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        try {\n          solrClient.query(q);\n          log.info(\"expected query error\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n\n        assertNotNull(sse);\n        assertEquals(\" Error code should be \", sse.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n      }\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      try (SolrClient solrClient = new HttpSolrClient(theNode + \"/\"+collectionName)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        try {\n          solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be \", sse.code(), SolrException.ErrorCode.INVALID_STATE.code);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n    CloudSolrClient client = createCloudClient(null);\n    try {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName);\n\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, collectionName+\":\"+ (coll.getZNodeVersion() -1)); //an older version expect error\n\n      HttpSolrClient.RemoteSolrException sse = null;\n      try {\n        solrClient.query(q);\n        log.info(\"expected query error\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      solrClient.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \", sse.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n      solrClient = new HttpSolrClient(theNode + \"/\"+collectionName);\n\n      q.setParam(CloudSolrClient.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n\n      try {\n        solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      solrClient.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n    } finally {\n      client.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a20a867de92263c94258f9778db64a5efc7956d","date":1424955868,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      try (HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      try (SolrClient solrClient = new HttpSolrClient(theNode + \"/\"+collectionName)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      try (HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        try {\n          solrClient.query(q);\n          log.info(\"expected query error\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n\n        assertNotNull(sse);\n        assertEquals(\" Error code should be \", sse.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n      }\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      try (SolrClient solrClient = new HttpSolrClient(theNode + \"/\"+collectionName)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        try {\n          solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be \", sse.code(), SolrException.ErrorCode.INVALID_STATE.code);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      try (HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      try (SolrClient solrClient = new HttpSolrClient(theNode + \"/\"+collectionName)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      try (HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        try {\n          solrClient.query(q);\n          log.info(\"expected query error\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n\n        assertNotNull(sse);\n        assertEquals(\" Error code should be \", sse.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n      }\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      try (SolrClient solrClient = new HttpSolrClient(theNode + \"/\"+collectionName)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        try {\n          solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be \", sse.code(), SolrException.ErrorCode.INVALID_STATE.code);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" +collectionName;\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      \n      final String solrClientUrl = theNode + \"/\" + collectionName;\n      try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      try (HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      try (SolrClient solrClient = new HttpSolrClient(theNode + \"/\"+collectionName)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" +collectionName;\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      \n      final String solrClientUrl = theNode + \"/\" + collectionName;\n      try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      try (HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      try (SolrClient solrClient = new HttpSolrClient(theNode + \"/\"+collectionName)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b940572a59da1b42b6c20ab5278155b12816807a","date":1462388874,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" +collectionName;\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      \n      final String solrClientUrl = theNode + \"/\" + collectionName;\n      try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd78ba595fa6cdd7fff930f26d154d13a823fa47","date":1462400514,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" +collectionName;\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      \n      final String solrClientUrl = theNode + \"/\" + collectionName;\n      try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" +collectionName;\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      \n      final String solrClientUrl = theNode + \"/\" + collectionName;\n      try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n\n    try (CloudSolrClient client = createCloudClient(null)) {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 1, 3);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n      HttpSolrClient.RemoteSolrException sse = null;\n\n      final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" +collectionName;\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n        log.info(\"should work query, result {}\", solrClient.query(q));\n        //no problem\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n        //no error yet good\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n        QueryResponse rsp = solrClient.query(q);\n        Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n        assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n        assertNotNull(m.get(collectionName));\n      }\n\n      //now send the request to another node that does not serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      Set<String> liveNodes = client.getZkStateReader().getClusterState().getLiveNodes();\n      for (String s : liveNodes) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(n)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"the node which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n\n      \n      final String solrClientUrl = theNode + \"/\" + collectionName;\n      try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n        q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + (coll.getZNodeVersion()-1));\n        try {\n          QueryResponse rsp = solrClient.query(q);\n          log.info(\"error was expected\");\n        } catch (HttpSolrClient.RemoteSolrException e) {\n          sse = e;\n        }\n        assertNotNull(sse);\n        assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"177e0a3b3d5d15f9cc40e392177343f6945f0fec","date":1539157346,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION, cluster.getSolrClient().getZkStateReader(),\n        false, true, TIMEOUT);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void stateVersionParamTest() throws Exception {\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION, cluster.getSolrClient().getZkStateReader(),\n        false, true, TIMEOUT);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":["177e0a3b3d5d15f9cc40e392177343f6945f0fec"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db96734b79e26d948b59f68bd4564c4836a71acf","date":1585375566,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    HttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      if (log.isInfoEnabled()) {\n        log.info(\"should work query, result {}\", solrClient.query(q));\n      }\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      if (log.isInfoEnabled()) {\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n      }\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ba1b632c041956c93c41aa1143d16a567014891","date":1592328473,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","sourceNew":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      if (log.isInfoEnabled()) {\n        log.info(\"should work query, result {}\", solrClient.query(q));\n      }\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      if (log.isInfoEnabled()) {\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n      }\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      @SuppressWarnings({\"rawtypes\"})\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void stateVersionParamTest() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(COLLECTION, 2, 2);\n\n    DocCollection coll = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COLLECTION);\n    Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n    SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n    BaseHttpSolrClient.RemoteSolrException sse = null;\n\n    final String url = r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\" + COLLECTION;\n    try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n\n      if (log.isInfoEnabled()) {\n        log.info(\"should work query, result {}\", solrClient.query(q));\n      }\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + coll.getZNodeVersion());\n      if (log.isInfoEnabled()) {\n        log.info(\"2nd query , result {}\", solrClient.query(q));\n      }\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion() - 1)); //an older version expect error\n\n      QueryResponse rsp = solrClient.query(q);\n      Map m = (Map) rsp.getResponse().get(CloudSolrClient.STATE_VERSION, rsp.getResponse().size()-1);\n      assertNotNull(\"Expected an extra information from server with the list of invalid collection states\", m);\n      assertNotNull(m.get(COLLECTION));\n    }\n\n    //now send the request to another node that does not serve the collection\n\n    Set<String> allNodesOfColl = new HashSet<>();\n    for (Slice slice : coll.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n      }\n    }\n    String theNode = null;\n    Set<String> liveNodes = cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes();\n    for (String s : liveNodes) {\n      String n = cluster.getSolrClient().getZkStateReader().getBaseUrlForNodeName(s);\n      if(!allNodesOfColl.contains(n)){\n        theNode = n;\n        break;\n      }\n    }\n    log.info(\"the node which does not serve this collection{} \",theNode);\n    assertNotNull(theNode);\n\n\n    final String solrClientUrl = theNode + \"/\" + COLLECTION;\n    try (SolrClient solrClient = getHttpSolrClient(solrClientUrl)) {\n\n      q.setParam(CloudSolrClient.STATE_VERSION, COLLECTION + \":\" + (coll.getZNodeVersion()-1));\n      try {\n        QueryResponse rsp = solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (BaseHttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      assertNotNull(sse);\n      assertEquals(\" Error code should be 510\", SolrException.ErrorCode.INVALID_STATE.code, sse.code());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ba1b632c041956c93c41aa1143d16a567014891":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["db96734b79e26d948b59f68bd4564c4836a71acf"],"0a20a867de92263c94258f9778db64a5efc7956d":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["177e0a3b3d5d15f9cc40e392177343f6945f0fec"],"73450c0955930295d34703e7ddbfc6973b7a121a":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","b940572a59da1b42b6c20ab5278155b12816807a"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["0a20a867de92263c94258f9778db64a5efc7956d"],"177e0a3b3d5d15f9cc40e392177343f6945f0fec":["73450c0955930295d34703e7ddbfc6973b7a121a"],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b940572a59da1b42b6c20ab5278155b12816807a":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"bd78ba595fa6cdd7fff930f26d154d13a823fa47":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","b940572a59da1b42b6c20ab5278155b12816807a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["cc3b13b430571c2e169f98fe38e1e7666f88522d","0a20a867de92263c94258f9778db64a5efc7956d"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["0a20a867de92263c94258f9778db64a5efc7956d","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"db96734b79e26d948b59f68bd4564c4836a71acf":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ba1b632c041956c93c41aa1143d16a567014891"]},"commit2Childs":{"9ba1b632c041956c93c41aa1143d16a567014891":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["9ba1b632c041956c93c41aa1143d16a567014891"],"0a20a867de92263c94258f9778db64a5efc7956d":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["db96734b79e26d948b59f68bd4564c4836a71acf"],"73450c0955930295d34703e7ddbfc6973b7a121a":["177e0a3b3d5d15f9cc40e392177343f6945f0fec","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"177e0a3b3d5d15f9cc40e392177343f6945f0fec":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bafca15d8e408346a67f4282ad1143b88023893b":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"b940572a59da1b42b6c20ab5278155b12816807a":["73450c0955930295d34703e7ddbfc6973b7a121a","bd78ba595fa6cdd7fff930f26d154d13a823fa47"],"bd78ba595fa6cdd7fff930f26d154d13a823fa47":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["73450c0955930295d34703e7ddbfc6973b7a121a","b940572a59da1b42b6c20ab5278155b12816807a","bd78ba595fa6cdd7fff930f26d154d13a823fa47","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"db96734b79e26d948b59f68bd4564c4836a71acf":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["0a20a867de92263c94258f9778db64a5efc7956d","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bd78ba595fa6cdd7fff930f26d154d13a823fa47","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}