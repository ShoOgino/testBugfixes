{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSort(HeapPointWriter,int,int,int,int).mjava","commits":[{"id":"c2344a1c769566d8c85cffcacc5e55153fa54b86","date":1550661298,"type":0,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSort(HeapPointWriter,int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Sort the heap writer by the specified dim. It is used to sort the leaves of the tree */\n  public void heapRadixSort(final HeapPointWriter points, int from, int to, int dim, int commonPrefixLength) {\n    final int offset = dim * bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = bytesPerDim - commonPrefixLength;\n    new MSBRadixSorter(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k - dimCmpBytes);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected Sorter getFallbackSorter(int k) {\n        int skypedBytes = k + commonPrefixLength;\n        final int start = dim * bytesPerDim + skypedBytes;\n        final int end =  dim * bytesPerDim + bytesPerDim;\n        return new IntroSorter() {\n\n          int pivotDoc = -1;\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            pivotDoc = points.docIDs[i];\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesLength;\n              int jOffset = j * packedBytesLength;\n              int cmp = FutureArrays.compareUnsigned(points.block, iOffset + start, iOffset + end,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return points.docIDs[i] - points.docIDs[j];\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesLength;\n              int cmp = FutureArrays.compareUnsigned(scratch, skypedBytes, bytesPerDim,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return pivotDoc - points.docIDs[j];\n          }\n        };\n      }\n    }.sort(from, to);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSort(HeapPointWriter,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSort(HeapPointWriter,int,int,int,int).mjava","sourceNew":"  /** Sort the heap writer by the specified dim. It is used to sort the leaves of the tree */\n  public void heapRadixSort(final HeapPointWriter points, int from, int to, int dim, int commonPrefixLength) {\n    final int offset = dim * bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = bytesPerDim - commonPrefixLength;\n    new MSBRadixSorter(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k - dimCmpBytes);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected Sorter getFallbackSorter(int k) {\n        int skypedBytes = k + commonPrefixLength;\n        final int start = dim * bytesPerDim + skypedBytes;\n        final int end =  dim * bytesPerDim + bytesPerDim;\n        return new IntroSorter() {\n\n          int pivotDoc = -1;\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            pivotDoc = points.docIDs[i];\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesLength;\n              int jOffset = j * packedBytesLength;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + start, iOffset + end,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return points.docIDs[i] - points.docIDs[j];\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesLength;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return pivotDoc - points.docIDs[j];\n          }\n        };\n      }\n    }.sort(from, to);\n  }\n\n","sourceOld":"  /** Sort the heap writer by the specified dim. It is used to sort the leaves of the tree */\n  public void heapRadixSort(final HeapPointWriter points, int from, int to, int dim, int commonPrefixLength) {\n    final int offset = dim * bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = bytesPerDim - commonPrefixLength;\n    new MSBRadixSorter(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k - dimCmpBytes);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected Sorter getFallbackSorter(int k) {\n        int skypedBytes = k + commonPrefixLength;\n        final int start = dim * bytesPerDim + skypedBytes;\n        final int end =  dim * bytesPerDim + bytesPerDim;\n        return new IntroSorter() {\n\n          int pivotDoc = -1;\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            pivotDoc = points.docIDs[i];\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesLength;\n              int jOffset = j * packedBytesLength;\n              int cmp = FutureArrays.compareUnsigned(points.block, iOffset + start, iOffset + end,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return points.docIDs[i] - points.docIDs[j];\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesLength;\n              int cmp = FutureArrays.compareUnsigned(scratch, skypedBytes, bytesPerDim,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return pivotDoc - points.docIDs[j];\n          }\n        };\n      }\n    }.sort(from, to);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7f06758793500ca773d0df1037290e6e404fb33","date":1562230223,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSort(HeapPointWriter,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSort(HeapPointWriter,int,int,int,int).mjava","sourceNew":"  /** Sort the heap writer by the specified dim. It is used to sort the leaves of the tree */\n  public void heapRadixSort(final HeapPointWriter points, int from, int to, int dim, int commonPrefixLength) {\n    final int dimOffset = dim * bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = bytesPerDim - commonPrefixLength;\n    final int dataOffset = numIndexDims * bytesPerDim - dimCmpBytes;\n    new MSBRadixSorter(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesDocIDLength + dimOffset + k] & 0xff;\n        } else {\n          // data bytes\n          return points.block[i * packedBytesDocIDLength + dataOffset + k] & 0xff;\n        }\n      }\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected Sorter getFallbackSorter(int k) {\n        final int skypedBytes = k + commonPrefixLength;\n        final int dimStart = dim * bytesPerDim + skypedBytes;\n        final int dimEnd =  dim * bytesPerDim + bytesPerDim;\n        final int dataOffset = numIndexDims * bytesPerDim;\n        // data length is composed by the data dimensions plus the docID\n        final int dataLength = (numDataDims - numIndexDims) * bytesPerDim + Integer.BYTES;\n        return new IntroSorter() {\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesDocIDLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            System.arraycopy(points.block, i * packedBytesDocIDLength + dataOffset, scratch, bytesPerDim, dataLength);\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesDocIDLength;\n              int jOffset = j * packedBytesDocIDLength;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + dimStart, iOffset + dimEnd, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int iOffset = i * packedBytesDocIDLength + dataOffset;\n            int jOffset = j * packedBytesDocIDLength + dataOffset;\n            return Arrays.compareUnsigned(points.block, iOffset, iOffset + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesDocIDLength;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int jOffset = j * packedBytesDocIDLength + dataOffset;\n            return Arrays.compareUnsigned(scratch, bytesPerDim, bytesPerDim + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n        };\n      }\n    }.sort(from, to);\n  }\n\n","sourceOld":"  /** Sort the heap writer by the specified dim. It is used to sort the leaves of the tree */\n  public void heapRadixSort(final HeapPointWriter points, int from, int to, int dim, int commonPrefixLength) {\n    final int offset = dim * bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = bytesPerDim - commonPrefixLength;\n    new MSBRadixSorter(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesLength + offset + k] & 0xff;\n        } else {\n          // doc id\n          int s = 3 - (k - dimCmpBytes);\n          return (points.docIDs[i] >>> (s * 8)) & 0xff;\n        }\n      }\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected Sorter getFallbackSorter(int k) {\n        int skypedBytes = k + commonPrefixLength;\n        final int start = dim * bytesPerDim + skypedBytes;\n        final int end =  dim * bytesPerDim + bytesPerDim;\n        return new IntroSorter() {\n\n          int pivotDoc = -1;\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            pivotDoc = points.docIDs[i];\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesLength;\n              int jOffset = j * packedBytesLength;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + start, iOffset + end,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return points.docIDs[i] - points.docIDs[j];\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesLength;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim,\n                  points.block, jOffset + start, jOffset + end);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            return pivotDoc - points.docIDs[j];\n          }\n        };\n      }\n    }.sort(from, to);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSort(HeapPointWriter,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#heapRadixSort(HeapPointWriter,int,int,int,int).mjava","sourceNew":"  /** Sort the heap writer by the specified dim. It is used to sort the leaves of the tree */\n  public void heapRadixSort(final HeapPointWriter points, int from, int to, int dim, int commonPrefixLength) {\n    final int dimOffset = dim * config.bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = config.bytesPerDim - commonPrefixLength;\n    final int dataOffset = config.packedIndexBytesLength - dimCmpBytes;\n    new MSBRadixSorter(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * config.bytesPerDoc + dimOffset + k] & 0xff;\n        } else {\n          // data bytes\n          return points.block[i * config.bytesPerDoc + dataOffset + k] & 0xff;\n        }\n      }\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected Sorter getFallbackSorter(int k) {\n        final int skypedBytes = k + commonPrefixLength;\n        final int dimStart = dim * config.bytesPerDim + skypedBytes;\n        final int dimEnd =  dim * config.bytesPerDim + config.bytesPerDim;\n        // data length is composed by the data dimensions plus the docID\n        final int dataLength = (config.numDims - config.numIndexDims) * config.bytesPerDim + Integer.BYTES;\n        return new IntroSorter() {\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < config.bytesPerDim) {\n              System.arraycopy(points.block, i * config.bytesPerDoc + dim * config.bytesPerDim, scratch, 0, config.bytesPerDim);\n            }\n            System.arraycopy(points.block, i * config.bytesPerDoc + config.packedIndexBytesLength, scratch, config.bytesPerDim, dataLength);\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < config.bytesPerDim) {\n              int iOffset = i * config.bytesPerDoc;\n              int jOffset = j * config.bytesPerDoc;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + dimStart, iOffset + dimEnd, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int iOffset = i * config.bytesPerDoc + config.packedIndexBytesLength;\n            int jOffset = j * config.bytesPerDoc + config.packedIndexBytesLength;\n            return Arrays.compareUnsigned(points.block, iOffset, iOffset + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < config.bytesPerDim) {\n              int jOffset = j * config.bytesPerDoc;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, config.bytesPerDim, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int jOffset = j * config.bytesPerDoc + config.packedIndexBytesLength;\n            return Arrays.compareUnsigned(scratch, config.bytesPerDim, config.bytesPerDim + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n        };\n      }\n    }.sort(from, to);\n  }\n\n","sourceOld":"  /** Sort the heap writer by the specified dim. It is used to sort the leaves of the tree */\n  public void heapRadixSort(final HeapPointWriter points, int from, int to, int dim, int commonPrefixLength) {\n    final int dimOffset = dim * bytesPerDim + commonPrefixLength;\n    final int dimCmpBytes = bytesPerDim - commonPrefixLength;\n    final int dataOffset = numIndexDims * bytesPerDim - dimCmpBytes;\n    new MSBRadixSorter(bytesSorted - commonPrefixLength) {\n\n      @Override\n      protected int byteAt(int i, int k) {\n        assert k >= 0 : \"negative prefix \" + k;\n        if (k  < dimCmpBytes) {\n          // dim bytes\n          return points.block[i * packedBytesDocIDLength + dimOffset + k] & 0xff;\n        } else {\n          // data bytes\n          return points.block[i * packedBytesDocIDLength + dataOffset + k] & 0xff;\n        }\n      }\n\n      @Override\n      protected void swap(int i, int j) {\n        points.swap(i, j);\n      }\n\n      @Override\n      protected Sorter getFallbackSorter(int k) {\n        final int skypedBytes = k + commonPrefixLength;\n        final int dimStart = dim * bytesPerDim + skypedBytes;\n        final int dimEnd =  dim * bytesPerDim + bytesPerDim;\n        final int dataOffset = numIndexDims * bytesPerDim;\n        // data length is composed by the data dimensions plus the docID\n        final int dataLength = (numDataDims - numIndexDims) * bytesPerDim + Integer.BYTES;\n        return new IntroSorter() {\n\n          @Override\n          protected void swap(int i, int j) {\n            points.swap(i, j);\n          }\n\n          @Override\n          protected void setPivot(int i) {\n            if (skypedBytes < bytesPerDim) {\n              System.arraycopy(points.block, i * packedBytesDocIDLength + dim * bytesPerDim, scratch, 0, bytesPerDim);\n            }\n            System.arraycopy(points.block, i * packedBytesDocIDLength + dataOffset, scratch, bytesPerDim, dataLength);\n          }\n\n          @Override\n          protected int compare(int i, int j) {\n            if (skypedBytes < bytesPerDim) {\n              int iOffset = i * packedBytesDocIDLength;\n              int jOffset = j * packedBytesDocIDLength;\n              int cmp = Arrays.compareUnsigned(points.block, iOffset + dimStart, iOffset + dimEnd, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int iOffset = i * packedBytesDocIDLength + dataOffset;\n            int jOffset = j * packedBytesDocIDLength + dataOffset;\n            return Arrays.compareUnsigned(points.block, iOffset, iOffset + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n\n          @Override\n          protected int comparePivot(int j) {\n            if (skypedBytes < bytesPerDim) {\n              int jOffset = j * packedBytesDocIDLength;\n              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim, points.block, jOffset + dimStart, jOffset + dimEnd);\n              if (cmp != 0) {\n                return cmp;\n              }\n            }\n            int jOffset = j * packedBytesDocIDLength + dataOffset;\n            return Arrays.compareUnsigned(scratch, bytesPerDim, bytesPerDim + dataLength, points.block, jOffset, jOffset + dataLength);\n          }\n        };\n      }\n    }.sort(from, to);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7f06758793500ca773d0df1037290e6e404fb33":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["c7f06758793500ca773d0df1037290e6e404fb33"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"c7f06758793500ca773d0df1037290e6e404fb33":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["c7f06758793500ca773d0df1037290e6e404fb33"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}