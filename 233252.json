{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,FieldInfos,SegmentDocValues).mjava","commits":[{"id":"240c2c222c1b7eb253bd7e596c2d4731355836ef","date":1416366514,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,FieldInfos,SegmentDocValues).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","sourceNew":"  /**\n   * Creates a new producer that handles updated docvalues fields\n   * @param si commit point\n   * @param dir directory\n   * @param coreInfos fieldinfos for the segment\n   * @param allInfos all fieldinfos including updated ones\n   * @param segDocValues producer map\n   */\n  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos coreInfos, FieldInfos allInfos, SegmentDocValues segDocValues) throws IOException {\n    boolean success = false;\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : allInfos) {\n        if (fi.getDocValuesType() == DocValuesType.NONE) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets the original fieldinfos it wrote\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, dir, coreInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          // otherwise, producer sees only the one fieldinfo it wrote\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, dir, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos fieldInfos, SegmentDocValues segDocValues, DocValuesFormat dvFormat) throws IOException {\n    boolean success = false;\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.getDocValuesType() == DocValuesType.NONE) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets all the fields, so the Codec can validate properly\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14d66d86a8b184a86bcaebcf6e15fcef486e0876","date":1521539412,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,FieldInfos,SegmentDocValues).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,FieldInfos,SegmentDocValues).mjava","sourceNew":"  /**\n   * Creates a new producer that handles updated docvalues fields\n   * @param si commit point\n   * @param dir directory\n   * @param coreInfos fieldinfos for the segment\n   * @param allInfos all fieldinfos including updated ones\n   * @param segDocValues producer map\n   */\n  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos coreInfos, FieldInfos allInfos, SegmentDocValues segDocValues) throws IOException {\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : allInfos) {\n        if (fi.getDocValuesType() == DocValuesType.NONE) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets the original fieldinfos it wrote\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, dir, coreInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          // otherwise, producer sees only the one fieldinfo it wrote\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, dir, new FieldInfos(new FieldInfo[]{fi}));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n    } catch (Throwable t) {\n      try {\n        segDocValues.decRef(dvGens);\n      } catch (Throwable t1) {\n        t.addSuppressed(t1);\n      }\n      throw t;\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new producer that handles updated docvalues fields\n   * @param si commit point\n   * @param dir directory\n   * @param coreInfos fieldinfos for the segment\n   * @param allInfos all fieldinfos including updated ones\n   * @param segDocValues producer map\n   */\n  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos coreInfos, FieldInfos allInfos, SegmentDocValues segDocValues) throws IOException {\n    boolean success = false;\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : allInfos) {\n        if (fi.getDocValuesType() == DocValuesType.NONE) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets the original fieldinfos it wrote\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, dir, coreInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          // otherwise, producer sees only the one fieldinfo it wrote\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, dir, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,FieldInfos,SegmentDocValues).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,FieldInfos,SegmentDocValues).mjava","sourceNew":"  /**\n   * Creates a new producer that handles updated docvalues fields\n   * @param si commit point\n   * @param dir directory\n   * @param coreInfos fieldinfos for the segment\n   * @param allInfos all fieldinfos including updated ones\n   * @param segDocValues producer map\n   */\n  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos coreInfos, FieldInfos allInfos, SegmentDocValues segDocValues) throws IOException {\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : allInfos) {\n        if (fi.getDocValuesType() == DocValuesType.NONE) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets the original fieldinfos it wrote\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, dir, coreInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          // otherwise, producer sees only the one fieldinfo it wrote\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, dir, new FieldInfos(new FieldInfo[]{fi}));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n    } catch (Throwable t) {\n      try {\n        segDocValues.decRef(dvGens);\n      } catch (Throwable t1) {\n        t.addSuppressed(t1);\n      }\n      throw t;\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new producer that handles updated docvalues fields\n   * @param si commit point\n   * @param dir directory\n   * @param coreInfos fieldinfos for the segment\n   * @param allInfos all fieldinfos including updated ones\n   * @param segDocValues producer map\n   */\n  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos coreInfos, FieldInfos allInfos, SegmentDocValues segDocValues) throws IOException {\n    boolean success = false;\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : allInfos) {\n        if (fi.getDocValuesType() == DocValuesType.NONE) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets the original fieldinfos it wrote\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, dir, coreInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          // otherwise, producer sees only the one fieldinfo it wrote\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, dir, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["240c2c222c1b7eb253bd7e596c2d4731355836ef","14d66d86a8b184a86bcaebcf6e15fcef486e0876"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"240c2c222c1b7eb253bd7e596c2d4731355836ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"14d66d86a8b184a86bcaebcf6e15fcef486e0876":["240c2c222c1b7eb253bd7e596c2d4731355836ef"]},"commit2Childs":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["240c2c222c1b7eb253bd7e596c2d4731355836ef"],"240c2c222c1b7eb253bd7e596c2d4731355836ef":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","14d66d86a8b184a86bcaebcf6e15fcef486e0876"],"14d66d86a8b184a86bcaebcf6e15fcef486e0876":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}