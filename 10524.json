{"path":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"/dev/null","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    // fire off the requests before getting our own recent updates (for better concurrency)\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n    \n    \n    Collections.sort(ourUpdates, absComparator);\n\n    if (ourUpdates.size() > 0) {\n      ourLowThreshold = percentile(ourUpdates, 0.8f);\n      ourHighThreshold = percentile(ourUpdates, 0.2f);\n    }  else {\n      // we have no versions and hence no frame of reference to tell if we can use a peers\n      // updates to bring us into sync\n      return false;\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb62cc3362417c3e5136f2f26d34a1072ad633eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"/dev/null","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    // fire off the requests before getting our own recent updates (for better concurrency)\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n    \n    \n    Collections.sort(ourUpdates, absComparator);\n\n    if (ourUpdates.size() > 0) {\n      ourLowThreshold = percentile(ourUpdates, 0.8f);\n      ourHighThreshold = percentile(ourUpdates, 0.2f);\n    }  else {\n      // we have no versions and hence no frame of reference to tell if we can use a peers\n      // updates to bring us into sync\n      return false;\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"/dev/null","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    // fire off the requests before getting our own recent updates (for better concurrency)\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n    \n    \n    Collections.sort(ourUpdates, absComparator);\n\n    if (ourUpdates.size() > 0) {\n      ourLowThreshold = percentile(ourUpdates, 0.8f);\n      ourHighThreshold = percentile(ourUpdates, 0.2f);\n    }  else {\n      // we have no versions and hence no frame of reference to tell if we can use a peers\n      // updates to bring us into sync\n      return false;\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5d4fc4244db21f4ed1c00098f9c4deeab5275aa","date":1329352216,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(\"PeerSync: too many updates received since start - startingUpdates no longer overlaps with cour urrentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    // fire off the requests before getting our own recent updates (for better concurrency)\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n    \n    \n    Collections.sort(ourUpdates, absComparator);\n\n    if (ourUpdates.size() > 0) {\n      ourLowThreshold = percentile(ourUpdates, 0.8f);\n      ourHighThreshold = percentile(ourUpdates, 0.2f);\n    }  else {\n      // we have no versions and hence no frame of reference to tell if we can use a peers\n      // updates to bring us into sync\n      return false;\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["1ff69c72e86ce37f772dd66b93cb13df77a02dc7","003945478044d882f26d39d0d2fc19c20e78f858","e99829242bceda4cf974ec0eb5d82d713615b3da"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5620d3cb34306ea5b7d016a832fbc964b74c2650","date":1329755478,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(\"PeerSync: too many updates received since start - startingUpdates no longer overlaps with cour urrentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8f7907798e0c730e9ab37681c6e8dfbde0e4173","date":1330361299,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e99829242bceda4cf974ec0eb5d82d713615b3da","date":1337646971,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<Long>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":["b5d4fc4244db21f4ed1c00098f9c4deeab5275aa"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<Long>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        log.warn(\"no frame of reference to tell of we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<Long>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<Long>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["1ff69c72e86ce37f772dd66b93cb13df77a02dc7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ff69c72e86ce37f772dd66b93cb13df77a02dc7","date":1377825581,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        log.warn(\"no frame of reference to tell if we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<Long>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        log.warn(\"no frame of reference to tell of we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<Long>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508","b5d4fc4244db21f4ed1c00098f9c4deeab5275aa"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        log.warn(\"no frame of reference to tell if we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<Long>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        // no frame of reference to tell of we've missed updates\n        log.warn(\"no frame of reference to tell of we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<Long>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        log.warn(\"no frame of reference to tell if we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<>(ourUpdates);\n    requestedUpdateSet = new HashSet<>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        log.warn(\"no frame of reference to tell if we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<Long>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<Long>(ourUpdates);\n    requestedUpdateSet = new HashSet<Long>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        log.warn(\"no frame of reference to tell if we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<>(ourUpdates);\n    requestedUpdateSet = new HashSet<>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and it's peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        log.warn(\"no frame of reference to tell if we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<>(ourUpdates);\n    requestedUpdateSet = new HashSet<>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      // TODO: does it ever make sense to allow sync when buffering or applying buffered? Someone might request that we\n      // do it...\n      if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState() == UpdateLog.State.REPLAYING)) {\n        log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n        // return false;\n      }\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n      \n      recentUpdates = ulog.getRecentUpdates();\n      try {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      } finally {\n        recentUpdates.close();\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n        \n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n      \n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>(ourUpdates);\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n      \n      log.info(msg() + \"DONE. sync succeeded\");\n      return true;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n\n    log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n    // TODO: does it ever make sense to allow sync when buffering or applying buffered?  Someone might request that we do it...\n    if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState()==UpdateLog.State.REPLAYING)) {\n      log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n      // return false;\n    }\n    \n    if (debug) {\n      if (startingVersions != null) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n    }\n\n    // Fire off the requests before getting our own recent updates (for better concurrency)\n    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would\n    // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n    for (String replica : replicas) {\n      requestVersions(replica);\n    }\n\n    recentUpdates = ulog.getRecentUpdates();\n    try {\n      ourUpdates = recentUpdates.getVersions(nUpdates);\n    } finally {\n      recentUpdates.close();\n    }\n\n    Collections.sort(ourUpdates, absComparator);\n\n    if (startingVersions != null) {\n      if (startingVersions.size() == 0) {\n        log.warn(\"no frame of reference to tell if we've missed updates\");\n        return false;\n      }\n      Collections.sort(startingVersions, absComparator);\n\n      ourLowThreshold = percentile(startingVersions, 0.8f);\n      ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg() + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        return false;\n      }\n\n      // let's merge the lists\n      List<Long> newList = new ArrayList<>(ourUpdates);\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          newList.add(ver);\n        }\n      }\n\n      ourUpdates = newList;\n    }  else {\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      }  else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        return false;\n      }\n    }\n\n    ourUpdateSet = new HashSet<>(ourUpdates);\n    requestedUpdateSet = new HashSet<>(ourUpdates);\n\n    for(;;) {\n      ShardResponse srsp = shardHandler.takeCompletedOrError();\n      if (srsp == null) break;\n      boolean success = handleResponse(srsp);\n      if (!success) {\n        log.info(msg() +  \"DONE. sync failed\");\n        shardHandler.cancelAll();\n        return false;\n      }\n    }\n\n    log.info(msg() +  \"DONE. sync succeeded\");\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["bb62cc3362417c3e5136f2f26d34a1072ad633eb","003945478044d882f26d39d0d2fc19c20e78f858"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","date":1449051812,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      // TODO: does it ever make sense to allow sync when buffering or applying buffered? Someone might request that we\n      // do it...\n      if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState() == UpdateLog.State.REPLAYING)) {\n        log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n        // return false;\n      }\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n        \n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n      \n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>(ourUpdates);\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n      \n      log.info(msg() + \"DONE. sync succeeded\");\n      return true;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      // TODO: does it ever make sense to allow sync when buffering or applying buffered? Someone might request that we\n      // do it...\n      if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState() == UpdateLog.State.REPLAYING)) {\n        log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n        // return false;\n      }\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n      \n      recentUpdates = ulog.getRecentUpdates();\n      try {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      } finally {\n        recentUpdates.close();\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n        \n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n      \n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>(ourUpdates);\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n      \n      log.info(msg() + \"DONE. sync succeeded\");\n      return true;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"003945478044d882f26d39d0d2fc19c20e78f858","date":1450452969,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n        \n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n      \n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>(ourUpdates);\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n      \n      log.info(msg() + \"DONE. sync succeeded\");\n      return true;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      // TODO: does it ever make sense to allow sync when buffering or applying buffered? Someone might request that we\n      // do it...\n      if (!(ulog.getState() == UpdateLog.State.ACTIVE || ulog.getState() == UpdateLog.State.REPLAYING)) {\n        log.error(msg() + \"ERROR, update log not in ACTIVE or REPLAY state. \" + ulog);\n        // return false;\n      }\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n        \n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n      \n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>(ourUpdates);\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n      \n      log.info(msg() + \"DONE. sync succeeded\");\n      return true;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["439c63ae5d22132fca810a0029a854e97d2c1a3e","b5d4fc4244db21f4ed1c00098f9c4deeab5275aa"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"979e22aa7c63c9dc651adf861610c7e444d45832","date":1454615713,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n        \n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n      \n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>(ourUpdates);\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n      \n      log.info(msg() + \"DONE. sync succeeded\");\n      return true;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb62cc3362417c3e5136f2f26d34a1072ad633eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1704c078ec59838c9d95d5bf5738b393b537494","date":1454693901,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n        \n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n      \n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>(ourUpdates);\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n      \n      log.info(msg() + \"DONE. sync succeeded\");\n      return true;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates\n   *  when considering the last N updates between it and its peers.\n   *  A commit is not performed.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n        \n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n      \n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>(ourUpdates);\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n      \n      log.info(msg() + \"DONE. sync succeeded\");\n      return true;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fcc7eba0b32cbc7cc5b8fd388032bb833fa07786","date":1474482359,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        return true;\n      }\n      \n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb62cc3362417c3e5136f2f26d34a1072ad633eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb62cc3362417c3e5136f2f26d34a1072ad633eb","date":1475149102,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        return PeerSyncResult.success();\n      }\n      \n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        return true;\n      }\n      \n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["fcc7eba0b32cbc7cc5b8fd388032bb833fa07786","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","439c63ae5d22132fca810a0029a854e97d2c1a3e","979e22aa7c63c9dc651adf861610c7e444d45832"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        return PeerSyncResult.success();\n      }\n      \n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        return PeerSyncResult.success();\n      }\n      \n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public boolean sync() {\n    if (ulog == null) {\n      return false;\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return false;\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return false;\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          return false;\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return false;\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"268f09ed3a9a9b77003b15a5ae30386dc4e3721f","date":1483992000,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        return PeerSyncResult.success();\n      }\n      \n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        return PeerSyncResult.success();\n      }\n      \n      \n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"746467918bcca1fc9791421f4a615b295c5e6da8","date":1502249179,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try {\n        // waiting a little bit, there are a chance that an update is sending from leader,\n        // so it will present in the response, but not in our recent updates (SOLR-10126)\n        Thread.sleep(300);\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try {\n        // waiting a little bit, there are a chance that an update is sending from leader,\n        // so it will present in the response, but not in our recent updates (SOLR-10126)\n        Thread.sleep(300);\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try {\n        // waiting a little bit, there are a chance that an update is sending from leader,\n        // so it will present in the response, but not in our recent updates (SOLR-10126)\n        Thread.sleep(300);\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","date":1529486762,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      long ourLowThreshold, ourHighThreshold;\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      ourUpdates.sort(absComparator);\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      } else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        for (;;)  {\n          ShardResponse srsp = shardHandler.takeCompletedOrError();\n          if (srsp == null) break;\n          if (srsp.getException() == null)  {\n            List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n            if (otherVersions != null && !otherVersions.isEmpty())  {\n              syncErrors.inc();\n              return PeerSyncResult.failure(true);\n            }\n          }\n        }\n        syncErrors.inc();\n        return PeerSyncResult.failure(false);\n      }\n\n      this.missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold, ourHighThreshold);\n\n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try {\n        // waiting a little bit, there are a chance that an update is sending from leader,\n        // so it will present in the response, but not in our recent updates (SOLR-10126)\n        Thread.sleep(300);\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      long ourLowThreshold, ourHighThreshold;\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      ourUpdates.sort(absComparator);\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      } else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        for (;;)  {\n          ShardResponse srsp = shardHandler.takeCompletedOrError();\n          if (srsp == null) break;\n          if (srsp.getException() == null)  {\n            List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n            if (otherVersions != null && !otherVersions.isEmpty())  {\n              syncErrors.inc();\n              return PeerSyncResult.failure(true);\n            }\n          }\n        }\n        syncErrors.inc();\n        return PeerSyncResult.failure(false);\n      }\n\n      this.missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold, ourHighThreshold);\n\n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try {\n        // waiting a little bit, there are a chance that an update is sending from leader,\n        // so it will present in the response, but not in our recent updates (SOLR-10126)\n        Thread.sleep(300);\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      long ourLowThreshold, ourHighThreshold;\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      ourUpdates.sort(absComparator);\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      } else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        for (;;)  {\n          ShardResponse srsp = shardHandler.takeCompletedOrError();\n          if (srsp == null) break;\n          if (srsp.getException() == null)  {\n            List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n            if (otherVersions != null && !otherVersions.isEmpty())  {\n              syncErrors.inc();\n              return PeerSyncResult.failure(true);\n            }\n          }\n        }\n        syncErrors.inc();\n        return PeerSyncResult.failure(false);\n      }\n\n      this.missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold, ourHighThreshold);\n\n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n      \n      if (debug) {\n        if (startingVersions != null) {\n          log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n        }\n      }\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      try {\n        // waiting a little bit, there are a chance that an update is sending from leader,\n        // so it will present in the response, but not in our recent updates (SOLR-10126)\n        Thread.sleep(300);\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n      }\n\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      Collections.sort(ourUpdates, absComparator);\n      \n      if (startingVersions != null) {\n        if (startingVersions.size() == 0) {\n          log.warn(\"no frame of reference to tell if we've missed updates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        Collections.sort(startingVersions, absComparator);\n        \n        ourLowThreshold = percentile(startingVersions, 0.8f);\n        ourHighThreshold = percentile(startingVersions, 0.2f);\n\n        // now make sure that the starting updates overlap our updates\n        // there shouldn't be reorders, so any overlap will do.\n        \n        long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n        \n        if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n          log.warn(msg()\n              + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n        \n        // let's merge the lists\n        List<Long> newList = new ArrayList<>(ourUpdates);\n        for (Long ver : startingVersions) {\n          if (Math.abs(ver) < smallestNewUpdate) {\n            newList.add(ver);\n          }\n        }\n        \n        ourUpdates = newList;\n        Collections.sort(ourUpdates, absComparator);\n      } else {\n        \n        if (ourUpdates.size() > 0) {\n          ourLowThreshold = percentile(ourUpdates, 0.8f);\n          ourHighThreshold = percentile(ourUpdates, 0.2f);\n        } else {\n          // we have no versions and hence no frame of reference to tell if we can use a peers\n          // updates to bring us into sync\n          log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n          for (;;)  {\n            ShardResponse srsp = shardHandler.takeCompletedOrError();\n            if (srsp == null) break;\n            if (srsp.getException() == null)  {\n              List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n              if (otherVersions != null && !otherVersions.isEmpty())  {\n                syncErrors.inc();\n                return PeerSyncResult.failure(true);\n              }\n            }\n          }\n          syncErrors.inc();\n          return PeerSyncResult.failure(false);\n        }\n      }\n\n      ourHighest = ourUpdates.get(0);\n      ourUpdateSet = new HashSet<>(ourUpdates);\n      requestedUpdateSet = new HashSet<>();\n      \n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed5005b977107bba28c700351216f1595e7abe4f","date":1585964712,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      long ourLowThreshold, ourHighThreshold;\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      ourUpdates.sort(absComparator);\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      } else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        for (;;)  {\n          ShardResponse srsp = shardHandler.takeCompletedOrError();\n          if (srsp == null) break;\n          if (srsp.getException() == null)  {\n            List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n            if (otherVersions != null && !otherVersions.isEmpty())  {\n              syncErrors.inc();\n              return PeerSyncResult.failure(true);\n            }\n          }\n        }\n        syncErrors.inc();\n        return PeerSyncResult.failure(false);\n      }\n\n      this.missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold, ourHighThreshold);\n\n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      long ourLowThreshold, ourHighThreshold;\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      ourUpdates.sort(absComparator);\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      } else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        for (;;)  {\n          ShardResponse srsp = shardHandler.takeCompletedOrError();\n          if (srsp == null) break;\n          if (srsp.getException() == null)  {\n            List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n            if (otherVersions != null && !otherVersions.isEmpty())  {\n              syncErrors.inc();\n              return PeerSyncResult.failure(true);\n            }\n          }\n        }\n        syncErrors.inc();\n        return PeerSyncResult.failure(false);\n      }\n\n      this.missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold, ourHighThreshold);\n\n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    Timer.Context timerContext = null;\n    try {\n      if (log.isInfoEnabled()) {\n        log.info(\"{} START replicas={} nUpdates={}\", msg(), replicas, nUpdates);\n      }\n\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      long ourLowThreshold, ourHighThreshold;\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      ourUpdates.sort(absComparator);\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      } else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        if (log.isInfoEnabled()) {\n          log.info(\"{} DONE. We have no versions. sync failed.\", msg());\n        }\n        for (;;)  {\n          ShardResponse srsp = shardHandler.takeCompletedOrError();\n          if (srsp == null) break;\n          if (srsp.getException() == null)  {\n            List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n            if (otherVersions != null && !otherVersions.isEmpty())  {\n              syncErrors.inc();\n              return PeerSyncResult.failure(true);\n            }\n          }\n        }\n        syncErrors.inc();\n        return PeerSyncResult.failure(false);\n      }\n\n      this.missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold, ourHighThreshold);\n\n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          if (log.isInfoEnabled()) {\n            log.info(\"{} DONE. sync failed\", msg());\n          }\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      if (log.isInfoEnabled()) {\n        log.info(\"{} DONE. sync {}\", msg(), (success ? \"succeeded\" : \"failed\"));\n      }\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START replicas=\" + replicas + \" nUpdates=\" + nUpdates);\n\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      long ourLowThreshold, ourHighThreshold;\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      ourUpdates.sort(absComparator);\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      } else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        log.info(msg() + \"DONE.  We have no versions.  sync failed.\");\n        for (;;)  {\n          ShardResponse srsp = shardHandler.takeCompletedOrError();\n          if (srsp == null) break;\n          if (srsp.getException() == null)  {\n            List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n            if (otherVersions != null && !otherVersions.isEmpty())  {\n              syncErrors.inc();\n              return PeerSyncResult.failure(true);\n            }\n          }\n        }\n        syncErrors.inc();\n        return PeerSyncResult.failure(false);\n      }\n\n      this.missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold, ourHighThreshold);\n\n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          log.info(msg() + \"DONE. sync failed\");\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSync#sync().mjava","sourceNew":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    Timer.Context timerContext = null;\n    try {\n      if (log.isInfoEnabled()) {\n        log.info(\"{} START replicas={} nUpdates={}\", msg(), replicas, nUpdates);\n      }\n\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      long ourLowThreshold, ourHighThreshold;\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      ourUpdates.sort(absComparator);\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      } else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        if (log.isInfoEnabled()) {\n          log.info(\"{} DONE. We have no versions. sync failed.\", msg());\n        }\n        for (;;)  {\n          ShardResponse srsp = shardHandler.takeCompletedOrError();\n          if (srsp == null) break;\n          if (srsp.getException() == null)  {\n            @SuppressWarnings({\"unchecked\"})\n            List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n            if (otherVersions != null && !otherVersions.isEmpty())  {\n              syncErrors.inc();\n              return PeerSyncResult.failure(true);\n            }\n          }\n        }\n        syncErrors.inc();\n        return PeerSyncResult.failure(false);\n      }\n\n      this.missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold, ourHighThreshold);\n\n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          if (log.isInfoEnabled()) {\n            log.info(\"{} DONE. sync failed\", msg());\n          }\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      if (log.isInfoEnabled()) {\n        log.info(\"{} DONE. sync {}\", msg(), (success ? \"succeeded\" : \"failed\"));\n      }\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true if peer sync was successful, meaning that this core may be considered to have the latest updates.\n   * It does not mean that the remote replica is in sync with us.\n   */\n  public PeerSyncResult sync() {\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSyncResult.failure();\n    }\n    Timer.Context timerContext = null;\n    try {\n      if (log.isInfoEnabled()) {\n        log.info(\"{} START replicas={} nUpdates={}\", msg(), replicas, nUpdates);\n      }\n\n      // check if we already in sync to begin with \n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      // Fire off the requests before getting our own recent updates (for better concurrency)\n      // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates,\n      // they would\n      // have newer stuff that we also had (assuming updates are going on and are being forwarded).\n      for (String replica : replicas) {\n        requestVersions(replica);\n      }\n\n      long ourLowThreshold, ourHighThreshold;\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n      }\n      \n      ourUpdates.sort(absComparator);\n\n      if (ourUpdates.size() > 0) {\n        ourLowThreshold = percentile(ourUpdates, 0.8f);\n        ourHighThreshold = percentile(ourUpdates, 0.2f);\n      } else {\n        // we have no versions and hence no frame of reference to tell if we can use a peers\n        // updates to bring us into sync\n        if (log.isInfoEnabled()) {\n          log.info(\"{} DONE. We have no versions. sync failed.\", msg());\n        }\n        for (;;)  {\n          ShardResponse srsp = shardHandler.takeCompletedOrError();\n          if (srsp == null) break;\n          if (srsp.getException() == null)  {\n            List<Long> otherVersions = (List<Long>)srsp.getSolrResponse().getResponse().get(\"versions\");\n            if (otherVersions != null && !otherVersions.isEmpty())  {\n              syncErrors.inc();\n              return PeerSyncResult.failure(true);\n            }\n          }\n        }\n        syncErrors.inc();\n        return PeerSyncResult.failure(false);\n      }\n\n      this.missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold, ourHighThreshold);\n\n      for (;;) {\n        ShardResponse srsp = shardHandler.takeCompletedOrError();\n        if (srsp == null) break;\n        boolean success = handleResponse(srsp);\n        if (!success) {\n          if (log.isInfoEnabled()) {\n            log.info(\"{} DONE. sync failed\", msg());\n          }\n          shardHandler.cancelAll();\n          syncErrors.inc();\n          return PeerSyncResult.failure();\n        }\n      }\n\n      // finish up any comparisons with other shards that we deferred\n      boolean success = true;\n      for (SyncShardRequest sreq : requests) {\n        if (sreq.doFingerprintComparison) {\n          success = compareFingerprint(sreq);\n          if (!success) break;\n        }\n      }\n\n      if (log.isInfoEnabled()) {\n        log.info(\"{} DONE. sync {}\", msg(), (success ? \"succeeded\" : \"failed\"));\n      }\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSyncResult.success() : PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5620d3cb34306ea5b7d016a832fbc964b74c2650":["b5d4fc4244db21f4ed1c00098f9c4deeab5275aa"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["ed5005b977107bba28c700351216f1595e7abe4f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["5620d3cb34306ea5b7d016a832fbc964b74c2650","f8f7907798e0c730e9ab37681c6e8dfbde0e4173"],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"ed5005b977107bba28c700351216f1595e7abe4f":["ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"fcc7eba0b32cbc7cc5b8fd388032bb833fa07786":["979e22aa7c63c9dc651adf861610c7e444d45832"],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"003945478044d882f26d39d0d2fc19c20e78f858":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"b5d4fc4244db21f4ed1c00098f9c4deeab5275aa":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["746467918bcca1fc9791421f4a615b295c5e6da8","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f","746467918bcca1fc9791421f4a615b295c5e6da8"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["979e22aa7c63c9dc651adf861610c7e444d45832","bb62cc3362417c3e5136f2f26d34a1072ad633eb"],"3599646b4d4c346cf74d334813488b8b337b5bf5":["f8f7907798e0c730e9ab37681c6e8dfbde0e4173","e99829242bceda4cf974ec0eb5d82d713615b3da"],"b1704c078ec59838c9d95d5bf5738b393b537494":["003945478044d882f26d39d0d2fc19c20e78f858","979e22aa7c63c9dc651adf861610c7e444d45832"],"e99829242bceda4cf974ec0eb5d82d713615b3da":["f8f7907798e0c730e9ab37681c6e8dfbde0e4173"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["746467918bcca1fc9791421f4a615b295c5e6da8"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["746467918bcca1fc9791421f4a615b295c5e6da8","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1ff69c72e86ce37f772dd66b93cb13df77a02dc7"],"f8f7907798e0c730e9ab37681c6e8dfbde0e4173":["5620d3cb34306ea5b7d016a832fbc964b74c2650"],"746467918bcca1fc9791421f4a615b295c5e6da8":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"1ff69c72e86ce37f772dd66b93cb13df77a02dc7":["a6378064655e76cd7b908b1cab4ce425b384b508"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a6378064655e76cd7b908b1cab4ce425b384b508","1ff69c72e86ce37f772dd66b93cb13df77a02dc7"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["003945478044d882f26d39d0d2fc19c20e78f858","979e22aa7c63c9dc651adf861610c7e444d45832"],"bb62cc3362417c3e5136f2f26d34a1072ad633eb":["fcc7eba0b32cbc7cc5b8fd388032bb833fa07786"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["979e22aa7c63c9dc651adf861610c7e444d45832","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a6378064655e76cd7b908b1cab4ce425b384b508":["e99829242bceda4cf974ec0eb5d82d713615b3da"],"979e22aa7c63c9dc651adf861610c7e444d45832":["003945478044d882f26d39d0d2fc19c20e78f858"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f","746467918bcca1fc9791421f4a615b295c5e6da8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"]},"commit2Childs":{"5620d3cb34306ea5b7d016a832fbc964b74c2650":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f8f7907798e0c730e9ab37681c6e8dfbde0e4173"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"740d649f013f07efbeb73ca854f106c60166e7c0":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["58884af1f68e9d61c217c753fbd6266d86a63b14","746467918bcca1fc9791421f4a615b295c5e6da8","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"ed5005b977107bba28c700351216f1595e7abe4f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"fcc7eba0b32cbc7cc5b8fd388032bb833fa07786":["bb62cc3362417c3e5136f2f26d34a1072ad633eb"],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["003945478044d882f26d39d0d2fc19c20e78f858"],"003945478044d882f26d39d0d2fc19c20e78f858":["b1704c078ec59838c9d95d5bf5738b393b537494","1e6acbaae7af722f17204ceccf0f7db5753eccf3","979e22aa7c63c9dc651adf861610c7e444d45832"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"b5d4fc4244db21f4ed1c00098f9c4deeab5275aa":["5620d3cb34306ea5b7d016a832fbc964b74c2650"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"b1704c078ec59838c9d95d5bf5738b393b537494":[],"e99829242bceda4cf974ec0eb5d82d713615b3da":["3599646b4d4c346cf74d334813488b8b337b5bf5","a6378064655e76cd7b908b1cab4ce425b384b508"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["ed5005b977107bba28c700351216f1595e7abe4f","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"f8f7907798e0c730e9ab37681c6e8dfbde0e4173":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","3599646b4d4c346cf74d334813488b8b337b5bf5","e99829242bceda4cf974ec0eb5d82d713615b3da"],"746467918bcca1fc9791421f4a615b295c5e6da8":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","58884af1f68e9d61c217c753fbd6266d86a63b14","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"1ff69c72e86ce37f772dd66b93cb13df77a02dc7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"bb62cc3362417c3e5136f2f26d34a1072ad633eb":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"a6378064655e76cd7b908b1cab4ce425b384b508":["1ff69c72e86ce37f772dd66b93cb13df77a02dc7","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"979e22aa7c63c9dc651adf861610c7e444d45832":["fcc7eba0b32cbc7cc5b8fd388032bb833fa07786","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","b1704c078ec59838c9d95d5bf5738b393b537494","1e6acbaae7af722f17204ceccf0f7db5753eccf3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["b5d4fc4244db21f4ed1c00098f9c4deeab5275aa","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","58884af1f68e9d61c217c753fbd6266d86a63b14","0d22ac6a4146774c1bc8400160fc0b6150294e92","3599646b4d4c346cf74d334813488b8b337b5bf5","b1704c078ec59838c9d95d5bf5738b393b537494","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","1e6acbaae7af722f17204ceccf0f7db5753eccf3","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}