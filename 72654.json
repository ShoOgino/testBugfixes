{"path":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","commits":[{"id":"e69f59b863731d864bf3047235e718f0f88f8841","date":1250105498,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","pathOld":"/dev/null","sourceNew":"    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern((String) entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          // we expect that there is at most one term per document\n          if (t >= mterms.length) throw new RuntimeException (\"there are more terms than \" +\n                  \"documents in field \\\"\" + field + \"\\\", but it's impossible to sort on \" +\n                  \"tokenized fields\");\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20645c714ca2a7b7707c2707d58ee9fa384c7362","date":1256074979,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","sourceNew":"    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          // we expect that there is at most one term per document\n          if (t >= mterms.length) throw new RuntimeException (\"there are more terms than \" +\n                  \"documents in field \\\"\" + field + \"\\\", but it's impossible to sort on \" +\n                  \"tokenized fields\");\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","sourceOld":"    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern((String) entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          // we expect that there is at most one term per document\n          if (t >= mterms.length) throw new RuntimeException (\"there are more terms than \" +\n                  \"documents in field \\\"\" + field + \"\\\", but it's impossible to sort on \" +\n                  \"tokenized fields\");\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a9e385641d717e641408d8fbbc62be8fc766357","date":1256746606,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          // we expect that there is at most one term per document\n          if (t >= mterms.length) throw new RuntimeException (\"there are more terms than \" +\n                  \"documents in field \\\"\" + field + \"\\\", but it's impossible to sort on \" +\n                  \"tokenized fields\");\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","sourceOld":"    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          // we expect that there is at most one term per document\n          if (t >= mterms.length) throw new RuntimeException (\"there are more terms than \" +\n                  \"documents in field \\\"\" + field + \"\\\", but it's impossible to sort on \" +\n                  \"tokenized fields\");\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"828c82c67f16267da6a419b2068970477a1625b0","date":1260531497,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          // we expect that there is at most one term per document\n          if (t >= mterms.length) throw new RuntimeException (\"there are more terms than \" +\n                  \"documents in field \\\"\" + field + \"\\\", but it's impossible to sort on \" +\n                  \"tokenized fields\");\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"828c82c67f16267da6a419b2068970477a1625b0":["8a9e385641d717e641408d8fbbc62be8fc766357"],"8a9e385641d717e641408d8fbbc62be8fc766357":["20645c714ca2a7b7707c2707d58ee9fa384c7362"],"e69f59b863731d864bf3047235e718f0f88f8841":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"20645c714ca2a7b7707c2707d58ee9fa384c7362":["e69f59b863731d864bf3047235e718f0f88f8841"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["828c82c67f16267da6a419b2068970477a1625b0"]},"commit2Childs":{"828c82c67f16267da6a419b2068970477a1625b0":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"8a9e385641d717e641408d8fbbc62be8fc766357":["828c82c67f16267da6a419b2068970477a1625b0"],"e69f59b863731d864bf3047235e718f0f88f8841":["20645c714ca2a7b7707c2707d58ee9fa384c7362"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e69f59b863731d864bf3047235e718f0f88f8841"],"20645c714ca2a7b7707c2707d58ee9fa384c7362":["8a9e385641d717e641408d8fbbc62be8fc766357"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}