{"path":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        try {\n          parseParams(FacetParams.FACET_FIELD, f);\n          String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n          if (termList != null) {\n            res.add(key, getListedTermCounts(facetValue, termList));\n          } else {\n            res.add(key, getTermCounts(facetValue));\n          }\n        } catch (Exception e) {\n          String msg = \"Exception during facet.field of \" + f;\n          SolrException.logOnce(SolrCore.log, msg, e);\n          addException(msg , e);\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        try {\n          parseParams(FacetParams.FACET_FIELD, f);\n          String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n          if (termList != null) {\n            res.add(key, getListedTermCounts(facetValue, termList));\n          } else {\n            res.add(key, getTermCounts(facetValue));\n          }\n        } catch (Exception e) {\n          String msg = \"Exception during facet.field of \" + f;\n          SolrException.logOnce(SolrCore.log, msg, e);\n          addException(msg , e);\n        }\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        try {\n          parseParams(FacetParams.FACET_FIELD, f);\n          String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n          if (termList != null) {\n            res.add(key, getListedTermCounts(facetValue, termList));\n          } else {\n            res.add(key, getTermCounts(facetValue));\n          }\n        } catch (Exception e) {\n          String msg = \"Exception during facet.field of \" + f;\n          SolrException.logOnce(SolrCore.log, msg, e);\n          addException(msg , e);\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        try {\n          parseParams(FacetParams.FACET_FIELD, f);\n          String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n          if (termList != null) {\n            res.add(key, getListedTermCounts(facetValue, termList));\n          } else {\n            res.add(key, getTermCounts(facetValue));\n          }\n        } catch (Exception e) {\n          String msg = \"Exception during facet.field of \" + f;\n          SolrException.logOnce(SolrCore.log, msg, e);\n          addException(msg , e);\n        }\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        try {\n          parseParams(FacetParams.FACET_FIELD, f);\n          String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n          if (termList != null) {\n            res.add(key, getListedTermCounts(facetValue, termList));\n          } else {\n            res.add(key, getTermCounts(facetValue));\n          }\n        } catch (Exception e) {\n          String msg = \"Exception during facet.field of \" + f;\n          SolrException.logOnce(SolrCore.log, msg, e);\n          addException(msg , e);\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        try {\n          parseParams(FacetParams.FACET_FIELD, f);\n          String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n          if (termList != null) {\n            res.add(key, getListedTermCounts(facetValue, termList));\n          } else {\n            res.add(key, getTermCounts(facetValue));\n          }\n        } catch (Exception e) {\n          String msg = \"Exception during facet.field of \" + f;\n          SolrException.logOnce(SolrCore.log, msg, e);\n          addException(msg , e);\n        }\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d7a2fb72910dc110efb34c773de307e5cbe4305a","date":1312025755,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        if (termList != null) {\n          res.add(key, getListedTermCounts(facetValue, termList));\n        } else {\n          res.add(key, getTermCounts(facetValue));\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        try {\n          parseParams(FacetParams.FACET_FIELD, f);\n          String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n          if (termList != null) {\n            res.add(key, getListedTermCounts(facetValue, termList));\n          } else {\n            res.add(key, getTermCounts(facetValue));\n          }\n        } catch (Exception e) {\n          String msg = \"Exception during facet.field of \" + f;\n          SolrException.logOnce(SolrCore.log, msg, e);\n          addException(msg , e);\n        }\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cdb67100dc016748799a77218aa409478372d79","date":1353699950,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        if (termList != null) {\n          res.add(key, getListedTermCounts(facetValue, termList));\n        } else {\n          res.add(key, getTermCounts(facetValue));\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        if (termList != null) {\n          res.add(key, getListedTermCounts(facetValue, termList));\n        } else {\n          res.add(key, getTermCounts(facetValue));\n        }\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        if (termList != null) {\n          res.add(key, getListedTermCounts(facetValue, termList));\n        } else {\n          res.add(key, getTermCounts(facetValue));\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, ParseException {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        if (termList != null) {\n          res.add(key, getListedTermCounts(facetValue, termList));\n        } else {\n          res.add(key, getTermCounts(facetValue));\n        }\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c","date":1378490020,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n\n    // passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directeExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by this thread.\n    maxThreads = (maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads;\n    CompletionService completionService = new ExecutorCompletionService(executor);\n    LinkedList<Callable> pending = new LinkedList<Callable>();\n    for (String f : facetFs) {\n      parseParams(FacetParams.FACET_FIELD, f);\n      final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n      final String workerKey = key;\n      final String workerFacetValue = facetValue;\n      final DocSet workerBase = this.docs;\n      Callable worker = new Callable() {\n        @Override\n        public Object call() throws Exception {\n          NamedList<Object> result = new SimpleOrderedMap<Object>();\n          try {\n            if(termList != null) {\n              result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n            } else {\n              result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n            }\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e){\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + workerFacetValue, e.getCause());\n          }\n          return result;\n        }\n      };\n      if (--maxThreads >= 0) {\n        completionService.submit(worker);\n      } else {\n        pending.add(worker);\n      }\n    }\n    for (String f : facetFs) {\n      NamedList taskResult;\n      try {\n        Future future = completionService.take();\n        taskResult = (NamedList)future.get();\n        if (taskResult != null) {\n          res.addAll(taskResult);\n        }\n        if (pending.isEmpty() == false) {\n          completionService.submit(pending.removeFirst());\n        }\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Processing of facet fields InterruptedException\", e);\n      } catch (ExecutionException e) {\n        Throwable cause = e.getCause();\n        if (cause instanceof SolrException) {\n          throw (SolrException) cause;\n        }\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Processing of facet fields ExecutionException \", e);\n      }\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n          throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null != facetFs) {\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        if (termList != null) {\n          res.add(key, getListedTermCounts(facetValue, termList));\n        } else {\n          res.add(key, getTermCounts(facetValue));\n        }\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20495d37d0c28755f57920096796d2c8d85d17d1","date":1379342043,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<Future<NamedList>>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<Object>();\n              if(termList != null) {\n                result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e.getCause());\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<NamedList>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n\n    // passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directeExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by this thread.\n    maxThreads = (maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads;\n    CompletionService completionService = new ExecutorCompletionService(executor);\n    LinkedList<Callable> pending = new LinkedList<Callable>();\n    for (String f : facetFs) {\n      parseParams(FacetParams.FACET_FIELD, f);\n      final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n      final String workerKey = key;\n      final String workerFacetValue = facetValue;\n      final DocSet workerBase = this.docs;\n      Callable worker = new Callable() {\n        @Override\n        public Object call() throws Exception {\n          NamedList<Object> result = new SimpleOrderedMap<Object>();\n          try {\n            if(termList != null) {\n              result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n            } else {\n              result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n            }\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e){\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + workerFacetValue, e.getCause());\n          }\n          return result;\n        }\n      };\n      if (--maxThreads >= 0) {\n        completionService.submit(worker);\n      } else {\n        pending.add(worker);\n      }\n    }\n    for (String f : facetFs) {\n      NamedList taskResult;\n      try {\n        Future future = completionService.take();\n        taskResult = (NamedList)future.get();\n        if (taskResult != null) {\n          res.addAll(taskResult);\n        }\n        if (pending.isEmpty() == false) {\n          completionService.submit(pending.removeFirst());\n        }\n      } catch (InterruptedException e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Processing of facet fields InterruptedException\", e);\n      } catch (ExecutionException e) {\n        Throwable cause = e.getCause();\n        if (cause instanceof SolrException) {\n          throw (SolrException) cause;\n        }\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Processing of facet fields ExecutionException \", e);\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7bde94df914e38596e2ce6907c04bcca8925e19","date":1385775146,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<Future<NamedList>>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<Object>();\n              if(termList != null) {\n                result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<NamedList>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<Future<NamedList>>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<Object>();\n              if(termList != null) {\n                result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e.getCause());\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<NamedList>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<Future<NamedList>>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<Object>();\n              if(termList != null) {\n                result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<NamedList>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<Future<NamedList>>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<Object>();\n              if(termList != null) {\n                result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e.getCause());\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<NamedList>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<>();\n              if(termList != null) {\n                result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<Future<NamedList>>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<Object>();\n              if(termList != null) {\n                result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<NamedList>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<>();\n              if(termList != null) {\n                List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n                result.add(workerKey, getListedTermCounts(workerFacetValue, workerBase, terms));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<>();\n              if(termList != null) {\n                result.add(workerKey, getListedTermCounts(workerFacetValue, termList, workerBase));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<>();\n              if(termList != null) {\n                List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n                result.add(key, getListedTermCounts(facetValue, parsed, terms));\n              } else {\n                result.add(key, getTermCounts(facetValue, parsed));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + facetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        parseParams(FacetParams.FACET_FIELD, f);\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String workerKey = key;\n        final String workerFacetValue = facetValue;\n        final DocSet workerBase = this.docs;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<>();\n              if(termList != null) {\n                List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n                result.add(workerKey, getListedTermCounts(workerFacetValue, workerBase, terms));\n              } else {\n                result.add(workerKey, getTermCounts(workerFacetValue, workerBase));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + workerFacetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":["c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef","c7bde94df914e38596e2ce6907c04bcca8925e19","20495d37d0c28755f57920096796d2c8d85d17d1","92751ba9273251eab6a2e379ec42a1697a32ff96"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<>();\n              if(termList != null) {\n                List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n                result.add(key, getListedTermCounts(facetValue, parsed, terms));\n              } else {\n                result.add(key, getTermCounts(facetValue, parsed));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + facetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = new Callable<NamedList>() {\n          @Override\n          public NamedList call() throws Exception {\n            try {\n              NamedList<Object> result = new SimpleOrderedMap<>();\n              if(termList != null) {\n                List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n                result.add(key, getListedTermCounts(facetValue, parsed, terms));\n              } else {\n                result.add(key, getTermCounts(facetValue, parsed));\n              }\n              return result;\n            } catch (SolrException se) {\n              throw se;\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                                      \"Exception during facet.field: \" + facetValue, e);\n            } finally {\n              semaphore.release();\n            }\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e5f469d206ae27a1d59e654e70a1413ffcec765","date":1462661221,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    if (fdebugParent != null) {\n      fdebugParent.putInfoItem(\"maxThreads\", maxThreads);\n    }\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        if (fdebugParent != null) {\n          fdebug = new FacetDebugInfo();\n          fdebugParent.addChild(fdebug);\n        }\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e66a459d38c1c4a2f97128433dab546f683a9fed","date":1462873476,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    if (fdebugParent != null) {\n      fdebugParent.putInfoItem(\"maxThreads\", maxThreads);\n    }\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        if (fdebugParent != null) {\n          fdebug = new FacetDebugInfo();\n          fdebugParent.addChild(fdebug);\n        }\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    if (fdebugParent != null) {\n      fdebugParent.putInfoItem(\"maxThreads\", maxThreads);\n    }\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        if (fdebugParent != null) {\n          fdebug = new FacetDebugInfo();\n          fdebugParent.addChild(fdebug);\n        }\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    if (fdebugParent != null) {\n      fdebugParent.putInfoItem(\"maxThreads\", maxThreads);\n    }\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        if (fdebugParent != null) {\n          fdebug = new FacetDebugInfo();\n          fdebugParent.addChild(fdebug);\n        }\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } \n          catch(ExitableDirectoryReader.ExitingReaderException timeout) {\n            throw timeout;\n          }\n          catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    if (fdebugParent != null) {\n      fdebugParent.putInfoItem(\"maxThreads\", maxThreads);\n    }\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        if (fdebugParent != null) {\n          fdebug = new FacetDebugInfo();\n          fdebugParent.addChild(fdebug);\n        }\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":["043df2e9a841864922c32756a44c939ed768cb89"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetFieldCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    @SuppressWarnings({\"rawtypes\"})\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    if (fdebugParent != null) {\n      fdebugParent.putInfoItem(\"maxThreads\", maxThreads);\n    }\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        if (fdebugParent != null) {\n          fdebug = new FacetDebugInfo();\n          fdebugParent.addChild(fdebug);\n        }\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        @SuppressWarnings({\"rawtypes\"})\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } \n          catch(ExitableDirectoryReader.ExitingReaderException timeout) {\n            throw timeout;\n          }\n          catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        @SuppressWarnings({\"rawtypes\"})\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (@SuppressWarnings({\"rawtypes\"})Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet field specified in the params.\n   *\n   * @see FacetParams#FACET_FIELD\n   * @see #getFieldMissingCount\n   * @see #getFacetTermEnumCounts\n   */\n  @SuppressWarnings(\"unchecked\")\n  public NamedList<Object> getFacetFieldCounts()\n      throws IOException, SyntaxError {\n\n    NamedList<Object> res = new SimpleOrderedMap<>();\n    String[] facetFs = global.getParams(FacetParams.FACET_FIELD);\n    if (null == facetFs) {\n      return res;\n    }\n\n    // Passing a negative number for FACET_THREADS implies an unlimited number of threads is acceptable.\n    // Also, a subtlety of directExecutor is that no matter how many times you \"submit\" a job, it's really\n    // just a method call in that it's run by the calling thread.\n    int maxThreads = req.getParams().getInt(FacetParams.FACET_THREADS, 0);\n    Executor executor = maxThreads == 0 ? directExecutor : facetExecutor;\n    final Semaphore semaphore = new Semaphore((maxThreads <= 0) ? Integer.MAX_VALUE : maxThreads);\n    List<Future<NamedList>> futures = new ArrayList<>(facetFs.length);\n\n    if (fdebugParent != null) {\n      fdebugParent.putInfoItem(\"maxThreads\", maxThreads);\n    }\n\n    try {\n      //Loop over fields; submit to executor, keeping the future\n      for (String f : facetFs) {\n        if (fdebugParent != null) {\n          fdebug = new FacetDebugInfo();\n          fdebugParent.addChild(fdebug);\n        }\n        final ParsedParams parsed = parseParams(FacetParams.FACET_FIELD, f);\n        final SolrParams localParams = parsed.localParams;\n        final String termList = localParams == null ? null : localParams.get(CommonParams.TERMS);\n        final String key = parsed.key;\n        final String facetValue = parsed.facetValue;\n        Callable<NamedList> callable = () -> {\n          try {\n            NamedList<Object> result = new SimpleOrderedMap<>();\n            if(termList != null) {\n              List<String> terms = StrUtils.splitSmart(termList, \",\", true);\n              result.add(key, getListedTermCounts(facetValue, parsed, terms));\n            } else {\n              result.add(key, getTermCounts(facetValue, parsed));\n            }\n            return result;\n          } catch (SolrException se) {\n            throw se;\n          } \n          catch(ExitableDirectoryReader.ExitingReaderException timeout) {\n            throw timeout;\n          }\n          catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                                    \"Exception during facet.field: \" + facetValue, e);\n          } finally {\n            semaphore.release();\n          }\n        };\n\n        RunnableFuture<NamedList> runnableFuture = new FutureTask<>(callable);\n        semaphore.acquire();//may block and/or interrupt\n        executor.execute(runnableFuture);//releases semaphore when done\n        futures.add(runnableFuture);\n      }//facetFs loop\n\n      //Loop over futures to get the values. The order is the same as facetFs but shouldn't matter.\n      for (Future<NamedList> future : futures) {\n        res.addAll(future.get());\n      }\n      assert semaphore.availablePermits() >= maxThreads;\n    } catch (InterruptedException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: InterruptedException\", e);\n    } catch (ExecutionException ee) {\n      Throwable e = ee.getCause();//unwrap\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException) e;\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Error while processing facet fields: \" + e.toString(), e);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c7bde94df914e38596e2ce6907c04bcca8925e19"],"20495d37d0c28755f57920096796d2c8d85d17d1":["540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c"],"043df2e9a841864922c32756a44c939ed768cb89":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3cdb67100dc016748799a77218aa409478372d79":["d7a2fb72910dc110efb34c773de307e5cbe4305a"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d7a2fb72910dc110efb34c773de307e5cbe4305a","3cdb67100dc016748799a77218aa409478372d79"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["3e5f469d206ae27a1d59e654e70a1413ffcec765"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b6284684320a9808c41a5e43de958b2da22f89bd","3e5f469d206ae27a1d59e654e70a1413ffcec765"],"c7bde94df914e38596e2ce6907c04bcca8925e19":["20495d37d0c28755f57920096796d2c8d85d17d1"],"b6284684320a9808c41a5e43de958b2da22f89bd":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1","043df2e9a841864922c32756a44c939ed768cb89"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3e5f469d206ae27a1d59e654e70a1413ffcec765":["b6284684320a9808c41a5e43de958b2da22f89bd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["20495d37d0c28755f57920096796d2c8d85d17d1","c7bde94df914e38596e2ce6907c04bcca8925e19"],"e66a459d38c1c4a2f97128433dab546f683a9fed":["b6284684320a9808c41a5e43de958b2da22f89bd","3e5f469d206ae27a1d59e654e70a1413ffcec765"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d7a2fb72910dc110efb34c773de307e5cbe4305a":["c26f00b574427b55127e869b935845554afde1fa"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c":["3cdb67100dc016748799a77218aa409478372d79"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"20495d37d0c28755f57920096796d2c8d85d17d1":["c7bde94df914e38596e2ce6907c04bcca8925e19","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"3cdb67100dc016748799a77218aa409478372d79":["407687e67faf6e1f02a211ca078d8e3eed631027","540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c"],"c26f00b574427b55127e869b935845554afde1fa":["d7a2fb72910dc110efb34c773de307e5cbe4305a"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"a3584d3db8b472772e3329d9d95d584b68ae997e":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c7bde94df914e38596e2ce6907c04bcca8925e19":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"b6284684320a9808c41a5e43de958b2da22f89bd":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3e5f469d206ae27a1d59e654e70a1413ffcec765","e66a459d38c1c4a2f97128433dab546f683a9fed"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"3e5f469d206ae27a1d59e654e70a1413ffcec765":["a3584d3db8b472772e3329d9d95d584b68ae997e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e66a459d38c1c4a2f97128433dab546f683a9fed"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"e66a459d38c1c4a2f97128433dab546f683a9fed":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"d7a2fb72910dc110efb34c773de307e5cbe4305a":["3cdb67100dc016748799a77218aa409478372d79","407687e67faf6e1f02a211ca078d8e3eed631027"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"540d8a5fd510a46e41f9a51f7a93f8b2d37c1c4c":["20495d37d0c28755f57920096796d2c8d85d17d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","74f45af4339b0daf7a95c820ab88c1aea74fbce0","e66a459d38c1c4a2f97128433dab546f683a9fed","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}