{"path":"solr/solrj/src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf0b1b21012d341c80a1f3975cf88823f0fe95a9","date":1316016056,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cf0b1b21012d341c80a1f3975cf88823f0fe95a9":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf0b1b21012d341c80a1f3975cf88823f0fe95a9"]},"commit2Childs":{"cf0b1b21012d341c80a1f3975cf88823f0fe95a9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cf0b1b21012d341c80a1f3975cf88823f0fe95a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}