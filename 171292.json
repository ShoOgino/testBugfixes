{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell2/Dictionary#readDictionaryFile(InputStream,CharsetDecoder,TreeMap[BytesRef,Integer]).mjava","commits":[{"id":"c214bc712d04c78c4d434119d560d0a4dd2fce4f","date":1393216863,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell2/Dictionary#readDictionaryFile(InputStream,CharsetDecoder,TreeMap[BytesRef,Integer]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStream, building up the words map\n   *\n   * @param dictionary InputStream to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFile(InputStream dictionary, CharsetDecoder decoder, TreeMap<BytesRef,Integer> words) throws IOException {\n    BytesRef flagsScratch = new BytesRef();\n    BytesRef flagsScratch2 = new BytesRef();\n    \n    BufferedReader reader = new BufferedReader(new InputStreamReader(dictionary, decoder));\n    // TODO: don't create millions of strings.\n    String line = reader.readLine(); // first line is number of entries\n    // sometimes the number of entries has a comment/copyright after it\n    line = line.replaceFirst(\"\\\\s*\\\\#.*$\", \"\");\n    int numEntries = Integer.parseInt(line);\n    \n    // TODO: the flags themselves can be double-chars (long) or also numeric\n    // either way the trick is to encode them as char... but they must be parsed differently\n    while ((line = reader.readLine()) != null) {\n      String entry;\n      char wordForm[];\n      \n      int flagSep = line.lastIndexOf('/');\n      if (flagSep == -1) {\n        wordForm = NOFLAGS;\n        entry = line;\n      } else {\n        // note, there can be comments (morph description) after a flag.\n        // we should really look for any whitespace\n        int end = line.indexOf('\\t', flagSep);\n        if (end == -1)\n          end = line.length();\n        \n        String flagPart = line.substring(flagSep + 1, end);\n        if (aliasCount > 0) {\n          flagPart = getAliasValue(Integer.parseInt(flagPart));\n        } \n        \n        wordForm = flagParsingStrategy.parseFlags(flagPart);\n        Arrays.sort(wordForm);\n        entry = line.substring(0, flagSep);\n      }\n\n      BytesRef scratch = new BytesRef(entry);\n      Integer existingOrd = words.get(scratch);\n      final char mergedEntries[];\n      if (existingOrd == null || existingOrd == 0) {\n        mergedEntries = wordForm;\n      } else {\n        flagLookup.get(existingOrd, flagsScratch2);\n        mergedEntries = merge(decodeFlags(flagsScratch2), wordForm);\n      }\n\n      final int hashCode = encodeFlagsWithHash(flagsScratch, mergedEntries);\n      int ord = flagLookup.add(flagsScratch, hashCode);\n      if (ord < 0) {\n        // already exists in our hash\n        ord = (-ord)-1;\n      }\n      \n      words.put(scratch, ord);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"211216ec4602e62cede2940d33a93a36c2aaf8a6","date":1393221868,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell2/Dictionary#readDictionaryFile(InputStream,CharsetDecoder,Builder[Long]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell2/Dictionary#readDictionaryFile(InputStream,CharsetDecoder,TreeMap[BytesRef,Integer]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStream, building up the words map\n   *\n   * @param dictionary InputStream to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFile(InputStream dictionary, CharsetDecoder decoder, Builder<Long> words) throws IOException {\n    BytesRef flagsScratch = new BytesRef();\n    IntsRef scratchInts = new IntsRef();\n    \n    BufferedReader reader = new BufferedReader(new InputStreamReader(dictionary, decoder));\n    // TODO: don't create millions of strings.\n    String line = reader.readLine(); // first line is number of entries (approximately, sometimes)\n    // sometimes the number of entries has a comment/copyright after it\n    line = line.replaceFirst(\"\\\\s*\\\\#.*$\", \"\");\n    int numEntries = Integer.parseInt(line);\n    \n    String lines[] = new String[numEntries];\n    int upto = 0;\n    while ((line = reader.readLine()) != null) {\n      if (upto == lines.length) {\n        lines = Arrays.copyOf(lines, (int)(lines.length * 1.25));\n      }\n      lines[upto++] = line;\n    }\n    \n    // TODO: just replace this with offline sorter?\n    Arrays.sort(lines, 0, upto, new Comparator<String>() {\n      @Override\n      public int compare(String o1, String o2) {\n        int sep1 = o1.lastIndexOf('/');\n        if (sep1 >= 0) {\n          o1 = o1.substring(0, sep1);\n        }\n        \n        int sep2 = o2.lastIndexOf('/');\n        if (sep2 >= 0) {\n          o2 = o2.substring(0, sep2);\n        }\n        return o1.compareTo(o2);\n      }\n    });\n    \n    // TODO: the flags themselves can be double-chars (long) or also numeric\n    // either way the trick is to encode them as char... but they must be parsed differently\n    \n    BytesRef currentEntry = new BytesRef();\n    char currentFlags[] = new char[0];\n    \n    for (int i = 0; i < upto; i++) {\n      line = lines[i];\n      String entry;\n      char wordForm[];\n      \n      int flagSep = line.lastIndexOf('/');\n      if (flagSep == -1) {\n        wordForm = NOFLAGS;\n        entry = line;\n      } else {\n        // note, there can be comments (morph description) after a flag.\n        // we should really look for any whitespace\n        int end = line.indexOf('\\t', flagSep);\n        if (end == -1)\n          end = line.length();\n        \n        String flagPart = line.substring(flagSep + 1, end);\n        if (aliasCount > 0) {\n          flagPart = getAliasValue(Integer.parseInt(flagPart));\n        } \n        \n        wordForm = flagParsingStrategy.parseFlags(flagPart);\n        Arrays.sort(wordForm);\n        entry = line.substring(0, flagSep);\n      }\n\n      BytesRef scratch = new BytesRef(entry);\n      int cmp = scratch.compareTo(currentEntry);\n      if (cmp < 0) {\n        throw new IllegalArgumentException(\"out of order: \" + scratch.utf8ToString() + \" < \" + currentEntry.utf8ToString());\n      } else if (cmp == 0) {\n        currentFlags = merge(currentFlags, wordForm);\n      } else {\n        final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n        int ord = flagLookup.add(flagsScratch, hashCode);\n        if (ord < 0) {\n          // already exists in our hash\n          ord = (-ord)-1;\n        }\n        UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n        words.add(scratchInts, (long)ord);\n        currentEntry = scratch;\n        currentFlags = wordForm;\n      }\n    }\n    \n    final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n    int ord = flagLookup.add(flagsScratch, hashCode);\n    if (ord < 0) {\n      // already exists in our hash\n      ord = (-ord)-1;\n    }\n    UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n    words.add(scratchInts, (long)ord);\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStream, building up the words map\n   *\n   * @param dictionary InputStream to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFile(InputStream dictionary, CharsetDecoder decoder, TreeMap<BytesRef,Integer> words) throws IOException {\n    BytesRef flagsScratch = new BytesRef();\n    BytesRef flagsScratch2 = new BytesRef();\n    \n    BufferedReader reader = new BufferedReader(new InputStreamReader(dictionary, decoder));\n    // TODO: don't create millions of strings.\n    String line = reader.readLine(); // first line is number of entries\n    // sometimes the number of entries has a comment/copyright after it\n    line = line.replaceFirst(\"\\\\s*\\\\#.*$\", \"\");\n    int numEntries = Integer.parseInt(line);\n    \n    // TODO: the flags themselves can be double-chars (long) or also numeric\n    // either way the trick is to encode them as char... but they must be parsed differently\n    while ((line = reader.readLine()) != null) {\n      String entry;\n      char wordForm[];\n      \n      int flagSep = line.lastIndexOf('/');\n      if (flagSep == -1) {\n        wordForm = NOFLAGS;\n        entry = line;\n      } else {\n        // note, there can be comments (morph description) after a flag.\n        // we should really look for any whitespace\n        int end = line.indexOf('\\t', flagSep);\n        if (end == -1)\n          end = line.length();\n        \n        String flagPart = line.substring(flagSep + 1, end);\n        if (aliasCount > 0) {\n          flagPart = getAliasValue(Integer.parseInt(flagPart));\n        } \n        \n        wordForm = flagParsingStrategy.parseFlags(flagPart);\n        Arrays.sort(wordForm);\n        entry = line.substring(0, flagSep);\n      }\n\n      BytesRef scratch = new BytesRef(entry);\n      Integer existingOrd = words.get(scratch);\n      final char mergedEntries[];\n      if (existingOrd == null || existingOrd == 0) {\n        mergedEntries = wordForm;\n      } else {\n        flagLookup.get(existingOrd, flagsScratch2);\n        mergedEntries = merge(decodeFlags(flagsScratch2), wordForm);\n      }\n\n      final int hashCode = encodeFlagsWithHash(flagsScratch, mergedEntries);\n      int ord = flagLookup.add(flagsScratch, hashCode);\n      if (ord < 0) {\n        // already exists in our hash\n        ord = (-ord)-1;\n      }\n      \n      words.put(scratch, ord);\n    }\n  }\n\n","bugFix":null,"bugIntro":["cbc3688252d4a8045d69a164236b2cf87b721f17","b6b9214e93abd5c360b7dc32483691d5555a9c7e","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"211216ec4602e62cede2940d33a93a36c2aaf8a6":["c214bc712d04c78c4d434119d560d0a4dd2fce4f"],"c214bc712d04c78c4d434119d560d0a4dd2fce4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c214bc712d04c78c4d434119d560d0a4dd2fce4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"211216ec4602e62cede2940d33a93a36c2aaf8a6":[],"c214bc712d04c78c4d434119d560d0a4dd2fce4f":["211216ec4602e62cede2940d33a93a36c2aaf8a6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["211216ec4602e62cede2940d33a93a36c2aaf8a6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}