{"path":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent.Phrase#populateStats(List[Phrase],Collection[String],SolrIndexSearcher).mjava","commits":[{"id":"0d1411e62d30c460b09c6f3643df82daa10a27cc","date":1536256256,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent.Phrase#populateStats(List[Phrase],Collection[String],SolrIndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Populates the phrases with stats from the local index for the specified fields \n     */\n    public static void populateStats(final List<Phrase> phrases, final Collection<String> fieldNames,\n                                     final SolrIndexSearcher searcher) throws IOException {\n      final IndexReader reader = searcher.getIndexReader();\n      for (String field : fieldNames) {\n        for (Phrase phrase : phrases) {\n          if (phrase.is_indexed) {\n            // add stats based on this entire phrase as an indexed term\n            final Term t = new Term(field, phrase.bytes);\n            phrase.phrase_ttf.put(field, reader.totalTermFreq(t));\n            phrase.phrase_df.put(field, (long)reader.docFreq(t));\n          }\n\n          // even if our phrase is too long to be indexed whole, add stats based on the\n          // conjunction of all the individual terms in the phrase\n          List<Query> filters = new ArrayList<>(phrase.individualIndexedTerms.size());\n          for (Phrase term : phrase.individualIndexedTerms) {\n            // trust the SolrIndexSearcher to cache & intersect the individual terms so that this\n            // can be efficient regardless of how often terms are re-used multiple times in the input/phrases\n            filters.add(new TermQuery(new Term(field, term.bytes)));\n          }\n          final long count = searcher.getDocSet(filters).size();\n          phrase.subTerms_conjunctionCounts.put(field, count);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d1411e62d30c460b09c6f3643df82daa10a27cc"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d1411e62d30c460b09c6f3643df82daa10a27cc"],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}