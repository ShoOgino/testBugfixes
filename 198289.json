{"path":"lucene/core/src/java/org/apache/lucene/search/BulkScorer#score(LeafCollector,Bits,int,int).mjava","commits":[{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BulkScorer#score(LeafCollector,Bits,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BulkScorer#score(LeafCollector,int,int).mjava","sourceNew":"  /**\n   * Collects matching documents in a range and return an estimation of the\n   * next matching document which is on or after {@code max}.\n   * <p>The return value must be:</p><ul>\n   *   <li>&gt;= {@code max},</li>\n   *   <li>{@link DocIdSetIterator#NO_MORE_DOCS} if there are no more matches,</li>\n   *   <li>&lt;= the first matching document that is &gt;= {@code max} otherwise.</li>\n   * </ul>\n   * <p>{@code min} is the minimum document to be considered for matching. All\n   * documents strictly before this value must be ignored.</p>\n   * <p>Although {@code max} would be a legal return value for this method, higher\n   * values might help callers skip more efficiently over non-matching portions\n   * of the docID space.</p>\n   * <p>For instance, a {@link Scorer}-based implementation could look like\n   * below:</p>\n   * <pre class=\"prettyprint\">\n   * private final Scorer scorer; // set via constructor\n   *\n   * public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n   *   collector.setScorer(scorer);\n   *   int doc = scorer.docID();\n   *   if (doc &lt; min) {\n   *     doc = scorer.advance(min);\n   *   }\n   *   while (doc &lt; max) {\n   *     if (acceptDocs == null || acceptDocs.get(doc)) {\n   *       collector.collect(doc);\n   *     }\n   *     doc = scorer.nextDoc();\n   *   }\n   *   return doc;\n   * }\n   * </pre>\n   *\n   * @param  collector The collector to which all matching documents are passed.\n   * @param acceptDocs {@link Bits} that represents the allowed documents to match, or\n   *                   {@code null} if they are all allowed to match.\n   * @param  min Score starting at, including, this document \n   * @param  max Score up to, but not including, this doc\n   * @return an under-estimation of the next matching doc after max\n   */\n  public abstract int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException;\n\n","sourceOld":"  /**\n   * Collects matching documents in a range and return an estimation of the\n   * next matching document which is on or after {@code max}.\n   * <p>The return value must be:</p><ul>\n   *   <li>&gt;= {@code max},</li>\n   *   <li>{@link DocIdSetIterator#NO_MORE_DOCS} if there are no more matches,</li>\n   *   <li>&lt;= the first matching document that is &gt;= {@code max} otherwise.</li>\n   * </ul>\n   * <p>{@code min} is the minimum document to be considered for matching. All\n   * documents strictly before this value must be ignored.</p>\n   * <p>Although {@code max} would be a legal return value for this method, higher\n   * values might help callers skip more efficiently over non-matching portions\n   * of the docID space.</p>\n   * <p>For instance, a {@link Scorer}-based implementation could look like\n   * below:</p>\n   * <pre class=\"prettyprint\">\n   * private final Scorer scorer; // set via constructor\n   *\n   * public int score(LeafCollector collector, int min, int max) throws IOException {\n   *   collector.setScorer(scorer);\n   *   int doc = scorer.docID();\n   *   if (doc &lt; min) {\n   *     doc = scorer.advance(min);\n   *   }\n   *   while (doc &lt; max) {\n   *     collector.collect(doc);\n   *     doc = scorer.nextDoc();\n   *   }\n   *   return doc;\n   * }\n   * </pre>\n   *\n   * @param  collector The collector to which all matching documents are passed.\n   * @param  min Score starting at, including, this document \n   * @param  max Score up to, but not including, this doc\n   * @return an under-estimation of the next matching doc after max\n   */\n  public abstract int score(LeafCollector collector, int min, int max) throws IOException;\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}