{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","commits":[{"id":"02453e8d9fe1bde22dc7676145ad809cb1dbfcad","date":1386084179,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"/dev/null","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<SortField>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<SchemaField>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields);\n      newSpec.setOffset(current.getOffset());\n      newSpec.setCount(current.getCount());\n      return newSpec;\n    }\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"/dev/null","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<SortField>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<SchemaField>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields);\n      newSpec.setOffset(current.getOffset());\n      newSpec.setCount(current.getCount());\n      return newSpec;\n    }\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields);\n      newSpec.setOffset(current.getOffset());\n      newSpec.setCount(current.getCount());\n      return newSpec;\n    }\n    return null;\n  }\n\n","sourceOld":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<SortField>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<SchemaField>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields);\n      newSpec.setOffset(current.getOffset());\n      newSpec.setCount(current.getCount());\n      return newSpec;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f20d97ebbd280405cebcc21d53c781bf4456453","date":1480454130,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields,\n                                      current.getCount(),\n                                      current.getOffset());\n      return newSpec;\n    }\n    return null;\n  }\n\n","sourceOld":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields);\n      newSpec.setOffset(current.getOffset());\n      newSpec.setCount(current.getCount());\n      return newSpec;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b101c3c0e7f5871415e80d970cb3289309f3522e","date":1480511898,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields,\n                                      current.getCount(),\n                                      current.getOffset());\n      return newSpec;\n    }\n    return null;\n  }\n\n","sourceOld":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields);\n      newSpec.setOffset(current.getOffset());\n      newSpec.setCount(current.getCount());\n      return newSpec;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields,\n                                      current.getCount(),\n                                      current.getOffset());\n      return newSpec;\n    }\n    return null;\n  }\n\n","sourceOld":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields);\n      newSpec.setOffset(current.getOffset());\n      newSpec.setCount(current.getCount());\n      return newSpec;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ad458affd82a1d762eb506003907d9363a333cb","date":1528558344,"type":3,"author":"broustant","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean forceElevation, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (forceElevation && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    return modify ?\n            new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                    fields,\n                    current.getCount(),\n                    current.getOffset())\n            : null;\n  }\n\n","sourceOld":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields,\n                                      current.getCount(),\n                                      current.getOffset());\n      return newSpec;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean forceElevation, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (forceElevation && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    return modify ?\n            new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                    fields,\n                    current.getCount(),\n                    current.getOffset())\n            : null;\n  }\n\n","sourceOld":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields,\n                                      current.getCount(),\n                                      current.getOffset());\n      return newSpec;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean forceElevation, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (forceElevation && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    return modify ?\n            new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                    fields,\n                    current.getCount(),\n                    current.getOffset())\n            : null;\n  }\n\n","sourceOld":"  private SortSpec modifySortSpec(SortSpec current, boolean force, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (force && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    if (modify) {\n      SortSpec newSpec = new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                                      fields,\n                                      current.getCount(),\n                                      current.getOffset());\n      return newSpec;\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6046c615b67e878b7c0ab9257d01dd759493f06","date":1564997027,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean forceElevation, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (forceElevation && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    return modify ?\n            new SortSpec(new Sort(sorts.toArray(new SortField[0])),\n                    fields,\n                    current.getCount(),\n                    current.getOffset())\n            : null;\n  }\n\n","sourceOld":"  private SortSpec modifySortSpec(SortSpec current, boolean forceElevation, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (forceElevation && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    return modify ?\n            new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                    fields,\n                    current.getCount(),\n                    current.getOffset())\n            : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","date":1565097295,"type":3,"author":"Jan HÃ¸ydahl","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#modifySortSpec(SortSpec,boolean,ElevationComparatorSource).mjava","sourceNew":"  private SortSpec modifySortSpec(SortSpec current, boolean forceElevation, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (forceElevation && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    return modify ?\n            new SortSpec(new Sort(sorts.toArray(new SortField[0])),\n                    fields,\n                    current.getCount(),\n                    current.getOffset())\n            : null;\n  }\n\n","sourceOld":"  private SortSpec modifySortSpec(SortSpec current, boolean forceElevation, ElevationComparatorSource comparator) {\n    boolean modify = false;\n    SortField[] currentSorts = current.getSort().getSort();\n    List<SchemaField> currentFields = current.getSchemaFields();\n\n    ArrayList<SortField> sorts = new ArrayList<>(currentSorts.length + 1);\n    List<SchemaField> fields = new ArrayList<>(currentFields.size() + 1);\n\n    // Perhaps force it to always sort by score\n    if (forceElevation && currentSorts[0].getType() != SortField.Type.SCORE) {\n      sorts.add(new SortField(\"_elevate_\", comparator, true));\n      fields.add(null);\n      modify = true;\n    }\n    for (int i = 0; i < currentSorts.length; i++) {\n      SortField sf = currentSorts[i];\n      if (sf.getType() == SortField.Type.SCORE) {\n        sorts.add(new SortField(\"_elevate_\", comparator, !sf.getReverse()));\n        fields.add(null);\n        modify = true;\n      }\n      sorts.add(sf);\n      fields.add(currentFields.get(i));\n    }\n    return modify ?\n            new SortSpec(new Sort(sorts.toArray(new SortField[sorts.size()])),\n                    fields,\n                    current.getCount(),\n                    current.getOffset())\n            : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"3f20d97ebbd280405cebcc21d53c781bf4456453":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"e6046c615b67e878b7c0ab9257d01dd759493f06":["2ad458affd82a1d762eb506003907d9363a333cb"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["b101c3c0e7f5871415e80d970cb3289309f3522e","2ad458affd82a1d762eb506003907d9363a333cb"],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b101c3c0e7f5871415e80d970cb3289309f3522e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","3f20d97ebbd280405cebcc21d53c781bf4456453"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2ad458affd82a1d762eb506003907d9363a333cb":["b101c3c0e7f5871415e80d970cb3289309f3522e"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"9856095f7afb5a607bf5e65077615ed91273508c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","b101c3c0e7f5871415e80d970cb3289309f3522e"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":["2ad458affd82a1d762eb506003907d9363a333cb","e6046c615b67e878b7c0ab9257d01dd759493f06"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e6046c615b67e878b7c0ab9257d01dd759493f06"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["b101c3c0e7f5871415e80d970cb3289309f3522e","2ad458affd82a1d762eb506003907d9363a333cb"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3f20d97ebbd280405cebcc21d53c781bf4456453","b101c3c0e7f5871415e80d970cb3289309f3522e","9856095f7afb5a607bf5e65077615ed91273508c"],"3f20d97ebbd280405cebcc21d53c781bf4456453":["b101c3c0e7f5871415e80d970cb3289309f3522e"],"e6046c615b67e878b7c0ab9257d01dd759493f06":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"b101c3c0e7f5871415e80d970cb3289309f3522e":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","2ad458affd82a1d762eb506003907d9363a333cb","9856095f7afb5a607bf5e65077615ed91273508c","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"2ad458affd82a1d762eb506003907d9363a333cb":["e6046c615b67e878b7c0ab9257d01dd759493f06","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"9856095f7afb5a607bf5e65077615ed91273508c":[],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","74f45af4339b0daf7a95c820ab88c1aea74fbce0","9856095f7afb5a607bf5e65077615ed91273508c","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}