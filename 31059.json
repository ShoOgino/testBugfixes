{"path":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","commits":[{"id":"209b03e6aa9098ac043cc757e46f758400427b15","date":1355045906,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final CategoryDocumentBuilder cdb = new CategoryDocumentBuilder(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length();\n                while (level > 0) {\n                  String s = cp.toString('/', level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              cdb.setCategoryPaths(cats);\n              cdb.build(doc);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final CategoryDocumentBuilder cdb = new CategoryDocumentBuilder(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length();\n                while (level > 0) {\n                  String s = cp.toString('/', level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              cdb.setCategoryPaths(cats);\n              cdb.build(doc);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a1037d9031f9702ee6912f8751ef1d5320da6d9","date":1357217787,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final FacetFields facetFields = new FacetFields(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length();\n                while (level > 0) {\n                  String s = cp.toString('/', level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              facetFields.addFields(doc, cats);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final CategoryDocumentBuilder cdb = new CategoryDocumentBuilder(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length();\n                while (level > 0) {\n                  String s = cp.toString('/', level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              cdb.setCategoryPaths(cats);\n              cdb.build(doc);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","date":1357499264,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final FacetFields facetFields = new FacetFields(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length;\n                while (level > 0) {\n                  String s = cp.subpath(level).toString('/');\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              facetFields.addFields(doc, cats);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = CategoryPath.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final FacetFields facetFields = new FacetFields(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length();\n                while (level > 0) {\n                  String s = cp.toString('/', level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              facetFields.addFields(doc, cats);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final FacetFields facetFields = new FacetFields(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length;\n                while (level > 0) {\n                  String s = cp.subpath(level).toString('/');\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              facetFields.addFields(doc, cats);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = CategoryPath.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final CategoryDocumentBuilder cdb = new CategoryDocumentBuilder(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length();\n                while (level > 0) {\n                  String s = cp.toString('/', level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              cdb.setCategoryPaths(cats);\n              cdb.build(doc);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final FacetFields facetFields = new FacetFields(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<FacetLabel> cats = new ArrayList<FacetLabel>(numCats);\n              while (numCats-- > 0) {\n                FacetLabel cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length;\n                while (level > 0) {\n                  String s = cp.subpath(level).toString('/');\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              facetFields.addFields(doc, cats);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final FacetFields facetFields = new FacetFields(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length;\n                while (level > 0) {\n                  String s = cp.subpath(level).toString('/');\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              facetFields.addFields(doc, cats);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = CategoryPath.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33e19a97046248623a7591aeaa6547233fd15e2","date":1385424777,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = FacetLabel.create(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = label.subpath(level).toString('/');\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final FacetFields facetFields = new FacetFields(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<FacetLabel> cats = new ArrayList<FacetLabel>(numCats);\n              while (numCats-- > 0) {\n                FacetLabel cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length;\n                while (level > 0) {\n                  String s = cp.subpath(level).toString('/');\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              facetFields.addFields(doc, cats);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbe9946d3cd818d329255e4c325597ac3480503e","date":1385580921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = FacetLabel.create(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = FacetLabel.create(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = label.subpath(level).toString('/');\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd83550e4b0bdd36e7d9dca9273264100782440b","date":1385761753,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = FacetLabel.create(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56d44586f4c409c6c6c5942b9f0227df806b7300","date":1386027853,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9264c0cc71ca63967ca4c832e5d3514c000b55e6","date":1386094934,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        private final FacetFields facetFields = new FacetFields(tw);\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);\n              while (numCats-- > 0) {\n                CategoryPath cp = newCategory();\n                cats.add(cp);\n                // add all prefixes to values\n                int level = cp.length;\n                while (level > 0) {\n                  String s = cp.subpath(level).toString('/');\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              facetFields.addFields(doc, cats);\n              iw.addDocument(doc);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, tr.getSize()); // +1 for root category\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = CategoryPath.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    tr.close();\n\n    IOUtils.close(tw, iw, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    iw.shutdown();\n    IOUtils.close(tw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(tw, iw, tr, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    iw.shutdown();\n    IOUtils.close(tw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    iw.shutdown();\n    IOUtils.close(tw, tr, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    iw.close();\n    IOUtils.close(tw, tr, taxoDir, indexDir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final AtomicInteger numDocs = new AtomicInteger(atLeast(10000));\n    final Directory indexDir = newDirectory();\n    final Directory taxoDir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(null));\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE, newTaxoWriterCache(numDocs.get()));\n    final Thread[] indexThreads = new Thread[atLeast(4)];\n    final FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<10;i++) {\n      config.setHierarchical(\"l1.\" + i, true);\n      config.setMultiValued(\"l1.\" + i, true);\n    }\n\n    for (int i = 0; i < indexThreads.length; i++) {\n      indexThreads[i] = new Thread() {\n        \n        @Override\n        public void run() {\n          Random random = random();\n          while (numDocs.decrementAndGet() > 0) {\n            try {\n              Document doc = new Document();\n              int numCats = random.nextInt(3) + 1; // 1-3\n              while (numCats-- > 0) {\n                FacetField ff = newCategory();\n                doc.add(ff);\n\n                FacetLabel label = new FacetLabel(ff.dim, ff.path);\n                // add all prefixes to values\n                int level = label.length;\n                while (level > 0) {\n                  String s = FacetsConfig.pathToString(label.components, level);\n                  values.put(s, s);\n                  --level;\n                }\n              }\n              iw.addDocument(config.build(tw, doc));\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : indexThreads) t.start();\n    for (Thread t : indexThreads) t.join();\n    \n    DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    // +1 for root category\n    if (values.size() + 1 != tr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (tr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, tr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = null;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = tr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    iw.shutdown();\n    IOUtils.close(tw, tr, taxoDir, indexDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"7a1037d9031f9702ee6912f8751ef1d5320da6d9":["209b03e6aa9098ac043cc757e46f758400427b15"],"d33e19a97046248623a7591aeaa6547233fd15e2":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"56d44586f4c409c6c6c5942b9f0227df806b7300":["fd83550e4b0bdd36e7d9dca9273264100782440b"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","209b03e6aa9098ac043cc757e46f758400427b15"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["7a1037d9031f9702ee6912f8751ef1d5320da6d9"],"209b03e6aa9098ac043cc757e46f758400427b15":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9264c0cc71ca63967ca4c832e5d3514c000b55e6":["56d44586f4c409c6c6c5942b9f0227df806b7300"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"fd83550e4b0bdd36e7d9dca9273264100782440b":["bbe9946d3cd818d329255e4c325597ac3480503e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","9264c0cc71ca63967ca4c832e5d3514c000b55e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"bbe9946d3cd818d329255e4c325597ac3480503e":["d33e19a97046248623a7591aeaa6547233fd15e2"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"7a1037d9031f9702ee6912f8751ef1d5320da6d9":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"d33e19a97046248623a7591aeaa6547233fd15e2":["bbe9946d3cd818d329255e4c325597ac3480503e"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"56d44586f4c409c6c6c5942b9f0227df806b7300":["9264c0cc71ca63967ca4c832e5d3514c000b55e6"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["d33e19a97046248623a7591aeaa6547233fd15e2"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c190847801a50f4dd20fd639bdc29b54ea3b288b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"209b03e6aa9098ac043cc757e46f758400427b15":["7a1037d9031f9702ee6912f8751ef1d5320da6d9","407687e67faf6e1f02a211ca078d8e3eed631027"],"9264c0cc71ca63967ca4c832e5d3514c000b55e6":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["407687e67faf6e1f02a211ca078d8e3eed631027","209b03e6aa9098ac043cc757e46f758400427b15"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fd83550e4b0bdd36e7d9dca9273264100782440b":["56d44586f4c409c6c6c5942b9f0227df806b7300"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"bbe9946d3cd818d329255e4c325597ac3480503e":["fd83550e4b0bdd36e7d9dca9273264100782440b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}