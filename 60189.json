{"path":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","commits":[{"id":"d984627825732e682759c22df7a3b171a80f3812","date":1461857653,"type":0,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","pathOld":"/dev/null","sourceNew":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields and filterQueries\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields = list.append(\"fields\",\n        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));\n    final Expression filterQueries = list.append(\"filterQueries\", constantArrayList(solrImplementor.filterQueries, String.class));\n    final Expression order = list.append(\"order\", constantArrayList(solrImplementor.order, String.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, filterQueries, order, limit));\n    if (CalcitePrepareImpl.DEBUG) {\n      System.out.println(\"Solr: \" + filterQueries);\n    }\n    Hook.QUERY_PLAN.run(filterQueries);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1bfdd692c5b78fe01e8f90339fb1edbcc887a90","date":1461958396,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","sourceNew":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields and filterQueries\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields = list.append(\"fields\",\n        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));\n    final Expression filterQueries = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression order = list.append(\"order\", constantArrayList(solrImplementor.order, String.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, filterQueries, order, limit));\n    if (CalcitePrepareImpl.DEBUG) {\n      System.out.println(\"Solr: \" + filterQueries);\n    }\n    Hook.QUERY_PLAN.run(filterQueries);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","sourceOld":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields and filterQueries\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields = list.append(\"fields\",\n        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));\n    final Expression filterQueries = list.append(\"filterQueries\", constantArrayList(solrImplementor.filterQueries, String.class));\n    final Expression order = list.append(\"order\", constantArrayList(solrImplementor.order, String.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, filterQueries, order, limit));\n    if (CalcitePrepareImpl.DEBUG) {\n      System.out.println(\"Solr: \" + filterQueries);\n    }\n    Hook.QUERY_PLAN.run(filterQueries);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef","date":1462373155,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","sourceNew":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields and filterQueries\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields = list.append(\"fields\",\n        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));\n    final Expression filterQueries = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression order = list.append(\"order\", constantArrayList(solrImplementor.order, String.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metrics = list.append(\"metrics\", constantArrayList(solrImplementor.metrics, Metric.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, filterQueries, order, buckets, metrics, limit));\n    if (CalcitePrepareImpl.DEBUG) {\n      System.out.println(\"Solr: \" + filterQueries);\n    }\n    Hook.QUERY_PLAN.run(filterQueries);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","sourceOld":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields and filterQueries\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields = list.append(\"fields\",\n        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));\n    final Expression filterQueries = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression order = list.append(\"order\", constantArrayList(solrImplementor.order, String.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, filterQueries, order, limit));\n    if (CalcitePrepareImpl.DEBUG) {\n      System.out.println(\"Solr: \" + filterQueries);\n    }\n    Hook.QUERY_PLAN.run(filterQueries);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cc8e977a08af3169747ab78c578cc3037d095d5","date":1462391783,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","sourceNew":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields = list.append(\"fields\",\n        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression order = list.append(\"order\", constantArrayList(solrImplementor.order, String.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, order, buckets, metricPairs, limit));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","sourceOld":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields and filterQueries\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields = list.append(\"fields\",\n        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));\n    final Expression filterQueries = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression order = list.append(\"order\", constantArrayList(solrImplementor.order, String.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metrics = list.append(\"metrics\", constantArrayList(solrImplementor.metrics, Metric.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, filterQueries, order, buckets, metrics, limit));\n    if (CalcitePrepareImpl.DEBUG) {\n      System.out.println(\"Solr: \" + filterQueries);\n    }\n    Hook.QUERY_PLAN.run(filterQueries);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa4a466195c69a11a113b33adc90f9069031e54e","date":1477605536,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","sourceNew":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields =\n        list.append(\"fields\",\n            constantArrayList(\n                Pair.zip(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings),\n                    new AbstractList<Class>() {\n                      @Override public Class get(int index) {\n                        return physType.fieldClass(index);\n                      }\n\n                      @Override public int size() {\n                        return rowType.getFieldCount();\n                      }\n                    }),\n                Pair.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression orders = list.append(\"orders\", constantArrayList(solrImplementor.orders, Pair.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, orders, buckets, metricPairs, limit));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","sourceOld":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields = list.append(\"fields\",\n        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression order = list.append(\"order\", constantArrayList(solrImplementor.order, String.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, order, buckets, metricPairs, limit));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36b1ce25b5b465615c00f409ce694664abbe7bd2","date":1481836328,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","sourceNew":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields =\n        list.append(\"fields\",\n            constantArrayList(\n                Pair.zip(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings),\n                    new AbstractList<Class>() {\n                      @Override\n                      public Class get(int index) {\n                        return physType.fieldClass(index);\n                      }\n\n                      @Override\n                      public int size() {\n                        return rowType.getFieldCount();\n                      }\n                    }),\n                Pair.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression orders = list.append(\"orders\", constantArrayList(solrImplementor.orders, Pair.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    final Expression negativeQuery = list.append(\"negativeQuery\", Expressions.constant(Boolean.toString(solrImplementor.negativeQuery), String.class));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, orders, buckets, metricPairs, limit, negativeQuery));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","sourceOld":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields =\n        list.append(\"fields\",\n            constantArrayList(\n                Pair.zip(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings),\n                    new AbstractList<Class>() {\n                      @Override public Class get(int index) {\n                        return physType.fieldClass(index);\n                      }\n\n                      @Override public int size() {\n                        return rowType.getFieldCount();\n                      }\n                    }),\n                Pair.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression orders = list.append(\"orders\", constantArrayList(solrImplementor.orders, Pair.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, orders, buckets, metricPairs, limit));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5cb41f0427fb7a75b0bfefe992561738c11fd80","date":1486576891,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","sourceNew":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields =\n        list.append(\"fields\",\n            constantArrayList(\n                Pair.zip(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings),\n                    new AbstractList<Class>() {\n                      @Override\n                      public Class get(int index) {\n                        return physType.fieldClass(index);\n                      }\n\n                      @Override\n                      public int size() {\n                        return rowType.getFieldCount();\n                      }\n                    }),\n                Pair.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression orders = list.append(\"orders\", constantArrayList(solrImplementor.orders, Pair.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    final Expression negativeQuery = list.append(\"negativeQuery\", Expressions.constant(Boolean.toString(solrImplementor.negativeQuery), String.class));\n    final Expression havingPredicate = list.append(\"havingTest\", Expressions.constant(solrImplementor.havingPredicate, String.class));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, orders, buckets, metricPairs, limit, negativeQuery, havingPredicate));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","sourceOld":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields =\n        list.append(\"fields\",\n            constantArrayList(\n                Pair.zip(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings),\n                    new AbstractList<Class>() {\n                      @Override\n                      public Class get(int index) {\n                        return physType.fieldClass(index);\n                      }\n\n                      @Override\n                      public int size() {\n                        return rowType.getFieldCount();\n                      }\n                    }),\n                Pair.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression orders = list.append(\"orders\", constantArrayList(solrImplementor.orders, Pair.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    final Expression negativeQuery = list.append(\"negativeQuery\", Expressions.constant(Boolean.toString(solrImplementor.negativeQuery), String.class));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, orders, buckets, metricPairs, limit, negativeQuery));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"116fdd6b9e04e18a6547a5650bc0afd3fda020aa","date":1487184909,"type":0,"author":"Joel Bernstein","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","pathOld":"/dev/null","sourceNew":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields =\n        list.append(\"fields\",\n            constantArrayList(\n                Pair.zip(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings),\n                    new AbstractList<Class>() {\n                      @Override\n                      public Class get(int index) {\n                        return physType.fieldClass(index);\n                      }\n\n                      @Override\n                      public int size() {\n                        return rowType.getFieldCount();\n                      }\n                    }),\n                Pair.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression orders = list.append(\"orders\", constantArrayList(solrImplementor.orders, Pair.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    final Expression negativeQuery = list.append(\"negativeQuery\", Expressions.constant(Boolean.toString(solrImplementor.negativeQuery), String.class));\n    final Expression havingPredicate = list.append(\"havingTest\", Expressions.constant(solrImplementor.havingPredicate, String.class));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, orders, buckets, metricPairs, limit, negativeQuery, havingPredicate));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrToEnumerableConverter#implement(EnumerableRelImplementor,Prefer).mjava","sourceNew":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    @SuppressWarnings({\"rawtypes\"})\n    final Expression fields =\n        list.append(\"fields\",\n            constantArrayList(\n                Pair.zip(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings),\n                    new AbstractList<Class>() {\n                      @Override\n                      @SuppressWarnings({\"rawtypes\"})\n                      public Class get(int index) {\n                        return physType.fieldClass(index);\n                      }\n\n                      @Override\n                      public int size() {\n                        return rowType.getFieldCount();\n                      }\n                    }),\n                Pair.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression orders = list.append(\"orders\", constantArrayList(solrImplementor.orders, Pair.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    final Expression negativeQuery = list.append(\"negativeQuery\", Expressions.constant(Boolean.toString(solrImplementor.negativeQuery), String.class));\n    final Expression havingPredicate = list.append(\"havingTest\", Expressions.constant(solrImplementor.havingPredicate, String.class));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, orders, buckets, metricPairs, limit, negativeQuery, havingPredicate));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","sourceOld":"  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n    // Generates a call to \"query\" with the appropriate fields\n    final BlockBuilder list = new BlockBuilder();\n    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();\n    solrImplementor.visitChild(0, getInput());\n    final RelDataType rowType = getRowType();\n    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));\n    final Expression table = list.append(\"table\", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));\n    final Expression fields =\n        list.append(\"fields\",\n            constantArrayList(\n                Pair.zip(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings),\n                    new AbstractList<Class>() {\n                      @Override\n                      public Class get(int index) {\n                        return physType.fieldClass(index);\n                      }\n\n                      @Override\n                      public int size() {\n                        return rowType.getFieldCount();\n                      }\n                    }),\n                Pair.class));\n    final Expression query = list.append(\"query\", Expressions.constant(solrImplementor.query, String.class));\n    final Expression orders = list.append(\"orders\", constantArrayList(solrImplementor.orders, Pair.class));\n    final Expression buckets = list.append(\"buckets\", constantArrayList(solrImplementor.buckets, String.class));\n    final Expression metricPairs = list.append(\"metricPairs\", constantArrayList(solrImplementor.metricPairs, Pair.class));\n    final Expression limit = list.append(\"limit\", Expressions.constant(solrImplementor.limitValue));\n    final Expression negativeQuery = list.append(\"negativeQuery\", Expressions.constant(Boolean.toString(solrImplementor.negativeQuery), String.class));\n    final Expression havingPredicate = list.append(\"havingTest\", Expressions.constant(solrImplementor.havingPredicate, String.class));\n    Expression enumerable = list.append(\"enumerable\", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,\n        fields, query, orders, buckets, metricPairs, limit, negativeQuery, havingPredicate));\n    Hook.QUERY_PLAN.run(query);\n    list.add(Expressions.return_(null, enumerable));\n    return implementor.result(physType, list.toBlock());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa4a466195c69a11a113b33adc90f9069031e54e":["9cc8e977a08af3169747ab78c578cc3037d095d5"],"9cc8e977a08af3169747ab78c578cc3037d095d5":["724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef"],"116fdd6b9e04e18a6547a5650bc0afd3fda020aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d5cb41f0427fb7a75b0bfefe992561738c11fd80"],"d5cb41f0427fb7a75b0bfefe992561738c11fd80":["36b1ce25b5b465615c00f409ce694664abbe7bd2"],"36b1ce25b5b465615c00f409ce694664abbe7bd2":["fa4a466195c69a11a113b33adc90f9069031e54e"],"d984627825732e682759c22df7a3b171a80f3812":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c1bfdd692c5b78fe01e8f90339fb1edbcc887a90":["d984627825732e682759c22df7a3b171a80f3812"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef":["c1bfdd692c5b78fe01e8f90339fb1edbcc887a90"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["116fdd6b9e04e18a6547a5650bc0afd3fda020aa"]},"commit2Childs":{"fa4a466195c69a11a113b33adc90f9069031e54e":["36b1ce25b5b465615c00f409ce694664abbe7bd2"],"9cc8e977a08af3169747ab78c578cc3037d095d5":["fa4a466195c69a11a113b33adc90f9069031e54e"],"116fdd6b9e04e18a6547a5650bc0afd3fda020aa":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"d5cb41f0427fb7a75b0bfefe992561738c11fd80":["116fdd6b9e04e18a6547a5650bc0afd3fda020aa"],"36b1ce25b5b465615c00f409ce694664abbe7bd2":["d5cb41f0427fb7a75b0bfefe992561738c11fd80"],"d984627825732e682759c22df7a3b171a80f3812":["c1bfdd692c5b78fe01e8f90339fb1edbcc887a90"],"c1bfdd692c5b78fe01e8f90339fb1edbcc887a90":["724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["116fdd6b9e04e18a6547a5650bc0afd3fda020aa","d984627825732e682759c22df7a3b171a80f3812"],"724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef":["9cc8e977a08af3169747ab78c578cc3037d095d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}