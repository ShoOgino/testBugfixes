{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#addSubShardLeaders(DocCollection,String,String,SolrInputDocument,List[Node]).mjava","commits":[{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#addSubShardLeaders(DocCollection,String,String,SolrInputDocument,List[Node]).mjava","pathOld":"/dev/null","sourceNew":"  private List<Node> addSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc, List<Node> nodes) {\n    Collection<Slice> allSlices = coll.getSlices();\n    for (Slice aslice : allSlices) {\n      if (Slice.CONSTRUCTION.equals(aslice.getState()))  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n            || (docId != null && coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll)))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null)  {\n            if (nodes == null) nodes = new ArrayList<Node>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new StdNode(nodeProps));\n            forwardToSubShard = true;\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b5f4ea6ae725ccb8bc0996a64d32adb2302b80a","date":1366034299,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#addSubShardLeaders(DocCollection,String,String,SolrInputDocument,List[Node]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#addSubShardLeaders(DocCollection,String,String,SolrInputDocument,List[Node]).mjava","sourceNew":"  private List<Node> addSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc, List<Node> nodes) {\n    Collection<Slice> allSlices = coll.getSlices();\n    for (Slice aslice : allSlices) {\n      if (Slice.CONSTRUCTION.equals(aslice.getState()))  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n            || (docId != null && coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll)))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && zkController.getClusterState().liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<Node>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new StdNode(nodeProps));\n            forwardToSubShard = true;\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> addSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc, List<Node> nodes) {\n    Collection<Slice> allSlices = coll.getSlices();\n    for (Slice aslice : allSlices) {\n      if (Slice.CONSTRUCTION.equals(aslice.getState()))  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n            || (docId != null && coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll)))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null)  {\n            if (nodes == null) nodes = new ArrayList<Node>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new StdNode(nodeProps));\n            forwardToSubShard = true;\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f1ea787bab5bdb5e72685e55424898da05509b6","date":1370289750,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getSubShardLeaders(DocCollection,String,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#addSubShardLeaders(DocCollection,String,String,SolrInputDocument,List[Node]).mjava","sourceNew":"  private List<Node> getSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc) {\n    Collection<Slice> allSlices = coll.getSlices();\n    List<Node> nodes = null;\n    for (Slice aslice : allSlices) {\n      if (Slice.CONSTRUCTION.equals(aslice.getState()))  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n            || (docId != null && coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll)))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && zkController.getClusterState().liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<Node>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new StdNode(nodeProps));\n            forwardToSubShard = true;\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> addSubShardLeaders(DocCollection coll, String shardId, String docId, SolrInputDocument doc, List<Node> nodes) {\n    Collection<Slice> allSlices = coll.getSlices();\n    for (Slice aslice : allSlices) {\n      if (Slice.CONSTRUCTION.equals(aslice.getState()))  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n            || (docId != null && coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll)))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && zkController.getClusterState().liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<Node>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new StdNode(nodeProps));\n            forwardToSubShard = true;\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8f1ea787bab5bdb5e72685e55424898da05509b6":["6b5f4ea6ae725ccb8bc0996a64d32adb2302b80a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6b5f4ea6ae725ccb8bc0996a64d32adb2302b80a":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8f1ea787bab5bdb5e72685e55424898da05509b6"]},"commit2Childs":{"8f1ea787bab5bdb5e72685e55424898da05509b6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"6b5f4ea6ae725ccb8bc0996a64d32adb2302b80a":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["6b5f4ea6ae725ccb8bc0996a64d32adb2302b80a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}