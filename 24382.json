{"path":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4#decompress(DataInput,int,byte[],int).mjava","commits":[{"id":"9407318969e8504257b4c5764c65755a043e5404","date":1579873617,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4#decompress(DataInput,int,byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","sourceNew":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","sourceOld":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e673a608cacc7de01f6ad30a0fc89a889a2cca86","date":1582885616,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4#decompress(DataInput,int,byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4#decompress(DataInput,int,byte[],int).mjava","sourceNew":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest) throws IOException {\n    int dOff = 0;\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","sourceOld":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9aefce86de8b17eed91ab011fb54d704d91102ef","date":1599128224,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4#decompress(DataInput,int,byte[],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/compress/LZ4#decompress(DataInput,int,byte[]).mjava","sourceNew":"  /**\n   * Decompress at least {@code decompressedLen} bytes into\n   * {@code dest[dOff:]}. Please note that {@code dest} must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   * If the given bytes were compressed using a preset dictionary then the same\n   * dictionary must be provided in {@code dest[dOff-dictLen:dOff]}.\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dOff + decompressedLen;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= destEnd) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < destEnd);\n\n    return dOff;\n  }\n\n","sourceOld":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest) throws IOException {\n    int dOff = 0;\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = (matchLen + 7) & 0xFFFFFFF8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e673a608cacc7de01f6ad30a0fc89a889a2cca86":["9407318969e8504257b4c5764c65755a043e5404"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9aefce86de8b17eed91ab011fb54d704d91102ef":["e673a608cacc7de01f6ad30a0fc89a889a2cca86"],"9407318969e8504257b4c5764c65755a043e5404":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9aefce86de8b17eed91ab011fb54d704d91102ef"]},"commit2Childs":{"e673a608cacc7de01f6ad30a0fc89a889a2cca86":["9aefce86de8b17eed91ab011fb54d704d91102ef"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9407318969e8504257b4c5764c65755a043e5404"],"9407318969e8504257b4c5764c65755a043e5404":["e673a608cacc7de01f6ad30a0fc89a889a2cca86"],"9aefce86de8b17eed91ab011fb54d704d91102ef":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}