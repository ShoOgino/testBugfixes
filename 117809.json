{"path":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered irregardless if there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt{@link SolrIndexSearcher}&gt will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link &ltSolrIndexSearcher&gt} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @return\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone elses searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        // reset to 1 (don't bother synchronizing)\n        onDeckSearchers=1;\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then register this one\n          // before warming is complete instead of waiting.\n          registerSearcher(newSearchHolder);\n          decrementOnDeckCount[0]=false;\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      Future finalFuture=null;\n      if (currSearcherHolder != null) {\n        finalFuture = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registertSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = finalFuture;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e96fd8a5ecee99fb518c16ceb03a6a11c01b5468","date":1148693744,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered irregardless if there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone elses searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        // reset to 1 (don't bother synchronizing)\n        onDeckSearchers=1;\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then register this one\n          // before warming is complete instead of waiting.\n          registerSearcher(newSearchHolder);\n          decrementOnDeckCount[0]=false;\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      Future finalFuture=null;\n      if (currSearcherHolder != null) {\n        finalFuture = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registertSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = finalFuture;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered irregardless if there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt{@link SolrIndexSearcher}&gt will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link &ltSolrIndexSearcher&gt} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @return\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone elses searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        // reset to 1 (don't bother synchronizing)\n        onDeckSearchers=1;\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then register this one\n          // before warming is complete instead of waiting.\n          registerSearcher(newSearchHolder);\n          decrementOnDeckCount[0]=false;\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      Future finalFuture=null;\n      if (currSearcherHolder != null) {\n        finalFuture = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registertSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = finalFuture;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c79691d8e68029e864b42b3a0001fcdec77f4bfb","date":1165375543,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered irregardless if there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone elses searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        // reset to 1 (don't bother synchronizing)\n        onDeckSearchers=1;\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (SolrConfig.config.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered irregardless if there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone elses searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        // reset to 1 (don't bother synchronizing)\n        onDeckSearchers=1;\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then register this one\n          // before warming is complete instead of waiting.\n          registerSearcher(newSearchHolder);\n          decrementOnDeckCount[0]=false;\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      Future finalFuture=null;\n      if (currSearcherHolder != null) {\n        finalFuture = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registertSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = finalFuture;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4daa7ff683ea3a4aae444031f743a9c93cc63a31","date":1165964091,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        // reset to 1 (don't bother synchronizing)\n        onDeckSearchers=1;\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (SolrConfig.config.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered irregardless if there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone elses searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        // reset to 1 (don't bother synchronizing)\n        onDeckSearchers=1;\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (SolrConfig.config.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e99eba54d46b7d62e0202b1ab5da1725fb39fecd","date":1168639208,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(503,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (SolrConfig.config.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        // reset to 1 (don't bother synchronizing)\n        onDeckSearchers=1;\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (SolrConfig.config.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996","date":1180477701,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (SolrConfig.config.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(503,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (SolrConfig.config.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (SolrConfig.config.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    }\n    catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"048361614025800e582bfc7a7b0329dc6fd6a95e","date":1196999392,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"[\"+name+\"] ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(\"[\"+name+\"] \"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(\"[\"+name+\"] PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"[\"+name+\"] ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b46f0ccfb6b63c307ea901d48482630e3689042c","date":1198805331,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(\"[\"+name+\"] ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(\"[\"+name+\"] \"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(\"[\"+name+\"] PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(\"[\"+name+\"] ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6dc6ab6902f8f70ae43365947ccf44c25986906d","date":1204603577,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", index_path, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af9eaa0ea32c76c51438440b908d759cb5413fa9","date":1208429088,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"47d1e1ec1b59a7953de3afd6b310bac5c76017f4","date":1209829568,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b9ee90cb9c9196a70b1d7cc96cca56fdabaad263","date":1216648894,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe366944118e4f2dcf893ae671f9eda0aa2f31fa","date":1217532456,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bf92a1372bedffa4074073bb4f63b9975371311","date":1219854446,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", IndexReader.open(FSDirectory.getDirectory(getIndexDir()), true), true, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", getIndexDir(), true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"72ec6c7587d2da4bfac762c58d0d6b8552d2102d","date":1221688171,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        IndexReader newReader = currentReader.reopen();\n\n        if(newReader == currentReader) {\n          currentReader.incRef();\n        }\n        \n        tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n      } else {\n        tmp = new SolrIndexSearcher(this, schema, \"main\", IndexReader.open(FSDirectory.getDirectory(getIndexDir()), true), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    try {\n      tmp = new SolrIndexSearcher(this, schema, \"main\", IndexReader.open(FSDirectory.getDirectory(getIndexDir()), true), true, true);\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    }\n\n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        IndexReader newReader = currentReader.reopen();\n\n        if(newReader == currentReader) {\n          currentReader.incRef();\n        }\n        \n        tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n      } else {\n        tmp = new SolrIndexSearcher(this, schema, \"main\", IndexReader.open(FSDirectory.getDirectory(getIndexDir()), true), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.severe(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warning(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        IndexReader newReader = currentReader.reopen();\n\n        if(newReader == currentReader) {\n          currentReader.incRef();\n        }\n        \n        tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n      } else {\n        tmp = new SolrIndexSearcher(this, schema, \"main\", IndexReader.open(FSDirectory.getDirectory(getIndexDir()), true), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.severe(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29765e35c99654ed87e394d8bc13d8ab07b51092","date":1223889162,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        String newIndexDir = getNewIndexDir();\n        if(new File(getIndexDir()).equals(new File(newIndexDir)))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n\n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", newIndexDir, true);\n        }\n      } else {\n        tmp = new SolrIndexSearcher(this, schema, \"main\", getNewIndexDir(), true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        IndexReader newReader = currentReader.reopen();\n\n        if(newReader == currentReader) {\n          currentReader.incRef();\n        }\n        \n        tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n      } else {\n        tmp = new SolrIndexSearcher(this, schema, \"main\", IndexReader.open(FSDirectory.getDirectory(getIndexDir()), true), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31f1e0aff124b03ebeca0a1de45361b8efd0d2d9","date":1226014899,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        if(new File(getIndexDir()).equals(new File(newIndexDir)))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n        }\n      } else {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        String newIndexDir = getNewIndexDir();\n        if(new File(getIndexDir()).equals(new File(newIndexDir)))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n\n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", newIndexDir, true);\n        }\n      } else {\n        tmp = new SolrIndexSearcher(this, schema, \"main\", getNewIndexDir(), true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55a6f923d1ac6b52bf6766e2919289a3d578a95a","date":1238307727,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        if(new File(getIndexDir()).getCanonicalFile().equals(new File(newIndexDir).getCanonicalFile()))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n        }\n      } else {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        if(new File(getIndexDir()).equals(new File(newIndexDir)))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n        }\n      } else {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"656ba78dd2c0e88d11623fc5bceca3ea217ce0b3","date":1244100008,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        if(new File(getIndexDir()).getCanonicalFile().equals(new File(newIndexDir).getCanonicalFile()))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n        }\n      } else {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        if(new File(getIndexDir()).getCanonicalFile().equals(new File(newIndexDir).getCanonicalFile()))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n        }\n      } else {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.getBool(\"query/useColdSearcher\",false)) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0fb097757a4d69c293a71ad98fc00f338651ccef","date":1244117851,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        if(solrConfig.reopenReaders && new File(getIndexDir()).getCanonicalFile().equals(new File(newIndexDir).getCanonicalFile()))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n        }\n      } else {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        if(new File(getIndexDir()).getCanonicalFile().equals(new File(newIndexDir).getCanonicalFile()))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n        }\n      } else {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"87d6953dbc5baae40e6e21efa735a75f85ac13f2","date":1244472991,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        IndexReader newReader = currentReader.reopen();\n\n        if (newReader == currentReader) {\n          currentReader.incRef();\n        }\n\n        tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      if (newestSearcher != null) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        if(solrConfig.reopenReaders && new File(getIndexDir()).getCanonicalFile().equals(new File(newIndexDir).getCanonicalFile()))  {\n          IndexReader newReader = currentReader.reopen();\n\n          if(newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        } else  {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n        }\n      } else {\n          tmp = new SolrIndexSearcher(this, schema, \"main\", getDirectoryFactory().open(newIndexDir), true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[]).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        IndexReader newReader = currentReader.reopen();\n\n        if (newReader == currentReader) {\n          currentReader.incRef();\n        }\n\n        tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew           if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher     if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher       if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        IndexReader currentReader = newestSearcher.get().getReader();\n        IndexReader newReader = currentReader.reopen();\n\n        if (newReader == currentReader) {\n          currentReader.incRef();\n        }\n\n        tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"55a6f923d1ac6b52bf6766e2919289a3d578a95a":["31f1e0aff124b03ebeca0a1de45361b8efd0d2d9"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"72ec6c7587d2da4bfac762c58d0d6b8552d2102d":["6bf92a1372bedffa4074073bb4f63b9975371311"],"af9eaa0ea32c76c51438440b908d759cb5413fa9":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"6bf92a1372bedffa4074073bb4f63b9975371311":["fe366944118e4f2dcf893ae671f9eda0aa2f31fa"],"87d6953dbc5baae40e6e21efa735a75f85ac13f2":["0fb097757a4d69c293a71ad98fc00f338651ccef"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["e99eba54d46b7d62e0202b1ab5da1725fb39fecd"],"e99eba54d46b7d62e0202b1ab5da1725fb39fecd":["4daa7ff683ea3a4aae444031f743a9c93cc63a31"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["6d6338c87060be5f66757a94945975f3bbd377a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad94625fb8d088209f46650c8097196fec67f00c":["87d6953dbc5baae40e6e21efa735a75f85ac13f2"],"e96fd8a5ecee99fb518c16ceb03a6a11c01b5468":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"b9ee90cb9c9196a70b1d7cc96cca56fdabaad263":["47d1e1ec1b59a7953de3afd6b310bac5c76017f4"],"0fb097757a4d69c293a71ad98fc00f338651ccef":["656ba78dd2c0e88d11623fc5bceca3ea217ce0b3"],"656ba78dd2c0e88d11623fc5bceca3ea217ce0b3":["55a6f923d1ac6b52bf6766e2919289a3d578a95a"],"6d6338c87060be5f66757a94945975f3bbd377a9":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"4daa7ff683ea3a4aae444031f743a9c93cc63a31":["c79691d8e68029e864b42b3a0001fcdec77f4bfb"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["b46f0ccfb6b63c307ea901d48482630e3689042c"],"b46f0ccfb6b63c307ea901d48482630e3689042c":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["72ec6c7587d2da4bfac762c58d0d6b8552d2102d"],"31f1e0aff124b03ebeca0a1de45361b8efd0d2d9":["29765e35c99654ed87e394d8bc13d8ab07b51092"],"c79691d8e68029e864b42b3a0001fcdec77f4bfb":["e96fd8a5ecee99fb518c16ceb03a6a11c01b5468"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"fe366944118e4f2dcf893ae671f9eda0aa2f31fa":["b9ee90cb9c9196a70b1d7cc96cca56fdabaad263"],"47d1e1ec1b59a7953de3afd6b310bac5c76017f4":["af9eaa0ea32c76c51438440b908d759cb5413fa9"],"29765e35c99654ed87e394d8bc13d8ab07b51092":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"55a6f923d1ac6b52bf6766e2919289a3d578a95a":["656ba78dd2c0e88d11623fc5bceca3ea217ce0b3"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"72ec6c7587d2da4bfac762c58d0d6b8552d2102d":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"af9eaa0ea32c76c51438440b908d759cb5413fa9":["47d1e1ec1b59a7953de3afd6b310bac5c76017f4"],"6bf92a1372bedffa4074073bb4f63b9975371311":["72ec6c7587d2da4bfac762c58d0d6b8552d2102d"],"87d6953dbc5baae40e6e21efa735a75f85ac13f2":["ad94625fb8d088209f46650c8097196fec67f00c"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["6d6338c87060be5f66757a94945975f3bbd377a9"],"e99eba54d46b7d62e0202b1ab5da1725fb39fecd":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["b46f0ccfb6b63c307ea901d48482630e3689042c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"e96fd8a5ecee99fb518c16ceb03a6a11c01b5468":["c79691d8e68029e864b42b3a0001fcdec77f4bfb"],"b9ee90cb9c9196a70b1d7cc96cca56fdabaad263":["fe366944118e4f2dcf893ae671f9eda0aa2f31fa"],"0fb097757a4d69c293a71ad98fc00f338651ccef":["87d6953dbc5baae40e6e21efa735a75f85ac13f2"],"6d6338c87060be5f66757a94945975f3bbd377a9":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"656ba78dd2c0e88d11623fc5bceca3ea217ce0b3":["0fb097757a4d69c293a71ad98fc00f338651ccef"],"4daa7ff683ea3a4aae444031f743a9c93cc63a31":["e99eba54d46b7d62e0202b1ab5da1725fb39fecd"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["af9eaa0ea32c76c51438440b908d759cb5413fa9"],"b46f0ccfb6b63c307ea901d48482630e3689042c":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["29765e35c99654ed87e394d8bc13d8ab07b51092"],"31f1e0aff124b03ebeca0a1de45361b8efd0d2d9":["55a6f923d1ac6b52bf6766e2919289a3d578a95a"],"c79691d8e68029e864b42b3a0001fcdec77f4bfb":["4daa7ff683ea3a4aae444031f743a9c93cc63a31"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["e96fd8a5ecee99fb518c16ceb03a6a11c01b5468"],"fe366944118e4f2dcf893ae671f9eda0aa2f31fa":["6bf92a1372bedffa4074073bb4f63b9975371311"],"47d1e1ec1b59a7953de3afd6b310bac5c76017f4":["b9ee90cb9c9196a70b1d7cc96cca56fdabaad263"],"29765e35c99654ed87e394d8bc13d8ab07b51092":["31f1e0aff124b03ebeca0a1de45361b8efd0d2d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}