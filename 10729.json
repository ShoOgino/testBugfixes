{"path":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSeeks(Random,IndexReader).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSeeks(Random,IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  private static void testRandomSeeks(Random rand, IndexReader r) throws Exception {\n    final int ITER = 100;\n    List<String> allFields = new ArrayList<String>();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    while(true) {\n      String f = fieldsEnum.next();\n      if (f == null) {\n        break;\n      }\n      allFields.add(f);\n    }\n    final int fieldCount = allFields.size();\n    if (fieldCount == 0) {\n      return;\n    }\n    \n    final TermPositions termPositions = r.termPositions();\n    DocsEnum docs = null;\n    DocsAndPositionsEnum postings = null;\n\n    for(int i=0;i<ITER;i++) {\n      // Random field:\n      String f = allFields.get(rand.nextInt(fieldCount));\n\n      String text = getRandomText(rand, 1, 3, false);\n      final TermsEnum termsEnum = MultiFields.getFields(r).terms(f).iterator();\n\n      final TermsEnum.SeekStatus seekStatus = termsEnum.seek(new BytesRef(text));\n      Term t = new Term(f, text);\n      //System.out.println(\"seek to \" + t);\n\n      final TermEnum termEnum = r.terms(t);\n      \n      if (seekStatus == TermsEnum.SeekStatus.END) {\n        //System.out.println(\"found end\");\n        assertTrue(termEnum.term() == null || termEnum.term().field() != f);\n        continue;\n      } else if (seekStatus == TermsEnum.SeekStatus.FOUND) {\n        //System.out.println(\"found exact\");\n        assertEquals(t, termEnum.term());\n      } else {\n        //System.out.println(\"found other\");\n        assertEquals(termsEnum.term().utf8ToString(), termEnum.term().text());\n      }\n\n      assertEquals(termsEnum.docFreq(), termEnum.docFreq());\n\n      docs = termsEnum.docs(MultiFields.getDeletedDocs(r), docs);\n      postings = termsEnum.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n\n      termPositions.seek(termEnum.term());\n\n      int doc = 0;\n\n      final DocsEnum docsEnum;\n      if (postings != null) {\n        docsEnum = postings;\n      } else {\n        docsEnum = docs;\n      }\n      for(int j=0;j<20;j++) {\n        final int inc = nextInt(rand, 1, Math.max(10, r.maxDoc()/15));\n        int newDoc1 = docsEnum.advance(doc+inc);\n        boolean found = termPositions.skipTo(doc+inc);\n        int newDoc2;\n\n        if (newDoc1 == DocsEnum.NO_MORE_DOCS) {\n          assertFalse(found);\n          break;\n        } else {\n          assertTrue(found);\n          newDoc2 = termPositions.doc();\n        }\n        \n        assertEquals(newDoc1, newDoc2);\n        assertEquals(docsEnum.freq(), termPositions.freq());\n\n        doc = newDoc1;\n\n        if (postings == null) {\n          assertEquals(1, termPositions.freq());\n          // Old API did not always do this,\n          // specifically in the MultiTermPositions\n          // case when some segs omit positions and\n          // some don't\n          //assertEquals(0, termPositions.nextPosition());\n          assertFalse(termPositions.isPayloadAvailable());\n        } else {\n          for(int k=0;k<docsEnum.freq();k++) {\n            int pos1 = postings.nextPosition();\n            int pos2 = termPositions.nextPosition();\n            assertEquals(pos1, pos2);\n            assertEquals(postings.hasPayload(), termPositions.isPayloadAvailable());\n            if (postings.hasPayload()) {\n              assertEquals(postings.getPayloadLength(), termPositions.getPayloadLength());\n              BytesRef b1 = postings.getPayload();\n              byte[] b2 = termPositions.getPayload(null, 0);\n              assertNotNull(b1);\n              assertNotNull(b2);\n              assertTrue(equals(b1, b2));\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5c4531fadbecf73a7716fdf5cd742463e866e84e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2aafd88401639311b0404e67c94e829e123a0e45","date":1273477632,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSeeks(Random,IndexReader).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSeeks(Random,IndexReader).mjava","sourceNew":"  private static void testRandomSeeks(Random rand, IndexReader r) throws Exception {\n    final int ITER = 100 * _TestUtil.getRandomMultiplier();\n    List<String> allFields = new ArrayList<String>();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    while(true) {\n      String f = fieldsEnum.next();\n      if (f == null) {\n        break;\n      }\n      allFields.add(f);\n    }\n    final int fieldCount = allFields.size();\n    if (fieldCount == 0) {\n      return;\n    }\n    \n    final TermPositions termPositions = r.termPositions();\n    DocsEnum docs = null;\n    DocsAndPositionsEnum postings = null;\n\n    for(int i=0;i<ITER;i++) {\n      // Random field:\n      String f = allFields.get(rand.nextInt(fieldCount));\n\n      String text = getRandomText(rand, 1, 3, false);\n      final TermsEnum termsEnum = MultiFields.getFields(r).terms(f).iterator();\n\n      final TermsEnum.SeekStatus seekStatus = termsEnum.seek(new BytesRef(text));\n      Term t = new Term(f, text);\n      //System.out.println(\"seek to \" + t);\n\n      final TermEnum termEnum = r.terms(t);\n      \n      if (seekStatus == TermsEnum.SeekStatus.END) {\n        //System.out.println(\"found end\");\n        assertTrue(termEnum.term() == null || termEnum.term().field() != f);\n        continue;\n      } else if (seekStatus == TermsEnum.SeekStatus.FOUND) {\n        //System.out.println(\"found exact\");\n        assertEquals(t, termEnum.term());\n      } else {\n        //System.out.println(\"found other\");\n        assertEquals(termsEnum.term().utf8ToString(), termEnum.term().text());\n      }\n\n      assertEquals(termsEnum.docFreq(), termEnum.docFreq());\n\n      docs = termsEnum.docs(MultiFields.getDeletedDocs(r), docs);\n      postings = termsEnum.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n\n      termPositions.seek(termEnum.term());\n\n      int doc = 0;\n\n      final DocsEnum docsEnum;\n      if (postings != null) {\n        docsEnum = postings;\n      } else {\n        docsEnum = docs;\n      }\n      for(int j=0;j<20;j++) {\n        final int inc = nextInt(rand, 1, Math.max(10, r.maxDoc()/15));\n        int newDoc1 = docsEnum.advance(doc+inc);\n        boolean found = termPositions.skipTo(doc+inc);\n        int newDoc2;\n\n        if (newDoc1 == DocsEnum.NO_MORE_DOCS) {\n          assertFalse(found);\n          break;\n        } else {\n          assertTrue(found);\n          newDoc2 = termPositions.doc();\n        }\n        \n        assertEquals(newDoc1, newDoc2);\n        assertEquals(docsEnum.freq(), termPositions.freq());\n\n        doc = newDoc1;\n\n        if (postings == null) {\n          assertEquals(1, termPositions.freq());\n          // Old API did not always do this,\n          // specifically in the MultiTermPositions\n          // case when some segs omit positions and\n          // some don't\n          //assertEquals(0, termPositions.nextPosition());\n          assertFalse(termPositions.isPayloadAvailable());\n        } else {\n          for(int k=0;k<docsEnum.freq();k++) {\n            int pos1 = postings.nextPosition();\n            int pos2 = termPositions.nextPosition();\n            assertEquals(pos1, pos2);\n            assertEquals(postings.hasPayload(), termPositions.isPayloadAvailable());\n            if (postings.hasPayload()) {\n              assertEquals(postings.getPayloadLength(), termPositions.getPayloadLength());\n              BytesRef b1 = postings.getPayload();\n              byte[] b2 = termPositions.getPayload(null, 0);\n              assertNotNull(b1);\n              assertNotNull(b2);\n              assertTrue(equals(b1, b2));\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private static void testRandomSeeks(Random rand, IndexReader r) throws Exception {\n    final int ITER = 100;\n    List<String> allFields = new ArrayList<String>();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    while(true) {\n      String f = fieldsEnum.next();\n      if (f == null) {\n        break;\n      }\n      allFields.add(f);\n    }\n    final int fieldCount = allFields.size();\n    if (fieldCount == 0) {\n      return;\n    }\n    \n    final TermPositions termPositions = r.termPositions();\n    DocsEnum docs = null;\n    DocsAndPositionsEnum postings = null;\n\n    for(int i=0;i<ITER;i++) {\n      // Random field:\n      String f = allFields.get(rand.nextInt(fieldCount));\n\n      String text = getRandomText(rand, 1, 3, false);\n      final TermsEnum termsEnum = MultiFields.getFields(r).terms(f).iterator();\n\n      final TermsEnum.SeekStatus seekStatus = termsEnum.seek(new BytesRef(text));\n      Term t = new Term(f, text);\n      //System.out.println(\"seek to \" + t);\n\n      final TermEnum termEnum = r.terms(t);\n      \n      if (seekStatus == TermsEnum.SeekStatus.END) {\n        //System.out.println(\"found end\");\n        assertTrue(termEnum.term() == null || termEnum.term().field() != f);\n        continue;\n      } else if (seekStatus == TermsEnum.SeekStatus.FOUND) {\n        //System.out.println(\"found exact\");\n        assertEquals(t, termEnum.term());\n      } else {\n        //System.out.println(\"found other\");\n        assertEquals(termsEnum.term().utf8ToString(), termEnum.term().text());\n      }\n\n      assertEquals(termsEnum.docFreq(), termEnum.docFreq());\n\n      docs = termsEnum.docs(MultiFields.getDeletedDocs(r), docs);\n      postings = termsEnum.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n\n      termPositions.seek(termEnum.term());\n\n      int doc = 0;\n\n      final DocsEnum docsEnum;\n      if (postings != null) {\n        docsEnum = postings;\n      } else {\n        docsEnum = docs;\n      }\n      for(int j=0;j<20;j++) {\n        final int inc = nextInt(rand, 1, Math.max(10, r.maxDoc()/15));\n        int newDoc1 = docsEnum.advance(doc+inc);\n        boolean found = termPositions.skipTo(doc+inc);\n        int newDoc2;\n\n        if (newDoc1 == DocsEnum.NO_MORE_DOCS) {\n          assertFalse(found);\n          break;\n        } else {\n          assertTrue(found);\n          newDoc2 = termPositions.doc();\n        }\n        \n        assertEquals(newDoc1, newDoc2);\n        assertEquals(docsEnum.freq(), termPositions.freq());\n\n        doc = newDoc1;\n\n        if (postings == null) {\n          assertEquals(1, termPositions.freq());\n          // Old API did not always do this,\n          // specifically in the MultiTermPositions\n          // case when some segs omit positions and\n          // some don't\n          //assertEquals(0, termPositions.nextPosition());\n          assertFalse(termPositions.isPayloadAvailable());\n        } else {\n          for(int k=0;k<docsEnum.freq();k++) {\n            int pos1 = postings.nextPosition();\n            int pos2 = termPositions.nextPosition();\n            assertEquals(pos1, pos2);\n            assertEquals(postings.hasPayload(), termPositions.isPayloadAvailable());\n            if (postings.hasPayload()) {\n              assertEquals(postings.getPayloadLength(), termPositions.getPayloadLength());\n              BytesRef b1 = postings.getPayload();\n              byte[] b2 = termPositions.getPayload(null, 0);\n              assertNotNull(b1);\n              assertNotNull(b2);\n              assertTrue(equals(b1, b2));\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c4531fadbecf73a7716fdf5cd742463e866e84e","date":1273851662,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSeeks(Random,IndexReader).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSeeks(Random,IndexReader).mjava","sourceNew":"  private static void testRandomSeeks(Random rand, IndexReader r) throws Exception {\n    final int ITER = 100 * _TestUtil.getRandomMultiplier();\n    List<String> allFields = new ArrayList<String>();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    while(true) {\n      String f = fieldsEnum.next();\n      if (f == null) {\n        break;\n      }\n      allFields.add(f);\n    }\n    final int fieldCount = allFields.size();\n    if (fieldCount == 0) {\n      return;\n    }\n    \n    final TermPositions termPositions = r.termPositions();\n    DocsEnum docs = null;\n    DocsAndPositionsEnum postings = null;\n\n    for(int i=0;i<ITER;i++) {\n      // Random field:\n      String f = allFields.get(rand.nextInt(fieldCount));\n\n      String text = getRandomText(rand, 1, 3, false);\n      final TermsEnum termsEnum = MultiFields.getFields(r).terms(f).iterator();\n\n      final TermsEnum.SeekStatus seekStatus = termsEnum.seek(new BytesRef(text));\n      Term t = new Term(f, text);\n      //System.out.println(\"seek to \" + t);\n\n      final TermEnum termEnum = r.terms(t);\n      \n      if (seekStatus == TermsEnum.SeekStatus.END) {\n        //System.out.println(\"found end\");\n        assertTrue(termEnum.term() == null || termEnum.term().field() != f);\n        continue;\n      } else if (seekStatus == TermsEnum.SeekStatus.FOUND) {\n        //System.out.println(\"found exact\");\n        assertEquals(t, termEnum.term());\n      } else {\n        //System.out.println(\"found other\");\n        assertEquals(termsEnum.term().utf8ToString(), termEnum.term().text());\n      }\n\n      assertEquals(termsEnum.docFreq(), termEnum.docFreq());\n\n      docs = termsEnum.docs(MultiFields.getDeletedDocs(r), docs);\n      postings = termsEnum.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n\n      termPositions.seek(termEnum.term());\n\n      int doc = 0;\n\n      final DocsEnum docsEnum;\n      if (postings != null) {\n        docsEnum = postings;\n      } else {\n        docsEnum = docs;\n      }\n      for(int j=0;j<20;j++) {\n        final int inc = nextInt(rand, 1, Math.max(10, r.maxDoc()/15));\n        int newDoc1 = docsEnum.advance(doc+inc);\n        boolean found = termPositions.skipTo(doc+inc);\n        int newDoc2;\n\n        if (newDoc1 == DocsEnum.NO_MORE_DOCS) {\n          assertFalse(found);\n          break;\n        } else {\n          assertTrue(found);\n          newDoc2 = termPositions.doc();\n        }\n        \n        assertEquals(newDoc1, newDoc2);\n        assertEquals(docsEnum.freq(), termPositions.freq());\n\n        doc = newDoc1;\n\n        if (postings == null) {\n          assertEquals(1, termPositions.freq());\n          // Old API did not always do this,\n          // specifically in the MultiTermPositions\n          // case when some segs omit positions and\n          // some don't\n          //assertEquals(0, termPositions.nextPosition());\n          assertFalse(termPositions.isPayloadAvailable());\n        } else {\n          for(int k=0;k<docsEnum.freq();k++) {\n            int pos1 = postings.nextPosition();\n            int pos2 = termPositions.nextPosition();\n            assertEquals(pos1, pos2);\n            assertEquals(postings.hasPayload(), termPositions.isPayloadAvailable());\n            if (postings.hasPayload()) {\n              BytesRef b1 = postings.getPayload();\n              assertEquals(b1.length, termPositions.getPayloadLength());\n              byte[] b2 = termPositions.getPayload(null, 0);\n              assertNotNull(b1);\n              assertNotNull(b2);\n              assertTrue(equals(b1, b2));\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private static void testRandomSeeks(Random rand, IndexReader r) throws Exception {\n    final int ITER = 100 * _TestUtil.getRandomMultiplier();\n    List<String> allFields = new ArrayList<String>();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    while(true) {\n      String f = fieldsEnum.next();\n      if (f == null) {\n        break;\n      }\n      allFields.add(f);\n    }\n    final int fieldCount = allFields.size();\n    if (fieldCount == 0) {\n      return;\n    }\n    \n    final TermPositions termPositions = r.termPositions();\n    DocsEnum docs = null;\n    DocsAndPositionsEnum postings = null;\n\n    for(int i=0;i<ITER;i++) {\n      // Random field:\n      String f = allFields.get(rand.nextInt(fieldCount));\n\n      String text = getRandomText(rand, 1, 3, false);\n      final TermsEnum termsEnum = MultiFields.getFields(r).terms(f).iterator();\n\n      final TermsEnum.SeekStatus seekStatus = termsEnum.seek(new BytesRef(text));\n      Term t = new Term(f, text);\n      //System.out.println(\"seek to \" + t);\n\n      final TermEnum termEnum = r.terms(t);\n      \n      if (seekStatus == TermsEnum.SeekStatus.END) {\n        //System.out.println(\"found end\");\n        assertTrue(termEnum.term() == null || termEnum.term().field() != f);\n        continue;\n      } else if (seekStatus == TermsEnum.SeekStatus.FOUND) {\n        //System.out.println(\"found exact\");\n        assertEquals(t, termEnum.term());\n      } else {\n        //System.out.println(\"found other\");\n        assertEquals(termsEnum.term().utf8ToString(), termEnum.term().text());\n      }\n\n      assertEquals(termsEnum.docFreq(), termEnum.docFreq());\n\n      docs = termsEnum.docs(MultiFields.getDeletedDocs(r), docs);\n      postings = termsEnum.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n\n      termPositions.seek(termEnum.term());\n\n      int doc = 0;\n\n      final DocsEnum docsEnum;\n      if (postings != null) {\n        docsEnum = postings;\n      } else {\n        docsEnum = docs;\n      }\n      for(int j=0;j<20;j++) {\n        final int inc = nextInt(rand, 1, Math.max(10, r.maxDoc()/15));\n        int newDoc1 = docsEnum.advance(doc+inc);\n        boolean found = termPositions.skipTo(doc+inc);\n        int newDoc2;\n\n        if (newDoc1 == DocsEnum.NO_MORE_DOCS) {\n          assertFalse(found);\n          break;\n        } else {\n          assertTrue(found);\n          newDoc2 = termPositions.doc();\n        }\n        \n        assertEquals(newDoc1, newDoc2);\n        assertEquals(docsEnum.freq(), termPositions.freq());\n\n        doc = newDoc1;\n\n        if (postings == null) {\n          assertEquals(1, termPositions.freq());\n          // Old API did not always do this,\n          // specifically in the MultiTermPositions\n          // case when some segs omit positions and\n          // some don't\n          //assertEquals(0, termPositions.nextPosition());\n          assertFalse(termPositions.isPayloadAvailable());\n        } else {\n          for(int k=0;k<docsEnum.freq();k++) {\n            int pos1 = postings.nextPosition();\n            int pos2 = termPositions.nextPosition();\n            assertEquals(pos1, pos2);\n            assertEquals(postings.hasPayload(), termPositions.isPayloadAvailable());\n            if (postings.hasPayload()) {\n              assertEquals(postings.getPayloadLength(), termPositions.getPayloadLength());\n              BytesRef b1 = postings.getPayload();\n              byte[] b2 = termPositions.getPayload(null, 0);\n              assertNotNull(b1);\n              assertNotNull(b2);\n              assertTrue(equals(b1, b2));\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28427ef110c4c5bf5b4057731b83110bd1e13724","date":1276701452,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSeeks(Random,IndexReader).mjava","sourceNew":null,"sourceOld":"  private static void testRandomSeeks(Random rand, IndexReader r) throws Exception {\n    final int ITER = 100 * _TestUtil.getRandomMultiplier();\n    List<String> allFields = new ArrayList<String>();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    while(true) {\n      String f = fieldsEnum.next();\n      if (f == null) {\n        break;\n      }\n      allFields.add(f);\n    }\n    final int fieldCount = allFields.size();\n    if (fieldCount == 0) {\n      return;\n    }\n    \n    final TermPositions termPositions = r.termPositions();\n    DocsEnum docs = null;\n    DocsAndPositionsEnum postings = null;\n\n    for(int i=0;i<ITER;i++) {\n      // Random field:\n      String f = allFields.get(rand.nextInt(fieldCount));\n\n      String text = getRandomText(rand, 1, 3, false);\n      final TermsEnum termsEnum = MultiFields.getFields(r).terms(f).iterator();\n\n      final TermsEnum.SeekStatus seekStatus = termsEnum.seek(new BytesRef(text));\n      Term t = new Term(f, text);\n      //System.out.println(\"seek to \" + t);\n\n      final TermEnum termEnum = r.terms(t);\n      \n      if (seekStatus == TermsEnum.SeekStatus.END) {\n        //System.out.println(\"found end\");\n        assertTrue(termEnum.term() == null || termEnum.term().field() != f);\n        continue;\n      } else if (seekStatus == TermsEnum.SeekStatus.FOUND) {\n        //System.out.println(\"found exact\");\n        assertEquals(t, termEnum.term());\n      } else {\n        //System.out.println(\"found other\");\n        assertEquals(termsEnum.term().utf8ToString(), termEnum.term().text());\n      }\n\n      assertEquals(termsEnum.docFreq(), termEnum.docFreq());\n\n      docs = termsEnum.docs(MultiFields.getDeletedDocs(r), docs);\n      postings = termsEnum.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n\n      termPositions.seek(termEnum.term());\n\n      int doc = 0;\n\n      final DocsEnum docsEnum;\n      if (postings != null) {\n        docsEnum = postings;\n      } else {\n        docsEnum = docs;\n      }\n      for(int j=0;j<20;j++) {\n        final int inc = nextInt(rand, 1, Math.max(10, r.maxDoc()/15));\n        int newDoc1 = docsEnum.advance(doc+inc);\n        boolean found = termPositions.skipTo(doc+inc);\n        int newDoc2;\n\n        if (newDoc1 == DocsEnum.NO_MORE_DOCS) {\n          assertFalse(found);\n          break;\n        } else {\n          assertTrue(found);\n          newDoc2 = termPositions.doc();\n        }\n        \n        assertEquals(newDoc1, newDoc2);\n        assertEquals(docsEnum.freq(), termPositions.freq());\n\n        doc = newDoc1;\n\n        if (postings == null) {\n          assertEquals(1, termPositions.freq());\n          // Old API did not always do this,\n          // specifically in the MultiTermPositions\n          // case when some segs omit positions and\n          // some don't\n          //assertEquals(0, termPositions.nextPosition());\n          assertFalse(termPositions.isPayloadAvailable());\n        } else {\n          for(int k=0;k<docsEnum.freq();k++) {\n            int pos1 = postings.nextPosition();\n            int pos2 = termPositions.nextPosition();\n            assertEquals(pos1, pos2);\n            assertEquals(postings.hasPayload(), termPositions.isPayloadAvailable());\n            if (postings.hasPayload()) {\n              BytesRef b1 = postings.getPayload();\n              assertEquals(b1.length, termPositions.getPayloadLength());\n              byte[] b2 = termPositions.getPayload(null, 0);\n              assertNotNull(b1);\n              assertNotNull(b2);\n              assertTrue(equals(b1, b2));\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/index/FlexTestUtil#testRandomSeeks(Random,IndexReader).mjava","sourceNew":null,"sourceOld":"  private static void testRandomSeeks(Random rand, IndexReader r) throws Exception {\n    final int ITER = 100 * _TestUtil.getRandomMultiplier();\n    List<String> allFields = new ArrayList<String>();\n    Fields fields = MultiFields.getFields(r);\n    if (fields == null) {\n      return;\n    }\n    FieldsEnum fieldsEnum = fields.iterator();\n    while(true) {\n      String f = fieldsEnum.next();\n      if (f == null) {\n        break;\n      }\n      allFields.add(f);\n    }\n    final int fieldCount = allFields.size();\n    if (fieldCount == 0) {\n      return;\n    }\n    \n    final TermPositions termPositions = r.termPositions();\n    DocsEnum docs = null;\n    DocsAndPositionsEnum postings = null;\n\n    for(int i=0;i<ITER;i++) {\n      // Random field:\n      String f = allFields.get(rand.nextInt(fieldCount));\n\n      String text = getRandomText(rand, 1, 3, false);\n      final TermsEnum termsEnum = MultiFields.getFields(r).terms(f).iterator();\n\n      final TermsEnum.SeekStatus seekStatus = termsEnum.seek(new BytesRef(text));\n      Term t = new Term(f, text);\n      //System.out.println(\"seek to \" + t);\n\n      final TermEnum termEnum = r.terms(t);\n      \n      if (seekStatus == TermsEnum.SeekStatus.END) {\n        //System.out.println(\"found end\");\n        assertTrue(termEnum.term() == null || termEnum.term().field() != f);\n        continue;\n      } else if (seekStatus == TermsEnum.SeekStatus.FOUND) {\n        //System.out.println(\"found exact\");\n        assertEquals(t, termEnum.term());\n      } else {\n        //System.out.println(\"found other\");\n        assertEquals(termsEnum.term().utf8ToString(), termEnum.term().text());\n      }\n\n      assertEquals(termsEnum.docFreq(), termEnum.docFreq());\n\n      docs = termsEnum.docs(MultiFields.getDeletedDocs(r), docs);\n      postings = termsEnum.docsAndPositions(MultiFields.getDeletedDocs(r), postings);\n\n      termPositions.seek(termEnum.term());\n\n      int doc = 0;\n\n      final DocsEnum docsEnum;\n      if (postings != null) {\n        docsEnum = postings;\n      } else {\n        docsEnum = docs;\n      }\n      for(int j=0;j<20;j++) {\n        final int inc = nextInt(rand, 1, Math.max(10, r.maxDoc()/15));\n        int newDoc1 = docsEnum.advance(doc+inc);\n        boolean found = termPositions.skipTo(doc+inc);\n        int newDoc2;\n\n        if (newDoc1 == DocsEnum.NO_MORE_DOCS) {\n          assertFalse(found);\n          break;\n        } else {\n          assertTrue(found);\n          newDoc2 = termPositions.doc();\n        }\n        \n        assertEquals(newDoc1, newDoc2);\n        assertEquals(docsEnum.freq(), termPositions.freq());\n\n        doc = newDoc1;\n\n        if (postings == null) {\n          assertEquals(1, termPositions.freq());\n          // Old API did not always do this,\n          // specifically in the MultiTermPositions\n          // case when some segs omit positions and\n          // some don't\n          //assertEquals(0, termPositions.nextPosition());\n          assertFalse(termPositions.isPayloadAvailable());\n        } else {\n          for(int k=0;k<docsEnum.freq();k++) {\n            int pos1 = postings.nextPosition();\n            int pos2 = termPositions.nextPosition();\n            assertEquals(pos1, pos2);\n            assertEquals(postings.hasPayload(), termPositions.isPayloadAvailable());\n            if (postings.hasPayload()) {\n              BytesRef b1 = postings.getPayload();\n              assertEquals(b1.length, termPositions.getPayloadLength());\n              byte[] b2 = termPositions.getPayload(null, 0);\n              assertNotNull(b1);\n              assertNotNull(b2);\n              assertTrue(equals(b1, b2));\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"28427ef110c4c5bf5b4057731b83110bd1e13724":["5c4531fadbecf73a7716fdf5cd742463e866e84e"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5c4531fadbecf73a7716fdf5cd742463e866e84e":["2aafd88401639311b0404e67c94e829e123a0e45"],"2aafd88401639311b0404e67c94e829e123a0e45":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"5f4e87790277826a2aea119328600dfb07761f32":["5c4531fadbecf73a7716fdf5cd742463e866e84e","28427ef110c4c5bf5b4057731b83110bd1e13724"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28427ef110c4c5bf5b4057731b83110bd1e13724"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"28427ef110c4c5bf5b4057731b83110bd1e13724":["5f4e87790277826a2aea119328600dfb07761f32","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["2aafd88401639311b0404e67c94e829e123a0e45"],"5c4531fadbecf73a7716fdf5cd742463e866e84e":["28427ef110c4c5bf5b4057731b83110bd1e13724","5f4e87790277826a2aea119328600dfb07761f32"],"2aafd88401639311b0404e67c94e829e123a0e45":["5c4531fadbecf73a7716fdf5cd742463e866e84e"],"5f4e87790277826a2aea119328600dfb07761f32":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5f4e87790277826a2aea119328600dfb07761f32","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}