{"path":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","commits":[{"id":"2ee056ec8e953928ee49a691090634eed1fa4d6b","date":1274852580,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String).mjava","sourceNew":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    //Intercept poly fields, as they get expanded by default to an OR clause of\n    SchemaField sf = schema.getField(field);\n    //TODO: is there anyway to avoid this instance of check?\n    if (sf != null&& !(sf.getType() instanceof TextField)){//we have a poly field, deal with it specially by delegating to the FieldType\n      return sf.getType().getFieldQuery(parser, sf, queryText); \n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  protected Query getFieldQuery(String field, String queryText) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    //Intercept poly fields, as they get expanded by default to an OR clause of\n    SchemaField sf = schema.getField(field);\n    //TODO: is there anyway to avoid this instance of check?\n    if (sf != null&& !(sf.getType() instanceof TextField)){//we have a poly field, deal with it specially by delegating to the FieldType\n      return sf.getType().getFieldQuery(parser, sf, queryText); \n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33e4a95ed08968b85d84e9fba82424f1fd945fbb","date":1274878310,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  protected Query getFieldQuery(String field, String queryText) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    //Intercept poly fields, as they get expanded by default to an OR clause of\n    SchemaField sf = schema.getField(field);\n    //TODO: is there anyway to avoid this instance of check?\n    if (sf != null&& !(sf.getType() instanceof TextField)){//we have a poly field, deal with it specially by delegating to the FieldType\n      return sf.getType().getFieldQuery(parser, sf, queryText); \n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText);\n  }\n\n","sourceOld":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    //Intercept poly fields, as they get expanded by default to an OR clause of\n    SchemaField sf = schema.getField(field);\n    //TODO: is there anyway to avoid this instance of check?\n    if (sf != null&& !(sf.getType() instanceof TextField)){//we have a poly field, deal with it specially by delegating to the FieldType\n      return sf.getType().getFieldQuery(parser, sf, queryText); \n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55f0d8e9a3f2e45eeea14a4803eaac02a0865097","date":1279565910,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String).mjava","sourceNew":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    //Intercept poly fields, as they get expanded by default to an OR clause of\n    SchemaField sf = schema.getField(field);\n    //TODO: is there anyway to avoid this instance of check?\n    if (sf != null&& !(sf.getType() instanceof TextField)){//we have a poly field, deal with it specially by delegating to the FieldType\n      return sf.getType().getFieldQuery(parser, sf, queryText); \n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  protected Query getFieldQuery(String field, String queryText) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    //Intercept poly fields, as they get expanded by default to an OR clause of\n    SchemaField sf = schema.getField(field);\n    //TODO: is there anyway to avoid this instance of check?\n    if (sf != null&& !(sf.getType() instanceof TextField)){//we have a poly field, deal with it specially by delegating to the FieldType\n      return sf.getType().getFieldQuery(parser, sf, queryText); \n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"/dev/null","sourceNew":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    //Intercept poly fields, as they get expanded by default to an OR clause of\n    SchemaField sf = schema.getField(field);\n    //TODO: is there anyway to avoid this instance of check?\n    if (sf != null&& !(sf.getType() instanceof TextField)){//we have a poly field, deal with it specially by delegating to the FieldType\n      return sf.getType().getFieldQuery(parser, sf, queryText); \n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a48e06ad71e6dcb230e678c6304facd688202735","date":1280070785,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    //Intercept poly fields, as they get expanded by default to an OR clause of\n    SchemaField sf = schema.getField(field);\n    //TODO: is there anyway to avoid this instance of check?\n    if (sf != null&& !(sf.getType() instanceof TextField)){//we have a poly field, deal with it specially by delegating to the FieldType\n      return sf.getType().getFieldQuery(parser, sf, queryText); \n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    //Intercept poly fields, as they get expanded by default to an OR clause of\n    SchemaField sf = schema.getField(field);\n    //TODO: is there anyway to avoid this instance of check?\n    if (sf != null&& !(sf.getType() instanceof TextField)){//we have a poly field, deal with it specially by delegating to the FieldType\n      return sf.getType().getFieldQuery(parser, sf, queryText); \n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e9bbb27241bcf9645bb2f724c137537aa69918a","date":1287780008,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b12d3e81e0f95a4527b5703953c503f71120ffcc","date":1288080933,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e48ed0466fe2d4f8ba58a47caef1174d9e856d13","date":1293745585,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":["759d2c8462a6935ee9b8e23c16cc0a096fb329b7","759d2c8462a6935ee9b8e23c16cc0a096fb329b7","759d2c8462a6935ee9b8e23c16cc0a096fb329b7","b53e1fdeb877dfb9c1aba24b343170ae7ffe7108","b53e1fdeb877dfb9c1aba24b343170ae7ffe7108","b53e1fdeb877dfb9c1aba24b343170ae7ffe7108"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","date":1294014627,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        if (parser==null) {\n          return QueryParsing.parseFunction(queryText, schema);\n        } else {\n          QParser nested = parser.subQuery(queryText, \"func\");\n          return nested.getQuery();\n        }\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee3a275f925be62184fad78d647fa70e27ac7cea","date":1301416659,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except tokenized fields\n      if (ft.isTokenized()) {\n        return super.getFieldQuery(field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45669a651c970812a680841b97a77cce06af559f","date":1301922222,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except tokenized fields\n      if (ft.isTokenized()) {\n        return super.getFieldQuery(field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except tokenized fields\n      if (ft.isTokenized()) {\n        return super.getFieldQuery(field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except TextField\n      if (ft instanceof TextField) {\n        return super.getFieldQuery(field, queryText, quoted || ((TextField)ft).getAutoGeneratePhraseQueries());\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except tokenized fields\n      if (ft.isTokenized()) {\n        return super.getFieldQuery(field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except tokenized fields\n      if (ft.isTokenized()) {\n        return super.getFieldQuery(field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except tokenized fields\n      if (ft.isTokenized()) {\n        return super.getFieldQuery(field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except tokenized fields\n      if (ft.isTokenized()) {\n        return super.getFieldQuery(field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrQueryParser#getFieldQuery(String,String,boolean).mjava","sourceNew":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except tokenized fields\n      if (ft.isTokenized()) {\n        return super.getFieldQuery(field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","sourceOld":"  @Override\n  protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {\n    checkNullField(field);\n    // intercept magic field name of \"_\" to use as a hook for our\n    // own functions.\n    if (field.charAt(0) == '_') {\n      if (\"_val_\".equals(field)) {\n        QParser nested = parser.subQuery(queryText, \"func\");\n        return nested.getQuery();\n      } else if (\"_query_\".equals(field) && parser != null) {\n        return parser.subQuery(queryText, null).getQuery();\n      }\n    }\n    SchemaField sf = schema.getFieldOrNull(field);\n    if (sf != null) {\n      FieldType ft = sf.getType();\n      // delegate to type for everything except tokenized fields\n      if (ft.isTokenized()) {\n        return super.getFieldQuery(field, queryText, quoted || (ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries()));\n      } else {\n        return sf.getType().getFieldQuery(parser, sf, queryText);\n      }\n    }\n\n    // default to a normal field query\n    return super.getFieldQuery(field, queryText, quoted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["b12d3e81e0f95a4527b5703953c503f71120ffcc","e48ed0466fe2d4f8ba58a47caef1174d9e856d13"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["5f4e87790277826a2aea119328600dfb07761f32","a48e06ad71e6dcb230e678c6304facd688202735"],"c26f00b574427b55127e869b935845554afde1fa":["ee3a275f925be62184fad78d647fa70e27ac7cea","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a48e06ad71e6dcb230e678c6304facd688202735":["55f0d8e9a3f2e45eeea14a4803eaac02a0865097"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["70ad682703b8585f5d0a637efec044d57ec05efb","ee3a275f925be62184fad78d647fa70e27ac7cea"],"33e4a95ed08968b85d84e9fba82424f1fd945fbb":["2ee056ec8e953928ee49a691090634eed1fa4d6b"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["a48e06ad71e6dcb230e678c6304facd688202735","4e9bbb27241bcf9645bb2f724c137537aa69918a"],"e48ed0466fe2d4f8ba58a47caef1174d9e856d13":["4e9bbb27241bcf9645bb2f724c137537aa69918a"],"2ee056ec8e953928ee49a691090634eed1fa4d6b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5f4e87790277826a2aea119328600dfb07761f32":["33e4a95ed08968b85d84e9fba82424f1fd945fbb","55f0d8e9a3f2e45eeea14a4803eaac02a0865097"],"55f0d8e9a3f2e45eeea14a4803eaac02a0865097":["33e4a95ed08968b85d84e9fba82424f1fd945fbb"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["3242a09f703274d3b9283f2064a1a33064b53a1b","4e9bbb27241bcf9645bb2f724c137537aa69918a"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","e48ed0466fe2d4f8ba58a47caef1174d9e856d13"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["ee3a275f925be62184fad78d647fa70e27ac7cea"],"4e9bbb27241bcf9645bb2f724c137537aa69918a":["a48e06ad71e6dcb230e678c6304facd688202735"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["ee3a275f925be62184fad78d647fa70e27ac7cea"],"45669a651c970812a680841b97a77cce06af559f":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","ee3a275f925be62184fad78d647fa70e27ac7cea"],"ee3a275f925be62184fad78d647fa70e27ac7cea":["e48ed0466fe2d4f8ba58a47caef1174d9e856d13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a48e06ad71e6dcb230e678c6304facd688202735":["3242a09f703274d3b9283f2064a1a33064b53a1b","b12d3e81e0f95a4527b5703953c503f71120ffcc","4e9bbb27241bcf9645bb2f724c137537aa69918a"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"33e4a95ed08968b85d84e9fba82424f1fd945fbb":["5f4e87790277826a2aea119328600dfb07761f32","55f0d8e9a3f2e45eeea14a4803eaac02a0865097"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["70ad682703b8585f5d0a637efec044d57ec05efb"],"e48ed0466fe2d4f8ba58a47caef1174d9e856d13":["70ad682703b8585f5d0a637efec044d57ec05efb","ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","ee3a275f925be62184fad78d647fa70e27ac7cea"],"5f4e87790277826a2aea119328600dfb07761f32":["3242a09f703274d3b9283f2064a1a33064b53a1b"],"2ee056ec8e953928ee49a691090634eed1fa4d6b":["33e4a95ed08968b85d84e9fba82424f1fd945fbb"],"55f0d8e9a3f2e45eeea14a4803eaac02a0865097":["a48e06ad71e6dcb230e678c6304facd688202735","5f4e87790277826a2aea119328600dfb07761f32"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["45669a651c970812a680841b97a77cce06af559f"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"4e9bbb27241bcf9645bb2f724c137537aa69918a":["b12d3e81e0f95a4527b5703953c503f71120ffcc","e48ed0466fe2d4f8ba58a47caef1174d9e856d13","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2ee056ec8e953928ee49a691090634eed1fa4d6b"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"45669a651c970812a680841b97a77cce06af559f":[],"ee3a275f925be62184fad78d647fa70e27ac7cea":["c26f00b574427b55127e869b935845554afde1fa","135621f3a0670a9394eb563224a3b76cc4dddc0f","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee","45669a651c970812a680841b97a77cce06af559f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","a258fbb26824fd104ed795e5d9033d2d040049ee","45669a651c970812a680841b97a77cce06af559f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}