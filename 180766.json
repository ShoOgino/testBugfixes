{"path":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","commits":[{"id":"af09a11446184597ca824554260a98704507f8a7","date":1157138567,"type":0,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","pathOld":"/dev/null","sourceNew":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException\n   {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new NamedList();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++)\n      {\n         int docId = iterator.nextDoc();\n         // use the Searcher's doc cache\n         Document doc = searcher.doc(docId);\n         NamedList docSummaries = new NamedList();\n         for (String fieldName : fieldNames)\n         {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1)\n            {\n               // single-valued field\n               TokenStream tstream;\n               try\n               {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e)\n               {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else\n            {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0)\n            {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++)\n               {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0))\n                  {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["33e6ce261fb71637077f5afb0521a898795a4340"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a","date":1164667221,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","pathOld":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","sourceNew":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException\n   {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new NamedList();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n      Document[] readDocs = new Document[docs.size()];\n      {\n        // pre-fetch documents using the Searcher's doc cache\n        Set<String> fset = new HashSet<String>();\n        for(String f : fieldNames) { fset.add(f); }\n        // fetch unique key if one exists.\n        SchemaField keyField = req.getSearcher().getSchema().getUniqueKeyField();\n        if(null != keyField)\n          fset.add(keyField.getName());  \n        searcher.readDocs(readDocs, docs, fset);\n      }\n\n      // Highlight each document\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++)\n      {\n         int docId = iterator.nextDoc();\n         Document doc = readDocs[i];\n         NamedList docSummaries = new NamedList();\n         for (String fieldName : fieldNames)\n         {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1)\n            {\n               // single-valued field\n               TokenStream tstream;\n               try\n               {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e)\n               {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else\n            {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0)\n            {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++)\n               {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0))\n                  {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","sourceOld":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException\n   {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new NamedList();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++)\n      {\n         int docId = iterator.nextDoc();\n         // use the Searcher's doc cache\n         Document doc = searcher.doc(docId);\n         NamedList docSummaries = new NamedList();\n         for (String fieldName : fieldNames)\n         {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1)\n            {\n               // single-valued field\n               TokenStream tstream;\n               try\n               {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e)\n               {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else\n            {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0)\n            {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++)\n               {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0))\n                  {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","bugFix":null,"bugIntro":["33e6ce261fb71637077f5afb0521a898795a4340"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4145b7b13874de95211223a6edb648da8794a688","date":1170182192,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","pathOld":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","sourceNew":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException\n   {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new SimpleOrderedMap();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n      Document[] readDocs = new Document[docs.size()];\n      {\n        // pre-fetch documents using the Searcher's doc cache\n        Set<String> fset = new HashSet<String>();\n        for(String f : fieldNames) { fset.add(f); }\n        // fetch unique key if one exists.\n        SchemaField keyField = req.getSearcher().getSchema().getUniqueKeyField();\n        if(null != keyField)\n          fset.add(keyField.getName());  \n        searcher.readDocs(readDocs, docs, fset);\n      }\n\n      // Highlight each document\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++)\n      {\n         int docId = iterator.nextDoc();\n         Document doc = readDocs[i];\n         NamedList docSummaries = new SimpleOrderedMap();\n         for (String fieldName : fieldNames)\n         {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1)\n            {\n               // single-valued field\n               TokenStream tstream;\n               try\n               {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e)\n               {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else\n            {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0)\n            {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++)\n               {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0))\n                  {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","sourceOld":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException\n   {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new NamedList();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n      Document[] readDocs = new Document[docs.size()];\n      {\n        // pre-fetch documents using the Searcher's doc cache\n        Set<String> fset = new HashSet<String>();\n        for(String f : fieldNames) { fset.add(f); }\n        // fetch unique key if one exists.\n        SchemaField keyField = req.getSearcher().getSchema().getUniqueKeyField();\n        if(null != keyField)\n          fset.add(keyField.getName());  \n        searcher.readDocs(readDocs, docs, fset);\n      }\n\n      // Highlight each document\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++)\n      {\n         int docId = iterator.nextDoc();\n         Document doc = readDocs[i];\n         NamedList docSummaries = new NamedList();\n         for (String fieldName : fieldNames)\n         {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1)\n            {\n               // single-valued field\n               TokenStream tstream;\n               try\n               {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e)\n               {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else\n            {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0)\n            {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++)\n               {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0))\n                  {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","bugFix":null,"bugIntro":["33e6ce261fb71637077f5afb0521a898795a4340"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"090f8d702b753c18c64a6fd5fb550596c68861ce","date":1172108327,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","pathOld":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","sourceNew":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new SimpleOrderedMap();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n      Document[] readDocs = new Document[docs.size()];\n      {\n        // pre-fetch documents using the Searcher's doc cache\n        Set<String> fset = new HashSet<String>();\n        for(String f : fieldNames) { fset.add(f); }\n        // fetch unique key if one exists.\n        SchemaField keyField = req.getSearcher().getSchema().getUniqueKeyField();\n        if(null != keyField)\n          fset.add(keyField.getName());  \n        searcher.readDocs(readDocs, docs, fset);\n      }\n\n      // Highlight each document\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++) {\n         int docId = iterator.nextDoc();\n         Document doc = readDocs[i];\n         NamedList docSummaries = new SimpleOrderedMap();\n         for (String fieldName : fieldNames) {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1) {\n               // single-valued field\n               TokenStream tstream;\n               try {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e) {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0) {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++) {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0)) {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) \n\t\t docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","sourceOld":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException\n   {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new SimpleOrderedMap();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n      Document[] readDocs = new Document[docs.size()];\n      {\n        // pre-fetch documents using the Searcher's doc cache\n        Set<String> fset = new HashSet<String>();\n        for(String f : fieldNames) { fset.add(f); }\n        // fetch unique key if one exists.\n        SchemaField keyField = req.getSearcher().getSchema().getUniqueKeyField();\n        if(null != keyField)\n          fset.add(keyField.getName());  \n        searcher.readDocs(readDocs, docs, fset);\n      }\n\n      // Highlight each document\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++)\n      {\n         int docId = iterator.nextDoc();\n         Document doc = readDocs[i];\n         NamedList docSummaries = new SimpleOrderedMap();\n         for (String fieldName : fieldNames)\n         {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1)\n            {\n               // single-valued field\n               TokenStream tstream;\n               try\n               {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e)\n               {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else\n            {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0)\n            {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++)\n               {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0))\n                  {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","bugFix":null,"bugIntro":["33e6ce261fb71637077f5afb0521a898795a4340"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4114a9012ed90fa73da6201bb0aeec818808848","date":1183444190,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","pathOld":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","sourceNew":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   @SuppressWarnings(\"unchecked\")\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new SimpleOrderedMap();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n      Document[] readDocs = new Document[docs.size()];\n      {\n        // pre-fetch documents using the Searcher's doc cache\n        Set<String> fset = new HashSet<String>();\n        for(String f : fieldNames) { fset.add(f); }\n        // fetch unique key if one exists.\n        SchemaField keyField = req.getSearcher().getSchema().getUniqueKeyField();\n        if(null != keyField)\n          fset.add(keyField.getName());  \n        searcher.readDocs(readDocs, docs, fset);\n      }\n\n      // Highlight each document\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++) {\n         int docId = iterator.nextDoc();\n         Document doc = readDocs[i];\n         NamedList docSummaries = new SimpleOrderedMap();\n         for (String fieldName : fieldNames) {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1) {\n               // single-valued field\n               TokenStream tstream;\n               try {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e) {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0) {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++) {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0)) {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) \n                 docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","sourceOld":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new SimpleOrderedMap();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n      Document[] readDocs = new Document[docs.size()];\n      {\n        // pre-fetch documents using the Searcher's doc cache\n        Set<String> fset = new HashSet<String>();\n        for(String f : fieldNames) { fset.add(f); }\n        // fetch unique key if one exists.\n        SchemaField keyField = req.getSearcher().getSchema().getUniqueKeyField();\n        if(null != keyField)\n          fset.add(keyField.getName());  \n        searcher.readDocs(readDocs, docs, fset);\n      }\n\n      // Highlight each document\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++) {\n         int docId = iterator.nextDoc();\n         Document doc = readDocs[i];\n         NamedList docSummaries = new SimpleOrderedMap();\n         for (String fieldName : fieldNames) {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1) {\n               // single-valued field\n               TokenStream tstream;\n               try {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e) {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0) {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++) {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0)) {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) \n\t\t docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","bugFix":null,"bugIntro":["33e6ce261fb71637077f5afb0521a898795a4340"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33e6ce261fb71637077f5afb0521a898795a4340","date":1238092945,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","pathOld":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","sourceNew":"   /**\n    * @deprecated use DefaultSolrHighlighter\n    * @see DefaultSolrHighlighter#doHighlighting\n    */\n   @SuppressWarnings(\"unchecked\")\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException {\n     return HIGHLIGHTER.doHighlighting(docs, query, req, defaultFields);\n   }\n\n","sourceOld":"   /**\n    * Generates a list of Highlighted query fragments for each item in a list\n    * of documents, or returns null if highlighting is disabled.\n    *\n    * @param docs query results\n    * @param query the query\n    * @param req the current request\n    * @param defaultFields default list of fields to summarize\n    *\n    * @return NamedList containing a NamedList for each document, which in\n    * turns contains sets (field, summary) pairs.\n    */\n   @SuppressWarnings(\"unchecked\")\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException {\n      if (!isHighlightingEnabled(req))\n         return null;\n      \n      SolrIndexSearcher searcher = req.getSearcher();\n      NamedList fragments = new SimpleOrderedMap();\n      String[] fieldNames = getHighlightFields(query, req, defaultFields);\n      Document[] readDocs = new Document[docs.size()];\n      {\n        // pre-fetch documents using the Searcher's doc cache\n        Set<String> fset = new HashSet<String>();\n        for(String f : fieldNames) { fset.add(f); }\n        // fetch unique key if one exists.\n        SchemaField keyField = req.getSearcher().getSchema().getUniqueKeyField();\n        if(null != keyField)\n          fset.add(keyField.getName());  \n        searcher.readDocs(readDocs, docs, fset);\n      }\n\n      // Highlight each document\n      DocIterator iterator = docs.iterator();\n      for (int i = 0; i < docs.size(); i++) {\n         int docId = iterator.nextDoc();\n         Document doc = readDocs[i];\n         NamedList docSummaries = new SimpleOrderedMap();\n         for (String fieldName : fieldNames) {\n            fieldName = fieldName.trim();\n            String[] docTexts = doc.getValues(fieldName);\n            if (docTexts == null) continue;\n\n            // get highlighter, and number of fragments for this field\n            Highlighter highlighter = getHighlighter(query, fieldName, req);\n            int numFragments = getMaxSnippets(fieldName, req);\n\n            String[] summaries;\n            TextFragment[] frag;\n            if (docTexts.length == 1) {\n               // single-valued field\n               TokenStream tstream;\n               try {\n                  // attempt term vectors\n                  tstream = TokenSources.getTokenStream(searcher.getReader(), docId, fieldName);\n               }\n               catch (IllegalArgumentException e) {\n                  // fall back to analyzer\n                  tstream = new TokenOrderingFilter(searcher.getSchema().getAnalyzer().tokenStream(fieldName, new StringReader(docTexts[0])), 10);\n               }\n               frag = highlighter.getBestTextFragments(tstream, docTexts[0], false, numFragments);\n            }\n            else {\n               // multi-valued field\n               MultiValueTokenStream tstream;\n               tstream = new MultiValueTokenStream(fieldName, docTexts, searcher.getSchema().getAnalyzer(), true);\n               frag = highlighter.getBestTextFragments(tstream, tstream.asSingleValue(), false, numFragments);\n            }\n            // convert fragments back into text\n            // TODO: we can include score and position information in output as snippet attributes\n            if (frag.length > 0) {\n               ArrayList<String> fragTexts = new ArrayList<String>();\n               for (int j = 0; j < frag.length; j++) {\n                  if ((frag[j] != null) && (frag[j].getScore() > 0)) {\n                     fragTexts.add(frag[j].toString());\n                  }\n               }\n               summaries = fragTexts.toArray(new String[0]);\n               if (summaries.length > 0) \n                 docSummaries.add(fieldName, summaries);\n            }\n         }\n         String printId = searcher.getSchema().printableUniqueKey(doc);\n         fragments.add(printId == null ? null : printId, docSummaries);\n      }\n      return fragments;\n   }\n\n","bugFix":["4145b7b13874de95211223a6edb648da8794a688","a4114a9012ed90fa73da6201bb0aeec818808848","7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a","090f8d702b753c18c64a6fd5fb550596c68861ce","af09a11446184597ca824554260a98704507f8a7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","pathOld":"src/java/org/apache/solr/util/HighlightingUtils#doHighlighting(DocList,Query,SolrQueryRequest,String[]).mjava","sourceNew":"   /**\n    * @deprecated use DefaultSolrHighlighter\n    * @see DefaultSolrHighlighter#doHighlighting\n    */\n   @SuppressWarnings(\"unchecked\")\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException {\n     return HIGHLIGHTER.doHighlighting(docs, query, req, defaultFields);\n   }\n\n","sourceOld":"   /**\n    * @deprecated use DefaultSolrHighlighter\n    * @see DefaultSolrHighlighter#doHighlighting\n    */\n   @SuppressWarnings(\"unchecked\")\n   public static NamedList doHighlighting(DocList docs, Query query, SolrQueryRequest req, String[] defaultFields) throws IOException {\n     return HIGHLIGHTER.doHighlighting(docs, query, req, defaultFields);\n   }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"33e6ce261fb71637077f5afb0521a898795a4340":["a4114a9012ed90fa73da6201bb0aeec818808848"],"a4114a9012ed90fa73da6201bb0aeec818808848":["090f8d702b753c18c64a6fd5fb550596c68861ce"],"7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a":["af09a11446184597ca824554260a98704507f8a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"af09a11446184597ca824554260a98704507f8a7":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"090f8d702b753c18c64a6fd5fb550596c68861ce":["4145b7b13874de95211223a6edb648da8794a688"],"ad94625fb8d088209f46650c8097196fec67f00c":["33e6ce261fb71637077f5afb0521a898795a4340"],"4145b7b13874de95211223a6edb648da8794a688":["7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"33e6ce261fb71637077f5afb0521a898795a4340":["ad94625fb8d088209f46650c8097196fec67f00c"],"a4114a9012ed90fa73da6201bb0aeec818808848":["33e6ce261fb71637077f5afb0521a898795a4340"],"7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a":["4145b7b13874de95211223a6edb648da8794a688"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["af09a11446184597ca824554260a98704507f8a7"],"af09a11446184597ca824554260a98704507f8a7":["7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a"],"090f8d702b753c18c64a6fd5fb550596c68861ce":["a4114a9012ed90fa73da6201bb0aeec818808848"],"4145b7b13874de95211223a6edb648da8794a688":["090f8d702b753c18c64a6fd5fb550596c68861ce"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}