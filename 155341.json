{"path":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","sourceNew":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i=0; i<tr.getSize(); i++) {\n      CategoryPath expectedCategory = new CategoryPath(expectedCategories[i]);\n      CategoryPath category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i=0; i<expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new CategoryPath(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i=0; i<tr.getSize(); i++) {\n      CategoryPath expectedCategory = new CategoryPath(expectedCategories[i]);\n      CategoryPath category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i=0; i<expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new CategoryPath(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ffa18fad2d839bbae5054931722c97d04c10258","date":1358772877,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","sourceNew":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i = 1; i < tr.getSize(); i++) {\n      CategoryPath expectedCategory = new CategoryPath(expectedCategories[i]);\n      CategoryPath category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i = 1; i < expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new CategoryPath(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i=0; i<tr.getSize(); i++) {\n      CategoryPath expectedCategory = new CategoryPath(expectedCategories[i]);\n      CategoryPath category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i=0; i<expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new CategoryPath(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07155cdd910937cdf6877e48884d5782845c8b8b","date":1358796205,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","sourceNew":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i = 1; i < tr.getSize(); i++) {\n      CategoryPath expectedCategory = new CategoryPath(expectedCategories[i]);\n      CategoryPath category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i = 1; i < expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new CategoryPath(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i=0; i<tr.getSize(); i++) {\n      CategoryPath expectedCategory = new CategoryPath(expectedCategories[i]);\n      CategoryPath category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i=0; i<expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new CategoryPath(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","sourceNew":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i = 1; i < tr.getSize(); i++) {\n      FacetLabel expectedCategory = new FacetLabel(expectedCategories[i]);\n      FacetLabel category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i = 1; i < expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new FacetLabel(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i = 1; i < tr.getSize(); i++) {\n      CategoryPath expectedCategory = new CategoryPath(expectedCategories[i]);\n      CategoryPath category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i = 1; i < expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new CategoryPath(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","sourceNew":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i = 1; i < tr.getSize(); i++) {\n      FacetLabel expectedCategory = new FacetLabel(expectedCategories[i]);\n      FacetLabel category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i = 1; i < expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new FacetLabel(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i = 1; i < tr.getSize(); i++) {\n      CategoryPath expectedCategory = new CategoryPath(expectedCategories[i]);\n      CategoryPath category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i = 1; i < expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new CategoryPath(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testReaderBasic().mjava","sourceNew":"  /**  Basic tests for TaxonomyReader's category &lt;=&gt; ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i = 1; i < tr.getSize(); i++) {\n      FacetLabel expectedCategory = new FacetLabel(expectedCategories[i]);\n      FacetLabel category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i = 1; i < expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new FacetLabel(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Basic tests for TaxonomyReader's category <=> ordinal transformations\n    (getSize(), getCategory() and getOrdinal()).\n    We test that after writing the index, it can be read and all the\n    categories and ordinals are there just as we expected them to be.\n   */\n  @Test\n  public void testReaderBasic() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    fillTaxonomy(tw);\n    tw.close();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    // test TaxonomyReader.getSize():\n    assertEquals(expectedCategories.length, tr.getSize());\n\n    // test round trips of ordinal => category => ordinal\n    for (int i=0; i<tr.getSize(); i++) {\n      assertEquals(i, tr.getOrdinal(tr.getPath(i)));\n    }\n\n    // test TaxonomyReader.getCategory():\n    for (int i = 1; i < tr.getSize(); i++) {\n      FacetLabel expectedCategory = new FacetLabel(expectedCategories[i]);\n      FacetLabel category = tr.getPath(i);\n      if (!expectedCategory.equals(category)) {\n        fail(\"For ordinal \"+i+\" expected category \"+\n            showcat(expectedCategory)+\", but got \"+showcat(category));\n      }\n    }\n    //  (also test invalid ordinals:)\n    assertNull(tr.getPath(-1));\n    assertNull(tr.getPath(tr.getSize()));\n    assertNull(tr.getPath(TaxonomyReader.INVALID_ORDINAL));\n\n    // test TaxonomyReader.getOrdinal():\n    for (int i = 1; i < expectedCategories.length; i++) {\n      int expectedOrdinal = i;\n      int ordinal = tr.getOrdinal(new FacetLabel(expectedCategories[i]));\n      if (expectedOrdinal != ordinal) {\n        fail(\"For category \"+showcat(expectedCategories[i])+\" expected ordinal \"+\n            expectedOrdinal+\", but got \"+ordinal);\n      }\n    }\n    // (also test invalid categories:)\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel(\"non-existant\")));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel(\"Author\", \"Jules Verne\")));\n\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1ffa18fad2d839bbae5054931722c97d04c10258":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["1ffa18fad2d839bbae5054931722c97d04c10258","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"07155cdd910937cdf6877e48884d5782845c8b8b":["b89678825b68eccaf09e6ab71675fc0b0af1e099","1ffa18fad2d839bbae5054931722c97d04c10258"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["1ffa18fad2d839bbae5054931722c97d04c10258"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["1ffa18fad2d839bbae5054931722c97d04c10258","07155cdd910937cdf6877e48884d5782845c8b8b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"1ffa18fad2d839bbae5054931722c97d04c10258":["3cc728b07df73b197e6d940d27f9b08b63918f13","07155cdd910937cdf6877e48884d5782845c8b8b","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"07155cdd910937cdf6877e48884d5782845c8b8b":[],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["07155cdd910937cdf6877e48884d5782845c8b8b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}