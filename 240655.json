{"path":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrServer],Object...).mjava","sourceNew":"  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrClient> upClients,\n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    QueryResponse rsp = queryRandomUpServer(params,upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Thread[] threads = new Thread[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrClient client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          }\n        };\n        threads[i].start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","sourceOld":"  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrServer> upClients, \n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    QueryResponse rsp = queryRandomUpServer(params,upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Thread[] threads = new Thread[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrServer client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          }\n        };\n        threads[i].start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8ed5ba2c6fdd51d5fb71cfabb554a7f2a7d6cfa","date":1425039471,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","sourceNew":"  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrClient> upClients,\n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    QueryResponse rsp = queryRandomUpServer(params,upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Thread[] threads = new Thread[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrClient client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException | IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          }\n        };\n        threads[i].start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","sourceOld":"  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrClient> upClients,\n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    QueryResponse rsp = queryRandomUpServer(params,upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Thread[] threads = new Thread[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrClient client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          }\n        };\n        threads[i].start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","sourceNew":"  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrClient> upClients,\n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    QueryResponse rsp = queryRandomUpServer(params,upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Thread[] threads = new Thread[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrClient client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException | IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          }\n        };\n        threads[i].start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","sourceOld":"  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrClient> upClients,\n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    QueryResponse rsp = queryRandomUpServer(params,upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Thread[] threads = new Thread[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrClient client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          }\n        };\n        threads[i].start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","sourceNew":"  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrClient> upClients,\n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    if (upClients.size() == 0) {\n      return;\n    }\n    QueryResponse rsp = queryRandomUpServer(params, upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Set<Future<Object>> pending = new HashSet<>();;\n      ExecutorCompletionService<Object> cs = new ExecutorCompletionService<>(executor);\n      Callable[] threads = new Callable[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Callable() {\n          @Override\n          public Object call() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrClient client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException | IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n            return null;\n          }\n        };\n        pending.add(cs.submit(threads[i]));\n      }\n      \n      while (pending.size() > 0) {\n        Future<Object> future = cs.take();\n        pending.remove(future);\n        future.get();\n      }\n\n    }\n  }\n\n","sourceOld":"  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrClient> upClients,\n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    QueryResponse rsp = queryRandomUpServer(params,upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Thread[] threads = new Thread[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrClient client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException | IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n          }\n        };\n        threads[i].start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n    }\n  }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","pathOld":"solr/core/src/test/org/apache/solr/TestDistributedSearch#queryPartialResults(List[String],List[SolrClient],Object...).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrClient> upClients,\n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    if (upClients.size() == 0) {\n      return;\n    }\n    QueryResponse rsp = queryRandomUpServer(params, upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Set<Future<Object>> pending = new HashSet<>();;\n      ExecutorCompletionService<Object> cs = new ExecutorCompletionService<>(executor);\n      Callable[] threads = new Callable[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Callable() {\n          @Override\n          public Object call() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrClient client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException | IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n            return null;\n          }\n        };\n        pending.add(cs.submit(threads[i]));\n      }\n      \n      while (pending.size() > 0) {\n        Future<Object> future = cs.take();\n        pending.remove(future);\n        future.get();\n      }\n\n    }\n  }\n\n","sourceOld":"  protected void queryPartialResults(final List<String> upShards,\n                                     final List<SolrClient> upClients,\n                                     Object... q) throws Exception {\n    \n    final ModifiableSolrParams params = new ModifiableSolrParams();\n\n    for (int i = 0; i < q.length; i += 2) {\n      params.add(q[i].toString(), q[i + 1].toString());\n    }\n    // TODO: look into why passing true causes fails\n    params.set(\"distrib\", \"false\");\n    final QueryResponse controlRsp = controlClient.query(params);\n    // if time.allowed is specified then even a control response can return a partialResults header\n    if (params.get(CommonParams.TIME_ALLOWED) == null)  {\n      validateControlData(controlRsp);\n    }\n\n    params.remove(\"distrib\");\n    setDistributedParams(params);\n\n    if (upClients.size() == 0) {\n      return;\n    }\n    QueryResponse rsp = queryRandomUpServer(params, upClients);\n\n    comparePartialResponses(rsp, controlRsp, upShards);\n\n    if (stress > 0) {\n      log.info(\"starting stress...\");\n      Set<Future<Object>> pending = new HashSet<>();;\n      ExecutorCompletionService<Object> cs = new ExecutorCompletionService<>(executor);\n      Callable[] threads = new Callable[nThreads];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Callable() {\n          @Override\n          public Object call() {\n            for (int j = 0; j < stress; j++) {\n              int which = r.nextInt(upClients.size());\n              SolrClient client = upClients.get(which);\n              try {\n                QueryResponse rsp = client.query(new ModifiableSolrParams(params));\n                if (verifyStress) {\n                  comparePartialResponses(rsp, controlRsp, upShards);\n                }\n              } catch (SolrServerException | IOException e) {\n                throw new RuntimeException(e);\n              }\n            }\n            return null;\n          }\n        };\n        pending.add(cs.submit(threads[i]));\n      }\n      \n      while (pending.size() > 0) {\n        Future<Object> future = cs.take();\n        pending.remove(future);\n        future.get();\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["bafca15d8e408346a67f4282ad1143b88023893b","b8ed5ba2c6fdd51d5fb71cfabb554a7f2a7d6cfa"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"b8ed5ba2c6fdd51d5fb71cfabb554a7f2a7d6cfa":["bafca15d8e408346a67f4282ad1143b88023893b"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b8ed5ba2c6fdd51d5fb71cfabb554a7f2a7d6cfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b8ed5ba2c6fdd51d5fb71cfabb554a7f2a7d6cfa":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b8ed5ba2c6fdd51d5fb71cfabb554a7f2a7d6cfa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}