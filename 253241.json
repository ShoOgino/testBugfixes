{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","commits":[{"id":"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9","date":1459984736,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = decodeValueMin(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = decodeValueMax(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = decodeValueMin(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = decodeValueMax(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = decodeValueMin(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = decodeValueMax(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"873caa2b3b10bf0e4724a950c3a11b841ebb0e4a","date":1460035668,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","sourceNew":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = decodeValueMin(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = decodeValueMax(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = decodeValueMin(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = decodeValueMax(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = decodeValueMin(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = decodeValueMax(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936e62fbacf493107c977e945b4211c43a957400","date":1460681198,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","sourceNew":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (shapeBounds.getMinimumX() >= xMin && shapeBounds.getMaximumX() <= xMax &&\n      shapeBounds.getMinimumY() >= yMin && shapeBounds.getMaximumY() <= yMax &&\n      shapeBounds.getMinimumZ() >= zMin && shapeBounds.getMaximumZ() <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n    \n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fce328ef870a3ecd74b752ab0906156ff29a4b93","date":1460809783,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","sourceNew":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (shapeBounds.getMinimumX() >= xMin && shapeBounds.getMaximumX() <= xMax &&\n      shapeBounds.getMinimumY() >= yMin && shapeBounds.getMaximumY() <= yMax &&\n      shapeBounds.getMinimumZ() >= zMin && shapeBounds.getMaximumZ() <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n\n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (shapeBounds.getMinimumX() >= xMin && shapeBounds.getMaximumX() <= xMax &&\n      shapeBounds.getMinimumY() >= yMin && shapeBounds.getMaximumY() <= yMax &&\n      shapeBounds.getMinimumZ() >= zMin && shapeBounds.getMaximumZ() <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n    \n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05b856843186ad4df844585f0c4f74ec1fdb7698","date":1475435878,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","sourceNew":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (minimumX >= xMin && maximumX <= xMax &&\n      minimumY >= yMin && maximumY <= yMax &&\n      minimumZ >= zMin && maximumZ <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n\n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (shapeBounds.getMinimumX() >= xMin && shapeBounds.getMaximumX() <= xMax &&\n      shapeBounds.getMinimumY() >= yMin && shapeBounds.getMaximumY() <= yMax &&\n      shapeBounds.getMinimumZ() >= zMin && shapeBounds.getMaximumZ() <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n\n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","sourceNew":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (minimumX >= xMin && maximumX <= xMax &&\n      minimumY >= yMin && maximumY <= yMax &&\n      minimumZ >= zMin && maximumZ <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n\n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (shapeBounds.getMinimumX() >= xMin && shapeBounds.getMaximumX() <= xMax &&\n      shapeBounds.getMinimumY() >= yMin && shapeBounds.getMaximumY() <= yMax &&\n      shapeBounds.getMinimumZ() >= zMin && shapeBounds.getMaximumZ() <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n\n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor#compare(byte[],byte[]).mjava","sourceNew":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0), shape.getPlanetModel());\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0), shape.getPlanetModel());\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES), shape.getPlanetModel());\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES), shape.getPlanetModel());\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES), shape.getPlanetModel());\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES), shape.getPlanetModel());\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (minimumX >= xMin && maximumX <= xMax &&\n      minimumY >= yMin && maximumY <= yMax &&\n      minimumZ >= zMin && maximumZ <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n\n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(shape.getPlanetModel(), xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n    // Because the dimensional format operates in quantized (64 bit -> 32 bit) space, and the cell bounds\n    // here are inclusive, we need to extend the bounds to the largest un-quantized values that\n    // could quantize into these bounds.  The encoding (Geo3DUtil.encodeValue) does\n    // a Math.round from double to long, so e.g. 1.4 -> 1, and -1.4 -> -1:\n    double xMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 0));\n    double xMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 0));\n    double yMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 1 * Integer.BYTES));\n    double yMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 1 * Integer.BYTES));\n    double zMin = Geo3DUtil.decodeValueFloor(NumericUtils.sortableBytesToInt(minPackedValue, 2 * Integer.BYTES));\n    double zMax = Geo3DUtil.decodeValueCeil(NumericUtils.sortableBytesToInt(maxPackedValue, 2 * Integer.BYTES));\n\n    //System.out.println(\"  compare: x=\" + cellXMin + \"-\" + cellXMax + \" y=\" + cellYMin + \"-\" + cellYMax + \" z=\" + cellZMin + \"-\" + cellZMax);\n    assert xMin <= xMax;\n    assert yMin <= yMax;\n    assert zMin <= zMax;\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (minimumX >= xMin && maximumX <= xMax &&\n      minimumY >= yMin && maximumY <= yMax &&\n      minimumZ >= zMin && maximumZ <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n\n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"936e62fbacf493107c977e945b4211c43a957400":["873caa2b3b10bf0e4724a950c3a11b841ebb0e4a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fce328ef870a3ecd74b752ab0906156ff29a4b93":["936e62fbacf493107c977e945b4211c43a957400"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["05b856843186ad4df844585f0c4f74ec1fdb7698"],"873caa2b3b10bf0e4724a950c3a11b841ebb0e4a":["4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["fce328ef870a3ecd74b752ab0906156ff29a4b93","05b856843186ad4df844585f0c4f74ec1fdb7698"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"05b856843186ad4df844585f0c4f74ec1fdb7698":["fce328ef870a3ecd74b752ab0906156ff29a4b93"]},"commit2Childs":{"4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9":["873caa2b3b10bf0e4724a950c3a11b841ebb0e4a"],"936e62fbacf493107c977e945b4211c43a957400":["fce328ef870a3ecd74b752ab0906156ff29a4b93"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d3a37d877793d2b7b46b7d8b0b0319d65f7d2a9"],"fce328ef870a3ecd74b752ab0906156ff29a4b93":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","05b856843186ad4df844585f0c4f74ec1fdb7698"],"873caa2b3b10bf0e4724a950c3a11b841ebb0e4a":["936e62fbacf493107c977e945b4211c43a957400"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"05b856843186ad4df844585f0c4f74ec1fdb7698":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}