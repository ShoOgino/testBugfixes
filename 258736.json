{"path":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,String,String,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","commits":[{"id":"1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87","date":1440409984,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,String,String,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,String,String,int,String,boolean,int,IntIntOpenHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            String min,\n                                            String max,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n\n\n      SortedDocValues docValues = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValues = uninvertingReader.getSortedDocValues(collapseField);\n        } else {\n          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if(max != null) {\n        if(max.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(max).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(max, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      if(min != null) {\n        if(min.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(min).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(min, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (min != null || max != null) {\n\n        if(collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValues,\n                                            nullPolicy,\n                                            max != null ? max : min,\n                                            max != null,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            max != null ? max : min,\n                                            max != null,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n\n      } else {\n\n        if(collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);\n\n        } else if(collapseFieldType instanceof TrieIntField ||\n                  collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            String min,\n                                            String max,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntOpenHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n\n\n      SortedDocValues docValues = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValues = uninvertingReader.getSortedDocValues(collapseField);\n        } else {\n          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if(max != null) {\n        if(max.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(max).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(max, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      if(min != null) {\n        if(min.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(min).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(min, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (min != null || max != null) {\n\n        if(collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValues,\n                                            nullPolicy,\n                                            max != null ? max : min,\n                                            max != null,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            max != null ? max : min,\n                                            max != null,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n\n      } else {\n\n        if(collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);\n\n        } else if(collapseFieldType instanceof TrieIntField ||\n                  collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0325de99180d346d61d36938843a5c8451fe26ae","date":1447368726,"type":5,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,String,String,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      SortedDocValues docValues = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValues = uninvertingReader.getSortedDocValues(collapseField);\n        } else {\n          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);\n\n        } else if (collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValues,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            String min,\n                                            String max,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n\n\n      SortedDocValues docValues = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n\n            /*\n            * This hint forces the use of the top level field cache for String fields.\n            * This is VERY fast at query time but slower to warm and causes insanity.\n            */\n\n          Map<String, UninvertingReader.Type> mapping = new HashMap();\n          mapping.put(collapseField, UninvertingReader.Type.SORTED);\n          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);\n          docValues = uninvertingReader.getSortedDocValues(collapseField);\n        } else {\n          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if(max != null) {\n        if(max.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(max).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(max, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      if(min != null) {\n        if(min.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(min).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(min, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (min != null || max != null) {\n\n        if(collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValues,\n                                            nullPolicy,\n                                            max != null ? max : min,\n                                            max != null,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if((collapseFieldType instanceof TrieIntField ||\n                   collapseFieldType instanceof TrieFloatField)) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            max != null ? max : min,\n                                            max != null,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n\n      } else {\n\n        if(collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);\n\n        } else if(collapseFieldType instanceof TrieIntField ||\n                  collapseFieldType instanceof TrieFloatField) {\n\n          int nullValue = 0;\n\n          if(collapseFieldType instanceof TrieFloatField) {\n            if(defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if(defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0325de99180d346d61d36938843a5c8451fe26ae":["1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87"],"1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0325de99180d346d61d36938843a5c8451fe26ae"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87"],"0325de99180d346d61d36938843a5c8451fe26ae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87":["0325de99180d346d61d36938843a5c8451fe26ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}