{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#computePackedValueBounds(MutablePointValues,int,int,byte[],byte[],BytesRef).mjava","commits":[{"id":"d0f206e78bea6261260b24c406e920d05c7ca2f3","date":1570809619,"type":0,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#computePackedValueBounds(MutablePointValues,int,int,byte[],byte[],BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  private void computePackedValueBounds(MutablePointValues values, int from, int to, byte[] minPackedValue, byte[] maxPackedValue, BytesRef scratch) {\n    if (from == to) {\n      return;\n    }\n    values.getValue(from, scratch);\n    System.arraycopy(scratch.bytes, scratch.offset, minPackedValue, 0, packedIndexBytesLength);\n    System.arraycopy(scratch.bytes, scratch.offset, maxPackedValue, 0, packedIndexBytesLength);\n    for (int i = from + 1 ; i < to; ++i) {\n      values.getValue(i, scratch);\n      for(int dim = 0; dim < numIndexDims; dim++) {\n        final int startOffset = dim * bytesPerDim;\n        final int endOffset = startOffset + bytesPerDim;\n        if (Arrays.compareUnsigned(scratch.bytes, scratch.offset + startOffset, scratch.offset + endOffset, minPackedValue, startOffset, endOffset) < 0) {\n          System.arraycopy(scratch.bytes, scratch.offset + startOffset, minPackedValue, startOffset, bytesPerDim);\n        } else if (Arrays.compareUnsigned(scratch.bytes, scratch.offset + startOffset, scratch.offset + endOffset, maxPackedValue, startOffset, endOffset) > 0) {\n          System.arraycopy(scratch.bytes, scratch.offset + startOffset, maxPackedValue, startOffset, bytesPerDim);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":0,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#computePackedValueBounds(MutablePointValues,int,int,byte[],byte[],BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  private void computePackedValueBounds(MutablePointValues values, int from, int to, byte[] minPackedValue, byte[] maxPackedValue, BytesRef scratch) {\n    if (from == to) {\n      return;\n    }\n    values.getValue(from, scratch);\n    System.arraycopy(scratch.bytes, scratch.offset, minPackedValue, 0, packedIndexBytesLength);\n    System.arraycopy(scratch.bytes, scratch.offset, maxPackedValue, 0, packedIndexBytesLength);\n    for (int i = from + 1 ; i < to; ++i) {\n      values.getValue(i, scratch);\n      for(int dim = 0; dim < numIndexDims; dim++) {\n        final int startOffset = dim * bytesPerDim;\n        final int endOffset = startOffset + bytesPerDim;\n        if (Arrays.compareUnsigned(scratch.bytes, scratch.offset + startOffset, scratch.offset + endOffset, minPackedValue, startOffset, endOffset) < 0) {\n          System.arraycopy(scratch.bytes, scratch.offset + startOffset, minPackedValue, startOffset, bytesPerDim);\n        } else if (Arrays.compareUnsigned(scratch.bytes, scratch.offset + startOffset, scratch.offset + endOffset, maxPackedValue, startOffset, endOffset) > 0) {\n          System.arraycopy(scratch.bytes, scratch.offset + startOffset, maxPackedValue, startOffset, bytesPerDim);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#computePackedValueBounds(MutablePointValues,int,int,byte[],byte[],BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#computePackedValueBounds(MutablePointValues,int,int,byte[],byte[],BytesRef).mjava","sourceNew":"  private void computePackedValueBounds(MutablePointValues values, int from, int to, byte[] minPackedValue, byte[] maxPackedValue, BytesRef scratch) {\n    if (from == to) {\n      return;\n    }\n    values.getValue(from, scratch);\n    System.arraycopy(scratch.bytes, scratch.offset, minPackedValue, 0, config.packedIndexBytesLength);\n    System.arraycopy(scratch.bytes, scratch.offset, maxPackedValue, 0, config.packedIndexBytesLength);\n    for (int i = from + 1 ; i < to; ++i) {\n      values.getValue(i, scratch);\n      for(int dim = 0; dim < config.numIndexDims; dim++) {\n        final int startOffset = dim * config.bytesPerDim;\n        final int endOffset = startOffset + config.bytesPerDim;\n        if (Arrays.compareUnsigned(scratch.bytes, scratch.offset + startOffset, scratch.offset + endOffset, minPackedValue, startOffset, endOffset) < 0) {\n          System.arraycopy(scratch.bytes, scratch.offset + startOffset, minPackedValue, startOffset, config.bytesPerDim);\n        } else if (Arrays.compareUnsigned(scratch.bytes, scratch.offset + startOffset, scratch.offset + endOffset, maxPackedValue, startOffset, endOffset) > 0) {\n          System.arraycopy(scratch.bytes, scratch.offset + startOffset, maxPackedValue, startOffset, config.bytesPerDim);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void computePackedValueBounds(MutablePointValues values, int from, int to, byte[] minPackedValue, byte[] maxPackedValue, BytesRef scratch) {\n    if (from == to) {\n      return;\n    }\n    values.getValue(from, scratch);\n    System.arraycopy(scratch.bytes, scratch.offset, minPackedValue, 0, packedIndexBytesLength);\n    System.arraycopy(scratch.bytes, scratch.offset, maxPackedValue, 0, packedIndexBytesLength);\n    for (int i = from + 1 ; i < to; ++i) {\n      values.getValue(i, scratch);\n      for(int dim = 0; dim < numIndexDims; dim++) {\n        final int startOffset = dim * bytesPerDim;\n        final int endOffset = startOffset + bytesPerDim;\n        if (Arrays.compareUnsigned(scratch.bytes, scratch.offset + startOffset, scratch.offset + endOffset, minPackedValue, startOffset, endOffset) < 0) {\n          System.arraycopy(scratch.bytes, scratch.offset + startOffset, minPackedValue, startOffset, bytesPerDim);\n        } else if (Arrays.compareUnsigned(scratch.bytes, scratch.offset + startOffset, scratch.offset + endOffset, maxPackedValue, startOffset, endOffset) > 0) {\n          System.arraycopy(scratch.bytes, scratch.offset + startOffset, maxPackedValue, startOffset, bytesPerDim);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["d0f206e78bea6261260b24c406e920d05c7ca2f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0f206e78bea6261260b24c406e920d05c7ca2f3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"b0b597c65628ca9e73913a07e81691f8229bae35":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d0f206e78bea6261260b24c406e920d05c7ca2f3"]},"commit2Childs":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d0f206e78bea6261260b24c406e920d05c7ca2f3","b0b597c65628ca9e73913a07e81691f8229bae35"],"d0f206e78bea6261260b24c406e920d05c7ca2f3":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}