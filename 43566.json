{"path":"src/test/org/apache/solr/analysis/TestSynonymFilter#testIncludeOrig().mjava","commits":[{"id":"0d3072fffb39e4aa50fce38815821919b35fc194","date":1138579199,"type":0,"author":"Yoav Shapira","isMerge":false,"pathNew":"src/test/org/apache/solr/analysis/TestSynonymFilter#testIncludeOrig().mjava","pathOld":"/dev/null","sourceNew":"  public void testIncludeOrig() throws IOException {\r\n    SynonymMap map = new SynonymMap();\r\n\r\n    boolean orig = true;\r\n    boolean merge = true;\r\n    map.add(strings(\"a b\"), tokens(\"ab\"), orig, merge);\r\n    map.add(strings(\"a c\"), tokens(\"ac\"), orig, merge);\r\n    map.add(strings(\"a\"), tokens(\"aa\"), orig, merge);\r\n    map.add(strings(\"b\"), tokens(\"bb\"), orig, merge);\r\n    map.add(strings(\"z x c v\"), tokens(\"zxcv\"), orig, merge);\r\n    map.add(strings(\"x c\"), tokens(\"xc\"), orig, merge);\r\n\r\n    // System.out.println(map);\r\n    // System.out.println(getTokList(map,\"a\",false));\r\n\r\n    assertTokEqual(getTokList(map,\"$\",false), tokens(\"$\"));\r\n    assertTokEqual(getTokList(map,\"a\",false), tokens(\"a/aa\"));\r\n    assertTokEqual(getTokList(map,\"a\",false), tokens(\"a/aa\"));\r\n    assertTokEqual(getTokList(map,\"$ a\",false), tokens(\"$ a/aa\"));\r\n    assertTokEqual(getTokList(map,\"a $\",false), tokens(\"a/aa $\"));\r\n    assertTokEqual(getTokList(map,\"$ a !\",false), tokens(\"$ a/aa !\"));\r\n    assertTokEqual(getTokList(map,\"a a\",false), tokens(\"a/aa a/aa\"));\r\n    assertTokEqual(getTokList(map,\"b\",false), tokens(\"b/bb\"));\r\n    assertTokEqual(getTokList(map,\"z x c v\",false), tokens(\"z/zxcv x c v\"));\r\n    assertTokEqual(getTokList(map,\"z x c $\",false), tokens(\"z x/xc c $\"));\r\n\r\n    // check for lack of recursion\r\n    map.add(strings(\"zoo zoo\"), tokens(\"zoo\"), orig, merge);\r\n    assertTokEqual(getTokList(map,\"zoo zoo $ zoo\",false), tokens(\"zoo/zoo zoo/zoo $ zoo/zoo\"));\r\n    map.add(strings(\"zoo\"), tokens(\"zoo zoo\"), orig, merge);\r\n    assertTokEqual(getTokList(map,\"zoo zoo $ zoo\",false), tokens(\"zoo/zoo zoo $ zoo/zoo zoo\"));\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c1781d63ce2d5e979c8b3f35682b60a86f5df553"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1781d63ce2d5e979c8b3f35682b60a86f5df553","date":1153254917,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/analysis/TestSynonymFilter#testIncludeOrig().mjava","pathOld":"src/test/org/apache/solr/analysis/TestSynonymFilter#testIncludeOrig().mjava","sourceNew":"  public void testIncludeOrig() throws IOException {\n    SynonymMap map = new SynonymMap();\n\n    boolean orig = true;\n    boolean merge = true;\n    map.add(strings(\"a b\"), tokens(\"ab\"), orig, merge);\n    map.add(strings(\"a c\"), tokens(\"ac\"), orig, merge);\n    map.add(strings(\"a\"), tokens(\"aa\"), orig, merge);\n    map.add(strings(\"b\"), tokens(\"bb\"), orig, merge);\n    map.add(strings(\"z x c v\"), tokens(\"zxcv\"), orig, merge);\n    map.add(strings(\"x c\"), tokens(\"xc\"), orig, merge);\n\n    // System.out.println(map);\n    // System.out.println(getTokList(map,\"a\",false));\n\n    assertTokEqual(getTokList(map,\"$\",false), tokens(\"$\"));\n    assertTokEqual(getTokList(map,\"a\",false), tokens(\"a/aa\"));\n    assertTokEqual(getTokList(map,\"a\",false), tokens(\"a/aa\"));\n    assertTokEqual(getTokList(map,\"$ a\",false), tokens(\"$ a/aa\"));\n    assertTokEqual(getTokList(map,\"a $\",false), tokens(\"a/aa $\"));\n    assertTokEqual(getTokList(map,\"$ a !\",false), tokens(\"$ a/aa !\"));\n    assertTokEqual(getTokList(map,\"a a\",false), tokens(\"a/aa a/aa\"));\n    assertTokEqual(getTokList(map,\"b\",false), tokens(\"b/bb\"));\n    assertTokEqual(getTokList(map,\"z x c v\",false), tokens(\"z/zxcv x c v\"));\n    assertTokEqual(getTokList(map,\"z x c $\",false), tokens(\"z x/xc c $\"));\n\n    // check for lack of recursion\n    map.add(strings(\"zoo zoo\"), tokens(\"zoo\"), orig, merge);\n    assertTokEqual(getTokList(map,\"zoo zoo $ zoo\",false), tokens(\"zoo/zoo zoo/zoo $ zoo/zoo\"));\n    map.add(strings(\"zoo\"), tokens(\"zoo zoo\"), orig, merge);\n    assertTokEqual(getTokList(map,\"zoo zoo $ zoo\",false), tokens(\"zoo/zoo zoo $ zoo/zoo zoo\"));\n  }\n\n","sourceOld":"  public void testIncludeOrig() throws IOException {\r\n    SynonymMap map = new SynonymMap();\r\n\r\n    boolean orig = true;\r\n    boolean merge = true;\r\n    map.add(strings(\"a b\"), tokens(\"ab\"), orig, merge);\r\n    map.add(strings(\"a c\"), tokens(\"ac\"), orig, merge);\r\n    map.add(strings(\"a\"), tokens(\"aa\"), orig, merge);\r\n    map.add(strings(\"b\"), tokens(\"bb\"), orig, merge);\r\n    map.add(strings(\"z x c v\"), tokens(\"zxcv\"), orig, merge);\r\n    map.add(strings(\"x c\"), tokens(\"xc\"), orig, merge);\r\n\r\n    // System.out.println(map);\r\n    // System.out.println(getTokList(map,\"a\",false));\r\n\r\n    assertTokEqual(getTokList(map,\"$\",false), tokens(\"$\"));\r\n    assertTokEqual(getTokList(map,\"a\",false), tokens(\"a/aa\"));\r\n    assertTokEqual(getTokList(map,\"a\",false), tokens(\"a/aa\"));\r\n    assertTokEqual(getTokList(map,\"$ a\",false), tokens(\"$ a/aa\"));\r\n    assertTokEqual(getTokList(map,\"a $\",false), tokens(\"a/aa $\"));\r\n    assertTokEqual(getTokList(map,\"$ a !\",false), tokens(\"$ a/aa !\"));\r\n    assertTokEqual(getTokList(map,\"a a\",false), tokens(\"a/aa a/aa\"));\r\n    assertTokEqual(getTokList(map,\"b\",false), tokens(\"b/bb\"));\r\n    assertTokEqual(getTokList(map,\"z x c v\",false), tokens(\"z/zxcv x c v\"));\r\n    assertTokEqual(getTokList(map,\"z x c $\",false), tokens(\"z x/xc c $\"));\r\n\r\n    // check for lack of recursion\r\n    map.add(strings(\"zoo zoo\"), tokens(\"zoo\"), orig, merge);\r\n    assertTokEqual(getTokList(map,\"zoo zoo $ zoo\",false), tokens(\"zoo/zoo zoo/zoo $ zoo/zoo\"));\r\n    map.add(strings(\"zoo\"), tokens(\"zoo zoo\"), orig, merge);\r\n    assertTokEqual(getTokList(map,\"zoo zoo $ zoo\",false), tokens(\"zoo/zoo zoo $ zoo/zoo zoo\"));\r\n  }\r\n\n","bugFix":["0d3072fffb39e4aa50fce38815821919b35fc194"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2fd023a662cc25ae7e0ad0f33d71c476a16d0579","date":1261403630,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/test/org/apache/solr/analysis/TestSynonymFilter#testIncludeOrig().mjava","pathOld":"src/test/org/apache/solr/analysis/TestSynonymFilter#testIncludeOrig().mjava","sourceNew":"  public void testIncludeOrig() throws IOException {\n    SynonymMap map = new SynonymMap();\n\n    boolean orig = true;\n    boolean merge = true;\n    map.add(strings(\"a b\"), tokens(\"ab\"), orig, merge);\n    map.add(strings(\"a c\"), tokens(\"ac\"), orig, merge);\n    map.add(strings(\"a\"), tokens(\"aa\"), orig, merge);\n    map.add(strings(\"b\"), tokens(\"bb\"), orig, merge);\n    map.add(strings(\"z x c v\"), tokens(\"zxcv\"), orig, merge);\n    map.add(strings(\"x c\"), tokens(\"xc\"), orig, merge);\n\n    assertTokenizesTo(map, \"$\", \n        new String[] { \"$\" },\n        new int[] { 1 });\n    assertTokenizesTo(map, \"a\", \n        new String[] { \"a\", \"aa\" },\n        new int[] { 1, 0 });\n    assertTokenizesTo(map, \"a\", \n        new String[] { \"a\", \"aa\" },\n        new int[] { 1, 0 });\n    assertTokenizesTo(map, \"$ a\", \n        new String[] { \"$\", \"a\", \"aa\" },\n        new int[] { 1, 1, 0 });\n    assertTokenizesTo(map, \"a $\", \n        new String[] { \"a\", \"aa\", \"$\" },\n        new int[] { 1, 0, 1 });\n    assertTokenizesTo(map, \"$ a !\", \n        new String[] { \"$\", \"a\", \"aa\", \"!\" },\n        new int[] { 1, 1, 0, 1 });\n    assertTokenizesTo(map, \"a a\", \n        new String[] { \"a\", \"aa\", \"a\", \"aa\" },\n        new int[] { 1, 0, 1, 0 });\n    assertTokenizesTo(map, \"b\", \n        new String[] { \"b\", \"bb\" },\n        new int[] { 1, 0 });\n    assertTokenizesTo(map, \"z x c v\",\n        new String[] { \"z\", \"zxcv\", \"x\", \"c\", \"v\" },\n        new int[] { 1, 0, 1, 1, 1 });\n    assertTokenizesTo(map, \"z x c $\",\n        new String[] { \"z\", \"x\", \"xc\", \"c\", \"$\" },\n        new int[] { 1, 1, 0, 1, 1 });\n\n    // check for lack of recursion\n    map.add(strings(\"zoo zoo\"), tokens(\"zoo\"), orig, merge);\n    // CHECKME: I think the previous test (with 4 zoo's), was just a typo.\n    assertTokenizesTo(map, \"zoo zoo $ zoo\",\n        new String[] { \"zoo\", \"zoo\", \"zoo\", \"$\", \"zoo\" },\n        new int[] { 1, 0, 1, 1, 1 });\n\n    map.add(strings(\"zoo\"), tokens(\"zoo zoo\"), orig, merge);\n    assertTokenizesTo(map, \"zoo zoo $ zoo\",\n        new String[] { \"zoo\", \"zoo\", \"zoo\", \"$\", \"zoo\", \"zoo\", \"zoo\" },\n        new int[] { 1, 0, 1, 1, 1, 0, 1 });\n  }\n\n","sourceOld":"  public void testIncludeOrig() throws IOException {\n    SynonymMap map = new SynonymMap();\n\n    boolean orig = true;\n    boolean merge = true;\n    map.add(strings(\"a b\"), tokens(\"ab\"), orig, merge);\n    map.add(strings(\"a c\"), tokens(\"ac\"), orig, merge);\n    map.add(strings(\"a\"), tokens(\"aa\"), orig, merge);\n    map.add(strings(\"b\"), tokens(\"bb\"), orig, merge);\n    map.add(strings(\"z x c v\"), tokens(\"zxcv\"), orig, merge);\n    map.add(strings(\"x c\"), tokens(\"xc\"), orig, merge);\n\n    // System.out.println(map);\n    // System.out.println(getTokList(map,\"a\",false));\n\n    assertTokEqual(getTokList(map,\"$\",false), tokens(\"$\"));\n    assertTokEqual(getTokList(map,\"a\",false), tokens(\"a/aa\"));\n    assertTokEqual(getTokList(map,\"a\",false), tokens(\"a/aa\"));\n    assertTokEqual(getTokList(map,\"$ a\",false), tokens(\"$ a/aa\"));\n    assertTokEqual(getTokList(map,\"a $\",false), tokens(\"a/aa $\"));\n    assertTokEqual(getTokList(map,\"$ a !\",false), tokens(\"$ a/aa !\"));\n    assertTokEqual(getTokList(map,\"a a\",false), tokens(\"a/aa a/aa\"));\n    assertTokEqual(getTokList(map,\"b\",false), tokens(\"b/bb\"));\n    assertTokEqual(getTokList(map,\"z x c v\",false), tokens(\"z/zxcv x c v\"));\n    assertTokEqual(getTokList(map,\"z x c $\",false), tokens(\"z x/xc c $\"));\n\n    // check for lack of recursion\n    map.add(strings(\"zoo zoo\"), tokens(\"zoo\"), orig, merge);\n    assertTokEqual(getTokList(map,\"zoo zoo $ zoo\",false), tokens(\"zoo/zoo zoo/zoo $ zoo/zoo\"));\n    map.add(strings(\"zoo\"), tokens(\"zoo zoo\"), orig, merge);\n    assertTokEqual(getTokList(map,\"zoo zoo $ zoo\",false), tokens(\"zoo/zoo zoo $ zoo/zoo zoo\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/analysis/TestSynonymFilter#testIncludeOrig().mjava","pathOld":"src/test/org/apache/solr/analysis/TestSynonymFilter#testIncludeOrig().mjava","sourceNew":"  public void testIncludeOrig() throws IOException {\n    SynonymMap map = new SynonymMap();\n\n    boolean orig = true;\n    boolean merge = true;\n    map.add(strings(\"a b\"), tokens(\"ab\"), orig, merge);\n    map.add(strings(\"a c\"), tokens(\"ac\"), orig, merge);\n    map.add(strings(\"a\"), tokens(\"aa\"), orig, merge);\n    map.add(strings(\"b\"), tokens(\"bb\"), orig, merge);\n    map.add(strings(\"z x c v\"), tokens(\"zxcv\"), orig, merge);\n    map.add(strings(\"x c\"), tokens(\"xc\"), orig, merge);\n\n    assertTokenizesTo(map, \"$\", \n        new String[] { \"$\" },\n        new int[] { 1 });\n    assertTokenizesTo(map, \"a\", \n        new String[] { \"a\", \"aa\" },\n        new int[] { 1, 0 });\n    assertTokenizesTo(map, \"a\", \n        new String[] { \"a\", \"aa\" },\n        new int[] { 1, 0 });\n    assertTokenizesTo(map, \"$ a\", \n        new String[] { \"$\", \"a\", \"aa\" },\n        new int[] { 1, 1, 0 });\n    assertTokenizesTo(map, \"a $\", \n        new String[] { \"a\", \"aa\", \"$\" },\n        new int[] { 1, 0, 1 });\n    assertTokenizesTo(map, \"$ a !\", \n        new String[] { \"$\", \"a\", \"aa\", \"!\" },\n        new int[] { 1, 1, 0, 1 });\n    assertTokenizesTo(map, \"a a\", \n        new String[] { \"a\", \"aa\", \"a\", \"aa\" },\n        new int[] { 1, 0, 1, 0 });\n    assertTokenizesTo(map, \"b\", \n        new String[] { \"b\", \"bb\" },\n        new int[] { 1, 0 });\n    assertTokenizesTo(map, \"z x c v\",\n        new String[] { \"z\", \"zxcv\", \"x\", \"c\", \"v\" },\n        new int[] { 1, 0, 1, 1, 1 });\n    assertTokenizesTo(map, \"z x c $\",\n        new String[] { \"z\", \"x\", \"xc\", \"c\", \"$\" },\n        new int[] { 1, 1, 0, 1, 1 });\n\n    // check for lack of recursion\n    map.add(strings(\"zoo zoo\"), tokens(\"zoo\"), orig, merge);\n    // CHECKME: I think the previous test (with 4 zoo's), was just a typo.\n    assertTokenizesTo(map, \"zoo zoo $ zoo\",\n        new String[] { \"zoo\", \"zoo\", \"zoo\", \"$\", \"zoo\" },\n        new int[] { 1, 0, 1, 1, 1 });\n\n    map.add(strings(\"zoo\"), tokens(\"zoo zoo\"), orig, merge);\n    assertTokenizesTo(map, \"zoo zoo $ zoo\",\n        new String[] { \"zoo\", \"zoo\", \"zoo\", \"$\", \"zoo\", \"zoo\", \"zoo\" },\n        new int[] { 1, 0, 1, 1, 1, 0, 1 });\n  }\n\n","sourceOld":"  public void testIncludeOrig() throws IOException {\n    SynonymMap map = new SynonymMap();\n\n    boolean orig = true;\n    boolean merge = true;\n    map.add(strings(\"a b\"), tokens(\"ab\"), orig, merge);\n    map.add(strings(\"a c\"), tokens(\"ac\"), orig, merge);\n    map.add(strings(\"a\"), tokens(\"aa\"), orig, merge);\n    map.add(strings(\"b\"), tokens(\"bb\"), orig, merge);\n    map.add(strings(\"z x c v\"), tokens(\"zxcv\"), orig, merge);\n    map.add(strings(\"x c\"), tokens(\"xc\"), orig, merge);\n\n    assertTokenizesTo(map, \"$\", \n        new String[] { \"$\" },\n        new int[] { 1 });\n    assertTokenizesTo(map, \"a\", \n        new String[] { \"a\", \"aa\" },\n        new int[] { 1, 0 });\n    assertTokenizesTo(map, \"a\", \n        new String[] { \"a\", \"aa\" },\n        new int[] { 1, 0 });\n    assertTokenizesTo(map, \"$ a\", \n        new String[] { \"$\", \"a\", \"aa\" },\n        new int[] { 1, 1, 0 });\n    assertTokenizesTo(map, \"a $\", \n        new String[] { \"a\", \"aa\", \"$\" },\n        new int[] { 1, 0, 1 });\n    assertTokenizesTo(map, \"$ a !\", \n        new String[] { \"$\", \"a\", \"aa\", \"!\" },\n        new int[] { 1, 1, 0, 1 });\n    assertTokenizesTo(map, \"a a\", \n        new String[] { \"a\", \"aa\", \"a\", \"aa\" },\n        new int[] { 1, 0, 1, 0 });\n    assertTokenizesTo(map, \"b\", \n        new String[] { \"b\", \"bb\" },\n        new int[] { 1, 0 });\n    assertTokenizesTo(map, \"z x c v\",\n        new String[] { \"z\", \"zxcv\", \"x\", \"c\", \"v\" },\n        new int[] { 1, 0, 1, 1, 1 });\n    assertTokenizesTo(map, \"z x c $\",\n        new String[] { \"z\", \"x\", \"xc\", \"c\", \"$\" },\n        new int[] { 1, 1, 0, 1, 1 });\n\n    // check for lack of recursion\n    map.add(strings(\"zoo zoo\"), tokens(\"zoo\"), orig, merge);\n    // CHECKME: I think the previous test (with 4 zoo's), was just a typo.\n    assertTokenizesTo(map, \"zoo zoo $ zoo\",\n        new String[] { \"zoo\", \"zoo\", \"zoo\", \"$\", \"zoo\" },\n        new int[] { 1, 0, 1, 1, 1 });\n\n    map.add(strings(\"zoo\"), tokens(\"zoo zoo\"), orig, merge);\n    assertTokenizesTo(map, \"zoo zoo $ zoo\",\n        new String[] { \"zoo\", \"zoo\", \"zoo\", \"$\", \"zoo\", \"zoo\", \"zoo\" },\n        new int[] { 1, 0, 1, 1, 1, 0, 1 });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["2fd023a662cc25ae7e0ad0f33d71c476a16d0579"],"c1781d63ce2d5e979c8b3f35682b60a86f5df553":["0d3072fffb39e4aa50fce38815821919b35fc194"],"2fd023a662cc25ae7e0ad0f33d71c476a16d0579":["c1781d63ce2d5e979c8b3f35682b60a86f5df553"],"0d3072fffb39e4aa50fce38815821919b35fc194":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0d3072fffb39e4aa50fce38815821919b35fc194"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"c1781d63ce2d5e979c8b3f35682b60a86f5df553":["2fd023a662cc25ae7e0ad0f33d71c476a16d0579"],"2fd023a662cc25ae7e0ad0f33d71c476a16d0579":["ad94625fb8d088209f46650c8097196fec67f00c"],"0d3072fffb39e4aa50fce38815821919b35fc194":["c1781d63ce2d5e979c8b3f35682b60a86f5df553"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}