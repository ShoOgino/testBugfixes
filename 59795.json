{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","commits":[{"id":"0415a016b37e58a017fed0a91234f733ab359971","date":1341458183,"type":1,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs,SimpleSpatialFieldInfo).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (! SpatialOperation.is(op, SpatialOperation.IsWithin, SpatialOperation.Intersects, SpatialOperation.BBoxWithin, SpatialOperation.BBoxIntersects))\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getMaxLevelForPrecision(shape, args.getDistPrecision());\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    TermsFilter filter = new TermsFilter();\n    for (Node cell : cells) {\n      filter.addTerm(new Term(getFieldName(), cell.getTokenString()));\n    }\n    return filter;\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {\n    final SpatialOperation op = args.getOperation();\n    if (! SpatialOperation.is(op, SpatialOperation.IsWithin, SpatialOperation.Intersects, SpatialOperation.BBoxWithin, SpatialOperation.BBoxIntersects))\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getMaxLevelForPrecision(shape, args.getDistPrecision());\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    TermsFilter filter = new TermsFilter();\n    for (Node cell : cells) {\n      filter.addTerm(new Term(fieldInfo.getFieldName(), cell.getTokenString()));\n    }\n    return filter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (! SpatialOperation.is(op, SpatialOperation.IsWithin, SpatialOperation.Intersects, SpatialOperation.BBoxWithin, SpatialOperation.BBoxIntersects))\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getMaxLevelForPrecision(shape, args.getDistPrecision());\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    TermsFilter filter = new TermsFilter();\n    for (Node cell : cells) {\n      filter.addTerm(new Term(getFieldName(), cell.getTokenString()));\n    }\n    return filter;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e2410e27320f6aaba450cbf500d7822baf642f8","date":1347075066,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (! SpatialOperation.is(op, SpatialOperation.IsWithin, SpatialOperation.Intersects, SpatialOperation.BBoxWithin, SpatialOperation.BBoxIntersects))\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    TermsFilter filter = new TermsFilter();\n    for (Node cell : cells) {\n      filter.addTerm(new Term(getFieldName(), cell.getTokenString()));\n    }\n    return filter;\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (! SpatialOperation.is(op, SpatialOperation.IsWithin, SpatialOperation.Intersects, SpatialOperation.BBoxWithin, SpatialOperation.BBoxIntersects))\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getMaxLevelForPrecision(shape, args.getDistPrecision());\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    TermsFilter filter = new TermsFilter();\n    for (Node cell : cells) {\n      filter.addTerm(new Term(getFieldName(), cell.getTokenString()));\n    }\n    return filter;\n  }\n\n","bugFix":["561469a62683fb18474394874c6010a19fb0deb7"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46e67dde361bddc1a35dc332c2a1e553d7a8ebd7","date":1347426169,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    TermsFilter filter = new TermsFilter();\n    for (Node cell : cells) {\n      filter.addTerm(new Term(getFieldName(), cell.getTokenString()));\n    }\n    return filter;\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (! SpatialOperation.is(op, SpatialOperation.IsWithin, SpatialOperation.Intersects, SpatialOperation.BBoxWithin, SpatialOperation.BBoxIntersects))\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    TermsFilter filter = new TermsFilter();\n    for (Node cell : cells) {\n      filter.addTerm(new Term(getFieldName(), cell.getTokenString()));\n    }\n    return filter;\n  }\n\n","bugFix":["561469a62683fb18474394874c6010a19fb0deb7"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4107dd39b127d892359c5c1d67d0f14d92f1a9bf","date":1351689723,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Node cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    TermsFilter filter = new TermsFilter();\n    for (Node cell : cells) {\n      filter.addTerm(new Term(getFieldName(), cell.getTokenString()));\n    }\n    return filter;\n  }\n\n","bugFix":["561469a62683fb18474394874c6010a19fb0deb7","0415a016b37e58a017fed0a91234f733ab359971"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b43aca0f70aef9b914114574de1d0916ad2a32b","date":1360908147,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Node cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Node cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","bugFix":["561469a62683fb18474394874c6010a19fb0deb7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b41f996b22bd5518650f897d050088ff808ec03","date":1360969107,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Node cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel, false);\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Node cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8259c159da2de2e8528524fb76b244b46cbded59","date":1364478249,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Cell> cells = grid.getCells(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Cell cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Node> cells = grid.getNodes(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Node cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efc64259f3c8f43dfc6841ffad77df3b9446e3a5","date":1395149462,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Cell> cells = grid.getCells(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Cell cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());//TODO use cell.getTokenBytes()\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Cell> cells = grid.getCells(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Cell cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4de14be4bd1b857ba37ca138b61c4661c6d1bed3","date":1396628861,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Cell> cells = grid.getCells(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Cell cell : cells) {\n      terms[i++] = cell.getTokenBytesNoLeaf(null);\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Cell> cells = grid.getCells(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Cell cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());//TODO use cell.getTokenBytes()\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Cell> cells = grid.getCells(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Cell cell : cells) {\n      terms[i++] = cell.getTokenBytesNoLeaf(null);\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Cell> cells = grid.getCells(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Cell cell : cells) {\n      terms[i++] = new BytesRef(cell.getTokenString());//TODO use cell.getTokenBytes()\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6","date":1397789149,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRef masterBytes = new BytesRef(GUESS_NUM_TERMS*detailLevel);//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes;\n    }\n    //unfortunately TermsFilter will needlessly sort & dedupe\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n    List<Cell> cells = grid.getCells(shape, detailLevel,\n        false,//no parents\n        true);//simplify\n    BytesRef[] terms = new BytesRef[cells.size()];\n    int i = 0;\n    for (Cell cell : cells) {\n      terms[i++] = cell.getTokenBytesNoLeaf(null);\n    }\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRefBuilder masterBytes = new BytesRefBuilder();//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length() + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length() - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes();\n    }\n    //unfortunately TermsFilter will needlessly sort & dedupe\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRef masterBytes = new BytesRef(GUESS_NUM_TERMS*detailLevel);//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes;\n    }\n    //unfortunately TermsFilter will needlessly sort & dedupe\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","bugFix":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2042d3e27841c5b60112990fc33559e10ccf6dd","date":1424537395,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRefBuilder masterBytes = new BytesRefBuilder();//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length() + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length() - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes();\n    }\n    //unfortunately TermsFilter will needlessly sort & dedupe\n    return new QueryWrapperFilter(new TermsQuery(getFieldName(), terms));\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRefBuilder masterBytes = new BytesRefBuilder();//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length() + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length() - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes();\n    }\n    //unfortunately TermsFilter will needlessly sort & dedupe\n    return new TermsFilter(getFieldName(), terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0","date":1426015524,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRefBuilder masterBytes = new BytesRefBuilder();//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length() + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length() - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes();\n    }\n    //unfortunately TermsQuery will needlessly sort & dedupe\n    //TODO an automatonQuery might be faster?\n    return new QueryWrapperFilter(new TermsQuery(getFieldName(), terms));\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRefBuilder masterBytes = new BytesRefBuilder();//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length() + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length() - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes();\n    }\n    //unfortunately TermsFilter will needlessly sort & dedupe\n    return new QueryWrapperFilter(new TermsQuery(getFieldName(), terms));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRefBuilder masterBytes = new BytesRefBuilder();//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length() + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length() - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes();\n    }\n    //unfortunately TermsQuery will needlessly sort & dedupe\n    //TODO an automatonQuery might be faster?\n    return new QueryWrapperFilter(new TermsQuery(getFieldName(), terms));\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRefBuilder masterBytes = new BytesRefBuilder();//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length() + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length() - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes();\n    }\n    //unfortunately TermsFilter will needlessly sort & dedupe\n    return new QueryWrapperFilter(new TermsQuery(getFieldName(), terms));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"672b198fc3dce868916c727917cae58c2906763d","date":1443669960,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeQuery(SpatialArgs).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy#makeFilter(SpatialArgs).mjava","sourceNew":"  @Override\n  public Query makeQuery(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRefBuilder masterBytes = new BytesRefBuilder();//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length() + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length() - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes();\n    }\n    //unfortunately TermsQuery will needlessly sort & dedupe\n    //TODO an automatonQuery might be faster?\n    return new TermsQuery(getFieldName(), terms);\n  }\n\n","sourceOld":"  @Override\n  public Filter makeFilter(SpatialArgs args) {\n    final SpatialOperation op = args.getOperation();\n    if (op != SpatialOperation.Intersects)\n      throw new UnsupportedSpatialOperation(op);\n\n    Shape shape = args.getShape();\n    int detailLevel = grid.getLevelForDistance(args.resolveDistErr(ctx, distErrPct));\n\n    //--get a List of BytesRef for each term we want (no parents, no leaf bytes))\n    final int GUESS_NUM_TERMS;\n    if (shape instanceof Point)\n      GUESS_NUM_TERMS = detailLevel;//perfect guess\n    else\n      GUESS_NUM_TERMS = 4096;//should this be a method on SpatialPrefixTree?\n\n    BytesRefBuilder masterBytes = new BytesRefBuilder();//shared byte array for all terms\n    List<BytesRef> terms = new ArrayList<>(GUESS_NUM_TERMS);\n\n    CellIterator cells = grid.getTreeCellIterator(shape, detailLevel);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      BytesRef term = cell.getTokenBytesNoLeaf(null);//null because we want a new BytesRef\n      //We copy out the bytes because it may be re-used across the iteration. This also gives us the opportunity\n      // to use one contiguous block of memory for the bytes of all terms we need.\n      masterBytes.grow(masterBytes.length() + term.length);\n      masterBytes.append(term);\n      term.bytes = null;//don't need; will reset later\n      term.offset = masterBytes.length() - term.length;\n      terms.add(term);\n    }\n    //doing this now because if we did earlier, it's possible the bytes needed to grow()\n    for (BytesRef byteRef : terms) {\n      byteRef.bytes = masterBytes.bytes();\n    }\n    //unfortunately TermsQuery will needlessly sort & dedupe\n    //TODO an automatonQuery might be faster?\n    return new QueryWrapperFilter(new TermsQuery(getFieldName(), terms));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0415a016b37e58a017fed0a91234f733ab359971":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"efc64259f3c8f43dfc6841ffad77df3b9446e3a5":["8259c159da2de2e8528524fb76b244b46cbded59"],"6b43aca0f70aef9b914114574de1d0916ad2a32b":["4107dd39b127d892359c5c1d67d0f14d92f1a9bf"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"c2042d3e27841c5b60112990fc33559e10ccf6dd":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"8259c159da2de2e8528524fb76b244b46cbded59":["6b43aca0f70aef9b914114574de1d0916ad2a32b"],"4107dd39b127d892359c5c1d67d0f14d92f1a9bf":["46e67dde361bddc1a35dc332c2a1e553d7a8ebd7"],"6e2410e27320f6aaba450cbf500d7822baf642f8":["0415a016b37e58a017fed0a91234f733ab359971"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c2042d3e27841c5b60112990fc33559e10ccf6dd","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"672b198fc3dce868916c727917cae58c2906763d":["11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"46e67dde361bddc1a35dc332c2a1e553d7a8ebd7":["6e2410e27320f6aaba450cbf500d7822baf642f8"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["efc64259f3c8f43dfc6841ffad77df3b9446e3a5","4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"3b41f996b22bd5518650f897d050088ff808ec03":["4107dd39b127d892359c5c1d67d0f14d92f1a9bf","6b43aca0f70aef9b914114574de1d0916ad2a32b"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0415a016b37e58a017fed0a91234f733ab359971"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4de14be4bd1b857ba37ca138b61c4661c6d1bed3":["efc64259f3c8f43dfc6841ffad77df3b9446e3a5"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["c2042d3e27841c5b60112990fc33559e10ccf6dd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["672b198fc3dce868916c727917cae58c2906763d"]},"commit2Childs":{"0415a016b37e58a017fed0a91234f733ab359971":["6e2410e27320f6aaba450cbf500d7822baf642f8","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"efc64259f3c8f43dfc6841ffad77df3b9446e3a5":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"6b43aca0f70aef9b914114574de1d0916ad2a32b":["8259c159da2de2e8528524fb76b244b46cbded59","3b41f996b22bd5518650f897d050088ff808ec03"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["c2042d3e27841c5b60112990fc33559e10ccf6dd"],"c2042d3e27841c5b60112990fc33559e10ccf6dd":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"8259c159da2de2e8528524fb76b244b46cbded59":["efc64259f3c8f43dfc6841ffad77df3b9446e3a5"],"4107dd39b127d892359c5c1d67d0f14d92f1a9bf":["6b43aca0f70aef9b914114574de1d0916ad2a32b","3b41f996b22bd5518650f897d050088ff808ec03"],"6e2410e27320f6aaba450cbf500d7822baf642f8":["46e67dde361bddc1a35dc332c2a1e553d7a8ebd7"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"672b198fc3dce868916c727917cae58c2906763d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"46e67dde361bddc1a35dc332c2a1e553d7a8ebd7":["4107dd39b127d892359c5c1d67d0f14d92f1a9bf"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"3b41f996b22bd5518650f897d050088ff808ec03":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0415a016b37e58a017fed0a91234f733ab359971","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"4de14be4bd1b857ba37ca138b61c4661c6d1bed3":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","672b198fc3dce868916c727917cae58c2906763d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","15e323346eac5e4685c0a9f2df85eb96b4239bbb","3b41f996b22bd5518650f897d050088ff808ec03","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}