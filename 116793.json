{"path":"lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader#read(Directory,String).mjava","commits":[{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader#read(Directory,String).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public SegmentInfo read(Directory directory, String segmentName) throws IOException {\n    BytesRef scratch = new BytesRef();\n    String fileName = IndexFileNames.segmentFileName(segmentName, \"\", SimpleTextSegmentInfosFormat.SI_EXTENSION);\n    IndexInput input = directory.openInput(fileName, IOContext.READONCE);\n    boolean success = false;\n    try {\n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_VERSION);\n      final String version = readString(SI_VERSION.length, scratch);\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DOCCOUNT);\n      final int docCount = Integer.parseInt(readString(SI_DOCCOUNT.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DELCOUNT);\n      final int delCount = Integer.parseInt(readString(SI_DELCOUNT.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_USECOMPOUND);\n      final boolean isCompoundFile = Boolean.parseBoolean(readString(SI_USECOMPOUND.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DSOFFSET);\n      final int dsOffset = Integer.parseInt(readString(SI_DSOFFSET.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DSSEGMENT);\n      final String dsSegment = readString(SI_DSSEGMENT.length, scratch);\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DSCOMPOUND);\n      final boolean dsCompoundFile = Boolean.parseBoolean(readString(SI_DSCOMPOUND.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DELGEN);\n      final long delGen = Long.parseLong(readString(SI_DELGEN.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_NUM_NORMGEN);\n      final int numNormGen = Integer.parseInt(readString(SI_NUM_NORMGEN.length, scratch));\n      final Map<Integer,Long> normGen;\n      if (numNormGen == 0) {\n        normGen = null;\n      } else {\n        normGen = new HashMap<Integer,Long>();\n        for (int i = 0; i < numNormGen; i++) {\n          SimpleTextUtil.readLine(input, scratch);\n          assert StringHelper.startsWith(scratch, SI_NORMGEN_KEY);\n          int key = Integer.parseInt(readString(SI_NORMGEN_KEY.length, scratch));\n        \n          SimpleTextUtil.readLine(input, scratch);\n          assert StringHelper.startsWith(scratch, SI_NORMGEN_VALUE);\n          long value = Long.parseLong(readString(SI_NORMGEN_VALUE.length, scratch));\n          normGen.put(key, value);\n        }\n      }\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_NUM_DIAG);\n      int numDiag = Integer.parseInt(readString(SI_NUM_DIAG.length, scratch));\n      Map<String,String> diagnostics = new HashMap<String,String>();\n\n      for (int i = 0; i < numDiag; i++) {\n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_KEY);\n        String key = readString(SI_DIAG_KEY.length, scratch);\n      \n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_VALUE);\n        String value = readString(SI_DIAG_VALUE.length, scratch);\n        diagnostics.put(key, value);\n      }\n\n      success = true;\n      return new SegmentInfo(directory, version, segmentName, docCount, dsOffset,\n                             dsSegment, dsCompoundFile, normGen, isCompoundFile,\n                             delCount, null, diagnostics);\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(input);\n      } else {\n        input.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"352763be0465236f8e2ac188aa1b761cb3e1c9ee","date":1337516554,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader#read(Directory,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader#read(Directory,String).mjava","sourceNew":"  @Override\n  public SegmentInfo read(Directory directory, String segmentName) throws IOException {\n    BytesRef scratch = new BytesRef();\n    String fileName = IndexFileNames.segmentFileName(segmentName, \"\", SimpleTextSegmentInfosFormat.SI_EXTENSION);\n    IndexInput input = directory.openInput(fileName, IOContext.READONCE);\n    boolean success = false;\n    try {\n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_VERSION);\n      final String version = readString(SI_VERSION.length, scratch);\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DOCCOUNT);\n      final int docCount = Integer.parseInt(readString(SI_DOCCOUNT.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_USECOMPOUND);\n      final boolean isCompoundFile = Boolean.parseBoolean(readString(SI_USECOMPOUND.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_NUM_DIAG);\n      int numDiag = Integer.parseInt(readString(SI_NUM_DIAG.length, scratch));\n      Map<String,String> diagnostics = new HashMap<String,String>();\n\n      for (int i = 0; i < numDiag; i++) {\n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_KEY);\n        String key = readString(SI_DIAG_KEY.length, scratch);\n      \n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_VALUE);\n        String value = readString(SI_DIAG_VALUE.length, scratch);\n        diagnostics.put(key, value);\n      }\n\n      success = true;\n      return new SegmentInfo(directory, version, segmentName, docCount, -1,\n                             segmentName, false, null, isCompoundFile,\n                             0, null, diagnostics);\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(input);\n      } else {\n        input.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public SegmentInfo read(Directory directory, String segmentName) throws IOException {\n    BytesRef scratch = new BytesRef();\n    String fileName = IndexFileNames.segmentFileName(segmentName, \"\", SimpleTextSegmentInfosFormat.SI_EXTENSION);\n    IndexInput input = directory.openInput(fileName, IOContext.READONCE);\n    boolean success = false;\n    try {\n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_VERSION);\n      final String version = readString(SI_VERSION.length, scratch);\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DOCCOUNT);\n      final int docCount = Integer.parseInt(readString(SI_DOCCOUNT.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DELCOUNT);\n      final int delCount = Integer.parseInt(readString(SI_DELCOUNT.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_USECOMPOUND);\n      final boolean isCompoundFile = Boolean.parseBoolean(readString(SI_USECOMPOUND.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DSOFFSET);\n      final int dsOffset = Integer.parseInt(readString(SI_DSOFFSET.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DSSEGMENT);\n      final String dsSegment = readString(SI_DSSEGMENT.length, scratch);\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DSCOMPOUND);\n      final boolean dsCompoundFile = Boolean.parseBoolean(readString(SI_DSCOMPOUND.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DELGEN);\n      final long delGen = Long.parseLong(readString(SI_DELGEN.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_NUM_NORMGEN);\n      final int numNormGen = Integer.parseInt(readString(SI_NUM_NORMGEN.length, scratch));\n      final Map<Integer,Long> normGen;\n      if (numNormGen == 0) {\n        normGen = null;\n      } else {\n        normGen = new HashMap<Integer,Long>();\n        for (int i = 0; i < numNormGen; i++) {\n          SimpleTextUtil.readLine(input, scratch);\n          assert StringHelper.startsWith(scratch, SI_NORMGEN_KEY);\n          int key = Integer.parseInt(readString(SI_NORMGEN_KEY.length, scratch));\n        \n          SimpleTextUtil.readLine(input, scratch);\n          assert StringHelper.startsWith(scratch, SI_NORMGEN_VALUE);\n          long value = Long.parseLong(readString(SI_NORMGEN_VALUE.length, scratch));\n          normGen.put(key, value);\n        }\n      }\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_NUM_DIAG);\n      int numDiag = Integer.parseInt(readString(SI_NUM_DIAG.length, scratch));\n      Map<String,String> diagnostics = new HashMap<String,String>();\n\n      for (int i = 0; i < numDiag; i++) {\n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_KEY);\n        String key = readString(SI_DIAG_KEY.length, scratch);\n      \n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_VALUE);\n        String value = readString(SI_DIAG_VALUE.length, scratch);\n        diagnostics.put(key, value);\n      }\n\n      success = true;\n      return new SegmentInfo(directory, version, segmentName, docCount, dsOffset,\n                             dsSegment, dsCompoundFile, normGen, isCompoundFile,\n                             delCount, null, diagnostics);\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(input);\n      } else {\n        input.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b2af6b2c05418fb9df466c739ed5b3a153eadde","date":1337520269,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader#read(Directory,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader#read(Directory,String).mjava","sourceNew":"  @Override\n  public SegmentInfo read(Directory directory, String segmentName, IOContext context) throws IOException {\n    BytesRef scratch = new BytesRef();\n    String fileName = IndexFileNames.segmentFileName(segmentName, \"\", SimpleTextSegmentInfosFormat.SI_EXTENSION);\n    IndexInput input = directory.openInput(fileName, context);\n    boolean success = false;\n    try {\n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_VERSION);\n      final String version = readString(SI_VERSION.length, scratch);\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DOCCOUNT);\n      final int docCount = Integer.parseInt(readString(SI_DOCCOUNT.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_USECOMPOUND);\n      final boolean isCompoundFile = Boolean.parseBoolean(readString(SI_USECOMPOUND.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_NUM_DIAG);\n      int numDiag = Integer.parseInt(readString(SI_NUM_DIAG.length, scratch));\n      Map<String,String> diagnostics = new HashMap<String,String>();\n\n      for (int i = 0; i < numDiag; i++) {\n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_KEY);\n        String key = readString(SI_DIAG_KEY.length, scratch);\n      \n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_VALUE);\n        String value = readString(SI_DIAG_VALUE.length, scratch);\n        diagnostics.put(key, value);\n      }\n\n      success = true;\n      return new SegmentInfo(directory, version, segmentName, docCount, -1,\n                             segmentName, false, null, isCompoundFile,\n                             0, null, diagnostics);\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(input);\n      } else {\n        input.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public SegmentInfo read(Directory directory, String segmentName) throws IOException {\n    BytesRef scratch = new BytesRef();\n    String fileName = IndexFileNames.segmentFileName(segmentName, \"\", SimpleTextSegmentInfosFormat.SI_EXTENSION);\n    IndexInput input = directory.openInput(fileName, IOContext.READONCE);\n    boolean success = false;\n    try {\n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_VERSION);\n      final String version = readString(SI_VERSION.length, scratch);\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_DOCCOUNT);\n      final int docCount = Integer.parseInt(readString(SI_DOCCOUNT.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_USECOMPOUND);\n      final boolean isCompoundFile = Boolean.parseBoolean(readString(SI_USECOMPOUND.length, scratch));\n    \n      SimpleTextUtil.readLine(input, scratch);\n      assert StringHelper.startsWith(scratch, SI_NUM_DIAG);\n      int numDiag = Integer.parseInt(readString(SI_NUM_DIAG.length, scratch));\n      Map<String,String> diagnostics = new HashMap<String,String>();\n\n      for (int i = 0; i < numDiag; i++) {\n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_KEY);\n        String key = readString(SI_DIAG_KEY.length, scratch);\n      \n        SimpleTextUtil.readLine(input, scratch);\n        assert StringHelper.startsWith(scratch, SI_DIAG_VALUE);\n        String value = readString(SI_DIAG_VALUE.length, scratch);\n        diagnostics.put(key, value);\n      }\n\n      success = true;\n      return new SegmentInfo(directory, version, segmentName, docCount, -1,\n                             segmentName, false, null, isCompoundFile,\n                             0, null, diagnostics);\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(input);\n      } else {\n        input.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4356000e349e38c9fb48034695b7c309abd54557":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"352763be0465236f8e2ac188aa1b761cb3e1c9ee":["4356000e349e38c9fb48034695b7c309abd54557"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9b2af6b2c05418fb9df466c739ed5b3a153eadde":["352763be0465236f8e2ac188aa1b761cb3e1c9ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"4356000e349e38c9fb48034695b7c309abd54557":["352763be0465236f8e2ac188aa1b761cb3e1c9ee"],"352763be0465236f8e2ac188aa1b761cb3e1c9ee":["9b2af6b2c05418fb9df466c739ed5b3a153eadde"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4356000e349e38c9fb48034695b7c309abd54557","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9b2af6b2c05418fb9df466c739ed5b3a153eadde":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9b2af6b2c05418fb9df466c739ed5b3a153eadde","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}