{"path":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","commits":[{"id":"ad28156288ac00b91352582904d97e6653205757","date":1486850922,"type":1,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String).mjava","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, () -> FileSystem.get(dataDirPath.toUri(), conf));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n    \n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      LOG.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    LOG.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, () -> FileSystem.get(dataDirPath.toUri(), conf));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Set<String> livePaths = getLivePaths();\n    for (FileStatus oldDir : oldIndexDirs) {\n      Path oldDirPath = oldDir.getPath();\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c","date":1512481565,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, () -> FileSystem.get(dataDirPath.toUri(), conf));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (FileNotFoundException fnfe) {\n      // already deleted - ignore\n      LOG.debug(\"Old index directory already deleted - skipping...\", fnfe);\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      LOG.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    LOG.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, () -> FileSystem.get(dataDirPath.toUri(), conf));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n    \n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      LOG.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    LOG.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":["ad28156288ac00b91352582904d97e6653205757"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60788e79302b77255f71a4bcfc58a2424a205d9c","date":1517245253,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    FileSystem fileSystem = getCachedFileSystem(dataDir);\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (FileNotFoundException fnfe) {\n      // already deleted - ignore\n      LOG.debug(\"Old index directory already deleted - skipping...\", fnfe);\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      LOG.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    LOG.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    final Configuration conf = getConf();\n    FileSystem fileSystem = null;\n    try {\n      fileSystem = tmpFsCache.get(dataDir, () -> FileSystem.get(dataDirPath.toUri(), conf));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e);\n    }\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (FileNotFoundException fnfe) {\n      // already deleted - ignore\n      LOG.debug(\"Old index directory already deleted - skipping...\", fnfe);\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      LOG.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    LOG.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":["e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0","043df2e9a841864922c32756a44c939ed768cb89"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    FileSystem fileSystem = getCachedFileSystem(dataDir);\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      log.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      log.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            log.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (FileNotFoundException fnfe) {\n      // already deleted - ignore\n      log.debug(\"Old index directory already deleted - skipping...\", fnfe);\n    } catch (IOException ioExc) {\n      log.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      log.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    log.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        log.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            log.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            log.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          log.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    FileSystem fileSystem = getCachedFileSystem(dataDir);\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      LOG.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      LOG.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            LOG.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (FileNotFoundException fnfe) {\n      // already deleted - ignore\n      LOG.debug(\"Old index directory already deleted - skipping...\", fnfe);\n    } catch (IOException ioExc) {\n      LOG.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      LOG.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    LOG.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        LOG.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            LOG.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            LOG.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          LOG.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"add53de9835b2cd1a7a80b4e0036afee171c9fdf","date":1552937136,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    FileSystem fileSystem = getCachedFileSystem(dataDir);\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      log.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      log.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.getFileStatus(path).isDirectory() && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            log.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (FileNotFoundException fnfe) {\n      // already deleted - ignore\n      log.debug(\"Old index directory already deleted - skipping...\", fnfe);\n    } catch (IOException ioExc) {\n      log.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      log.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    log.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        log.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            log.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            log.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          log.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    FileSystem fileSystem = getCachedFileSystem(dataDir);\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      log.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      log.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.isDirectory(path) && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            log.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (FileNotFoundException fnfe) {\n      // already deleted - ignore\n      log.debug(\"Old index directory already deleted - skipping...\", fnfe);\n    } catch (IOException ioExc) {\n      log.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      log.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    log.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        log.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            log.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            log.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          log.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":["e0bbfc7e96e0cf26b51dcefe3b2e4c93fe34e8c0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/HdfsDirectoryFactory#cleanupOldIndexDirectories(String,String,boolean).mjava","sourceNew":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    FileSystem fileSystem = getCachedFileSystem(dataDir);\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      log.error(\"Error checking if hdfs path exists {}\", dataDir, e);\n    }\n    if (!pathExists) {\n      log.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.getFileStatus(path).isDirectory() && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            log.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (FileNotFoundException fnfe) {\n      // already deleted - ignore\n      log.debug(\"Old index directory already deleted - skipping...\", fnfe);\n    } catch (IOException ioExc) {\n      log.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      log.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    log.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        log.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            log.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            log.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          log.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cleanupOldIndexDirectories(final String dataDir, final String currentIndexDir, boolean afterReload) {\n\n    // Get the FileSystem object\n    final Path dataDirPath = new Path(dataDir);\n    FileSystem fileSystem = getCachedFileSystem(dataDir);\n\n    boolean pathExists = false;\n    try {\n      pathExists = fileSystem.exists(dataDirPath);\n    } catch (IOException e) {\n      log.error(\"Error checking if hdfs path \"+dataDir+\" exists\", e);\n    }\n    if (!pathExists) {\n      log.warn(\"{} does not point to a valid data directory; skipping clean-up of old index directories.\", dataDir);\n      return;\n    }\n\n    final Path currentIndexDirPath = new Path(currentIndexDir); // make sure we don't delete the current\n    final FileSystem fs = fileSystem;\n    FileStatus[] oldIndexDirs = null;\n    try {\n      oldIndexDirs = fileSystem.listStatus(dataDirPath, new PathFilter() {\n        @Override\n        public boolean accept(Path path) {\n          boolean accept = false;\n          String pathName = path.getName();\n          try {\n            accept = fs.getFileStatus(path).isDirectory() && !path.equals(currentIndexDirPath) &&\n                (pathName.equals(\"index\") || pathName.matches(INDEX_W_TIMESTAMP_REGEX));\n          } catch (IOException e) {\n            log.error(\"Error checking if path {} is an old index directory, caused by: {}\", path, e);\n          }\n          return accept;\n        }\n      });\n    } catch (FileNotFoundException fnfe) {\n      // already deleted - ignore\n      log.debug(\"Old index directory already deleted - skipping...\", fnfe);\n    } catch (IOException ioExc) {\n      log.error(\"Error checking for old index directories to clean-up.\", ioExc);\n    }\n\n    if (oldIndexDirs == null || oldIndexDirs.length == 0)\n      return; // nothing to clean-up\n\n    List<Path> oldIndexPaths = new ArrayList<>(oldIndexDirs.length);\n    for (FileStatus ofs : oldIndexDirs) {\n      oldIndexPaths.add(ofs.getPath());\n    }\n\n    Collections.sort(oldIndexPaths, Collections.reverseOrder());\n    \n    Set<String> livePaths = getLivePaths();\n    \n    int i = 0;\n    if (afterReload) {\n      log.info(\"Will not remove most recent old directory on reload {}\", oldIndexDirs[0]);\n      i = 1;\n    }\n    log.info(\"Found {} old index directories to clean-up under {} afterReload={}\", oldIndexDirs.length - i, dataDirPath, afterReload);\n    for (; i < oldIndexPaths.size(); i++) {\n      Path oldDirPath = oldIndexPaths.get(i);\n      if (livePaths.contains(oldDirPath.toString())) {\n        log.warn(\"Cannot delete directory {} because it is still being referenced in the cache.\", oldDirPath);\n      } else {\n        try {\n          if (fileSystem.delete(oldDirPath, true)) {\n            log.info(\"Deleted old index directory {}\", oldDirPath);\n          } else {\n            log.warn(\"Failed to delete old index directory {}\", oldDirPath);\n          }\n        } catch (IOException e) {\n          log.error(\"Failed to delete old index directory {} due to: {}\", oldDirPath, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ad28156288ac00b91352582904d97e6653205757":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"60788e79302b77255f71a4bcfc58a2424a205d9c":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"140be51d03394488536f4aacedace29f9b318347":["add53de9835b2cd1a7a80b4e0036afee171c9fdf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["ad28156288ac00b91352582904d97e6653205757"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["140be51d03394488536f4aacedace29f9b318347"],"add53de9835b2cd1a7a80b4e0036afee171c9fdf":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["60788e79302b77255f71a4bcfc58a2424a205d9c"]},"commit2Childs":{"ad28156288ac00b91352582904d97e6653205757":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"60788e79302b77255f71a4bcfc58a2424a205d9c":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ad28156288ac00b91352582904d97e6653205757"],"140be51d03394488536f4aacedace29f9b318347":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["60788e79302b77255f71a4bcfc58a2424a205d9c"],"add53de9835b2cd1a7a80b4e0036afee171c9fdf":["140be51d03394488536f4aacedace29f9b318347"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["add53de9835b2cd1a7a80b4e0036afee171c9fdf"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}