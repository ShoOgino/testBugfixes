{"path":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","sourceNew":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    numberOfSkipLevels = log(docCount, skipInterval[0]);\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = (IndexInput) skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","sourceOld":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    numberOfSkipLevels = log(docCount, skipInterval[0]);\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = (IndexInput) skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f72b850f14bb4291a8c2728f0073d07da0462d8","date":1333634910,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","sourceNew":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    numberOfSkipLevels = MathUtil.log(docCount, skipInterval[0]);\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = (IndexInput) skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","sourceOld":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    numberOfSkipLevels = log(docCount, skipInterval[0]);\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = (IndexInput) skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e06babaa3e8b78433266149d50d1500ba941652c","date":1344293820,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","sourceNew":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = (IndexInput) skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","sourceOld":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    numberOfSkipLevels = MathUtil.log(docCount, skipInterval[0]);\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = (IndexInput) skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7460755aa94143153400f49c8ac2746f5d092e1a","date":1345536974,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","sourceNew":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    numberOfSkipLevels = MathUtil.log(docCount, skipInterval[0]);\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","sourceOld":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    numberOfSkipLevels = MathUtil.log(docCount, skipInterval[0]);\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = (IndexInput) skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8615860cb50aefb8eebca1d1b3893dbe21cf126","date":1345550448,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","sourceNew":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","sourceOld":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    numberOfSkipLevels = MathUtil.log(docCount, skipInterval[0]);\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"001b25b42373b22a52f399dbf072f1224632e8e6","date":1345889167,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","sourceNew":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","sourceOld":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    numberOfSkipLevels = MathUtil.log(docCount, skipInterval[0]);\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = (IndexInput) skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa","date":1402696520,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","sourceNew":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize(Math.max(BufferedIndexInput.MIN_BUFFER_SIZE, (int) length));\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","sourceOld":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","sourceNew":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize(Math.max(BufferedIndexInput.MIN_BUFFER_SIZE, (int) length));\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","sourceOld":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize((int) length);\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c924ed848363114bc21dd13c3a1953c42aefb554","date":1586956211,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/MultiLevelSkipListReader#loadSkipLevels().mjava","sourceNew":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","sourceOld":"  /** Loads the skip levels  */\n  private void loadSkipLevels() throws IOException {\n    if (docCount <= skipInterval[0]) {\n      numberOfSkipLevels = 1;\n    } else {\n      numberOfSkipLevels = 1+MathUtil.log(docCount/skipInterval[0], skipMultiplier);\n    }\n\n    if (numberOfSkipLevels > maxNumberOfSkipLevels) {\n      numberOfSkipLevels = maxNumberOfSkipLevels;\n    }\n\n    skipStream[0].seek(skipPointer[0]);\n    \n    int toBuffer = numberOfLevelsToBuffer;\n    \n    for (int i = numberOfSkipLevels - 1; i > 0; i--) {\n      // the length of the current level\n      long length = skipStream[0].readVLong();\n      \n      // the start pointer of the current level\n      skipPointer[i] = skipStream[0].getFilePointer();\n      if (toBuffer > 0) {\n        // buffer this level\n        skipStream[i] = new SkipBuffer(skipStream[0], (int) length);\n        toBuffer--;\n      } else {\n        // clone this stream, it is already at the start of the current level\n        skipStream[i] = skipStream[0].clone();\n        if (inputIsBuffered && length < BufferedIndexInput.BUFFER_SIZE) {\n          ((BufferedIndexInput) skipStream[i]).setBufferSize(Math.max(BufferedIndexInput.MIN_BUFFER_SIZE, (int) length));\n        }\n        \n        // move base stream beyond the current level\n        skipStream[0].seek(skipStream[0].getFilePointer() + length);\n      }\n    }\n   \n    // use base stream for the lowest level\n    skipPointer[0] = skipStream[0].getFilePointer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"001b25b42373b22a52f399dbf072f1224632e8e6":["2f72b850f14bb4291a8c2728f0073d07da0462d8","f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"c924ed848363114bc21dd13c3a1953c42aefb554":["c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2f72b850f14bb4291a8c2728f0073d07da0462d8":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f8615860cb50aefb8eebca1d1b3893dbe21cf126":["7460755aa94143153400f49c8ac2746f5d092e1a","e06babaa3e8b78433266149d50d1500ba941652c"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["f8615860cb50aefb8eebca1d1b3893dbe21cf126","c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa"],"e06babaa3e8b78433266149d50d1500ba941652c":["2f72b850f14bb4291a8c2728f0073d07da0462d8"],"c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa":["f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"7460755aa94143153400f49c8ac2746f5d092e1a":["2f72b850f14bb4291a8c2728f0073d07da0462d8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c924ed848363114bc21dd13c3a1953c42aefb554"]},"commit2Childs":{"001b25b42373b22a52f399dbf072f1224632e8e6":[],"c924ed848363114bc21dd13c3a1953c42aefb554":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["2f72b850f14bb4291a8c2728f0073d07da0462d8"],"2f72b850f14bb4291a8c2728f0073d07da0462d8":["001b25b42373b22a52f399dbf072f1224632e8e6","e06babaa3e8b78433266149d50d1500ba941652c","7460755aa94143153400f49c8ac2746f5d092e1a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"f8615860cb50aefb8eebca1d1b3893dbe21cf126":["001b25b42373b22a52f399dbf072f1224632e8e6","c6f080a2ab37c464dd98db173f6cbf10dc74f211","c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"e06babaa3e8b78433266149d50d1500ba941652c":["f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"c4a5111fd6f337fd12b1ad3b2403fd485a8bd3fa":["c924ed848363114bc21dd13c3a1953c42aefb554","c6f080a2ab37c464dd98db173f6cbf10dc74f211"],"7460755aa94143153400f49c8ac2746f5d092e1a":["f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["001b25b42373b22a52f399dbf072f1224632e8e6","c6f080a2ab37c464dd98db173f6cbf10dc74f211","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}