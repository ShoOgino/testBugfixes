{"path":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,AnalyticsRequest).mjava","commits":[{"id":"ff403346522eaa9de75403763e297e83a3ea585c","date":1384904731,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,AnalyticsRequest).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param request The AnalyticsRequest to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, AnalyticsRequest request) {\n    final Map<String, Set<String>> collectorStats =  new HashMap<String, Set<String>>();\n    final Map<String, Set<Integer>> collectorPercs =  new HashMap<String, Set<Integer>>();\n    final Map<String, ValueSource> collectorSources =  new HashMap<String, ValueSource>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : request.getExpressions()) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<Integer>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<String>();\n          collectorStats.put(source, stats);\n        }\n        stats.add(stat);\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : request.getExpressions()) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,AnalyticsRequest).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param request The AnalyticsRequest to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, AnalyticsRequest request) {\n    final Map<String, Set<String>> collectorStats =  new HashMap<String, Set<String>>();\n    final Map<String, Set<Integer>> collectorPercs =  new HashMap<String, Set<Integer>>();\n    final Map<String, ValueSource> collectorSources =  new HashMap<String, ValueSource>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : request.getExpressions()) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<Integer>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<String>();\n          collectorStats.put(source, stats);\n        }\n        stats.add(stat);\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : request.getExpressions()) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,AnalyticsRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,AnalyticsRequest).mjava","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param request The AnalyticsRequest to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, AnalyticsRequest request) {\n    final Map<String, Set<String>> collectorStats =  new HashMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new HashMap<>();\n    final Map<String, ValueSource> collectorSources =  new HashMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : request.getExpressions()) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        stats.add(stat);\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : request.getExpressions()) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param request The AnalyticsRequest to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, AnalyticsRequest request) {\n    final Map<String, Set<String>> collectorStats =  new HashMap<String, Set<String>>();\n    final Map<String, Set<Integer>> collectorPercs =  new HashMap<String, Set<Integer>>();\n    final Map<String, ValueSource> collectorSources =  new HashMap<String, ValueSource>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : request.getExpressions()) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<Integer>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<String>();\n          collectorStats.put(source, stats);\n        }\n        stats.add(stat);\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : request.getExpressions()) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"645e9dc687d04dbe961b35c0f3a305c48e892615","date":1396352607,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,AnalyticsRequest).mjava","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param request The AnalyticsRequest to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, AnalyticsRequest request) {\n    final Map<String, Set<String>> collectorStats =  new HashMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new HashMap<>();\n    final Map<String, ValueSource> collectorSources =  new HashMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : request.getExpressions()) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        stats.add(stat);\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : request.getExpressions()) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,AnalyticsRequest).mjava","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param request The AnalyticsRequest to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, AnalyticsRequest request) {\n    final Map<String, Set<String>> collectorStats =  new HashMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new HashMap<>();\n    final Map<String, ValueSource> collectorSources =  new HashMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : request.getExpressions()) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        stats.add(stat);\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : request.getExpressions()) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","645e9dc687d04dbe961b35c0f3a305c48e892615"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ff403346522eaa9de75403763e297e83a3ea585c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ff403346522eaa9de75403763e297e83a3ea585c"],"645e9dc687d04dbe961b35c0f3a305c48e892615":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"ff403346522eaa9de75403763e297e83a3ea585c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["645e9dc687d04dbe961b35c0f3a305c48e892615"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5eb2511ababf862ea11e10761c70ee560cd84510","645e9dc687d04dbe961b35c0f3a305c48e892615"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","ff403346522eaa9de75403763e297e83a3ea585c"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"645e9dc687d04dbe961b35c0f3a305c48e892615":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ff403346522eaa9de75403763e297e83a3ea585c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}