{"path":"solr/core/src/java/org/apache/solr/util/hll/BigEndianAscendingWordDeserializer#readWord(int).mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/BigEndianAscendingWordDeserializer#readWord(int).mjava","pathOld":"/dev/null","sourceNew":"    // ------------------------------------------------------------------------\n    /**\n     * Reads the word at the specified sequence position (zero-indexed).\n     *\n     * @param  position the zero-indexed position of the word to be read. This\n     *         must be greater than or equal to zero.\n     * @return the value of the serialized word at the specified position.\n     */\n    private long readWord(final int position) {\n        if(position < 0) {\n            throw new ArrayIndexOutOfBoundsException(position);\n        }\n\n        // First bit of the word\n        final long firstBitIndex = (position * wordLength);\n        final int firstByteIndex = (bytePadding + (int)(firstBitIndex / BITS_PER_BYTE));\n        final int firstByteSkipBits = (int)(firstBitIndex % BITS_PER_BYTE);\n\n        // Last bit of the word\n        final long lastBitIndex = (firstBitIndex + wordLength - 1);\n        final int lastByteIndex = (bytePadding + (int)(lastBitIndex / BITS_PER_BYTE));\n        final int lastByteBitsToConsume;\n\n        final int bitsAfterByteBoundary = (int)((lastBitIndex + 1) % BITS_PER_BYTE);\n        // If the word terminates at the end of the last byte, consume the whole\n        // last byte.\n        if(bitsAfterByteBoundary == 0) {\n            lastByteBitsToConsume = BITS_PER_BYTE;\n        } else {\n            // Otherwise, only consume what is necessary.\n            lastByteBitsToConsume = bitsAfterByteBoundary;\n        }\n\n        if(lastByteIndex >= bytes.length) {\n            throw new ArrayIndexOutOfBoundsException(\"Word out of bounds of backing array.\");\n        }\n\n        // Accumulator\n        long value = 0;\n\n        // --------------------------------------------------------------------\n        // First byte\n        final int bitsRemainingInFirstByte = (BITS_PER_BYTE - firstByteSkipBits);\n        final int bitsToConsumeInFirstByte = Math.min(bitsRemainingInFirstByte, wordLength);\n        long firstByte = (long)bytes[firstByteIndex];\n\n        // Mask off the bits to skip in the first byte.\n        final long firstByteMask = ((1L << bitsRemainingInFirstByte) - 1L);\n        firstByte &= firstByteMask;\n        // Right-align relevant bits of first byte.\n        firstByte >>>= (bitsRemainingInFirstByte - bitsToConsumeInFirstByte);\n\n        value |= firstByte;\n\n        // If the first byte contains the whole word, short-circuit.\n        if(firstByteIndex == lastByteIndex) {\n            return value;\n        }\n\n        // --------------------------------------------------------------------\n        // Middle bytes\n        final int middleByteCount = (lastByteIndex - firstByteIndex - 1);\n        for(int i=0; i<middleByteCount; i++) {\n            final long middleByte = (bytes[firstByteIndex + i + 1] & BYTE_MASK);\n            // Push middle byte onto accumulator.\n            value <<= BITS_PER_BYTE;\n            value |= middleByte;\n        }\n\n        // --------------------------------------------------------------------\n        // Last byte\n        long lastByte = (bytes[lastByteIndex] & BYTE_MASK);\n        lastByte >>= (BITS_PER_BYTE - lastByteBitsToConsume);\n        value <<= lastByteBitsToConsume;\n        value |= lastByte;\n        return value;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a81b342a33a0e68d2bb194ebcc3dfadcc69868b2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/BigEndianAscendingWordDeserializer#readWord(int).mjava","pathOld":"/dev/null","sourceNew":"    // ------------------------------------------------------------------------\n    /**\n     * Reads the word at the specified sequence position (zero-indexed).\n     *\n     * @param  position the zero-indexed position of the word to be read. This\n     *         must be greater than or equal to zero.\n     * @return the value of the serialized word at the specified position.\n     */\n    private long readWord(final int position) {\n        if(position < 0) {\n            throw new ArrayIndexOutOfBoundsException(position);\n        }\n\n        // First bit of the word\n        final long firstBitIndex = (position * wordLength);\n        final int firstByteIndex = (bytePadding + (int)(firstBitIndex / BITS_PER_BYTE));\n        final int firstByteSkipBits = (int)(firstBitIndex % BITS_PER_BYTE);\n\n        // Last bit of the word\n        final long lastBitIndex = (firstBitIndex + wordLength - 1);\n        final int lastByteIndex = (bytePadding + (int)(lastBitIndex / BITS_PER_BYTE));\n        final int lastByteBitsToConsume;\n\n        final int bitsAfterByteBoundary = (int)((lastBitIndex + 1) % BITS_PER_BYTE);\n        // If the word terminates at the end of the last byte, consume the whole\n        // last byte.\n        if(bitsAfterByteBoundary == 0) {\n            lastByteBitsToConsume = BITS_PER_BYTE;\n        } else {\n            // Otherwise, only consume what is necessary.\n            lastByteBitsToConsume = bitsAfterByteBoundary;\n        }\n\n        if(lastByteIndex >= bytes.length) {\n            throw new ArrayIndexOutOfBoundsException(\"Word out of bounds of backing array.\");\n        }\n\n        // Accumulator\n        long value = 0;\n\n        // --------------------------------------------------------------------\n        // First byte\n        final int bitsRemainingInFirstByte = (BITS_PER_BYTE - firstByteSkipBits);\n        final int bitsToConsumeInFirstByte = Math.min(bitsRemainingInFirstByte, wordLength);\n        long firstByte = (long)bytes[firstByteIndex];\n\n        // Mask off the bits to skip in the first byte.\n        final long firstByteMask = ((1L << bitsRemainingInFirstByte) - 1L);\n        firstByte &= firstByteMask;\n        // Right-align relevant bits of first byte.\n        firstByte >>>= (bitsRemainingInFirstByte - bitsToConsumeInFirstByte);\n\n        value |= firstByte;\n\n        // If the first byte contains the whole word, short-circuit.\n        if(firstByteIndex == lastByteIndex) {\n            return value;\n        }\n\n        // --------------------------------------------------------------------\n        // Middle bytes\n        final int middleByteCount = (lastByteIndex - firstByteIndex - 1);\n        for(int i=0; i<middleByteCount; i++) {\n            final long middleByte = (bytes[firstByteIndex + i + 1] & BYTE_MASK);\n            // Push middle byte onto accumulator.\n            value <<= BITS_PER_BYTE;\n            value |= middleByte;\n        }\n\n        // --------------------------------------------------------------------\n        // Last byte\n        long lastByte = (bytes[lastByteIndex] & BYTE_MASK);\n        lastByte >>= (BITS_PER_BYTE - lastByteBitsToConsume);\n        value <<= lastByteBitsToConsume;\n        value |= lastByte;\n        return value;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a81b342a33a0e68d2bb194ebcc3dfadcc69868b2","date":1440606819,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/BigEndianAscendingWordDeserializer#readWord(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/hll/BigEndianAscendingWordDeserializer#readWord(int).mjava","sourceNew":"    // ------------------------------------------------------------------------\n    /**\n     * Reads the word at the specified sequence position (zero-indexed).\n     *\n     * @param  position the zero-indexed position of the word to be read. This\n     *         must be greater than or equal to zero.\n     * @return the value of the serialized word at the specified position.\n     */\n    private long readWord(final int position) {\n        if(position < 0) {\n            throw new ArrayIndexOutOfBoundsException(position);\n        }\n\n        // First bit of the word\n        final long firstBitIndex = ((long)position) * ((long)wordLength);\n        final int firstByteIndex = (bytePadding + (int)(firstBitIndex / BITS_PER_BYTE));\n        final int firstByteSkipBits = (int)(firstBitIndex % BITS_PER_BYTE);\n\n        // Last bit of the word\n        final long lastBitIndex = (firstBitIndex + wordLength - 1);\n        final int lastByteIndex = (bytePadding + (int)(lastBitIndex / BITS_PER_BYTE));\n        final int lastByteBitsToConsume;\n\n        final int bitsAfterByteBoundary = (int)((lastBitIndex + 1) % BITS_PER_BYTE);\n        // If the word terminates at the end of the last byte, consume the whole\n        // last byte.\n        if(bitsAfterByteBoundary == 0) {\n            lastByteBitsToConsume = BITS_PER_BYTE;\n        } else {\n            // Otherwise, only consume what is necessary.\n            lastByteBitsToConsume = bitsAfterByteBoundary;\n        }\n\n        if(lastByteIndex >= bytes.length) {\n            throw new ArrayIndexOutOfBoundsException(\"Word out of bounds of backing array.\");\n        }\n\n        // Accumulator\n        long value = 0;\n\n        // --------------------------------------------------------------------\n        // First byte\n        final int bitsRemainingInFirstByte = (BITS_PER_BYTE - firstByteSkipBits);\n        final int bitsToConsumeInFirstByte = Math.min(bitsRemainingInFirstByte, wordLength);\n        long firstByte = (long)bytes[firstByteIndex];\n\n        // Mask off the bits to skip in the first byte.\n        final long firstByteMask = ((1L << bitsRemainingInFirstByte) - 1L);\n        firstByte &= firstByteMask;\n        // Right-align relevant bits of first byte.\n        firstByte >>>= (bitsRemainingInFirstByte - bitsToConsumeInFirstByte);\n\n        value |= firstByte;\n\n        // If the first byte contains the whole word, short-circuit.\n        if(firstByteIndex == lastByteIndex) {\n            return value;\n        }\n\n        // --------------------------------------------------------------------\n        // Middle bytes\n        final int middleByteCount = (lastByteIndex - firstByteIndex - 1);\n        for(int i=0; i<middleByteCount; i++) {\n            final long middleByte = (bytes[firstByteIndex + i + 1] & BYTE_MASK);\n            // Push middle byte onto accumulator.\n            value <<= BITS_PER_BYTE;\n            value |= middleByte;\n        }\n\n        // --------------------------------------------------------------------\n        // Last byte\n        long lastByte = (bytes[lastByteIndex] & BYTE_MASK);\n        lastByte >>= (BITS_PER_BYTE - lastByteBitsToConsume);\n        value <<= lastByteBitsToConsume;\n        value |= lastByte;\n        return value;\n    }\n\n","sourceOld":"    // ------------------------------------------------------------------------\n    /**\n     * Reads the word at the specified sequence position (zero-indexed).\n     *\n     * @param  position the zero-indexed position of the word to be read. This\n     *         must be greater than or equal to zero.\n     * @return the value of the serialized word at the specified position.\n     */\n    private long readWord(final int position) {\n        if(position < 0) {\n            throw new ArrayIndexOutOfBoundsException(position);\n        }\n\n        // First bit of the word\n        final long firstBitIndex = (position * wordLength);\n        final int firstByteIndex = (bytePadding + (int)(firstBitIndex / BITS_PER_BYTE));\n        final int firstByteSkipBits = (int)(firstBitIndex % BITS_PER_BYTE);\n\n        // Last bit of the word\n        final long lastBitIndex = (firstBitIndex + wordLength - 1);\n        final int lastByteIndex = (bytePadding + (int)(lastBitIndex / BITS_PER_BYTE));\n        final int lastByteBitsToConsume;\n\n        final int bitsAfterByteBoundary = (int)((lastBitIndex + 1) % BITS_PER_BYTE);\n        // If the word terminates at the end of the last byte, consume the whole\n        // last byte.\n        if(bitsAfterByteBoundary == 0) {\n            lastByteBitsToConsume = BITS_PER_BYTE;\n        } else {\n            // Otherwise, only consume what is necessary.\n            lastByteBitsToConsume = bitsAfterByteBoundary;\n        }\n\n        if(lastByteIndex >= bytes.length) {\n            throw new ArrayIndexOutOfBoundsException(\"Word out of bounds of backing array.\");\n        }\n\n        // Accumulator\n        long value = 0;\n\n        // --------------------------------------------------------------------\n        // First byte\n        final int bitsRemainingInFirstByte = (BITS_PER_BYTE - firstByteSkipBits);\n        final int bitsToConsumeInFirstByte = Math.min(bitsRemainingInFirstByte, wordLength);\n        long firstByte = (long)bytes[firstByteIndex];\n\n        // Mask off the bits to skip in the first byte.\n        final long firstByteMask = ((1L << bitsRemainingInFirstByte) - 1L);\n        firstByte &= firstByteMask;\n        // Right-align relevant bits of first byte.\n        firstByte >>>= (bitsRemainingInFirstByte - bitsToConsumeInFirstByte);\n\n        value |= firstByte;\n\n        // If the first byte contains the whole word, short-circuit.\n        if(firstByteIndex == lastByteIndex) {\n            return value;\n        }\n\n        // --------------------------------------------------------------------\n        // Middle bytes\n        final int middleByteCount = (lastByteIndex - firstByteIndex - 1);\n        for(int i=0; i<middleByteCount; i++) {\n            final long middleByte = (bytes[firstByteIndex + i + 1] & BYTE_MASK);\n            // Push middle byte onto accumulator.\n            value <<= BITS_PER_BYTE;\n            value |= middleByte;\n        }\n\n        // --------------------------------------------------------------------\n        // Last byte\n        long lastByte = (bytes[lastByteIndex] & BYTE_MASK);\n        lastByte >>= (BITS_PER_BYTE - lastByteBitsToConsume);\n        value <<= lastByteBitsToConsume;\n        value |= lastByte;\n        return value;\n    }\n\n","bugFix":["6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a81b342a33a0e68d2bb194ebcc3dfadcc69868b2":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a81b342a33a0e68d2bb194ebcc3dfadcc69868b2"]},"commit2Childs":{"a81b342a33a0e68d2bb194ebcc3dfadcc69868b2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a81b342a33a0e68d2bb194ebcc3dfadcc69868b2"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}