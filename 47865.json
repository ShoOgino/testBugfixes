{"path":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","commits":[{"id":"cd9165e54429bb5c99e75d5cb1c926cc98772456","date":1337362687,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[FieldInfo,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  /** Produce _X.nrm if any document had a field with norms\n   *  not disabled */\n  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state.numDocs);\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  /** Produce _X.nrm if any document had a field with norms\n   *  not disabled */\n  @Override\n  public void flush(Map<FieldInfo,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state.numDocs);\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null;\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16cbef32b882ec68df422af3f08845ec82620335","date":1337802266,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  /** Produce _X.nrm if any document had a field with norms\n   *  not disabled */\n  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state.segmentInfo.getDocCount());\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  /** Produce _X.nrm if any document had a field with norms\n   *  not disabled */\n  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state.numDocs);\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[FieldInfo,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  /** Produce _X.nrm if any document had a field with norms\n   *  not disabled */\n  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state.segmentInfo.getDocCount());\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  /** Produce _X.nrm if any document had a field with norms\n   *  not disabled */\n  @Override\n  public void flush(Map<FieldInfo,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitNorms) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state.numDocs);\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null;\n              fi.setNormValueType(null, false);\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a761b207f161726214a84533bf56a78f6c21ff56","date":1354384027,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    SimpleDVConsumer normsConsumer = null;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        SimpleNormsFormat normsFormat = state.segmentInfo.getCodec().simpleNormsFormat();\n\n        // nocommit change this to assert normsFormat != null\n        if (normsFormat != null) {\n          normsConsumer = normsFormat.normsConsumer(state);\n        }\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n        if (normsConsumer != null) {\n          \n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer, normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer, normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  /** Produce _X.nrm if any document had a field with norms\n   *  not disabled */\n  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state.segmentInfo.getDocCount());\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55eeb2534cd53d2a985669829df942468ebf5314","date":1354409119,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    SimpleDVConsumer normsConsumer = null;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        SimpleNormsFormat normsFormat = state.segmentInfo.getCodec().simpleNormsFormat();\n\n        // nocommit change this to assert normsFormat != null\n        if (normsFormat != null) {\n          normsConsumer = normsFormat.normsConsumer(state);\n        }\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n        // nocommit do we also need to normsConsumer.abort!?\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer, normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer, normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    SimpleDVConsumer normsConsumer = null;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        SimpleNormsFormat normsFormat = state.segmentInfo.getCodec().simpleNormsFormat();\n\n        // nocommit change this to assert normsFormat != null\n        if (normsFormat != null) {\n          normsConsumer = normsFormat.normsConsumer(state);\n        }\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n        if (normsConsumer != null) {\n          \n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer, normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer, normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    SimpleDVConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        SimpleNormsFormat normsFormat = state.segmentInfo.getCodec().simpleNormsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    SimpleDVConsumer normsConsumer = null;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        SimpleNormsFormat normsFormat = state.segmentInfo.getCodec().simpleNormsFormat();\n\n        // nocommit change this to assert normsFormat != null\n        if (normsFormat != null) {\n          normsConsumer = normsFormat.normsConsumer(state);\n        }\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n        // nocommit do we also need to normsConsumer.abort!?\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer, normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer, normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    SimpleDVConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        SimpleNormsFormat normsFormat = state.segmentInfo.getCodec().simpleNormsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  /** Produce _X.nrm if any document had a field with norms\n   *  not disabled */\n  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    boolean anythingFlushed = false;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && toWrite.initialized()) {\n              anythingFlushed = true;\n              final Type type = toWrite.flush(state.segmentInfo.getDocCount());\n              assert fi.getNormType() == type;\n            } else if (fi.isIndexed()) {\n              anythingFlushed = true;\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      } \n      \n      success = true;\n      if (!anythingFlushed && consumer != null) {\n        consumer.abort();\n      }\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":["bbe822fc2a6ca4ade8768d6b9a38cd8662e2775d","f6e3376a314fcc2b31bc46d399c2ff23552b78d6","16cbef32b882ec68df422af3f08845ec82620335","143d45d6fe43d56d1f541059577c929fc0ad27a1","9e8d5a6ffbfa3405d234a87c833741eabed98d13"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52c7e49be259508735752fba88085255014a6ecf","date":1398706273,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3394716f52b34ab259ad5247e7595d9f9db6e935","date":1398791921,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a761b207f161726214a84533bf56a78f6c21ff56":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["d4d69c535930b5cce125cff868d40f6373dc27d4","3394716f52b34ab259ad5247e7595d9f9db6e935"],"16cbef32b882ec68df422af3f08845ec82620335":["cd9165e54429bb5c99e75d5cb1c926cc98772456"],"55eeb2534cd53d2a985669829df942468ebf5314":["a761b207f161726214a84533bf56a78f6c21ff56"],"cd9165e54429bb5c99e75d5cb1c926cc98772456":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3394716f52b34ab259ad5247e7595d9f9db6e935":["d4d69c535930b5cce125cff868d40f6373dc27d4","52c7e49be259508735752fba88085255014a6ecf"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","16cbef32b882ec68df422af3f08845ec82620335"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["0837ab0472feecb3a54260729d845f839e1cbd72"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0837ab0472feecb3a54260729d845f839e1cbd72":["55eeb2534cd53d2a985669829df942468ebf5314"],"52c7e49be259508735752fba88085255014a6ecf":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3394716f52b34ab259ad5247e7595d9f9db6e935"]},"commit2Childs":{"a761b207f161726214a84533bf56a78f6c21ff56":["55eeb2534cd53d2a985669829df942468ebf5314"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"16cbef32b882ec68df422af3f08845ec82620335":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"55eeb2534cd53d2a985669829df942468ebf5314":["0837ab0472feecb3a54260729d845f839e1cbd72"],"cd9165e54429bb5c99e75d5cb1c926cc98772456":["16cbef32b882ec68df422af3f08845ec82620335"],"3394716f52b34ab259ad5247e7595d9f9db6e935":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a761b207f161726214a84533bf56a78f6c21ff56","d4d69c535930b5cce125cff868d40f6373dc27d4"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","3394716f52b34ab259ad5247e7595d9f9db6e935","52c7e49be259508735752fba88085255014a6ecf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd9165e54429bb5c99e75d5cb1c926cc98772456","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"0837ab0472feecb3a54260729d845f839e1cbd72":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"52c7e49be259508735752fba88085255014a6ecf":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}