{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"4ee5a5186e7187cd42c6f7ff64b6e7206a780325","date":1372914261,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n    \n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, message.getStr(\"name\")) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + message.getStr(\"name\"));\n      }\n\n      log.info(\"Successfully deleted collection \" + collection + \", shard: \" + message.getStr(\"name\"));\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + message.getStr(\"name\"), e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6512c0fadf4fc33401e33ab35ca85a2e61331180","a982453fa5a954e86ce77b1be9daf749881c13b3","0b5f2c825882b5378afd6f911e0d1cd0274b7410","344b0840364d990b29b97467bfcc766ff8325d11","344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n    \n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, message.getStr(\"name\")) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + message.getStr(\"name\"));\n      }\n\n      log.info(\"Successfully deleted collection \" + collection + \", shard: \" + message.getStr(\"name\"));\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + message.getStr(\"name\"), e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eeda7e62e149f90eee8895af874c74efa7d4852","date":1375293182,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, message.getStr(\"name\")) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + message.getStr(\"name\"));\n      }\n\n      log.info(\"Successfully deleted collection \" + collection + \", shard: \" + message.getStr(\"name\"));\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + message.getStr(\"name\"), e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n    \n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, message.getStr(\"name\")) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + message.getStr(\"name\"));\n      }\n\n      log.info(\"Successfully deleted collection \" + collection + \", shard: \" + message.getStr(\"name\"));\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + message.getStr(\"name\"), e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, message.getStr(\"name\")) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + message.getStr(\"name\"));\n      }\n\n      log.info(\"Successfully deleted collection \" + collection + \", shard: \" + message.getStr(\"name\"));\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + message.getStr(\"name\"), e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n    \n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, message.getStr(\"name\")) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + message.getStr(\"name\"));\n      }\n\n      log.info(\"Successfully deleted collection \" + collection + \", shard: \" + message.getStr(\"name\"));\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + message.getStr(\"name\"), e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0b5f2c825882b5378afd6f911e0d1cd0274b7410","date":1378970050,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, message.getStr(\"name\")) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + message.getStr(\"name\"));\n      }\n\n      log.info(\"Successfully deleted collection \" + collection + \", shard: \" + message.getStr(\"name\"));\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + message.getStr(\"name\"), e);\n    }\n  }\n\n","bugFix":["4ee5a5186e7187cd42c6f7ff64b6e7206a780325"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc841231667f1f315bae6799c068f9aad6543967","date":1381415189,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a982453fa5a954e86ce77b1be9daf749881c13b3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b753f4bd40fd8ec5276ceae15e867d2dceeb5552","date":1387799061,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.getCollections().contains(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.currentTimeMillis();\n      long timeout = now + 30000;\n      boolean removed = false;\n      while (System.currentTimeMillis() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice.getName());\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      processResponses(results);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["6512c0fadf4fc33401e33ab35ca85a2e61331180"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f26f74e4969851a019d28f10315cb1c77786f22","date":1400539241,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice.getName());\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice.getName());\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      processResponses(results);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice.getName());\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice.getName());\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice);\n\n      processResponses(results);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a982453fa5a954e86ce77b1be9daf749881c13b3","date":1400848395,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice.getName());\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n        || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice.getName());\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE) || slice.getState().equals(Slice.RECOVERY))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only INACTIVE (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":["4ee5a5186e7187cd42c6f7ff64b6e7206a780325","bc841231667f1f315bae6799c068f9aad6543967"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6512c0fadf4fc33401e33ab35ca85a2e61331180","date":1408028983,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n        || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with the specified name exists: \" + slice.getName());\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }      \n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n        || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","4ee5a5186e7187cd42c6f7ff64b6e7206a780325"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n        || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n        || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbf528c0e702c5cbd1339b2da1cdc823fd44a925","date":1427230904,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collection, sliceId, null, null);\n    try {\n      log.info(\"Delete shard invoked\");\n      Slice slice = clusterState.getSlice(collection, sliceId);\n\n      if (slice == null) {\n        if (clusterState.hasCollection(collection)) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n        } else {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No collection with the specified name exists: \" + collection);\n        }\n      }\n      // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n      // TODO: Add check for range gaps on Slice deletion\n      if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n          || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"The slice: \" + slice.getName() + \" is currently \"\n                + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n      }\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n      try {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n        params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n        sliceCmd(clusterState, params, null, slice, shardHandler);\n\n        processResponses(results, shardHandler);\n\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n            DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, sliceId);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n        // wait for a while until we don't see the shard\n        long now = System.nanoTime();\n        long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n        boolean removed = false;\n        while (System.nanoTime() < timeout) {\n          Thread.sleep(100);\n          removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n          if (removed) {\n            Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n            break;\n          }\n        }\n        if (!removed) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n        }\n\n        log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n      }\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n        || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collection, sliceId, null, null);\n    try {\n      log.info(\"Delete shard invoked\");\n      Slice slice = clusterState.getSlice(collection, sliceId);\n\n      if (slice == null) {\n        if (clusterState.hasCollection(collection)) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n        } else {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No collection with the specified name exists: \" + collection);\n        }\n      }\n      // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n      // TODO: Add check for range gaps on Slice deletion\n      if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n          || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"The slice: \" + slice.getName() + \" is currently \"\n                + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n      }\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n      try {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n        params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n        sliceCmd(clusterState, params, null, slice, shardHandler);\n\n        processResponses(results, shardHandler);\n\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n            DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, sliceId);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n        // wait for a while until we don't see the shard\n        long now = System.nanoTime();\n        long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n        boolean removed = false;\n        while (System.nanoTime() < timeout) {\n          Thread.sleep(100);\n          removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n          if (removed) {\n            Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n            break;\n          }\n        }\n        if (!removed) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n        }\n\n        log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n      }\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    log.info(\"Delete shard invoked\");\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if(clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n        || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"The slice: \" + slice.getName() + \" is currently \"\n          + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n\n      processResponses(results, shardHandler);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n          DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n          ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n\n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collection, sliceId, null, null);\n    try {\n      log.info(\"Delete shard invoked\");\n      Slice slice = clusterState.getSlice(collection, sliceId);\n\n      if (slice == null) {\n        if (clusterState.hasCollection(collection)) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n        } else {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No collection with the specified name exists: \" + collection);\n        }\n      }\n      // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n      // TODO: Add check for range gaps on Slice deletion\n      final Slice.State state = slice.getState();\n      if (!(slice.getRange() == null || state == Slice.State.INACTIVE\n          || state == Slice.State.RECOVERY || state == Slice.State.CONSTRUCTION)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"The slice: \" + slice.getName() + \" is currently \"\n                + state + \". Only non-active (or custom-hashed) slices can be deleted.\");\n      }\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n      try {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n        params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n        sliceCmd(clusterState, params, null, slice, shardHandler);\n\n        processResponses(results, shardHandler);\n\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n            DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, sliceId);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n        // wait for a while until we don't see the shard\n        long now = System.nanoTime();\n        long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n        boolean removed = false;\n        while (System.nanoTime() < timeout) {\n          Thread.sleep(100);\n          removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n          if (removed) {\n            Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n            break;\n          }\n        }\n        if (!removed) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n        }\n\n        log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n      }\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collection, sliceId, null, null);\n    try {\n      log.info(\"Delete shard invoked\");\n      Slice slice = clusterState.getSlice(collection, sliceId);\n\n      if (slice == null) {\n        if (clusterState.hasCollection(collection)) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n        } else {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No collection with the specified name exists: \" + collection);\n        }\n      }\n      // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n      // TODO: Add check for range gaps on Slice deletion\n      if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n          || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"The slice: \" + slice.getName() + \" is currently \"\n                + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n      }\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n      try {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n        params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n        sliceCmd(clusterState, params, null, slice, shardHandler);\n\n        processResponses(results, shardHandler);\n\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n            DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, sliceId);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n        // wait for a while until we don't see the shard\n        long now = System.nanoTime();\n        long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n        boolean removed = false;\n        while (System.nanoTime() < timeout) {\n          Thread.sleep(100);\n          removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n          if (removed) {\n            Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n            break;\n          }\n        }\n        if (!removed) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n        }\n\n        log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n      }\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collection, sliceId, null, null);\n    try {\n      log.info(\"Delete shard invoked\");\n      Slice slice = clusterState.getSlice(collection, sliceId);\n\n      if (slice == null) {\n        if (clusterState.hasCollection(collection)) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n        } else {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No collection with the specified name exists: \" + collection);\n        }\n      }\n      // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n      // TODO: Add check for range gaps on Slice deletion\n      final Slice.State state = slice.getState();\n      if (!(slice.getRange() == null || state == Slice.State.INACTIVE\n          || state == Slice.State.RECOVERY || state == Slice.State.CONSTRUCTION)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"The slice: \" + slice.getName() + \" is currently \"\n                + state + \". Only non-active (or custom-hashed) slices can be deleted.\");\n      }\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n      try {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n        params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n        sliceCmd(clusterState, params, null, slice, shardHandler);\n\n        processResponses(results, shardHandler);\n\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n            DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, sliceId);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n        // wait for a while until we don't see the shard\n        long now = System.nanoTime();\n        long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n        boolean removed = false;\n        while (System.nanoTime() < timeout) {\n          Thread.sleep(100);\n          removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n          if (removed) {\n            Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n            break;\n          }\n        }\n        if (!removed) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n        }\n\n        log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n      }\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collection, sliceId, null, null);\n    try {\n      log.info(\"Delete shard invoked\");\n      Slice slice = clusterState.getSlice(collection, sliceId);\n\n      if (slice == null) {\n        if (clusterState.hasCollection(collection)) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n        } else {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No collection with the specified name exists: \" + collection);\n        }\n      }\n      // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n      // TODO: Add check for range gaps on Slice deletion\n      if (!(slice.getRange() == null || slice.getState().equals(Slice.INACTIVE)\n          || slice.getState().equals(Slice.RECOVERY) || slice.getState().equals(Slice.CONSTRUCTION))) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"The slice: \" + slice.getName() + \" is currently \"\n                + slice.getState() + \". Only non-active (or custom-hashed) slices can be deleted.\");\n      }\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n      try {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n        params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n        sliceCmd(clusterState, params, null, slice, shardHandler);\n\n        processResponses(results, shardHandler);\n\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n            DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, sliceId);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n        // wait for a while until we don't see the shard\n        long now = System.nanoTime();\n        long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n        boolean removed = false;\n        while (System.nanoTime() < timeout) {\n          Thread.sleep(100);\n          removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n          if (removed) {\n            Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n            break;\n          }\n        }\n        if (!removed) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n        }\n\n        log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n      }\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    \n    log.info(\"Delete shard invoked\");\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if (clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    final Slice.State state = slice.getState();\n    if (!(slice.getRange() == null || state == Slice.State.INACTIVE || state == Slice.State.RECOVERY\n        || state == Slice.State.CONSTRUCTION)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"The slice: \" + slice.getName() + \" is currently \" + state\n          + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    \n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n      \n      processResponses(results, shardHandler);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP,\n          collection, ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n      \n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n      \n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setMDC(collection, sliceId, null, null);\n    try {\n      log.info(\"Delete shard invoked\");\n      Slice slice = clusterState.getSlice(collection, sliceId);\n\n      if (slice == null) {\n        if (clusterState.hasCollection(collection)) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n        } else {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"No collection with the specified name exists: \" + collection);\n        }\n      }\n      // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n      // TODO: Add check for range gaps on Slice deletion\n      final Slice.State state = slice.getState();\n      if (!(slice.getRange() == null || state == Slice.State.INACTIVE\n          || state == Slice.State.RECOVERY || state == Slice.State.CONSTRUCTION)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"The slice: \" + slice.getName() + \" is currently \"\n                + state + \". Only non-active (or custom-hashed) slices can be deleted.\");\n      }\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n      try {\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n        params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n        sliceCmd(clusterState, params, null, slice, shardHandler);\n\n        processResponses(results, shardHandler);\n\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n            DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,\n            ZkStateReader.SHARD_ID_PROP, sliceId);\n        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n\n        // wait for a while until we don't see the shard\n        long now = System.nanoTime();\n        long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n        boolean removed = false;\n        while (System.nanoTime() < timeout) {\n          Thread.sleep(100);\n          removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n          if (removed) {\n            Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n            break;\n          }\n        }\n        if (!removed) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n        }\n\n        log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n      }\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":["34127d6b305c3e200d697bfcb58e639d65250c6f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","344b0840364d990b29b97467bfcc766ff8325d11","344b0840364d990b29b97467bfcc766ff8325d11","6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b","6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b","092c3ae5fefa024f6d0c427be5f23dd3bfbdd20c","092c3ae5fefa024f6d0c427be5f23dd3bfbdd20c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    \n    log.info(\"Delete shard invoked\");\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if (clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    final Slice.State state = slice.getState();\n    if (!(slice.getRange() == null || state == Slice.State.INACTIVE || state == Slice.State.RECOVERY\n        || state == Slice.State.CONSTRUCTION)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"The slice: \" + slice.getName() + \" is currently \" + state\n          + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    \n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n      \n      processResponses(results, shardHandler);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP,\n          collection, ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n      \n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n      \n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n      \n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    \n    log.info(\"Delete shard invoked\");\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if (clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    final Slice.State state = slice.getState();\n    if (!(slice.getRange() == null || state == Slice.State.INACTIVE || state == Slice.State.RECOVERY\n        || state == Slice.State.CONSTRUCTION)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"The slice: \" + slice.getName() + \" is currently \" + state\n          + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    \n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n      \n      processResponses(results, shardHandler);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP,\n          collection, ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));\n      \n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n      \n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n      \n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    \n    log.info(\"Delete shard invoked\");\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if (clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    final Slice.State state = slice.getState();\n    if (!(slice.getRange() == null || state == Slice.State.INACTIVE || state == Slice.State.RECOVERY\n        || state == Slice.State.CONSTRUCTION)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"The slice: \" + slice.getName() + \" is currently \" + state\n          + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    \n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n      \n      processResponses(results, shardHandler);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP,\n          collection, ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n      \n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n      \n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n      \n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","sourceOld":"  private void deleteShard(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    String sliceId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    \n    log.info(\"Delete shard invoked\");\n    Slice slice = clusterState.getSlice(collection, sliceId);\n    \n    if (slice == null) {\n      if (clusterState.hasCollection(collection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No shard with name \" + sliceId + \" exists for collection \" + collection);\n      } else {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"No collection with the specified name exists: \" + collection);\n      }\n    }\n    // For now, only allow for deletions of Inactive slices or custom hashes (range==null).\n    // TODO: Add check for range gaps on Slice deletion\n    final Slice.State state = slice.getState();\n    if (!(slice.getRange() == null || state == Slice.State.INACTIVE || state == Slice.State.RECOVERY\n        || state == Slice.State.CONSTRUCTION)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"The slice: \" + slice.getName() + \" is currently \" + state\n          + \". Only non-active (or custom-hashed) slices can be deleted.\");\n    }\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    \n    try {\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INDEX, \"true\");\n      sliceCmd(clusterState, params, null, slice, shardHandler);\n      \n      processResponses(results, shardHandler);\n      \n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP,\n          collection, ZkStateReader.SHARD_ID_PROP, sliceId);\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n      \n      // wait for a while until we don't see the shard\n      long now = System.nanoTime();\n      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (System.nanoTime() < timeout) {\n        Thread.sleep(100);\n        removed = zkStateReader.getClusterState().getSlice(collection, sliceId) == null;\n        if (removed) {\n          Thread.sleep(100); // just a bit of time so it's more likely other readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection + \" shard: \" + sliceId);\n      }\n      \n      log.info(\"Successfully deleted collection: \" + collection + \", shard: \" + sliceId);\n      \n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR,\n          \"Error executing delete operation for collection: \" + collection + \" shard: \" + sliceId, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["37a0f60745e53927c4c876cfe5b5a58170f0646c","1eeda7e62e149f90eee8895af874c74efa7d4852"],"6512c0fadf4fc33401e33ab35ca85a2e61331180":["a982453fa5a954e86ce77b1be9daf749881c13b3"],"b753f4bd40fd8ec5276ceae15e867d2dceeb5552":["bc841231667f1f315bae6799c068f9aad6543967"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4ee5a5186e7187cd42c6f7ff64b6e7206a780325"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"a982453fa5a954e86ce77b1be9daf749881c13b3":["6f26f74e4969851a019d28f10315cb1c77786f22"],"b7605579001505896d48b07160075a5c8b8e128e":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","6f26f74e4969851a019d28f10315cb1c77786f22"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["6512c0fadf4fc33401e33ab35ca85a2e61331180"],"0b5f2c825882b5378afd6f911e0d1cd0274b7410":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["4ee5a5186e7187cd42c6f7ff64b6e7206a780325"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["b753f4bd40fd8ec5276ceae15e867d2dceeb5552"],"0c924d4069ef5a5bc479a493befe0121aada6896":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["30c688f7052130cef7bd419c85e3c5be214f7b9e","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"bc841231667f1f315bae6799c068f9aad6543967":["0b5f2c825882b5378afd6f911e0d1cd0274b7410"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6f26f74e4969851a019d28f10315cb1c77786f22":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"4ee5a5186e7187cd42c6f7ff64b6e7206a780325":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["30c688f7052130cef7bd419c85e3c5be214f7b9e"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"6512c0fadf4fc33401e33ab35ca85a2e61331180":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"b753f4bd40fd8ec5276ceae15e867d2dceeb5552":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["439c63ae5d22132fca810a0029a854e97d2c1a3e","0c924d4069ef5a5bc479a493befe0121aada6896"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["b7605579001505896d48b07160075a5c8b8e128e","6f26f74e4969851a019d28f10315cb1c77786f22"],"a982453fa5a954e86ce77b1be9daf749881c13b3":["6512c0fadf4fc33401e33ab35ca85a2e61331180"],"b7605579001505896d48b07160075a5c8b8e128e":[],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"0b5f2c825882b5378afd6f911e0d1cd0274b7410":["bc841231667f1f315bae6799c068f9aad6543967"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","0b5f2c825882b5378afd6f911e0d1cd0274b7410"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["0c924d4069ef5a5bc479a493befe0121aada6896"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bc841231667f1f315bae6799c068f9aad6543967":["b753f4bd40fd8ec5276ceae15e867d2dceeb5552"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","4ee5a5186e7187cd42c6f7ff64b6e7206a780325"],"6f26f74e4969851a019d28f10315cb1c77786f22":["a982453fa5a954e86ce77b1be9daf749881c13b3","b7605579001505896d48b07160075a5c8b8e128e"],"4ee5a5186e7187cd42c6f7ff64b6e7206a780325":["37a0f60745e53927c4c876cfe5b5a58170f0646c","1eeda7e62e149f90eee8895af874c74efa7d4852"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","b7605579001505896d48b07160075a5c8b8e128e","0c924d4069ef5a5bc479a493befe0121aada6896","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}