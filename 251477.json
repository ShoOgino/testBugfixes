{"path":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","commits":[{"id":"9435d55e3ea95c5d94406d3affc36f9505b6a736","date":1491251232,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","pathOld":"/dev/null","sourceNew":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    log.info(\"Allocating transient cache for {} transient cores\", cacheSize);\n    addObserver(this.observer);\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    transientCores = new LinkedHashMap<String, SolrCore>(Math.min(cacheSize, 1000), 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          setChanged();\n          notifyObservers(coreToClose);\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6a4b585aed7660a589375f6a09b90efd29c961","date":1491296430,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","pathOld":"/dev/null","sourceNew":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    log.info(\"Allocating transient cache for {} transient cores\", cacheSize);\n    addObserver(this.observer);\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    transientCores = new LinkedHashMap<String, SolrCore>(Math.min(cacheSize, 1000), 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          setChanged();\n          notifyObservers(coreToClose);\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","sourceNew":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    log.info(\"Allocating transient cache for {} transient cores\", cacheSize);\n    this.registerCoreCloseListener(this.coreCloseListener);\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    transientCores = new LinkedHashMap<String, SolrCore>(Math.min(cacheSize, 1000), 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          notifyCoreCloseListeners(coreToClose);\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    log.info(\"Allocating transient cache for {} transient cores\", cacheSize);\n    addObserver(this.observer);\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    transientCores = new LinkedHashMap<String, SolrCore>(Math.min(cacheSize, 1000), 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          setChanged();\n          notifyObservers(coreToClose);\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba387e642aff5fc3b3ff8c76a01f40e4d2e8e29f","date":1555718441,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","sourceNew":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    log.info(\"Allocating transient cache for {} transient cores\", cacheSize);\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    transientCores = new LinkedHashMap<String, SolrCore>(Math.min(cacheSize, 1000), 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          coreContainer.queueCoreToClose(coreToClose);\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    log.info(\"Allocating transient cache for {} transient cores\", cacheSize);\n    this.registerCoreCloseListener(this.coreCloseListener);\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    transientCores = new LinkedHashMap<String, SolrCore>(Math.min(cacheSize, 1000), 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          notifyCoreCloseListeners(coreToClose);\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5678b7836acd8d4c85c4fc6b2f03c38b4a4fe4e","date":1584132352,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","sourceNew":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    int actualCacheSize = Math.min(cacheSize, 1000);\n    log.info(\"Allocating transient cache for {} transient cores\", actualCacheSize);\n    transientCores = new LinkedHashMap<>(actualCacheSize, 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          coreContainer.queueCoreToClose(coreToClose);\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    log.info(\"Allocating transient cache for {} transient cores\", cacheSize);\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    transientCores = new LinkedHashMap<String, SolrCore>(Math.min(cacheSize, 1000), 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          coreContainer.queueCoreToClose(coreToClose);\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","sourceNew":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    int actualCacheSize = Math.min(cacheSize, 1000);\n    log.info(\"Allocating transient cache for {} transient cores\", actualCacheSize);\n    transientCores = new LinkedHashMap<>(actualCacheSize, 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          if (log.isInfoEnabled()) {\n            log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          }\n          coreContainer.queueCoreToClose(coreToClose);\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    int actualCacheSize = Math.min(cacheSize, 1000);\n    log.info(\"Allocating transient cache for {} transient cores\", actualCacheSize);\n    transientCores = new LinkedHashMap<>(actualCacheSize, 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          coreContainer.queueCoreToClose(coreToClose);\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75237075d8425856bf4bbf52a6be4f9162b8187d","date":1591103291,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/TransientSolrCoreCacheDefault#doInit().mjava","sourceNew":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    int actualCacheSize = Math.min(cacheSize, 1000);\n    log.info(\"Allocating transient cache for {} transient cores\", actualCacheSize);\n    transientCores = new LinkedHashMap<>(actualCacheSize, 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          if (log.isInfoEnabled()) {\n            log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          }\n          coreContainer.queueCoreToClose(coreToClose);\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","sourceOld":"  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    int actualCacheSize = Math.min(cacheSize, 1000);\n    log.info(\"Allocating transient cache for {} transient cores\", actualCacheSize);\n    transientCores = new LinkedHashMap<>(actualCacheSize, 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          if (log.isInfoEnabled()) {\n            log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          }\n          coreContainer.queueCoreToClose(coreToClose);\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9435d55e3ea95c5d94406d3affc36f9505b6a736":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"75237075d8425856bf4bbf52a6be4f9162b8187d":["140be51d03394488536f4aacedace29f9b318347"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["9435d55e3ea95c5d94406d3affc36f9505b6a736"],"140be51d03394488536f4aacedace29f9b318347":["c5678b7836acd8d4c85c4fc6b2f03c38b4a4fe4e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5678b7836acd8d4c85c4fc6b2f03c38b4a4fe4e":["ba387e642aff5fc3b3ff8c76a01f40e4d2e8e29f"],"8b6a4b585aed7660a589375f6a09b90efd29c961":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba387e642aff5fc3b3ff8c76a01f40e4d2e8e29f":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["75237075d8425856bf4bbf52a6be4f9162b8187d"]},"commit2Childs":{"9435d55e3ea95c5d94406d3affc36f9505b6a736":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"75237075d8425856bf4bbf52a6be4f9162b8187d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["ba387e642aff5fc3b3ff8c76a01f40e4d2e8e29f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9435d55e3ea95c5d94406d3affc36f9505b6a736","8b6a4b585aed7660a589375f6a09b90efd29c961"],"140be51d03394488536f4aacedace29f9b318347":["75237075d8425856bf4bbf52a6be4f9162b8187d"],"c5678b7836acd8d4c85c4fc6b2f03c38b4a4fe4e":["140be51d03394488536f4aacedace29f9b318347"],"8b6a4b585aed7660a589375f6a09b90efd29c961":[],"ba387e642aff5fc3b3ff8c76a01f40e4d2e8e29f":["c5678b7836acd8d4c85c4fc6b2f03c38b4a4fe4e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8b6a4b585aed7660a589375f6a09b90efd29c961","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}