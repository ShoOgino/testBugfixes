{"path":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 6) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHostOrIP = host name or IP address where LockVerifyServer is running\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\\n\" + \n                         \"\\n\");\n      System.exit(1);\n    }\n\n    final int myID = Integer.parseInt(args[0]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[1];\n    final int verifierPort = Integer.parseInt(args[2]);\n    final String lockFactoryClassName = args[3];\n    final String lockDirName = args[4];\n    final int sleepTimeMS = Integer.parseInt(args[5]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException e) {\n      throw new IOException(\"IllegalAccessException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (InstantiationException e) {\n      throw new IOException(\"InstantiationException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (ClassCastException e) {\n      throw new IOException(\"unable to cast LockClass \" + lockFactoryClassName + \" instance to a LockFactory\");\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"unable to find LockClass \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    lockFactory.setLockPrefix(\"test\");\n    \n    LockFactory verifyLF = new VerifyingLockFactory((byte) myID, lockFactory, verifierHost, verifierPort);\n\n    Lock l = verifyLF.makeLock(\"test.lock\");\n\n    while(true) {\n\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(10);\n      } catch (LockObtainFailedException e) {\n        System.out.print(\"x\");\n      }\n\n      if (obtained) {\n        System.out.print(\"l\");\n        l.release();\n      }\n      Thread.sleep(sleepTimeMS);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 6) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHostOrIP = host name or IP address where LockVerifyServer is running\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\\n\" + \n                         \"\\n\");\n      System.exit(1);\n    }\n\n    final int myID = Integer.parseInt(args[0]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[1];\n    final int verifierPort = Integer.parseInt(args[2]);\n    final String lockFactoryClassName = args[3];\n    final String lockDirName = args[4];\n    final int sleepTimeMS = Integer.parseInt(args[5]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException e) {\n      throw new IOException(\"IllegalAccessException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (InstantiationException e) {\n      throw new IOException(\"InstantiationException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (ClassCastException e) {\n      throw new IOException(\"unable to cast LockClass \" + lockFactoryClassName + \" instance to a LockFactory\");\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"unable to find LockClass \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    lockFactory.setLockPrefix(\"test\");\n    \n    LockFactory verifyLF = new VerifyingLockFactory((byte) myID, lockFactory, verifierHost, verifierPort);\n\n    Lock l = verifyLF.makeLock(\"test.lock\");\n\n    while(true) {\n\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(10);\n      } catch (LockObtainFailedException e) {\n        System.out.print(\"x\");\n      }\n\n      if (obtained) {\n        System.out.print(\"l\");\n        l.release();\n      }\n      Thread.sleep(sleepTimeMS);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fcdcf196523675146a4df3193e91413533857ab","date":1390686560,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 6) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHostOrIP = host name or IP address where LockVerifyServer is running\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\\n\" + \n                         \"\\n\");\n      System.exit(1);\n    }\n\n    final int myID = Integer.parseInt(args[0]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[1];\n    final int verifierPort = Integer.parseInt(args[2]);\n    final String lockFactoryClassName = args[3];\n    final String lockDirName = args[4];\n    final int sleepTimeMS = Integer.parseInt(args[5]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException e) {\n      throw new IOException(\"IllegalAccessException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (InstantiationException e) {\n      throw new IOException(\"InstantiationException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (ClassCastException e) {\n      throw new IOException(\"unable to cast LockClass \" + lockFactoryClassName + \" instance to a LockFactory\");\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"unable to find LockClass \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    lockFactory.setLockPrefix(\"test\");\n    \n    LockFactory verifyLF = new VerifyingLockFactory((byte) myID, lockFactory, verifierHost, verifierPort);\n\n    Lock l = verifyLF.makeLock(\"test.lock\");\n\n    while(true) {\n\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(10);\n      } catch (LockObtainFailedException e) {\n        System.out.print(\"x\");\n      }\n\n      if (obtained) {\n        System.out.print(\"l\");\n        l.close();\n      }\n      Thread.sleep(sleepTimeMS);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 6) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHostOrIP = host name or IP address where LockVerifyServer is running\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\\n\" + \n                         \"\\n\");\n      System.exit(1);\n    }\n\n    final int myID = Integer.parseInt(args[0]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[1];\n    final int verifierPort = Integer.parseInt(args[2]);\n    final String lockFactoryClassName = args[3];\n    final String lockDirName = args[4];\n    final int sleepTimeMS = Integer.parseInt(args[5]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException e) {\n      throw new IOException(\"IllegalAccessException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (InstantiationException e) {\n      throw new IOException(\"InstantiationException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (ClassCastException e) {\n      throw new IOException(\"unable to cast LockClass \" + lockFactoryClassName + \" instance to a LockFactory\");\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"unable to find LockClass \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    lockFactory.setLockPrefix(\"test\");\n    \n    LockFactory verifyLF = new VerifyingLockFactory((byte) myID, lockFactory, verifierHost, verifierPort);\n\n    Lock l = verifyLF.makeLock(\"test.lock\");\n\n    while(true) {\n\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(10);\n      } catch (LockObtainFailedException e) {\n        System.out.print(\"x\");\n      }\n\n      if (obtained) {\n        System.out.print(\"l\");\n        l.release();\n      }\n      Thread.sleep(sleepTimeMS);\n    }\n  }\n\n","bugFix":["67006a60923e2124212d3baa0d29b444bcbd8373"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"813fc8a2a50c4f282fc2463daeb353492aceabbd","date":1397856769,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final String lockDirName = args[arg++];\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException | InstantiationException | ClassCastException | ClassNotFoundException e) {\n      throw new IOException(\"Cannot instantiate lock factory \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    Socket socket = new Socket();\n    socket.setReuseAddress(true);\n    socket.connect(addr, 500);\n\n    OutputStream os = socket.getOutputStream();\n    os.write(myID);\n    os.flush();\n\n    lockFactory.setLockPrefix(\"test\");\n    final LockFactory verifyLF = new VerifyingLockFactory(lockFactory, socket);\n    final Lock l = verifyLF.makeLock(\"test.lock\");\n    final Random rnd = new Random();\n    \n    // wait for starting gun\n    if (socket.getInputStream().read() != 43) {\n      throw new IOException(\"Protocol violation\");\n    }\n    \n    for (int i = 0; i < count; i++) {\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(rnd.nextInt(100) + 10);\n      } catch (LockObtainFailedException e) {\n      }\n      \n      if (obtained) {\n        Thread.sleep(sleepTimeMS);\n        l.close();\n      }\n      \n      if (i % 500 == 0) {\n        System.out.println((i * 100. / count) + \"% done.\");\n      }\n      \n      Thread.sleep(sleepTimeMS);\n    }\n    \n    IOUtils.closeWhileHandlingException(socket);\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 6) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHostOrIP = host name or IP address where LockVerifyServer is running\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\\n\" + \n                         \"\\n\");\n      System.exit(1);\n    }\n\n    final int myID = Integer.parseInt(args[0]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[1];\n    final int verifierPort = Integer.parseInt(args[2]);\n    final String lockFactoryClassName = args[3];\n    final String lockDirName = args[4];\n    final int sleepTimeMS = Integer.parseInt(args[5]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException e) {\n      throw new IOException(\"IllegalAccessException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (InstantiationException e) {\n      throw new IOException(\"InstantiationException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (ClassCastException e) {\n      throw new IOException(\"unable to cast LockClass \" + lockFactoryClassName + \" instance to a LockFactory\");\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"unable to find LockClass \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    lockFactory.setLockPrefix(\"test\");\n    \n    LockFactory verifyLF = new VerifyingLockFactory((byte) myID, lockFactory, verifierHost, verifierPort);\n\n    Lock l = verifyLF.makeLock(\"test.lock\");\n\n    while(true) {\n\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(10);\n      } catch (LockObtainFailedException e) {\n        System.out.print(\"x\");\n      }\n\n      if (obtained) {\n        System.out.print(\"l\");\n        l.close();\n      }\n      Thread.sleep(sleepTimeMS);\n    }\n  }\n\n","bugFix":null,"bugIntro":["8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b44163bcc770353b79cdf8163b0ecbed3f6a9de1","date":1397862812,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final String lockDirName = args[arg++];\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException | InstantiationException | ClassCastException | ClassNotFoundException e) {\n      throw new IOException(\"Cannot instantiate lock factory \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n  \n      lockFactory.setLockPrefix(\"test\");\n      final LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      final Lock l = verifyLF.makeLock(\"test.lock\");\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        boolean obtained = false;\n  \n        try {\n          obtained = l.obtain(rnd.nextInt(100) + 10);\n        } catch (LockObtainFailedException e) {\n        }\n        \n        if (obtained) {\n          Thread.sleep(sleepTimeMS);\n          l.close();\n        }\n        \n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final String lockDirName = args[arg++];\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException | InstantiationException | ClassCastException | ClassNotFoundException e) {\n      throw new IOException(\"Cannot instantiate lock factory \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    Socket socket = new Socket();\n    socket.setReuseAddress(true);\n    socket.connect(addr, 500);\n\n    OutputStream os = socket.getOutputStream();\n    os.write(myID);\n    os.flush();\n\n    lockFactory.setLockPrefix(\"test\");\n    final LockFactory verifyLF = new VerifyingLockFactory(lockFactory, socket);\n    final Lock l = verifyLF.makeLock(\"test.lock\");\n    final Random rnd = new Random();\n    \n    // wait for starting gun\n    if (socket.getInputStream().read() != 43) {\n      throw new IOException(\"Protocol violation\");\n    }\n    \n    for (int i = 0; i < count; i++) {\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(rnd.nextInt(100) + 10);\n      } catch (LockObtainFailedException e) {\n      }\n      \n      if (obtained) {\n        Thread.sleep(sleepTimeMS);\n        l.close();\n      }\n      \n      if (i % 500 == 0) {\n        System.out.println((i * 100. / count) + \"% done.\");\n      }\n      \n      Thread.sleep(sleepTimeMS);\n    }\n    \n    IOUtils.closeWhileHandlingException(socket);\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","bugFix":null,"bugIntro":["8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fa71d5bc6be53f5f21420ccbcaecad4dd879728","date":1402044934,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final String lockDirName = args[arg++];\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName, lockDirName);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      Lock l = verifyLF.makeLock(\"test.lock\");\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        boolean obtained = false;\n        try {\n          obtained = l.obtain(rnd.nextInt(100) + 10);\n        } catch (LockObtainFailedException e) {}\n        \n        if (obtained) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName, lockDirName), in, out);\n            }\n            final Lock secondLock = verifyLF.makeLock(\"test.lock\");\n            if (secondLock.obtain()) {\n              throw new IOException(\"Double Obtain\");\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n          l.close();\n        }\n        \n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final String lockDirName = args[arg++];\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException | InstantiationException | ClassCastException | ClassNotFoundException e) {\n      throw new IOException(\"Cannot instantiate lock factory \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n  \n      lockFactory.setLockPrefix(\"test\");\n      final LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      final Lock l = verifyLF.makeLock(\"test.lock\");\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        boolean obtained = false;\n  \n        try {\n          obtained = l.obtain(rnd.nextInt(100) + 10);\n        } catch (LockObtainFailedException e) {\n        }\n        \n        if (obtained) {\n          Thread.sleep(sleepTimeMS);\n          l.close();\n        }\n        \n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","bugFix":["813fc8a2a50c4f282fc2463daeb353492aceabbd","67006a60923e2124212d3baa0d29b444bcbd8373","277b20588f94e26ec21ffdfc360528133991372e","b44163bcc770353b79cdf8163b0ecbed3f6a9de1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285cdc737de75b7cc7c284a156b20214deb67bca","date":1415535483,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new SimpleFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      Lock l = verifyLF.makeLock(lockDir, \"test.lock\");\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        boolean obtained = false;\n        try {\n          obtained = l.obtain(rnd.nextInt(100) + 10);\n        } catch (LockObtainFailedException e) {}\n        \n        if (obtained) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            final Lock secondLock = verifyLF.makeLock(lockDir, \"test.lock\");\n            if (secondLock.obtain()) {\n              throw new IOException(\"Double Obtain\");\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n          l.close();\n        }\n        \n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final String lockDirName = args[arg++];\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName, lockDirName);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      Lock l = verifyLF.makeLock(\"test.lock\");\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        boolean obtained = false;\n        try {\n          obtained = l.obtain(rnd.nextInt(100) + 10);\n        } catch (LockObtainFailedException e) {}\n        \n        if (obtained) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName, lockDirName), in, out);\n            }\n            final Lock secondLock = verifyLF.makeLock(\"test.lock\");\n            if (secondLock.obtain()) {\n              throw new IOException(\"Double Obtain\");\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n          l.close();\n        }\n        \n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e6d6f6217dc04f29ee177d2837147dd47627787","date":1429543326,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new SimpleFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      Lock l = verifyLF.makeLock(lockDir, \"test.lock\");\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        boolean obtained = false;\n        try {\n          obtained = l.obtain(rnd.nextInt(100) + 10);\n        } catch (LockObtainFailedException e) {}\n        \n        if (obtained) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            final Lock secondLock = verifyLF.makeLock(lockDir, \"test.lock\");\n            if (secondLock.obtain()) {\n              throw new IOException(\"Double Obtain\");\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n          l.close();\n        }\n        \n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new SimpleFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      Lock l = verifyLF.makeLock(lockDir, \"test.lock\");\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        boolean obtained = false;\n        try {\n          obtained = l.obtain(rnd.nextInt(100) + 10);\n        } catch (LockObtainFailedException e) {}\n        \n        if (obtained) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            final Lock secondLock = verifyLF.makeLock(lockDir, \"test.lock\");\n            if (secondLock.obtain()) {\n              throw new IOException(\"Double Obtain\");\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n          l.close();\n        }\n        \n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  @SuppressWarnings(\"try\")\n  public static void main(String[] args) throws Exception {\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new SimpleFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        try (final Lock l = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            try (final Lock secondLock = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n              throw new IOException(\"Double obtain\");\n            } catch (LockObtainFailedException loe) {\n              // pass\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n        } catch (LockObtainFailedException loe) {\n          // obtain failed\n        }\n\n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  public static void main(String[] args) throws Exception {\n\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new SimpleFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      Lock l = verifyLF.makeLock(lockDir, \"test.lock\");\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        boolean obtained = false;\n        try {\n          obtained = l.obtain(rnd.nextInt(100) + 10);\n        } catch (LockObtainFailedException e) {}\n        \n        if (obtained) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            final Lock secondLock = verifyLF.makeLock(lockDir, \"test.lock\");\n            if (secondLock.obtain()) {\n              throw new IOException(\"Double Obtain\");\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n          l.close();\n        }\n        \n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ae13d58e10d8dc818c75db483ed8b53c725f1d","date":1583449465,"type":3,"author":"Yannick Welsch","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  @SuppressWarnings(\"try\")\n  public static void main(String[] args) throws Exception {\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new NIOFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        try (final Lock l = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            try (final Lock secondLock = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n              throw new IOException(\"Double obtain\");\n            } catch (LockObtainFailedException loe) {\n              // pass\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n        } catch (LockObtainFailedException loe) {\n          // obtain failed\n        }\n\n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  @SuppressWarnings(\"try\")\n  public static void main(String[] args) throws Exception {\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new SimpleFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        try (final Lock l = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            try (final Lock secondLock = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n              throw new IOException(\"Double obtain\");\n            } catch (LockObtainFailedException loe) {\n              // pass\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n        } catch (LockObtainFailedException loe) {\n          // obtain failed\n        }\n\n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ca2a57dbb0665332572cf1a0dffa67234089615","date":1583491342,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  @SuppressWarnings(\"try\")\n  public static void main(String[] args) throws Exception {\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new NIOFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        try (final Lock l = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            try (final Lock secondLock = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n              throw new IOException(\"Double obtain\");\n            } catch (LockObtainFailedException loe) {\n              // pass\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n        } catch (LockObtainFailedException loe) {\n          // obtain failed\n        }\n\n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  @SuppressWarnings(\"try\")\n  public static void main(String[] args) throws Exception {\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new SimpleFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        try (final Lock l = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            try (final Lock secondLock = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n              throw new IOException(\"Double obtain\");\n            } catch (LockObtainFailedException loe) {\n              // pass\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n        } catch (LockObtainFailedException loe) {\n          // obtain failed\n        }\n\n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7ee2241d9fc5dee5029efe24602d8a4d2b4d760","date":1599669750,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  public static void main(String[] args) throws Exception {\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    int exitCode = run(myID, verifierHost, verifierPort, lockFactoryClassName, lockDirPath, sleepTimeMS, count);\n    System.exit(exitCode);\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"System.out required: command line tool\")\n  @SuppressWarnings(\"try\")\n  public static void main(String[] args) throws Exception {\n    if (args.length != 7) {\n      System.out.println(\"Usage: java org.apache.lucene.store.LockStressTest myID verifierHost verifierPort lockFactoryClassName lockDirName sleepTimeMS count\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHost = hostname that LockVerifyServer is listening on\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary FSLockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"  count = number of locking tries\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\");\n      System.exit(1);\n    }\n\n    int arg = 0;\n    final int myID = Integer.parseInt(args[arg++]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[arg++];\n    final int verifierPort = Integer.parseInt(args[arg++]);\n    final String lockFactoryClassName = args[arg++];\n    final Path lockDirPath = Paths.get(args[arg++]);\n    final int sleepTimeMS = Integer.parseInt(args[arg++]);\n    final int count = Integer.parseInt(args[arg++]);\n\n    final LockFactory lockFactory = getNewLockFactory(lockFactoryClassName);\n    // we test the lock factory directly, so we don't need it on the directory itsself (the directory is just for testing)\n    final FSDirectory lockDir = new NIOFSDirectory(lockDirPath, NoLockFactory.INSTANCE);\n    final InetSocketAddress addr = new InetSocketAddress(verifierHost, verifierPort);\n    System.out.println(\"Connecting to server \" + addr +\n        \" and registering as client \" + myID + \"...\");\n    try (Socket socket = new Socket()) {\n      socket.setReuseAddress(true);\n      socket.connect(addr, 500);\n      final OutputStream out = socket.getOutputStream();\n      final InputStream in = socket.getInputStream();\n      \n      out.write(myID);\n      out.flush();\n      LockFactory verifyLF = new VerifyingLockFactory(lockFactory, in, out);\n      final Random rnd = new Random();\n      \n      // wait for starting gun\n      if (in.read() != 43) {\n        throw new IOException(\"Protocol violation\");\n      }\n      \n      for (int i = 0; i < count; i++) {\n        try (final Lock l = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n          if (rnd.nextInt(10) == 0) {\n            if (rnd.nextBoolean()) {\n              verifyLF = new VerifyingLockFactory(getNewLockFactory(lockFactoryClassName), in, out);\n            }\n            try (final Lock secondLock = verifyLF.obtainLock(lockDir, LOCK_FILE_NAME)) {\n              throw new IOException(\"Double obtain\");\n            } catch (LockObtainFailedException loe) {\n              // pass\n            }\n          }\n          Thread.sleep(sleepTimeMS);\n        } catch (LockObtainFailedException loe) {\n          // obtain failed\n        }\n\n        if (i % 500 == 0) {\n          System.out.println((i * 100. / count) + \"% done.\");\n        }\n        \n        Thread.sleep(sleepTimeMS);\n      } \n    }\n    \n    System.out.println(\"Finished \" + count + \" tries.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ca2a57dbb0665332572cf1a0dffa67234089615":["618635065f043788c9e034f96ca5cd5cea1b4592","09ae13d58e10d8dc818c75db483ed8b53c725f1d"],"09ae13d58e10d8dc818c75db483ed8b53c725f1d":["618635065f043788c9e034f96ca5cd5cea1b4592"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"285cdc737de75b7cc7c284a156b20214deb67bca":["8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"813fc8a2a50c4f282fc2463daeb353492aceabbd":["0fcdcf196523675146a4df3193e91413533857ab"],"b7ee2241d9fc5dee5029efe24602d8a4d2b4d760":["9ca2a57dbb0665332572cf1a0dffa67234089615"],"b44163bcc770353b79cdf8163b0ecbed3f6a9de1":["813fc8a2a50c4f282fc2463daeb353492aceabbd"],"618635065f043788c9e034f96ca5cd5cea1b4592":["7e6d6f6217dc04f29ee177d2837147dd47627787"],"7e6d6f6217dc04f29ee177d2837147dd47627787":["285cdc737de75b7cc7c284a156b20214deb67bca"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0fcdcf196523675146a4df3193e91413533857ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b7ee2241d9fc5dee5029efe24602d8a4d2b4d760"],"8fa71d5bc6be53f5f21420ccbcaecad4dd879728":["b44163bcc770353b79cdf8163b0ecbed3f6a9de1"]},"commit2Childs":{"9ca2a57dbb0665332572cf1a0dffa67234089615":["b7ee2241d9fc5dee5029efe24602d8a4d2b4d760"],"09ae13d58e10d8dc818c75db483ed8b53c725f1d":["9ca2a57dbb0665332572cf1a0dffa67234089615"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["0fcdcf196523675146a4df3193e91413533857ab"],"285cdc737de75b7cc7c284a156b20214deb67bca":["7e6d6f6217dc04f29ee177d2837147dd47627787"],"813fc8a2a50c4f282fc2463daeb353492aceabbd":["b44163bcc770353b79cdf8163b0ecbed3f6a9de1"],"b7ee2241d9fc5dee5029efe24602d8a4d2b4d760":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b44163bcc770353b79cdf8163b0ecbed3f6a9de1":["8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"618635065f043788c9e034f96ca5cd5cea1b4592":["9ca2a57dbb0665332572cf1a0dffa67234089615","09ae13d58e10d8dc818c75db483ed8b53c725f1d"],"7e6d6f6217dc04f29ee177d2837147dd47627787":["618635065f043788c9e034f96ca5cd5cea1b4592"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"0fcdcf196523675146a4df3193e91413533857ab":["813fc8a2a50c4f282fc2463daeb353492aceabbd"],"8fa71d5bc6be53f5f21420ccbcaecad4dd879728":["285cdc737de75b7cc7c284a156b20214deb67bca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}