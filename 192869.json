{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","pathOld":"/dev/null","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    Collection<String> newNRTFiles = job.getFileNames();\n    long newPrimaryGen = job.getCopyState().primaryGen;\n    maybeNewPrimary(newPrimaryGen);\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // nocommit can't we .transferAndCancel?\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    Collection<String> newNRTFiles = job.getFileNames();\n    long newPrimaryGen = job.getCopyState().primaryGen;\n    maybeNewPrimary(newPrimaryGen);\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    Collection<String> newNRTFiles = job.getFileNames();\n    long newPrimaryGen = job.getCopyState().primaryGen;\n    maybeNewPrimary(newPrimaryGen);\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // nocommit can't we .transferAndCancel?\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    Collection<String> newNRTFiles = job.getFileNames();\n    long newPrimaryGen = job.getCopyState().primaryGen;\n    maybeNewPrimary(newPrimaryGen);\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    Collection<String> newNRTFiles = job.getFileNames();\n    long newPrimaryGen = job.getCopyState().primaryGen;\n    maybeNewPrimary(newPrimaryGen);\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13ea66b549e25413e4e3057bf3492ab828899110","date":1454958424,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    Collection<String> newNRTFiles = job.getFileNames();\n    long newPrimaryGen = job.getCopyState().primaryGen;\n    maybeNewPrimary(newPrimaryGen);\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b0febf62c2d9baeee7db38998d9197700ccbab9","date":1454958476,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    Collection<String> newNRTFiles = job.getFileNames();\n    long newPrimaryGen = job.getCopyState().primaryGen;\n    maybeNewPrimary(newPrimaryGen);\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2","13ea66b549e25413e4e3057bf3492ab828899110"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"13ea66b549e25413e4e3057bf3492ab828899110":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":[],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1b0febf62c2d9baeee7db38998d9197700ccbab9","13ea66b549e25413e4e3057bf3492ab828899110"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"13ea66b549e25413e4e3057bf3492ab828899110":["1b0febf62c2d9baeee7db38998d9197700ccbab9"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1b0febf62c2d9baeee7db38998d9197700ccbab9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}