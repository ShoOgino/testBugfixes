{"path":"lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTerm#binarySearchAssociatedDocuments(int,int,int).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTerm#binarySearchAssociatedDocuments(int,int,int).mjava","pathOld":"contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTerm#binarySearchAssociatedDocuments(int,int,int).mjava","sourceNew":"  /**\n   * @param target value to search for in the array\n   * @param offset index of the first valid value in the array\n   * @param length number of valid values in the array\n   * @return index of an occurrence of key in array, or -(insertionIndex + 1) if key is not contained in array (<i>insertionIndex</i> is then the index at which key could be inserted).\n   */\n  public int binarySearchAssociatedDocuments(int target, int offset, int length) {\n\n    // implementation originally from http://ochafik.free.fr/blog/?p=106\n\n    if (length == 0) {\n      return -1 - offset;\n    }\n    int min = offset, max = offset + length - 1;\n    int minVal = getAssociatedDocuments()[min].getDocument().getDocumentNumber();\n    int maxVal = getAssociatedDocuments()[max].getDocument().getDocumentNumber();\n\n\n    int nPreviousSteps = 0;\n\n    for (; ;) {\n\n      // be careful not to compute key - minVal, for there might be an integer overflow.\n      if (target <= minVal) return target == minVal ? min : -1 - min;\n      if (target >= maxVal) return target == maxVal ? max : -2 - max;\n\n      assert min != max;\n\n      int pivot;\n      // A typical binarySearch algorithm uses pivot = (min + max) / 2.\n      // The pivot we use here tries to be smarter and to choose a pivot close to the expectable location of the key.\n      // This reduces dramatically the number of steps needed to get to the key.\n      // However, it does not work well with a logarithmic distribution of values, for instance.\n      // When the key is not found quickly the smart way, we switch to the standard pivot.\n      if (nPreviousSteps > 2) {\n        pivot = (min + max) >> 1;\n        // stop increasing nPreviousSteps from now on\n      } else {\n        // NOTE: We cannot do the following operations in int precision, because there might be overflows.\n        //       long operations are slower than float operations with the hardware this was tested on (intel core duo 2, JVM 1.6.0).\n        //       Overall, using float proved to be the safest and fastest approach.\n        pivot = min + (int) ((target - (float) minVal) / (maxVal - (float) minVal) * (max - min));\n        nPreviousSteps++;\n      }\n\n      int pivotVal = getAssociatedDocuments()[pivot].getDocument().getDocumentNumber();\n\n      // NOTE: do not store key - pivotVal because of overflows\n      if (target > pivotVal) {\n        min = pivot + 1;\n        max--;\n      } else if (target == pivotVal) {\n        return pivot;\n      } else {\n        min++;\n        max = pivot - 1;\n      }\n      maxVal = getAssociatedDocuments()[max].getDocument().getDocumentNumber();\n      minVal = getAssociatedDocuments()[min].getDocument().getDocumentNumber();\n    }\n  }\n\n","sourceOld":"  /**\n   * @param target value to search for in the array\n   * @param offset index of the first valid value in the array\n   * @param length number of valid values in the array\n   * @return index of an occurrence of key in array, or -(insertionIndex + 1) if key is not contained in array (<i>insertionIndex</i> is then the index at which key could be inserted).\n   */\n  public int binarySearchAssociatedDocuments(int target, int offset, int length) {\n\n    // implementation originally from http://ochafik.free.fr/blog/?p=106\n\n    if (length == 0) {\n      return -1 - offset;\n    }\n    int min = offset, max = offset + length - 1;\n    int minVal = getAssociatedDocuments()[min].getDocument().getDocumentNumber();\n    int maxVal = getAssociatedDocuments()[max].getDocument().getDocumentNumber();\n\n\n    int nPreviousSteps = 0;\n\n    for (; ;) {\n\n      // be careful not to compute key - minVal, for there might be an integer overflow.\n      if (target <= minVal) return target == minVal ? min : -1 - min;\n      if (target >= maxVal) return target == maxVal ? max : -2 - max;\n\n      assert min != max;\n\n      int pivot;\n      // A typical binarySearch algorithm uses pivot = (min + max) / 2.\n      // The pivot we use here tries to be smarter and to choose a pivot close to the expectable location of the key.\n      // This reduces dramatically the number of steps needed to get to the key.\n      // However, it does not work well with a logarithmic distribution of values, for instance.\n      // When the key is not found quickly the smart way, we switch to the standard pivot.\n      if (nPreviousSteps > 2) {\n        pivot = (min + max) >> 1;\n        // stop increasing nPreviousSteps from now on\n      } else {\n        // NOTE: We cannot do the following operations in int precision, because there might be overflows.\n        //       long operations are slower than float operations with the hardware this was tested on (intel core duo 2, JVM 1.6.0).\n        //       Overall, using float proved to be the safest and fastest approach.\n        pivot = min + (int) ((target - (float) minVal) / (maxVal - (float) minVal) * (max - min));\n        nPreviousSteps++;\n      }\n\n      int pivotVal = getAssociatedDocuments()[pivot].getDocument().getDocumentNumber();\n\n      // NOTE: do not store key - pivotVal because of overflows\n      if (target > pivotVal) {\n        min = pivot + 1;\n        max--;\n      } else if (target == pivotVal) {\n        return pivot;\n      } else {\n        min++;\n        max = pivot - 1;\n      }\n      maxVal = getAssociatedDocuments()[max].getDocument().getDocumentNumber();\n      minVal = getAssociatedDocuments()[min].getDocument().getDocumentNumber();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedTerm#binarySearchAssociatedDocuments(int,int,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * @param target value to search for in the array\n   * @param offset index of the first valid value in the array\n   * @param length number of valid values in the array\n   * @return index of an occurrence of key in array, or -(insertionIndex + 1) if key is not contained in array (<i>insertionIndex</i> is then the index at which key could be inserted).\n   */\n  public int binarySearchAssociatedDocuments(int target, int offset, int length) {\n\n    // implementation originally from http://ochafik.free.fr/blog/?p=106\n\n    if (length == 0) {\n      return -1 - offset;\n    }\n    int min = offset, max = offset + length - 1;\n    int minVal = getAssociatedDocuments()[min].getDocument().getDocumentNumber();\n    int maxVal = getAssociatedDocuments()[max].getDocument().getDocumentNumber();\n\n\n    int nPreviousSteps = 0;\n\n    for (; ;) {\n\n      // be careful not to compute key - minVal, for there might be an integer overflow.\n      if (target <= minVal) return target == minVal ? min : -1 - min;\n      if (target >= maxVal) return target == maxVal ? max : -2 - max;\n\n      assert min != max;\n\n      int pivot;\n      // A typical binarySearch algorithm uses pivot = (min + max) / 2.\n      // The pivot we use here tries to be smarter and to choose a pivot close to the expectable location of the key.\n      // This reduces dramatically the number of steps needed to get to the key.\n      // However, it does not work well with a logarithmic distribution of values, for instance.\n      // When the key is not found quickly the smart way, we switch to the standard pivot.\n      if (nPreviousSteps > 2) {\n        pivot = (min + max) >> 1;\n        // stop increasing nPreviousSteps from now on\n      } else {\n        // NOTE: We cannot do the following operations in int precision, because there might be overflows.\n        //       long operations are slower than float operations with the hardware this was tested on (intel core duo 2, JVM 1.6.0).\n        //       Overall, using float proved to be the safest and fastest approach.\n        pivot = min + (int) ((target - (float) minVal) / (maxVal - (float) minVal) * (max - min));\n        nPreviousSteps++;\n      }\n\n      int pivotVal = getAssociatedDocuments()[pivot].getDocument().getDocumentNumber();\n\n      // NOTE: do not store key - pivotVal because of overflows\n      if (target > pivotVal) {\n        min = pivot + 1;\n        max--;\n      } else if (target == pivotVal) {\n        return pivot;\n      } else {\n        min++;\n        max = pivot - 1;\n      }\n      maxVal = getAssociatedDocuments()[max].getDocument().getDocumentNumber();\n      minVal = getAssociatedDocuments()[min].getDocument().getDocumentNumber();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc749c053615f5871f3b95715fe292f34e70a53"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"3cc749c053615f5871f3b95715fe292f34e70a53":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["3cc749c053615f5871f3b95715fe292f34e70a53"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}