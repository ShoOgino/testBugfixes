{"path":"lucene/core/src/java/org/apache/lucene/index/Terms#getMax().mjava","commits":[{"id":"0974f33be0e2189e71f36b67f1017f4072b1a126","date":1398347867,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#getMax().mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the largest term (in lexicographic order) in the field. \n   *  Note that, just like other term measures, this measure does not \n   *  take deleted documents into account. */\n  @SuppressWarnings(\"fallthrough\")\n  public BytesRef getMax() throws IOException {\n    long size = size();\n    \n    if (size == 0) {\n      // empty: only possible from a FilteredTermsEnum...\n      return null;\n    } else if (size >= 0) {\n      // try to seek-by-ord\n      try {\n        TermsEnum iterator = iterator(null);\n        iterator.seekExact(size - 1);\n        return iterator.term();\n      } catch (UnsupportedOperationException e) {\n        // ok\n      }\n    }\n    \n    // otherwise: binary search\n    TermsEnum iterator = iterator(null);\n    BytesRef v = iterator.next();\n    if (v == null) {\n      // empty: only possible from a FilteredTermsEnum...\n      return v;\n    }\n\n    BytesRef scratch = new BytesRef(1);\n\n    scratch.length = 1;\n\n    // Iterates over digits:\n    while (true) {\n\n      int low = 0;\n      int high = 256;\n\n      // Binary search current digit to find the highest\n      // digit before END:\n      while (low != high) {\n        int mid = (low+high) >>> 1;\n        scratch.bytes[scratch.length-1] = (byte) mid;\n        if (iterator.seekCeil(scratch) == TermsEnum.SeekStatus.END) {\n          // Scratch was too high\n          if (mid == 0) {\n            scratch.length--;\n            return scratch;\n          }\n          high = mid;\n        } else {\n          // Scratch was too low; there is at least one term\n          // still after it:\n          if (low == mid) {\n            break;\n          }\n          low = mid;\n        }\n      }\n\n      // Recurse to next digit:\n      scratch.length++;\n      scratch.grow(scratch.length);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f890447ef156e598bffbdc5aab15a68b458c3612","date":1398350662,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#getMax().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#getMax().mjava","sourceNew":"  /** Returns the largest term (in lexicographic order) in the field. \n   *  Note that, just like other term measures, this measure does not \n   *  take deleted documents into account.  This returns\n   *  null when there are no terms. */\n  @SuppressWarnings(\"fallthrough\")\n  public BytesRef getMax() throws IOException {\n    long size = size();\n    \n    if (size == 0) {\n      // empty: only possible from a FilteredTermsEnum...\n      return null;\n    } else if (size >= 0) {\n      // try to seek-by-ord\n      try {\n        TermsEnum iterator = iterator(null);\n        iterator.seekExact(size - 1);\n        return iterator.term();\n      } catch (UnsupportedOperationException e) {\n        // ok\n      }\n    }\n    \n    // otherwise: binary search\n    TermsEnum iterator = iterator(null);\n    BytesRef v = iterator.next();\n    if (v == null) {\n      // empty: only possible from a FilteredTermsEnum...\n      return v;\n    }\n\n    BytesRef scratch = new BytesRef(1);\n\n    scratch.length = 1;\n\n    // Iterates over digits:\n    while (true) {\n\n      int low = 0;\n      int high = 256;\n\n      // Binary search current digit to find the highest\n      // digit before END:\n      while (low != high) {\n        int mid = (low+high) >>> 1;\n        scratch.bytes[scratch.length-1] = (byte) mid;\n        if (iterator.seekCeil(scratch) == TermsEnum.SeekStatus.END) {\n          // Scratch was too high\n          if (mid == 0) {\n            scratch.length--;\n            return scratch;\n          }\n          high = mid;\n        } else {\n          // Scratch was too low; there is at least one term\n          // still after it:\n          if (low == mid) {\n            break;\n          }\n          low = mid;\n        }\n      }\n\n      // Recurse to next digit:\n      scratch.length++;\n      scratch.grow(scratch.length);\n    }\n  }\n\n","sourceOld":"  /** Returns the largest term (in lexicographic order) in the field. \n   *  Note that, just like other term measures, this measure does not \n   *  take deleted documents into account. */\n  @SuppressWarnings(\"fallthrough\")\n  public BytesRef getMax() throws IOException {\n    long size = size();\n    \n    if (size == 0) {\n      // empty: only possible from a FilteredTermsEnum...\n      return null;\n    } else if (size >= 0) {\n      // try to seek-by-ord\n      try {\n        TermsEnum iterator = iterator(null);\n        iterator.seekExact(size - 1);\n        return iterator.term();\n      } catch (UnsupportedOperationException e) {\n        // ok\n      }\n    }\n    \n    // otherwise: binary search\n    TermsEnum iterator = iterator(null);\n    BytesRef v = iterator.next();\n    if (v == null) {\n      // empty: only possible from a FilteredTermsEnum...\n      return v;\n    }\n\n    BytesRef scratch = new BytesRef(1);\n\n    scratch.length = 1;\n\n    // Iterates over digits:\n    while (true) {\n\n      int low = 0;\n      int high = 256;\n\n      // Binary search current digit to find the highest\n      // digit before END:\n      while (low != high) {\n        int mid = (low+high) >>> 1;\n        scratch.bytes[scratch.length-1] = (byte) mid;\n        if (iterator.seekCeil(scratch) == TermsEnum.SeekStatus.END) {\n          // Scratch was too high\n          if (mid == 0) {\n            scratch.length--;\n            return scratch;\n          }\n          high = mid;\n        } else {\n          // Scratch was too low; there is at least one term\n          // still after it:\n          if (low == mid) {\n            break;\n          }\n          low = mid;\n        }\n      }\n\n      // Recurse to next digit:\n      scratch.length++;\n      scratch.grow(scratch.length);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#getMax().mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the largest term (in lexicographic order) in the field. \n   *  Note that, just like other term measures, this measure does not \n   *  take deleted documents into account.  This returns\n   *  null when there are no terms. */\n  @SuppressWarnings(\"fallthrough\")\n  public BytesRef getMax() throws IOException {\n    long size = size();\n    \n    if (size == 0) {\n      // empty: only possible from a FilteredTermsEnum...\n      return null;\n    } else if (size >= 0) {\n      // try to seek-by-ord\n      try {\n        TermsEnum iterator = iterator(null);\n        iterator.seekExact(size - 1);\n        return iterator.term();\n      } catch (UnsupportedOperationException e) {\n        // ok\n      }\n    }\n    \n    // otherwise: binary search\n    TermsEnum iterator = iterator(null);\n    BytesRef v = iterator.next();\n    if (v == null) {\n      // empty: only possible from a FilteredTermsEnum...\n      return v;\n    }\n\n    BytesRef scratch = new BytesRef(1);\n\n    scratch.length = 1;\n\n    // Iterates over digits:\n    while (true) {\n\n      int low = 0;\n      int high = 256;\n\n      // Binary search current digit to find the highest\n      // digit before END:\n      while (low != high) {\n        int mid = (low+high) >>> 1;\n        scratch.bytes[scratch.length-1] = (byte) mid;\n        if (iterator.seekCeil(scratch) == TermsEnum.SeekStatus.END) {\n          // Scratch was too high\n          if (mid == 0) {\n            scratch.length--;\n            return scratch;\n          }\n          high = mid;\n        } else {\n          // Scratch was too low; there is at least one term\n          // still after it:\n          if (low == mid) {\n            break;\n          }\n          low = mid;\n        }\n      }\n\n      // Recurse to next digit:\n      scratch.length++;\n      scratch.grow(scratch.length);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#getMax().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#getMax().mjava","sourceNew":"  /** Returns the largest term (in lexicographic order) in the field. \n   *  Note that, just like other term measures, this measure does not \n   *  take deleted documents into account.  This returns\n   *  null when there are no terms. */\n  @SuppressWarnings(\"fallthrough\")\n  public BytesRef getMax() throws IOException {\n    long size = size();\n    \n    if (size == 0) {\n      // empty: only possible from a FilteredTermsEnum...\n      return null;\n    } else if (size >= 0) {\n      // try to seek-by-ord\n      try {\n        TermsEnum iterator = iterator(null);\n        iterator.seekExact(size - 1);\n        return iterator.term();\n      } catch (UnsupportedOperationException e) {\n        // ok\n      }\n    }\n    \n    // otherwise: binary search\n    TermsEnum iterator = iterator(null);\n    BytesRef v = iterator.next();\n    if (v == null) {\n      // empty: only possible from a FilteredTermsEnum...\n      return v;\n    }\n\n    BytesRefBuilder scratch = new BytesRefBuilder();\n    scratch.append((byte) 0);\n\n    // Iterates over digits:\n    while (true) {\n\n      int low = 0;\n      int high = 256;\n\n      // Binary search current digit to find the highest\n      // digit before END:\n      while (low != high) {\n        int mid = (low+high) >>> 1;\n        scratch.setByteAt(scratch.length()-1, (byte) mid);\n        if (iterator.seekCeil(scratch.get()) == TermsEnum.SeekStatus.END) {\n          // Scratch was too high\n          if (mid == 0) {\n            scratch.setLength(scratch.length() - 1);\n            return scratch.get();\n          }\n          high = mid;\n        } else {\n          // Scratch was too low; there is at least one term\n          // still after it:\n          if (low == mid) {\n            break;\n          }\n          low = mid;\n        }\n      }\n\n      // Recurse to next digit:\n      scratch.setLength(scratch.length() + 1);\n      scratch.grow(scratch.length());\n    }\n  }\n\n","sourceOld":"  /** Returns the largest term (in lexicographic order) in the field. \n   *  Note that, just like other term measures, this measure does not \n   *  take deleted documents into account.  This returns\n   *  null when there are no terms. */\n  @SuppressWarnings(\"fallthrough\")\n  public BytesRef getMax() throws IOException {\n    long size = size();\n    \n    if (size == 0) {\n      // empty: only possible from a FilteredTermsEnum...\n      return null;\n    } else if (size >= 0) {\n      // try to seek-by-ord\n      try {\n        TermsEnum iterator = iterator(null);\n        iterator.seekExact(size - 1);\n        return iterator.term();\n      } catch (UnsupportedOperationException e) {\n        // ok\n      }\n    }\n    \n    // otherwise: binary search\n    TermsEnum iterator = iterator(null);\n    BytesRef v = iterator.next();\n    if (v == null) {\n      // empty: only possible from a FilteredTermsEnum...\n      return v;\n    }\n\n    BytesRef scratch = new BytesRef(1);\n\n    scratch.length = 1;\n\n    // Iterates over digits:\n    while (true) {\n\n      int low = 0;\n      int high = 256;\n\n      // Binary search current digit to find the highest\n      // digit before END:\n      while (low != high) {\n        int mid = (low+high) >>> 1;\n        scratch.bytes[scratch.length-1] = (byte) mid;\n        if (iterator.seekCeil(scratch) == TermsEnum.SeekStatus.END) {\n          // Scratch was too high\n          if (mid == 0) {\n            scratch.length--;\n            return scratch;\n          }\n          high = mid;\n        } else {\n          // Scratch was too low; there is at least one term\n          // still after it:\n          if (low == mid) {\n            break;\n          }\n          low = mid;\n        }\n      }\n\n      // Recurse to next digit:\n      scratch.length++;\n      scratch.grow(scratch.length);\n    }\n  }\n\n","bugFix":["0974f33be0e2189e71f36b67f1017f4072b1a126"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/Terms#getMax().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/Terms#getMax().mjava","sourceNew":"  /** Returns the largest term (in lexicographic order) in the field. \n   *  Note that, just like other term measures, this measure does not \n   *  take deleted documents into account.  This returns\n   *  null when there are no terms. */\n  @SuppressWarnings(\"fallthrough\")\n  public BytesRef getMax() throws IOException {\n    long size = size();\n    \n    if (size == 0) {\n      // empty: only possible from a FilteredTermsEnum...\n      return null;\n    } else if (size >= 0) {\n      // try to seek-by-ord\n      try {\n        TermsEnum iterator = iterator();\n        iterator.seekExact(size - 1);\n        return iterator.term();\n      } catch (UnsupportedOperationException e) {\n        // ok\n      }\n    }\n    \n    // otherwise: binary search\n    TermsEnum iterator = iterator();\n    BytesRef v = iterator.next();\n    if (v == null) {\n      // empty: only possible from a FilteredTermsEnum...\n      return v;\n    }\n\n    BytesRefBuilder scratch = new BytesRefBuilder();\n    scratch.append((byte) 0);\n\n    // Iterates over digits:\n    while (true) {\n\n      int low = 0;\n      int high = 256;\n\n      // Binary search current digit to find the highest\n      // digit before END:\n      while (low != high) {\n        int mid = (low+high) >>> 1;\n        scratch.setByteAt(scratch.length()-1, (byte) mid);\n        if (iterator.seekCeil(scratch.get()) == TermsEnum.SeekStatus.END) {\n          // Scratch was too high\n          if (mid == 0) {\n            scratch.setLength(scratch.length() - 1);\n            return scratch.get();\n          }\n          high = mid;\n        } else {\n          // Scratch was too low; there is at least one term\n          // still after it:\n          if (low == mid) {\n            break;\n          }\n          low = mid;\n        }\n      }\n\n      // Recurse to next digit:\n      scratch.setLength(scratch.length() + 1);\n      scratch.grow(scratch.length());\n    }\n  }\n\n","sourceOld":"  /** Returns the largest term (in lexicographic order) in the field. \n   *  Note that, just like other term measures, this measure does not \n   *  take deleted documents into account.  This returns\n   *  null when there are no terms. */\n  @SuppressWarnings(\"fallthrough\")\n  public BytesRef getMax() throws IOException {\n    long size = size();\n    \n    if (size == 0) {\n      // empty: only possible from a FilteredTermsEnum...\n      return null;\n    } else if (size >= 0) {\n      // try to seek-by-ord\n      try {\n        TermsEnum iterator = iterator(null);\n        iterator.seekExact(size - 1);\n        return iterator.term();\n      } catch (UnsupportedOperationException e) {\n        // ok\n      }\n    }\n    \n    // otherwise: binary search\n    TermsEnum iterator = iterator(null);\n    BytesRef v = iterator.next();\n    if (v == null) {\n      // empty: only possible from a FilteredTermsEnum...\n      return v;\n    }\n\n    BytesRefBuilder scratch = new BytesRefBuilder();\n    scratch.append((byte) 0);\n\n    // Iterates over digits:\n    while (true) {\n\n      int low = 0;\n      int high = 256;\n\n      // Binary search current digit to find the highest\n      // digit before END:\n      while (low != high) {\n        int mid = (low+high) >>> 1;\n        scratch.setByteAt(scratch.length()-1, (byte) mid);\n        if (iterator.seekCeil(scratch.get()) == TermsEnum.SeekStatus.END) {\n          // Scratch was too high\n          if (mid == 0) {\n            scratch.setLength(scratch.length() - 1);\n            return scratch.get();\n          }\n          high = mid;\n        } else {\n          // Scratch was too low; there is at least one term\n          // still after it:\n          if (low == mid) {\n            break;\n          }\n          low = mid;\n        }\n      }\n\n      // Recurse to next digit:\n      scratch.setLength(scratch.length() + 1);\n      scratch.grow(scratch.length());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"0974f33be0e2189e71f36b67f1017f4072b1a126":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f890447ef156e598bffbdc5aab15a68b458c3612"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["f890447ef156e598bffbdc5aab15a68b458c3612"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"f890447ef156e598bffbdc5aab15a68b458c3612":["0974f33be0e2189e71f36b67f1017f4072b1a126"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0974f33be0e2189e71f36b67f1017f4072b1a126":["f890447ef156e598bffbdc5aab15a68b458c3612"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0974f33be0e2189e71f36b67f1017f4072b1a126","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"f890447ef156e598bffbdc5aab15a68b458c3612":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}