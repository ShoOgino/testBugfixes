{"path":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformerFactory#createChildDocTransformer(String,SolrParams,SolrQueryRequest).mjava","commits":[{"id":"373ea6b2f051d2a56e8e78a5da11de7aa52ed399","date":1536159014,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformerFactory#createChildDocTransformer(String,SolrParams,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  private DocTransformer createChildDocTransformer(String field, SolrParams params, SolrQueryRequest req) {\n    SchemaField uniqueKeyField = req.getSchema().getUniqueKeyField();\n    if (uniqueKeyField == null) {\n      throw new SolrException( ErrorCode.BAD_REQUEST,\n          \" ChildDocTransformer requires the schema to have a uniqueKeyField.\" );\n    }\n    // Do we build a hierarchy or flat list of child docs (attached anonymously)?\n    boolean buildHierarchy = req.getSchema().hasExplicitField(NEST_PATH_FIELD_NAME);\n\n    String parentFilterStr = params.get( \"parentFilter\" );\n    BitSetProducer parentsFilter;\n    // TODO reuse org.apache.solr.search.join.BlockJoinParentQParser.getCachedFilter (uses a cache)\n    // TODO shouldn't we try to use the Solr filter cache, and then ideally implement\n    //  BitSetProducer over that?\n    // DocSet parentDocSet = req.getSearcher().getDocSet(parentFilterQuery);\n    // then return BitSetProducer with custom BitSet impl accessing the docSet\n    if (parentFilterStr == null) {\n      if (!buildHierarchy) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Parent filter should be sent as parentFilter=filterCondition\");\n      }\n      parentsFilter = new QueryBitSetProducer(rootFilter);\n    } else {\n      if(buildHierarchy) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Parent filter should not be sent when the schema is nested\");\n      }\n      parentsFilter = new QueryBitSetProducer(parseQuery(parentFilterStr, req,  \"parentFilter\"));\n    }\n\n    String childFilterStr = params.get( \"childFilter\" );\n    DocSet childDocSet;\n    if (childFilterStr == null) {\n      childDocSet = null;\n    } else {\n      if (buildHierarchy) {\n        childFilterStr = processPathHierarchyQueryString(childFilterStr);\n      }\n      Query childFilter = parseQuery(childFilterStr, req, \"childFilter\");\n      try {\n        childDocSet = req.getSearcher().getDocSet(childFilter);\n      } catch (IOException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n    }\n\n    String childReturnFields = params.get(\"fl\");\n    SolrReturnFields childSolrReturnFields;\n    if(childReturnFields != null) {\n      childSolrReturnFields = new SolrReturnFields(childReturnFields, req);\n    } else if(req.getSchema().getDefaultLuceneMatchVersion().major < 8) {\n      // ensure backwards for versions prior to SOLR 8\n      childSolrReturnFields = new SolrReturnFields();\n    } else {\n      childSolrReturnFields = new SolrReturnFields(req);\n    }\n\n    int limit = params.getInt( \"limit\", 10 );\n\n    return new ChildDocTransformer(field, parentsFilter, childDocSet, childSolrReturnFields, buildHierarchy, limit);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4ebb1536e19c5444665867a1657edcb497771adf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ebb1536e19c5444665867a1657edcb497771adf","date":1584507748,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformerFactory#createChildDocTransformer(String,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformerFactory#createChildDocTransformer(String,SolrParams,SolrQueryRequest).mjava","sourceNew":"  private DocTransformer createChildDocTransformer(String field, SolrParams params, SolrQueryRequest req) {\n    SchemaField uniqueKeyField = req.getSchema().getUniqueKeyField();\n    if (uniqueKeyField == null) {\n      throw new SolrException( ErrorCode.BAD_REQUEST,\n          \" ChildDocTransformer requires the schema to have a uniqueKeyField.\" );\n    }\n    // Do we build a hierarchy or flat list of child docs (attached anonymously)?\n    boolean buildHierarchy = req.getSchema().hasExplicitField(NEST_PATH_FIELD_NAME);\n\n    String parentFilterStr = params.get( \"parentFilter\" );\n    BitSetProducer parentsFilter;\n    // TODO reuse org.apache.solr.search.join.BlockJoinParentQParser.getCachedFilter (uses a cache)\n    // TODO shouldn't we try to use the Solr filter cache, and then ideally implement\n    //  BitSetProducer over that?\n    // DocSet parentDocSet = req.getSearcher().getDocSet(parentFilterQuery);\n    // then return BitSetProducer with custom BitSet impl accessing the docSet\n    if (parentFilterStr == null) {\n      if (!buildHierarchy) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Parent filter should be sent as parentFilter=filterCondition\");\n      }\n      parentsFilter = new QueryBitSetProducer(rootFilter);\n    } else {\n      if(buildHierarchy) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Parent filter should not be sent when the schema is nested\");\n      }\n      Query query = parseQuery(parentFilterStr, req, \"parentFilter\");\n      if (query == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid Parent filter '\" + parentFilterStr + \"', resolves to null\");\n      }\n      parentsFilter = new QueryBitSetProducer(query);\n    }\n\n    String childFilterStr = params.get( \"childFilter\" );\n    DocSet childDocSet;\n    if (childFilterStr == null) {\n      childDocSet = null;\n    } else {\n      if (buildHierarchy) {\n        childFilterStr = processPathHierarchyQueryString(childFilterStr);\n      }\n      Query childFilter = parseQuery(childFilterStr, req, \"childFilter\");\n      try {\n        childDocSet = req.getSearcher().getDocSet(childFilter);\n      } catch (IOException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n    }\n\n    String childReturnFields = params.get(\"fl\");\n    SolrReturnFields childSolrReturnFields;\n    if (childReturnFields != null) {\n      childSolrReturnFields = new SolrReturnFields(childReturnFields, req);\n    } else {\n      childSolrReturnFields = new SolrReturnFields(req);\n    }\n\n    int limit = params.getInt( \"limit\", 10 );\n\n    return new ChildDocTransformer(field, parentsFilter, childDocSet, childSolrReturnFields, buildHierarchy, limit);\n  }\n\n","sourceOld":"  private DocTransformer createChildDocTransformer(String field, SolrParams params, SolrQueryRequest req) {\n    SchemaField uniqueKeyField = req.getSchema().getUniqueKeyField();\n    if (uniqueKeyField == null) {\n      throw new SolrException( ErrorCode.BAD_REQUEST,\n          \" ChildDocTransformer requires the schema to have a uniqueKeyField.\" );\n    }\n    // Do we build a hierarchy or flat list of child docs (attached anonymously)?\n    boolean buildHierarchy = req.getSchema().hasExplicitField(NEST_PATH_FIELD_NAME);\n\n    String parentFilterStr = params.get( \"parentFilter\" );\n    BitSetProducer parentsFilter;\n    // TODO reuse org.apache.solr.search.join.BlockJoinParentQParser.getCachedFilter (uses a cache)\n    // TODO shouldn't we try to use the Solr filter cache, and then ideally implement\n    //  BitSetProducer over that?\n    // DocSet parentDocSet = req.getSearcher().getDocSet(parentFilterQuery);\n    // then return BitSetProducer with custom BitSet impl accessing the docSet\n    if (parentFilterStr == null) {\n      if (!buildHierarchy) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Parent filter should be sent as parentFilter=filterCondition\");\n      }\n      parentsFilter = new QueryBitSetProducer(rootFilter);\n    } else {\n      if(buildHierarchy) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Parent filter should not be sent when the schema is nested\");\n      }\n      parentsFilter = new QueryBitSetProducer(parseQuery(parentFilterStr, req,  \"parentFilter\"));\n    }\n\n    String childFilterStr = params.get( \"childFilter\" );\n    DocSet childDocSet;\n    if (childFilterStr == null) {\n      childDocSet = null;\n    } else {\n      if (buildHierarchy) {\n        childFilterStr = processPathHierarchyQueryString(childFilterStr);\n      }\n      Query childFilter = parseQuery(childFilterStr, req, \"childFilter\");\n      try {\n        childDocSet = req.getSearcher().getDocSet(childFilter);\n      } catch (IOException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n    }\n\n    String childReturnFields = params.get(\"fl\");\n    SolrReturnFields childSolrReturnFields;\n    if(childReturnFields != null) {\n      childSolrReturnFields = new SolrReturnFields(childReturnFields, req);\n    } else if(req.getSchema().getDefaultLuceneMatchVersion().major < 8) {\n      // ensure backwards for versions prior to SOLR 8\n      childSolrReturnFields = new SolrReturnFields();\n    } else {\n      childSolrReturnFields = new SolrReturnFields(req);\n    }\n\n    int limit = params.getInt( \"limit\", 10 );\n\n    return new ChildDocTransformer(field, parentsFilter, childDocSet, childSolrReturnFields, buildHierarchy, limit);\n  }\n\n","bugFix":["373ea6b2f051d2a56e8e78a5da11de7aa52ed399"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ebb1536e19c5444665867a1657edcb497771adf":["373ea6b2f051d2a56e8e78a5da11de7aa52ed399"],"373ea6b2f051d2a56e8e78a5da11de7aa52ed399":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4ebb1536e19c5444665867a1657edcb497771adf"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["373ea6b2f051d2a56e8e78a5da11de7aa52ed399"],"4ebb1536e19c5444665867a1657edcb497771adf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"373ea6b2f051d2a56e8e78a5da11de7aa52ed399":["4ebb1536e19c5444665867a1657edcb497771adf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}