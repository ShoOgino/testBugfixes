{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","commits":[{"id":"33861a7dcb2e09155c04cd7507f0ab74d5d102b6","date":1461397689,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {\n    // MHL\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09149ac46adf9772db58c67d18f37b1c5e109b34","date":1461566431,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","sourceNew":null,"sourceOld":"  @Override\n  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {\n    // MHL\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89","date":1461609218,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {\n    // Create the intersector\n    final EdgeIterator intersector = new IntersectorEdgeIterator(p, notablePoints, bounds);\n    // First, compute the bounds for the the plane\n    final XYZBounds xyzBounds = new XYZBounds();\n    p.recordBounds(planetModel, xyzBounds, bounds);\n    // Figure out which tree likely works best\n    final double xDelta = xyzBounds.getMaximumX() - xyzBounds.getMinimumX();\n    final double yDelta = xyzBounds.getMaximumY() - xyzBounds.getMinimumY();\n    final double zDelta = xyzBounds.getMaximumZ() - xyzBounds.getMinimumZ();\n    // Select the smallest range\n    if (xDelta <= yDelta && xDelta <= zDelta) {\n      // Drill down in x\n      return !xTree.traverse(intersector, xyzBounds.getMinimumX(), xyzBounds.getMaximumX());\n    } else if (yDelta <= xDelta && yDelta <= zDelta) {\n      // Drill down in y\n      return !yTree.traverse(intersector, xyzBounds.getMinimumY(), xyzBounds.getMaximumY());\n    } else if (zDelta <= xDelta && zDelta <= yDelta) {\n      // Drill down in z\n      return !zTree.traverse(intersector, xyzBounds.getMinimumZ(), xyzBounds.getMaximumZ());\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a","date":1461845562,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","sourceNew":"  @Override\n  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {\n    // Create the intersector\n    final EdgeIterator intersector = new IntersectorEdgeIterator(p, notablePoints, bounds);\n    // First, compute the bounds for the the plane\n    final XYZBounds xyzBounds = new XYZBounds();\n    p.recordBounds(planetModel, xyzBounds, bounds);\n    for (final GeoPoint point : notablePoints) {\n      xyzBounds.addPoint(point);\n    }\n    // Figure out which tree likely works best\n    final double xDelta = xyzBounds.getMaximumX() - xyzBounds.getMinimumX();\n    final double yDelta = xyzBounds.getMaximumY() - xyzBounds.getMinimumY();\n    final double zDelta = xyzBounds.getMaximumZ() - xyzBounds.getMinimumZ();\n    // Select the smallest range\n    if (xDelta <= yDelta && xDelta <= zDelta) {\n      // Drill down in x\n      return !xTree.traverse(intersector, xyzBounds.getMinimumX(), xyzBounds.getMaximumX());\n    } else if (yDelta <= xDelta && yDelta <= zDelta) {\n      // Drill down in y\n      return !yTree.traverse(intersector, xyzBounds.getMinimumY(), xyzBounds.getMaximumY());\n    } else if (zDelta <= xDelta && zDelta <= yDelta) {\n      // Drill down in z\n      return !zTree.traverse(intersector, xyzBounds.getMinimumZ(), xyzBounds.getMaximumZ());\n    }\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {\n    // Create the intersector\n    final EdgeIterator intersector = new IntersectorEdgeIterator(p, notablePoints, bounds);\n    // First, compute the bounds for the the plane\n    final XYZBounds xyzBounds = new XYZBounds();\n    p.recordBounds(planetModel, xyzBounds, bounds);\n    // Figure out which tree likely works best\n    final double xDelta = xyzBounds.getMaximumX() - xyzBounds.getMinimumX();\n    final double yDelta = xyzBounds.getMaximumY() - xyzBounds.getMinimumY();\n    final double zDelta = xyzBounds.getMaximumZ() - xyzBounds.getMinimumZ();\n    // Select the smallest range\n    if (xDelta <= yDelta && xDelta <= zDelta) {\n      // Drill down in x\n      return !xTree.traverse(intersector, xyzBounds.getMinimumX(), xyzBounds.getMaximumX());\n    } else if (yDelta <= xDelta && yDelta <= zDelta) {\n      // Drill down in y\n      return !yTree.traverse(intersector, xyzBounds.getMinimumY(), xyzBounds.getMaximumY());\n    } else if (zDelta <= xDelta && zDelta <= yDelta) {\n      // Drill down in z\n      return !zTree.traverse(intersector, xyzBounds.getMinimumZ(), xyzBounds.getMaximumZ());\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {\n    // Create the intersector\n    final EdgeIterator intersector = new IntersectorEdgeIterator(p, notablePoints, bounds);\n    // First, compute the bounds for the the plane\n    final XYZBounds xyzBounds = new XYZBounds();\n    p.recordBounds(planetModel, xyzBounds, bounds);\n    for (final GeoPoint point : notablePoints) {\n      xyzBounds.addPoint(point);\n    }\n    // Figure out which tree likely works best\n    final double xDelta = xyzBounds.getMaximumX() - xyzBounds.getMinimumX();\n    final double yDelta = xyzBounds.getMaximumY() - xyzBounds.getMinimumY();\n    final double zDelta = xyzBounds.getMaximumZ() - xyzBounds.getMinimumZ();\n    // Select the smallest range\n    if (xDelta <= yDelta && xDelta <= zDelta) {\n      // Drill down in x\n      return !xTree.traverse(intersector, xyzBounds.getMinimumX(), xyzBounds.getMaximumX());\n    } else if (yDelta <= xDelta && yDelta <= zDelta) {\n      // Drill down in y\n      return !yTree.traverse(intersector, xyzBounds.getMinimumY(), xyzBounds.getMaximumY());\n    } else if (zDelta <= xDelta && zDelta <= yDelta) {\n      // Drill down in z\n      return !zTree.traverse(intersector, xyzBounds.getMinimumZ(), xyzBounds.getMaximumZ());\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {\n    // Create the intersector\n    final EdgeIterator intersector = new IntersectorEdgeIterator(p, notablePoints, bounds);\n    // First, compute the bounds for the the plane\n    final XYZBounds xyzBounds = new XYZBounds();\n    p.recordBounds(planetModel, xyzBounds, bounds);\n    for (final GeoPoint point : notablePoints) {\n      xyzBounds.addPoint(point);\n    }\n    // Figure out which tree likely works best\n    final double xDelta = xyzBounds.getMaximumX() - xyzBounds.getMinimumX();\n    final double yDelta = xyzBounds.getMaximumY() - xyzBounds.getMinimumY();\n    final double zDelta = xyzBounds.getMaximumZ() - xyzBounds.getMinimumZ();\n    // Select the smallest range\n    if (xDelta <= yDelta && xDelta <= zDelta) {\n      // Drill down in x\n      return !xTree.traverse(intersector, xyzBounds.getMinimumX(), xyzBounds.getMaximumX());\n    } else if (yDelta <= xDelta && yDelta <= zDelta) {\n      // Drill down in y\n      return !yTree.traverse(intersector, xyzBounds.getMinimumY(), xyzBounds.getMaximumY());\n    } else if (zDelta <= xDelta && zDelta <= yDelta) {\n      // Drill down in z\n      return !zTree.traverse(intersector, xyzBounds.getMinimumZ(), xyzBounds.getMaximumZ());\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44c3a4ebfa1a780298de8b00afc0722c16233080","date":1522505029,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#intersects(Plane,GeoPoint[],Membership...).mjava","sourceNew":"  @Override\n  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {\n    // Create the intersector\n    final EdgeIterator intersector = new IntersectorEdgeIterator(p, notablePoints, bounds);\n    // First, compute the bounds for the the plane\n    final XYZBounds xyzBounds = new XYZBounds();\n    p.recordBounds(planetModel, xyzBounds, bounds);\n    for (final GeoPoint point : notablePoints) {\n      xyzBounds.addPoint(point);\n    }\n    // If we have no bounds at all then the answer is \"false\"\n    if (xyzBounds.getMaximumX() == null || xyzBounds.getMinimumX() == null ||\n      xyzBounds.getMaximumY() == null || xyzBounds.getMinimumY() == null ||\n      xyzBounds.getMaximumZ() == null || xyzBounds.getMinimumZ() == null) {\n      return false;\n    }\n    // Figure out which tree likely works best\n    final double xDelta = xyzBounds.getMaximumX() - xyzBounds.getMinimumX();\n    final double yDelta = xyzBounds.getMaximumY() - xyzBounds.getMinimumY();\n    final double zDelta = xyzBounds.getMaximumZ() - xyzBounds.getMinimumZ();\n    // Select the smallest range\n    if (xDelta <= yDelta && xDelta <= zDelta) {\n      // Drill down in x\n      return !xTree.traverse(intersector, xyzBounds.getMinimumX(), xyzBounds.getMaximumX());\n    } else if (yDelta <= xDelta && yDelta <= zDelta) {\n      // Drill down in y\n      return !yTree.traverse(intersector, xyzBounds.getMinimumY(), xyzBounds.getMaximumY());\n    } else if (zDelta <= xDelta && zDelta <= yDelta) {\n      // Drill down in z\n      return !zTree.traverse(intersector, xyzBounds.getMinimumZ(), xyzBounds.getMaximumZ());\n    }\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean intersects(final Plane p, final GeoPoint[] notablePoints, final Membership... bounds) {\n    // Create the intersector\n    final EdgeIterator intersector = new IntersectorEdgeIterator(p, notablePoints, bounds);\n    // First, compute the bounds for the the plane\n    final XYZBounds xyzBounds = new XYZBounds();\n    p.recordBounds(planetModel, xyzBounds, bounds);\n    for (final GeoPoint point : notablePoints) {\n      xyzBounds.addPoint(point);\n    }\n    // Figure out which tree likely works best\n    final double xDelta = xyzBounds.getMaximumX() - xyzBounds.getMinimumX();\n    final double yDelta = xyzBounds.getMaximumY() - xyzBounds.getMinimumY();\n    final double zDelta = xyzBounds.getMaximumZ() - xyzBounds.getMinimumZ();\n    // Select the smallest range\n    if (xDelta <= yDelta && xDelta <= zDelta) {\n      // Drill down in x\n      return !xTree.traverse(intersector, xyzBounds.getMinimumX(), xyzBounds.getMaximumX());\n    } else if (yDelta <= xDelta && yDelta <= zDelta) {\n      // Drill down in y\n      return !yTree.traverse(intersector, xyzBounds.getMinimumY(), xyzBounds.getMaximumY());\n    } else if (zDelta <= xDelta && zDelta <= yDelta) {\n      // Drill down in z\n      return !zTree.traverse(intersector, xyzBounds.getMinimumZ(), xyzBounds.getMaximumZ());\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"33861a7dcb2e09155c04cd7507f0ab74d5d102b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"09149ac46adf9772db58c67d18f37b1c5e109b34":["33861a7dcb2e09155c04cd7507f0ab74d5d102b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["09149ac46adf9772db58c67d18f37b1c5e109b34"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"]},"commit2Childs":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"33861a7dcb2e09155c04cd7507f0ab74d5d102b6":["09149ac46adf9772db58c67d18f37b1c5e109b34"],"09149ac46adf9772db58c67d18f37b1c5e109b34":["116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["33861a7dcb2e09155c04cd7507f0ab74d5d102b6","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","55b50463286869f584cf849d1587a0fcd54d1dfa"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["44c3a4ebfa1a780298de8b00afc0722c16233080","55b50463286869f584cf849d1587a0fcd54d1dfa"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}