{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","sourceNew":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","sourceOld":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","sourceNew":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","sourceOld":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1","date":1517395742,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","sourceNew":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 1 : 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","sourceOld":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 0 : 1,\n              replicaType == Replica.Type.TLOG ? 0 : 1,\n              replicaType == Replica.Type.PULL ? 0 : 1\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ffc8d70d9f57a62a24c3dd15b66e353de935054","date":1533178472,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","sourceNew":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 1 : 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica of shard {}\", node, shard);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","sourceOld":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 1 : 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica\", node);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"deea3439de4f487ae553317e50d5d641ca386374","date":1537522941,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,ReplicaPosition).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","sourceNew":"  public static CreateReplica assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, ReplicaPosition replicaPosition) {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = replicaPosition.node;\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = replicaPosition.type;\n\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    log.info(\"Node Identified {} for creating new replica of shard {}\", node, shard);\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    return new CreateReplica(collection, shard, node, replicaType, coreName, coreNodeName);\n  }\n\n","sourceOld":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 1 : 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica of shard {}\", node, shard);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1fec8b37cbb6884a64d39565e9dd7b4522a0598","date":1537699559,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,ReplicaPosition).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#assignReplicaDetails(SolrCloudManager,ClusterState,ZkNodeProps,AtomicReference[PolicyHelper.SessionWrapper]).mjava","sourceNew":"  public static CreateReplica assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, ReplicaPosition replicaPosition) {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = replicaPosition.node;\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = replicaPosition.type;\n\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    log.info(\"Node Identified {} for creating new replica of shard {}\", node, shard);\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    return new CreateReplica(collection, shard, node, replicaType, coreName, coreNodeName);\n  }\n\n","sourceOld":"  public static ZkNodeProps assignReplicaDetails(SolrCloudManager cloudManager, ClusterState clusterState,\n                                                 ZkNodeProps message, AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper) throws IOException, InterruptedException {\n    boolean skipCreateReplicaInClusterState = message.getBool(SKIP_CREATE_REPLICA_IN_CLUSTER_STATE, false);\n\n    String collection = message.getStr(COLLECTION_PROP);\n    String node = message.getStr(CoreAdminParams.NODE);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String coreName = message.getStr(CoreAdminParams.NAME);\n    String coreNodeName = message.getStr(CoreAdminParams.CORE_NODE_NAME);\n    Replica.Type replicaType = Replica.Type.valueOf(message.getStr(ZkStateReader.REPLICA_TYPE, Replica.Type.NRT.name()).toUpperCase(Locale.ROOT));\n    if (StringUtils.isBlank(coreName)) {\n      coreName = message.getStr(CoreAdminParams.PROPERTY_PREFIX + CoreAdminParams.NAME);\n    }\n\n    DocCollection coll = clusterState.getCollection(collection);\n    if (coll == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + collection + \" does not exist\");\n    }\n    if (coll.getSlice(shard) == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Collection: \" + collection + \" shard: \" + shard + \" does not exist\");\n    }\n\n    // Kind of unnecessary, but it does put the logic of whether to override maxShardsPerNode in one place.\n    if (!skipCreateReplicaInClusterState) {\n      if (CloudUtil.usePolicyFramework(coll, cloudManager)) {\n        if (node == null) {\n          if(coll.getPolicyName() != null) message.getProperties().put(Policy.POLICY, coll.getPolicyName());\n          node = Assign.identifyNodes(cloudManager,\n              clusterState,\n              Collections.emptyList(),\n              collection,\n              message,\n              Collections.singletonList(shard),\n              replicaType == Replica.Type.NRT ? 1 : 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapper.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n      } else {\n        node = Assign.getNodesForNewReplicas(clusterState, collection, shard, 1, node,\n            cloudManager).get(0).nodeName;// TODO: use replica type in this logic too\n      }\n    }\n    log.info(\"Node Identified {} for creating new replica of shard {}\", node, shard);\n\n    if (!clusterState.liveNodesContain(node)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Node: \" + node + \" is not live\");\n    }\n    if (coreName == null) {\n      coreName = Assign.buildSolrCoreName(cloudManager.getDistribStateManager(), coll, shard, replicaType);\n    } else if (!skipCreateReplicaInClusterState) {\n      //Validate that the core name is unique in that collection\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          String replicaCoreName = replica.getStr(CORE_NAME_PROP);\n          if (coreName.equals(replicaCoreName)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Another replica with the same core name already exists\" +\n                \" for this collection\");\n          }\n        }\n      }\n    }\n    if (coreNodeName != null) {\n      message = message.plus(CoreAdminParams.CORE_NODE_NAME, coreNodeName);\n    }\n    message = message.plus(CoreAdminParams.NAME, coreName);\n    message = message.plus(CoreAdminParams.NODE, node);\n    return message;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1":["b94236357aaa22b76c10629851fe4e376e0cea82"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["2ffc8d70d9f57a62a24c3dd15b66e353de935054","deea3439de4f487ae553317e50d5d641ca386374"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"deea3439de4f487ae553317e50d5d641ca386374":["2ffc8d70d9f57a62a24c3dd15b66e353de935054"],"2ffc8d70d9f57a62a24c3dd15b66e353de935054":["135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1"],"135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1":["2ffc8d70d9f57a62a24c3dd15b66e353de935054"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"deea3439de4f487ae553317e50d5d641ca386374":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"2ffc8d70d9f57a62a24c3dd15b66e353de935054":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598","deea3439de4f487ae553317e50d5d641ca386374"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}