{"path":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],SolrCloudManager,ClusterState).mjava","commits":[{"id":"6397103f7076f0b5ee4edf5b3a63c750a072ff65","date":1510231708,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],SolrCloudManager,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],CoreContainer,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         SolrCloudManager cloudManager, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cloudManager, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         CoreContainer cc, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cc, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],SolrCloudManager,ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#ReplicaAssigner(List[Rule],Map[String,Integer],List,Map[String,Map[String,Integer]],List[String],SolrCloudManager,ClusterState).mjava","sourceNew":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         @SuppressWarnings({\"rawtypes\"})List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         SolrCloudManager cloudManager, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cloudManager, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param shardVsReplicaCount shard names vs no:of replicas required for each of those shards\n   * @param snitches            snitches details\n   * @param shardVsNodes        The current state of the system. can be an empty map if no nodes\n   *                            are created in this collection till now\n   */\n  public ReplicaAssigner(List<Rule> rules,\n                         Map<String, Integer> shardVsReplicaCount,\n                         List snitches,\n                         Map<String, Map<String, Integer>> shardVsNodes,\n                         List<String> participatingLiveNodes,\n                         SolrCloudManager cloudManager, ClusterState clusterState) {\n    this.rules = rules;\n    for (Rule rule : rules) tagNames.add(rule.tag.name);\n    this.shardVsReplicaCount = shardVsReplicaCount;\n    this.participatingLiveNodes = new ArrayList<>(participatingLiveNodes);\n    this.nodeVsTags = getTagsForNodes(cloudManager, snitches);\n    this.shardVsNodes = getDeepCopy(shardVsNodes, 2);\n\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        DocCollection coll = entry.getValue();\n        for (Slice slice : coll.getSlices()) {\n          for (Replica replica : slice.getReplicas()) {\n            AtomicInteger count = nodeVsCores.get(replica.getNodeName());\n            if (count == null) nodeVsCores.put(replica.getNodeName(), count = new AtomicInteger());\n            count.incrementAndGet();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6397103f7076f0b5ee4edf5b3a63c750a072ff65":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["6397103f7076f0b5ee4edf5b3a63c750a072ff65"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"]},"commit2Childs":{"6397103f7076f0b5ee4edf5b3a63c750a072ff65":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6397103f7076f0b5ee4edf5b3a63c750a072ff65"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}