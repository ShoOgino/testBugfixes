{"path":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","commits":[{"id":"84b6c001c19319635b53dd80ee9fc1ba9a5b4574","date":1213883214,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = true;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new HashMap<Token, String>(suggestions.size());\n    }\n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        NamedList suggestionList = new NamedList();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset(), tok.endOffset(), entry.getValue());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.fine(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fe24ba3350a1f7e19a0349838dc2722c743ee5aa","b65a5358ab784aed1eada0d344601b7d994ea64a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9371cd44a11f89652ff6c1b8b15cb2a94e550c42","date":1217595341,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = true;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new HashMap<Token, String>(suggestions.size());\n    }\n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset(), tok.endOffset(), entry.getValue());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.fine(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = true;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new HashMap<Token, String>(suggestions.size());\n    }\n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        NamedList suggestionList = new NamedList();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset(), tok.endOffset(), entry.getValue());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.fine(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe24ba3350a1f7e19a0349838dc2722c743ee5aa","date":1218737869,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = true;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.fine(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = true;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new HashMap<Token, String>(suggestions.size());\n    }\n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset(), tok.endOffset(), entry.getValue());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.fine(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":["84b6c001c19319635b53dd80ee9fc1ba9a5b4574"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = true;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = true;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.fine(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b275d6fe96a9c358f99b5f4904ff2579b334ec20","date":1240910645,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = true;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d48ad008b42264f401fa552a26024cc3961a318","date":1240920982,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b65a5358ab784aed1eada0d344601b7d994ea64a","date":1252448553,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap<Object> suggestionItem = new SimpleOrderedMap<Object>();\n            suggestionItem.add(\"frequency\", suggEntry.getValue());\n            suggestionItem.add(\"word\", suggEntry.getKey());\n            suggestionList.add(\"suggestion\", suggestionItem);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":["84b6c001c19319635b53dd80ee9fc1ba9a5b4574"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","pathOld":"src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.termBuffer(), 0, inputToken.termLength()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fe24ba3350a1f7e19a0349838dc2722c743ee5aa":["9371cd44a11f89652ff6c1b8b15cb2a94e550c42"],"84b6c001c19319635b53dd80ee9fc1ba9a5b4574":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"b275d6fe96a9c358f99b5f4904ff2579b334ec20":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"ad94625fb8d088209f46650c8097196fec67f00c":["b65a5358ab784aed1eada0d344601b7d994ea64a"],"b65a5358ab784aed1eada0d344601b7d994ea64a":["6d48ad008b42264f401fa552a26024cc3961a318"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["fe24ba3350a1f7e19a0349838dc2722c743ee5aa"],"9371cd44a11f89652ff6c1b8b15cb2a94e550c42":["84b6c001c19319635b53dd80ee9fc1ba9a5b4574"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6d48ad008b42264f401fa552a26024cc3961a318":["b275d6fe96a9c358f99b5f4904ff2579b334ec20"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe24ba3350a1f7e19a0349838dc2722c743ee5aa":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"84b6c001c19319635b53dd80ee9fc1ba9a5b4574":["9371cd44a11f89652ff6c1b8b15cb2a94e550c42"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["84b6c001c19319635b53dd80ee9fc1ba9a5b4574"],"b275d6fe96a9c358f99b5f4904ff2579b334ec20":["6d48ad008b42264f401fa552a26024cc3961a318"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"9371cd44a11f89652ff6c1b8b15cb2a94e550c42":["fe24ba3350a1f7e19a0349838dc2722c743ee5aa"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["b275d6fe96a9c358f99b5f4904ff2579b334ec20"],"b65a5358ab784aed1eada0d344601b7d994ea64a":["ad94625fb8d088209f46650c8097196fec67f00c"],"6d48ad008b42264f401fa552a26024cc3961a318":["b65a5358ab784aed1eada0d344601b7d994ea64a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}