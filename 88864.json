{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","commits":[{"id":"6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09","date":1492411712,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","pathOld":"/dev/null","sourceNew":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a taking time trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger-\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"326b5c746af092eb827c5c1accdab1b47fe0cf3c","date":1492433195,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","pathOld":"/dev/null","sourceNew":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a taking time trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger-\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ae77fc19f67fecb5b17339f978719030d96f8fc","date":1493794899,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","sourceNew":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a time taking trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger-\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n  }\n\n","sourceOld":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a taking time trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger-\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7699e9ae4550ba2a55335a64ae7de9d5d9de39e","date":1493894873,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","sourceNew":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a time taking trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n  }\n\n","sourceOld":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a time taking trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger-\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"009caa80830ac6369c42e5f6515405d686eabfee","date":1494487120,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","sourceNew":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a time taking trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n    // todo make the wait time configurable\n    actionThrottle = new ActionThrottle(\"action\", DEFAULT_MIN_MS_BETWEEN_ACTIONS);\n  }\n\n","sourceOld":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a time taking trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"464244264804e3f981bf1fb4b732516d8d62dbc2","date":1495736161,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers(SolrZkClient).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","sourceNew":"  public ScheduledTriggers(SolrZkClient zkClient) {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a time taking trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n    // todo make the wait time configurable\n    actionThrottle = new ActionThrottle(\"action\", DEFAULT_MIN_MS_BETWEEN_ACTIONS);\n    this.zkClient = zkClient;\n    queueStats = new Overseer.Stats();\n  }\n\n","sourceOld":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a time taking trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n    // todo make the wait time configurable\n    actionThrottle = new ActionThrottle(\"action\", DEFAULT_MIN_MS_BETWEEN_ACTIONS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5531f16a602ef350b6c9adfb08ebaa13a60fe3db","date":1495756318,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers(SolrZkClient).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#ScheduledTriggers().mjava","sourceNew":"  public ScheduledTriggers(SolrZkClient zkClient) {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a time taking trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n    // todo make the wait time configurable\n    actionThrottle = new ActionThrottle(\"action\", DEFAULT_MIN_MS_BETWEEN_ACTIONS);\n    this.zkClient = zkClient;\n    queueStats = new Overseer.Stats();\n  }\n\n","sourceOld":"  public ScheduledTriggers() {\n    // todo make the core pool size configurable\n    // it is important to use more than one because a time taking trigger can starve other scheduled triggers\n    // ideally we should have as many core threads as the number of triggers but firstly, we don't know beforehand\n    // how many triggers we have and secondly, that many threads will always be instantiated and kept around idle\n    // so it is wasteful as well. Hopefully 4 is a good compromise.\n    scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(4,\n        new DefaultSolrThreadFactory(\"ScheduledTrigger\"));\n    scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true);\n    scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    actionExecutor = ExecutorUtil.newMDCAwareSingleThreadExecutor(new DefaultSolrThreadFactory(\"AutoscalingActionExecutor\"));\n    // todo make the wait time configurable\n    actionThrottle = new ActionThrottle(\"action\", DEFAULT_MIN_MS_BETWEEN_ACTIONS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a7699e9ae4550ba2a55335a64ae7de9d5d9de39e":["6ae77fc19f67fecb5b17339f978719030d96f8fc"],"5531f16a602ef350b6c9adfb08ebaa13a60fe3db":["009caa80830ac6369c42e5f6515405d686eabfee","464244264804e3f981bf1fb4b732516d8d62dbc2"],"009caa80830ac6369c42e5f6515405d686eabfee":["a7699e9ae4550ba2a55335a64ae7de9d5d9de39e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ae77fc19f67fecb5b17339f978719030d96f8fc":["326b5c746af092eb827c5c1accdab1b47fe0cf3c"],"464244264804e3f981bf1fb4b732516d8d62dbc2":["009caa80830ac6369c42e5f6515405d686eabfee"],"326b5c746af092eb827c5c1accdab1b47fe0cf3c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09":["326b5c746af092eb827c5c1accdab1b47fe0cf3c"],"a7699e9ae4550ba2a55335a64ae7de9d5d9de39e":["009caa80830ac6369c42e5f6515405d686eabfee"],"5531f16a602ef350b6c9adfb08ebaa13a60fe3db":[],"009caa80830ac6369c42e5f6515405d686eabfee":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db","464244264804e3f981bf1fb4b732516d8d62dbc2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09","326b5c746af092eb827c5c1accdab1b47fe0cf3c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6ae77fc19f67fecb5b17339f978719030d96f8fc":["a7699e9ae4550ba2a55335a64ae7de9d5d9de39e"],"464244264804e3f981bf1fb4b732516d8d62dbc2":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db"],"326b5c746af092eb827c5c1accdab1b47fe0cf3c":["6ae77fc19f67fecb5b17339f978719030d96f8fc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}