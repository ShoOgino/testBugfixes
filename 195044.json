{"path":"modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.MV#collect(int).mjava","commits":[{"id":"369f44b665973d5aa5fc7d0f2a75ffad475d21ee","date":1331157468,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.MV#collect(int).mjava","pathOld":"/dev/null","sourceNew":"    public void collect(int doc) throws IOException {\n      int groupOrd = groupFieldTermsIndex.getOrd(doc);\n      reuse = facetFieldDocTermOrds.lookup(doc, reuse);\n      int chunk;\n      boolean first = true;\n      int[] buffer = new int[5];\n      do {\n        chunk = reuse.read(buffer);\n        if (first && chunk == 0) {\n          chunk = 1;\n          buffer[0] = facetFieldDocTermOrds.numTerms(); // this facet ord is reserved for docs not containing facet field.\n        }\n        first = false;\n\n        for (int pos = 0; pos < chunk; pos++) {\n          int facetOrd = buffer[pos];\n          if (facetOrd < startFacetOrd || facetOrd >= endFacetOrd) {\n            continue;\n          }\n\n          int segmentGroupedFacetsIndex = (groupOrd * (facetFieldDocTermOrds.numTerms() + 1)) + facetOrd;\n          if (segmentGroupedFacetHits.exists(segmentGroupedFacetsIndex)) {\n            continue;\n          }\n\n          segmentTotalCount++;\n          segmentFacetCounts[facetOrd]++;\n\n          segmentGroupedFacetHits.put(segmentGroupedFacetsIndex);\n          groupedFacetHits.add(\n              new GroupedFacetHit(\n                  groupOrd == 0 ? null : groupFieldTermsIndex.lookup(groupOrd, new BytesRef()),\n                  facetOrd == facetFieldDocTermOrds.numTerms() ? null : BytesRef.deepCopyOf(facetFieldDocTermOrds.lookupTerm(facetOrdTermsEnum, facetOrd))\n              )\n          );\n        }\n      } while (chunk >= buffer.length);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4","0870713be686b7dbb084bfcef739b585aa13e793","0af46d298d8d31b80331276f103009ca4bc08bc2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.MV#collect(int).mjava","pathOld":"/dev/null","sourceNew":"    public void collect(int doc) throws IOException {\n      int groupOrd = groupFieldTermsIndex.getOrd(doc);\n      reuse = facetFieldDocTermOrds.lookup(doc, reuse);\n      int chunk;\n      boolean first = true;\n      int[] buffer = new int[5];\n      do {\n        chunk = reuse.read(buffer);\n        if (first && chunk == 0) {\n          chunk = 1;\n          buffer[0] = facetFieldDocTermOrds.numTerms(); // this facet ord is reserved for docs not containing facet field.\n        }\n        first = false;\n\n        for (int pos = 0; pos < chunk; pos++) {\n          int facetOrd = buffer[pos];\n          if (facetOrd < startFacetOrd || facetOrd >= endFacetOrd) {\n            continue;\n          }\n\n          int segmentGroupedFacetsIndex = (groupOrd * (facetFieldDocTermOrds.numTerms() + 1)) + facetOrd;\n          if (segmentGroupedFacetHits.exists(segmentGroupedFacetsIndex)) {\n            continue;\n          }\n\n          segmentTotalCount++;\n          segmentFacetCounts[facetOrd]++;\n\n          segmentGroupedFacetHits.put(segmentGroupedFacetsIndex);\n          groupedFacetHits.add(\n              new GroupedFacetHit(\n                  groupOrd == 0 ? null : groupFieldTermsIndex.lookup(groupOrd, new BytesRef()),\n                  facetOrd == facetFieldDocTermOrds.numTerms() ? null : BytesRef.deepCopyOf(facetFieldDocTermOrds.lookupTerm(facetOrdTermsEnum, facetOrd))\n              )\n          );\n        }\n      } while (chunk >= buffer.length);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0af46d298d8d31b80331276f103009ca4bc08bc2","date":1332263105,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.MV#collect(int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.MV#collect(int).mjava","sourceNew":"    public void collect(int doc) throws IOException {\n      int groupOrd = groupFieldTermsIndex.getOrd(doc);\n      if (facetOrdTermsEnum != null) {\n        reuse = facetFieldDocTermOrds.lookup(doc, reuse);\n      }\n      int chunk;\n      boolean first = true;\n      int[] buffer = new int[5];\n      do {\n        chunk = reuse != null ? reuse.read(buffer) : 0;\n        if (first && chunk == 0) {\n          chunk = 1;\n          buffer[0] = facetFieldDocTermOrds.numTerms(); // this facet ord is reserved for docs not containing facet field.\n        }\n        first = false;\n\n        for (int pos = 0; pos < chunk; pos++) {\n          int facetOrd = buffer[pos];\n          if (facetOrd < startFacetOrd || facetOrd >= endFacetOrd) {\n            continue;\n          }\n\n          int segmentGroupedFacetsIndex = (groupOrd * (facetFieldDocTermOrds.numTerms() + 1)) + facetOrd;\n          if (segmentGroupedFacetHits.exists(segmentGroupedFacetsIndex)) {\n            continue;\n          }\n\n          segmentTotalCount++;\n          segmentFacetCounts[facetOrd]++;\n\n          segmentGroupedFacetHits.put(segmentGroupedFacetsIndex);\n          groupedFacetHits.add(\n              new GroupedFacetHit(\n                  groupOrd == 0 ? null : groupFieldTermsIndex.lookup(groupOrd, new BytesRef()),\n                  facetOrd == facetFieldDocTermOrds.numTerms() ? null : BytesRef.deepCopyOf(facetFieldDocTermOrds.lookupTerm(facetOrdTermsEnum, facetOrd))\n              )\n          );\n        }\n      } while (chunk >= buffer.length);\n    }\n\n","sourceOld":"    public void collect(int doc) throws IOException {\n      int groupOrd = groupFieldTermsIndex.getOrd(doc);\n      reuse = facetFieldDocTermOrds.lookup(doc, reuse);\n      int chunk;\n      boolean first = true;\n      int[] buffer = new int[5];\n      do {\n        chunk = reuse.read(buffer);\n        if (first && chunk == 0) {\n          chunk = 1;\n          buffer[0] = facetFieldDocTermOrds.numTerms(); // this facet ord is reserved for docs not containing facet field.\n        }\n        first = false;\n\n        for (int pos = 0; pos < chunk; pos++) {\n          int facetOrd = buffer[pos];\n          if (facetOrd < startFacetOrd || facetOrd >= endFacetOrd) {\n            continue;\n          }\n\n          int segmentGroupedFacetsIndex = (groupOrd * (facetFieldDocTermOrds.numTerms() + 1)) + facetOrd;\n          if (segmentGroupedFacetHits.exists(segmentGroupedFacetsIndex)) {\n            continue;\n          }\n\n          segmentTotalCount++;\n          segmentFacetCounts[facetOrd]++;\n\n          segmentGroupedFacetHits.put(segmentGroupedFacetsIndex);\n          groupedFacetHits.add(\n              new GroupedFacetHit(\n                  groupOrd == 0 ? null : groupFieldTermsIndex.lookup(groupOrd, new BytesRef()),\n                  facetOrd == facetFieldDocTermOrds.numTerms() ? null : BytesRef.deepCopyOf(facetFieldDocTermOrds.lookupTerm(facetOrdTermsEnum, facetOrd))\n              )\n          );\n        }\n      } while (chunk >= buffer.length);\n    }\n\n","bugFix":["369f44b665973d5aa5fc7d0f2a75ffad475d21ee"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.MV#collect(int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.MV#collect(int).mjava","sourceNew":"    public void collect(int doc) throws IOException {\n      int groupOrd = groupFieldTermsIndex.getOrd(doc);\n      if (facetOrdTermsEnum != null) {\n        reuse = facetFieldDocTermOrds.lookup(doc, reuse);\n      }\n      int chunk;\n      boolean first = true;\n      int[] buffer = new int[5];\n      do {\n        chunk = reuse != null ? reuse.read(buffer) : 0;\n        if (first && chunk == 0) {\n          chunk = 1;\n          buffer[0] = facetFieldDocTermOrds.numTerms(); // this facet ord is reserved for docs not containing facet field.\n        }\n        first = false;\n\n        for (int pos = 0; pos < chunk; pos++) {\n          int facetOrd = buffer[pos];\n          if (facetOrd < startFacetOrd || facetOrd >= endFacetOrd) {\n            continue;\n          }\n\n          int segmentGroupedFacetsIndex = (groupOrd * (facetFieldDocTermOrds.numTerms() + 1)) + facetOrd;\n          if (segmentGroupedFacetHits.exists(segmentGroupedFacetsIndex)) {\n            continue;\n          }\n\n          segmentTotalCount++;\n          segmentFacetCounts[facetOrd]++;\n\n          segmentGroupedFacetHits.put(segmentGroupedFacetsIndex);\n          groupedFacetHits.add(\n              new GroupedFacetHit(\n                  groupOrd == 0 ? null : groupFieldTermsIndex.lookup(groupOrd, new BytesRef()),\n                  facetOrd == facetFieldDocTermOrds.numTerms() ? null : BytesRef.deepCopyOf(facetFieldDocTermOrds.lookupTerm(facetOrdTermsEnum, facetOrd))\n              )\n          );\n        }\n      } while (chunk >= buffer.length);\n    }\n\n","sourceOld":"    public void collect(int doc) throws IOException {\n      int groupOrd = groupFieldTermsIndex.getOrd(doc);\n      if (facetOrdTermsEnum != null) {\n        reuse = facetFieldDocTermOrds.lookup(doc, reuse);\n      }\n      int chunk;\n      boolean first = true;\n      int[] buffer = new int[5];\n      do {\n        chunk = reuse != null ? reuse.read(buffer) : 0;\n        if (first && chunk == 0) {\n          chunk = 1;\n          buffer[0] = facetFieldDocTermOrds.numTerms(); // this facet ord is reserved for docs not containing facet field.\n        }\n        first = false;\n\n        for (int pos = 0; pos < chunk; pos++) {\n          int facetOrd = buffer[pos];\n          if (facetOrd < startFacetOrd || facetOrd >= endFacetOrd) {\n            continue;\n          }\n\n          int segmentGroupedFacetsIndex = (groupOrd * (facetFieldDocTermOrds.numTerms() + 1)) + facetOrd;\n          if (segmentGroupedFacetHits.exists(segmentGroupedFacetsIndex)) {\n            continue;\n          }\n\n          segmentTotalCount++;\n          segmentFacetCounts[facetOrd]++;\n\n          segmentGroupedFacetHits.put(segmentGroupedFacetsIndex);\n          groupedFacetHits.add(\n              new GroupedFacetHit(\n                  groupOrd == 0 ? null : groupFieldTermsIndex.lookup(groupOrd, new BytesRef()),\n                  facetOrd == facetFieldDocTermOrds.numTerms() ? null : BytesRef.deepCopyOf(facetFieldDocTermOrds.lookupTerm(facetOrdTermsEnum, facetOrd))\n              )\n          );\n        }\n      } while (chunk >= buffer.length);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0af46d298d8d31b80331276f103009ca4bc08bc2":["369f44b665973d5aa5fc7d0f2a75ffad475d21ee"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","369f44b665973d5aa5fc7d0f2a75ffad475d21ee"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["0af46d298d8d31b80331276f103009ca4bc08bc2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"369f44b665973d5aa5fc7d0f2a75ffad475d21ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"0af46d298d8d31b80331276f103009ca4bc08bc2":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["38e3b736c7ca086d61b7dbb841c905ee115490da","369f44b665973d5aa5fc7d0f2a75ffad475d21ee"],"369f44b665973d5aa5fc7d0f2a75ffad475d21ee":["0af46d298d8d31b80331276f103009ca4bc08bc2","38e3b736c7ca086d61b7dbb841c905ee115490da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}