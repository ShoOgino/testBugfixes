{"path":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrServer,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrServer client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState();\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState(true);\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      client.getZkStateReader().updateClusterState();\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"636a7098b1923741f1d9887fad7cc27074c26d1f","date":1502268482,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getStr(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicaPropertiesBase#verifyUnique(CloudSolrClient,String,String,boolean).mjava","sourceNew":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","sourceOld":"  public static void verifyUnique(CloudSolrClient client, String collectionName, String property, boolean balanced)\n      throws KeeperException, InterruptedException {\n\n    DocCollection col = null;\n    for (int idx = 0; idx < 300; ++idx) {\n      ClusterState clusterState = client.getZkStateReader().getClusterState();\n\n      col = clusterState.getCollection(collectionName);\n      if (col == null) {\n        fail(\"Could not find collection \" + collectionName);\n      }\n      Map<String, Integer> counts = new HashMap<>();\n      Set<String> uniqueNodes = new HashSet<>();\n      boolean allSlicesHaveProp = true;\n      boolean badSlice = false;\n      for (Slice slice : col.getSlices()) {\n        boolean thisSliceHasProp = false;\n        int propCount = 0;\n        for (Replica replica : slice.getReplicas()) {\n          uniqueNodes.add(replica.getNodeName());\n          String propVal = replica.getProperty(property);\n          if (StringUtils.isNotBlank(propVal)) {\n            ++propCount;\n            if (counts.containsKey(replica.getNodeName()) == false) {\n              counts.put(replica.getNodeName(), 0);\n            }\n            int count = counts.get(replica.getNodeName());\n            thisSliceHasProp = true;\n            counts.put(replica.getNodeName(), count + 1);\n          }\n        }\n        badSlice = (propCount > 1) ? true : badSlice;\n        allSlicesHaveProp = allSlicesHaveProp ? thisSliceHasProp : allSlicesHaveProp;\n      }\n      if (balanced == false && badSlice == false) {\n        return;\n      }\n      if (allSlicesHaveProp && balanced) {\n        // Check that the properties are evenly distributed.\n        int minProps = col.getSlices().size() / uniqueNodes.size();\n        int maxProps = minProps;\n\n        if (col.getSlices().size() % uniqueNodes.size() > 0) {\n          ++maxProps;\n        }\n        boolean doSleep = false;\n        for (Map.Entry<String, Integer> ent : counts.entrySet()) {\n          if (ent.getValue() != minProps && ent.getValue() != maxProps) {\n            doSleep = true;\n          }\n        }\n\n        if (doSleep == false) {\n          assertTrue(\"We really shouldn't be calling this if there is no node with the property \" + property,\n              counts.size() > 0);\n          return;\n        }\n      }\n      Thread.sleep(100);\n    }\n    fail(\"Collection \" + collectionName + \" does not have roles evenly distributed. Collection is: \" + col.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["636a7098b1923741f1d9887fad7cc27074c26d1f","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","636a7098b1923741f1d9887fad7cc27074c26d1f"],"636a7098b1923741f1d9887fad7cc27074c26d1f":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["bafca15d8e408346a67f4282ad1143b88023893b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["636a7098b1923741f1d9887fad7cc27074c26d1f"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","636a7098b1923741f1d9887fad7cc27074c26d1f"],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"636a7098b1923741f1d9887fad7cc27074c26d1f":["b94236357aaa22b76c10629851fe4e376e0cea82","58884af1f68e9d61c217c753fbd6266d86a63b14","6146c07c0dee1ae1e42926167acd127fed5ef59d","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"bafca15d8e408346a67f4282ad1143b88023893b":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["58884af1f68e9d61c217c753fbd6266d86a63b14","636a7098b1923741f1d9887fad7cc27074c26d1f","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}