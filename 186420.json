{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimLargeCluster#testCreateLargeSimCollections().mjava","commits":[{"id":"66b87d86427dfa19b2ef36b66de83aa9655cea33","date":1552627668,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimLargeCluster#testCreateLargeSimCollections().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testCreateLargeSimCollections() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n\n    final int numCollections = atLeast(10);\n    for (int i = 0; i < numCollections; i++) {\n      final int numShards = TestUtil.nextInt(random(), 5, 20);\n      final int nReps = TestUtil.nextInt(random(), 10, 25);\n      final int tReps = TestUtil.nextInt(random(), 10, 25);\n      final int pReps = TestUtil.nextInt(random(), 10, 25);\n      final int repsPerShard = (nReps + tReps + pReps);\n      final int totalCores = repsPerShard * numShards;\n      final int maxShardsPerNode = atLeast(2) + (totalCores / NUM_NODES);\n      final String name = \"large_sim_collection\" + i;\n      \n      final CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection\n        (name, \"conf\", numShards, nReps, tReps, pReps);\n      create.setMaxShardsPerNode(maxShardsPerNode);\n      create.setAutoAddReplicas(false);\n      \n      log.info(\"CREATE: {}\", create);\n      create.process(solrClient);\n\n      // Since our current goal is to try and find situations where cores are just flat out missing\n      // no matter how long we wait, let's be excessive and generous in our timeout.\n      // (REMINDER: this uses the cluster's timesource, and ADDREPLICA has a hardcoded delay of 500ms)\n      CloudTestUtils.waitForState(cluster, name, totalCores, TimeUnit.SECONDS,\n                                  CloudTestUtils.clusterShape(numShards, repsPerShard, false, true));\n      \n      final CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(name);\n      log.info(\"DELETE: {}\", delete);\n      delete.process(solrClient);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9ff5b52acf103581627aa7a063fdb3f335863be","date":1552671808,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimLargeCluster#testCreateLargeSimCollections().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimLargeCluster#testCreateLargeSimCollections().mjava","sourceNew":"  @Test\n  public void testCreateLargeSimCollections() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n\n    final int numCollections = atLeast(5);\n    for (int i = 0; i < numCollections; i++) {\n      // wide and shallow, or deep and narrow...\n      final int numShards = TestUtil.nextInt(random(), 5, 20);\n      final int nReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int tReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int pReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int repsPerShard = (nReps + tReps + pReps);\n      final int totalCores = repsPerShard * numShards;\n      final int maxShardsPerNode = atLeast(2) + (totalCores / NUM_NODES);\n      final String name = \"large_sim_collection\" + i;\n      \n      final CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection\n        (name, \"conf\", numShards, nReps, tReps, pReps);\n      create.setMaxShardsPerNode(maxShardsPerNode);\n      create.setAutoAddReplicas(false);\n      \n      log.info(\"CREATE: {}\", create);\n      create.process(solrClient);\n\n      // Since our current goal is to try and find situations where cores are just flat out missing\n      // no matter how long we wait, let's be excessive and generous in our timeout.\n      // (REMINDER: this uses the cluster's timesource, and ADDREPLICA has a hardcoded delay of 500ms)\n      CloudTestUtils.waitForState(cluster, name, 2 * totalCores, TimeUnit.SECONDS,\n                                  CloudTestUtils.clusterShape(numShards, repsPerShard, false, true));\n      \n      final CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(name);\n      log.info(\"DELETE: {}\", delete);\n      delete.process(solrClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCreateLargeSimCollections() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n\n    final int numCollections = atLeast(10);\n    for (int i = 0; i < numCollections; i++) {\n      final int numShards = TestUtil.nextInt(random(), 5, 20);\n      final int nReps = TestUtil.nextInt(random(), 10, 25);\n      final int tReps = TestUtil.nextInt(random(), 10, 25);\n      final int pReps = TestUtil.nextInt(random(), 10, 25);\n      final int repsPerShard = (nReps + tReps + pReps);\n      final int totalCores = repsPerShard * numShards;\n      final int maxShardsPerNode = atLeast(2) + (totalCores / NUM_NODES);\n      final String name = \"large_sim_collection\" + i;\n      \n      final CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection\n        (name, \"conf\", numShards, nReps, tReps, pReps);\n      create.setMaxShardsPerNode(maxShardsPerNode);\n      create.setAutoAddReplicas(false);\n      \n      log.info(\"CREATE: {}\", create);\n      create.process(solrClient);\n\n      // Since our current goal is to try and find situations where cores are just flat out missing\n      // no matter how long we wait, let's be excessive and generous in our timeout.\n      // (REMINDER: this uses the cluster's timesource, and ADDREPLICA has a hardcoded delay of 500ms)\n      CloudTestUtils.waitForState(cluster, name, totalCores, TimeUnit.SECONDS,\n                                  CloudTestUtils.clusterShape(numShards, repsPerShard, false, true));\n      \n      final CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(name);\n      log.info(\"DELETE: {}\", delete);\n      delete.process(solrClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimLargeCluster#testCreateLargeSimCollections().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimLargeCluster#testCreateLargeSimCollections().mjava","sourceNew":"  @Test\n  public void testCreateLargeSimCollections() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n\n    final int numCollections = atLeast(5);\n    for (int i = 0; i < numCollections; i++) {\n      // wide and shallow, or deep and narrow...\n      final int numShards = TestUtil.nextInt(random(), 5, 20);\n      final int nReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int tReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int pReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int repsPerShard = (nReps + tReps + pReps);\n      final int totalCores = repsPerShard * numShards;\n      final int maxShardsPerNode = atLeast(2) + (totalCores / NUM_NODES);\n      final String name = \"large_sim_collection\" + i;\n      \n      final CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection\n        (name, \"conf\", numShards, nReps, tReps, pReps);\n      create.setMaxShardsPerNode(maxShardsPerNode);\n      create.setAutoAddReplicas(false);\n      \n      log.info(\"CREATE: {}\", create);\n      create.process(solrClient);\n\n      // Since our current goal is to try and find situations where cores are just flat out missing\n      // no matter how long we wait, let's be excessive and generous in our timeout.\n      // (REMINDER: this uses the cluster's timesource, and ADDREPLICA has a hardcoded delay of 500ms)\n      CloudUtil.waitForState(cluster, name, 2 * totalCores, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(numShards, repsPerShard, false, true));\n      \n      final CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(name);\n      log.info(\"DELETE: {}\", delete);\n      delete.process(solrClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCreateLargeSimCollections() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n\n    final int numCollections = atLeast(5);\n    for (int i = 0; i < numCollections; i++) {\n      // wide and shallow, or deep and narrow...\n      final int numShards = TestUtil.nextInt(random(), 5, 20);\n      final int nReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int tReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int pReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int repsPerShard = (nReps + tReps + pReps);\n      final int totalCores = repsPerShard * numShards;\n      final int maxShardsPerNode = atLeast(2) + (totalCores / NUM_NODES);\n      final String name = \"large_sim_collection\" + i;\n      \n      final CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection\n        (name, \"conf\", numShards, nReps, tReps, pReps);\n      create.setMaxShardsPerNode(maxShardsPerNode);\n      create.setAutoAddReplicas(false);\n      \n      log.info(\"CREATE: {}\", create);\n      create.process(solrClient);\n\n      // Since our current goal is to try and find situations where cores are just flat out missing\n      // no matter how long we wait, let's be excessive and generous in our timeout.\n      // (REMINDER: this uses the cluster's timesource, and ADDREPLICA has a hardcoded delay of 500ms)\n      CloudTestUtils.waitForState(cluster, name, 2 * totalCores, TimeUnit.SECONDS,\n                                  CloudTestUtils.clusterShape(numShards, repsPerShard, false, true));\n      \n      final CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(name);\n      log.info(\"DELETE: {}\", delete);\n      delete.process(solrClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimLargeCluster#testCreateLargeSimCollections().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimLargeCluster#testCreateLargeSimCollections().mjava","sourceNew":"  @Test\n  public void testCreateLargeSimCollections() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n\n    final int numCollections = atLeast(5);\n    for (int i = 0; i < numCollections; i++) {\n      // wide and shallow, or deep and narrow...\n      final int numShards = TestUtil.nextInt(random(), 5, 20);\n      final int nReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int tReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int pReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int repsPerShard = (nReps + tReps + pReps);\n      final int totalCores = repsPerShard * numShards;\n      final String name = \"large_sim_collection\" + i;\n      \n      final CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection\n        (name, \"conf\", numShards, nReps, tReps, pReps);\n      create.setAutoAddReplicas(false);\n      \n      log.info(\"CREATE: {}\", create);\n      create.process(solrClient);\n\n      // Since our current goal is to try and find situations where cores are just flat out missing\n      // no matter how long we wait, let's be excessive and generous in our timeout.\n      // (REMINDER: this uses the cluster's timesource, and ADDREPLICA has a hardcoded delay of 500ms)\n      CloudUtil.waitForState(cluster, name, 2 * totalCores, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(numShards, repsPerShard, false, true));\n      \n      final CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(name);\n      log.info(\"DELETE: {}\", delete);\n      delete.process(solrClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCreateLargeSimCollections() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n\n    final int numCollections = atLeast(5);\n    for (int i = 0; i < numCollections; i++) {\n      // wide and shallow, or deep and narrow...\n      final int numShards = TestUtil.nextInt(random(), 5, 20);\n      final int nReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int tReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int pReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int repsPerShard = (nReps + tReps + pReps);\n      final int totalCores = repsPerShard * numShards;\n      final int maxShardsPerNode = atLeast(2) + (totalCores / NUM_NODES);\n      final String name = \"large_sim_collection\" + i;\n      \n      final CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection\n        (name, \"conf\", numShards, nReps, tReps, pReps);\n      create.setMaxShardsPerNode(maxShardsPerNode);\n      create.setAutoAddReplicas(false);\n      \n      log.info(\"CREATE: {}\", create);\n      create.process(solrClient);\n\n      // Since our current goal is to try and find situations where cores are just flat out missing\n      // no matter how long we wait, let's be excessive and generous in our timeout.\n      // (REMINDER: this uses the cluster's timesource, and ADDREPLICA has a hardcoded delay of 500ms)\n      CloudUtil.waitForState(cluster, name, 2 * totalCores, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(numShards, repsPerShard, false, true));\n      \n      final CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(name);\n      log.info(\"DELETE: {}\", delete);\n      delete.process(solrClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimLargeCluster#testCreateLargeSimCollections().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testCreateLargeSimCollections() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n\n    final int numCollections = atLeast(5);\n    for (int i = 0; i < numCollections; i++) {\n      // wide and shallow, or deep and narrow...\n      final int numShards = TestUtil.nextInt(random(), 5, 20);\n      final int nReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int tReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int pReps = TestUtil.nextInt(random(), 2, 25 - numShards);\n      final int repsPerShard = (nReps + tReps + pReps);\n      final int totalCores = repsPerShard * numShards;\n      final String name = \"large_sim_collection\" + i;\n      \n      final CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection\n        (name, \"conf\", numShards, nReps, tReps, pReps);\n      create.setAutoAddReplicas(false);\n      \n      log.info(\"CREATE: {}\", create);\n      create.process(solrClient);\n\n      // Since our current goal is to try and find situations where cores are just flat out missing\n      // no matter how long we wait, let's be excessive and generous in our timeout.\n      // (REMINDER: this uses the cluster's timesource, and ADDREPLICA has a hardcoded delay of 500ms)\n      CloudUtil.waitForState(cluster, name, 2 * totalCores, TimeUnit.SECONDS,\n          CloudUtil.clusterShape(numShards, repsPerShard, false, true));\n      \n      final CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(name);\n      log.info(\"DELETE: {}\", delete);\n      delete.process(solrClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"b9ff5b52acf103581627aa7a063fdb3f335863be":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["b9ff5b52acf103581627aa7a063fdb3f335863be"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b9ff5b52acf103581627aa7a063fdb3f335863be":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["b9ff5b52acf103581627aa7a063fdb3f335863be"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}