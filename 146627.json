{"path":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#[T]_lookupAnalysisClass(String,Class[T]).mjava","commits":[{"id":"7bb889a868ab9d608bde8136f42ed7234a3a927b","date":1359393528,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#[T]_lookupAnalysisClass(String,Class[T]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method looks up a class with its fully qualified name (FQN), or a short-name\n   * class-simplename, or with a package suffix, assuming \"org.apache.lucene.analysis.\"\n   * as the package prefix (e.g. \"standard.ClassicTokenizerFactory\" ->\n   * \"org.apache.lucene.analysis.standard.ClassicTokenizerFactory\").\n   *\n   * If className contains a period, the class is first looked up as-is, assuming that it\n   * is an FQN.  If this fails, lookup is retried after prepending the Lucene analysis\n   * package prefix to the class name.\n   *\n   * If className does not contain a period, the analysis SPI *Factory.lookupClass()\n   * methods are used to find the class.\n   *\n   * @param className The name or the short name of the class.\n   * @param expectedType The superclass className is expected to extend\n   * @return the loaded class.\n   * @throws ClassNotFoundException if lookup fails\n   */\n  public <T> Class<? extends T> lookupAnalysisClass(String className, Class<T> expectedType)\n      throws ClassNotFoundException {\n    if (className.contains(\".\")) {\n      try {\n        // First, try className == FQN\n        return Class.forName(className).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        try {\n          // Second, retry lookup after prepending the Lucene analysis package prefix\n          return Class.forName(LUCENE_ANALYSIS_PACKAGE_PREFIX + className).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          throw new ClassNotFoundException(\"Can't find class '\" + className\n                                           + \"' or '\" + LUCENE_ANALYSIS_PACKAGE_PREFIX + className + \"'\");\n        }\n      }\n    }\n    // No dot - use analysis SPI lookup\n    final String analysisComponentName = ANALYSIS_COMPONENT_SUFFIX_PATTERN.matcher(className).replaceFirst(\"\");\n    if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n      return CharFilterFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n      return TokenizerFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n      return TokenFilterFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    }\n\n    throw new ClassNotFoundException(\"Can't find class '\" + className + \"'\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de522d9303bd67c8473a269a1319125d1f3700e0","date":1359477856,"type":0,"author":"Adrien Grand","isMerge":true,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#[T]_lookupAnalysisClass(String,Class[T]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method looks up a class with its fully qualified name (FQN), or a short-name\n   * class-simplename, or with a package suffix, assuming \"org.apache.lucene.analysis.\"\n   * as the package prefix (e.g. \"standard.ClassicTokenizerFactory\" ->\n   * \"org.apache.lucene.analysis.standard.ClassicTokenizerFactory\").\n   *\n   * If className contains a period, the class is first looked up as-is, assuming that it\n   * is an FQN.  If this fails, lookup is retried after prepending the Lucene analysis\n   * package prefix to the class name.\n   *\n   * If className does not contain a period, the analysis SPI *Factory.lookupClass()\n   * methods are used to find the class.\n   *\n   * @param className The name or the short name of the class.\n   * @param expectedType The superclass className is expected to extend\n   * @return the loaded class.\n   * @throws ClassNotFoundException if lookup fails\n   */\n  public <T> Class<? extends T> lookupAnalysisClass(String className, Class<T> expectedType)\n      throws ClassNotFoundException {\n    if (className.contains(\".\")) {\n      try {\n        // First, try className == FQN\n        return Class.forName(className).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        try {\n          // Second, retry lookup after prepending the Lucene analysis package prefix\n          return Class.forName(LUCENE_ANALYSIS_PACKAGE_PREFIX + className).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          throw new ClassNotFoundException(\"Can't find class '\" + className\n                                           + \"' or '\" + LUCENE_ANALYSIS_PACKAGE_PREFIX + className + \"'\");\n        }\n      }\n    }\n    // No dot - use analysis SPI lookup\n    final String analysisComponentName = ANALYSIS_COMPONENT_SUFFIX_PATTERN.matcher(className).replaceFirst(\"\");\n    if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n      return CharFilterFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n      return TokenizerFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n      return TokenFilterFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    }\n\n    throw new ClassNotFoundException(\"Can't find class '\" + className + \"'\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#[T]_lookupAnalysisClass(String,Class[T]).mjava","pathOld":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask#[T]_lookupAnalysisClass(String,Class[T]).mjava","sourceNew":"  /**\n   * This method looks up a class with its fully qualified name (FQN), or a short-name\n   * class-simplename, or with a package suffix, assuming \"org.apache.lucene.analysis.\"\n   * as the package prefix (e.g. \"standard.ClassicTokenizerFactory\" -&gt;\n   * \"org.apache.lucene.analysis.standard.ClassicTokenizerFactory\").\n   *\n   * If className contains a period, the class is first looked up as-is, assuming that it\n   * is an FQN.  If this fails, lookup is retried after prepending the Lucene analysis\n   * package prefix to the class name.\n   *\n   * If className does not contain a period, the analysis SPI *Factory.lookupClass()\n   * methods are used to find the class.\n   *\n   * @param className The name or the short name of the class.\n   * @param expectedType The superclass className is expected to extend\n   * @return the loaded class.\n   * @throws ClassNotFoundException if lookup fails\n   */\n  public <T> Class<? extends T> lookupAnalysisClass(String className, Class<T> expectedType)\n      throws ClassNotFoundException {\n    if (className.contains(\".\")) {\n      try {\n        // First, try className == FQN\n        return Class.forName(className).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        try {\n          // Second, retry lookup after prepending the Lucene analysis package prefix\n          return Class.forName(LUCENE_ANALYSIS_PACKAGE_PREFIX + className).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          throw new ClassNotFoundException(\"Can't find class '\" + className\n                                           + \"' or '\" + LUCENE_ANALYSIS_PACKAGE_PREFIX + className + \"'\");\n        }\n      }\n    }\n    // No dot - use analysis SPI lookup\n    final String analysisComponentName = ANALYSIS_COMPONENT_SUFFIX_PATTERN.matcher(className).replaceFirst(\"\");\n    if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n      return CharFilterFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n      return TokenizerFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n      return TokenFilterFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    }\n\n    throw new ClassNotFoundException(\"Can't find class '\" + className + \"'\");\n  }\n\n","sourceOld":"  /**\n   * This method looks up a class with its fully qualified name (FQN), or a short-name\n   * class-simplename, or with a package suffix, assuming \"org.apache.lucene.analysis.\"\n   * as the package prefix (e.g. \"standard.ClassicTokenizerFactory\" ->\n   * \"org.apache.lucene.analysis.standard.ClassicTokenizerFactory\").\n   *\n   * If className contains a period, the class is first looked up as-is, assuming that it\n   * is an FQN.  If this fails, lookup is retried after prepending the Lucene analysis\n   * package prefix to the class name.\n   *\n   * If className does not contain a period, the analysis SPI *Factory.lookupClass()\n   * methods are used to find the class.\n   *\n   * @param className The name or the short name of the class.\n   * @param expectedType The superclass className is expected to extend\n   * @return the loaded class.\n   * @throws ClassNotFoundException if lookup fails\n   */\n  public <T> Class<? extends T> lookupAnalysisClass(String className, Class<T> expectedType)\n      throws ClassNotFoundException {\n    if (className.contains(\".\")) {\n      try {\n        // First, try className == FQN\n        return Class.forName(className).asSubclass(expectedType);\n      } catch (ClassNotFoundException e) {\n        try {\n          // Second, retry lookup after prepending the Lucene analysis package prefix\n          return Class.forName(LUCENE_ANALYSIS_PACKAGE_PREFIX + className).asSubclass(expectedType);\n        } catch (ClassNotFoundException e1) {\n          throw new ClassNotFoundException(\"Can't find class '\" + className\n                                           + \"' or '\" + LUCENE_ANALYSIS_PACKAGE_PREFIX + className + \"'\");\n        }\n      }\n    }\n    // No dot - use analysis SPI lookup\n    final String analysisComponentName = ANALYSIS_COMPONENT_SUFFIX_PATTERN.matcher(className).replaceFirst(\"\");\n    if (CharFilterFactory.class.isAssignableFrom(expectedType)) {\n      return CharFilterFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    } else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {\n      return TokenizerFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    } else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {\n      return TokenFilterFactory.lookupClass(analysisComponentName).asSubclass(expectedType);\n    }\n\n    throw new ClassNotFoundException(\"Can't find class '\" + className + \"'\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["7bb889a868ab9d608bde8136f42ed7234a3a927b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7bb889a868ab9d608bde8136f42ed7234a3a927b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"de522d9303bd67c8473a269a1319125d1f3700e0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7bb889a868ab9d608bde8136f42ed7234a3a927b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1eb427f2c6beed80d1724555fc1db003ccf3030"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7bb889a868ab9d608bde8136f42ed7234a3a927b","de522d9303bd67c8473a269a1319125d1f3700e0"],"7bb889a868ab9d608bde8136f42ed7234a3a927b":["b1eb427f2c6beed80d1724555fc1db003ccf3030","de522d9303bd67c8473a269a1319125d1f3700e0"],"de522d9303bd67c8473a269a1319125d1f3700e0":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["de522d9303bd67c8473a269a1319125d1f3700e0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}