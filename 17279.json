{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#IndexedDISI(IndexInput,RandomAccessInput,int,byte,long).mjava","commits":[{"id":"03e17b020972a0d6e8d6823f545571a66646a167","date":1547847724,"type":0,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#IndexedDISI(IndexInput,RandomAccessInput,int,byte,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This constructor allows to pass the slice and jumpTable directly in case it helps reuse.\n   * see eg. Lucene80 norms producer's merge instance.\n   * @param blockSlice data blocks, normally created by {@link #createBlockSlice}.\n   * @param jumpTable table holding jump-data for block-skips, normally created by {@link #createJumpTable}.\n   * @param jumpTableEntryCount the number of blocks covered by the jump-table.\n   *                            This must match the number returned by {@link #writeBitSet(DocIdSetIterator, IndexOutput, byte)}.\n   * @param denseRankPower the number of docIDs covered by each rank entry in DENSE blocks, expressed as {@code 2^denseRankPower}.\n   *                       This must match the power given in {@link #writeBitSet(DocIdSetIterator, IndexOutput, byte)}\n   * @param cost normally the number of logical docIDs.\n   */\n  IndexedDISI(IndexInput blockSlice, RandomAccessInput jumpTable, int jumpTableEntryCount, byte denseRankPower, long cost) throws IOException {\n    if ((denseRankPower < 7 || denseRankPower > 15) && denseRankPower != -1) {\n      throw new IllegalArgumentException(\"Acceptable values for denseRankPower are 7-15 (every 128-32768 docIDs). \" +\n          \"The provided power was \" + denseRankPower + \" (every \" + (int)Math.pow(2, denseRankPower) + \" docIDs). \");\n    }\n\n    this.slice = blockSlice;\n    this.jumpTable = jumpTable;\n    this.jumpTableEntryCount = jumpTableEntryCount;\n    this.denseRankPower = denseRankPower;\n    final int rankIndexShift = denseRankPower-7;\n    this.denseRankTable = denseRankPower == -1 ? null : new byte[DENSE_BLOCK_LONGS >> rankIndexShift];\n    this.cost = cost;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c89f1ef80a9432f4eabaeda9a1e135cd72e60836","date":1547972642,"type":0,"author":"Tommaso Teofili","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#IndexedDISI(IndexInput,RandomAccessInput,int,byte,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This constructor allows to pass the slice and jumpTable directly in case it helps reuse.\n   * see eg. Lucene80 norms producer's merge instance.\n   * @param blockSlice data blocks, normally created by {@link #createBlockSlice}.\n   * @param jumpTable table holding jump-data for block-skips, normally created by {@link #createJumpTable}.\n   * @param jumpTableEntryCount the number of blocks covered by the jump-table.\n   *                            This must match the number returned by {@link #writeBitSet(DocIdSetIterator, IndexOutput, byte)}.\n   * @param denseRankPower the number of docIDs covered by each rank entry in DENSE blocks, expressed as {@code 2^denseRankPower}.\n   *                       This must match the power given in {@link #writeBitSet(DocIdSetIterator, IndexOutput, byte)}\n   * @param cost normally the number of logical docIDs.\n   */\n  IndexedDISI(IndexInput blockSlice, RandomAccessInput jumpTable, int jumpTableEntryCount, byte denseRankPower, long cost) throws IOException {\n    if ((denseRankPower < 7 || denseRankPower > 15) && denseRankPower != -1) {\n      throw new IllegalArgumentException(\"Acceptable values for denseRankPower are 7-15 (every 128-32768 docIDs). \" +\n          \"The provided power was \" + denseRankPower + \" (every \" + (int)Math.pow(2, denseRankPower) + \" docIDs). \");\n    }\n\n    this.slice = blockSlice;\n    this.jumpTable = jumpTable;\n    this.jumpTableEntryCount = jumpTableEntryCount;\n    this.denseRankPower = denseRankPower;\n    final int rankIndexShift = denseRankPower-7;\n    this.denseRankTable = denseRankPower == -1 ? null : new byte[DENSE_BLOCK_LONGS >> rankIndexShift];\n    this.cost = cost;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"03e17b020972a0d6e8d6823f545571a66646a167":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","03e17b020972a0d6e8d6823f545571a66646a167"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["03e17b020972a0d6e8d6823f545571a66646a167"]},"commit2Childs":{"03e17b020972a0d6e8d6823f545571a66646a167":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["03e17b020972a0d6e8d6823f545571a66646a167","c89f1ef80a9432f4eabaeda9a1e135cd72e60836"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}