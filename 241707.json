{"path":"solr/core/src/java/org/apache/solr/internal/csv/CSVPrinter#printAndEncapsulate(char[],int,int).mjava","commits":[{"id":"80931fa1f3b04650bde7b20e61b02063a7093ced","date":1333130683,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/CSVPrinter#printAndEncapsulate(char[],int,int).mjava","pathOld":"/dev/null","sourceNew":"  void printAndEncapsulate(char[] value, int offset, int len) throws IOException {\n    boolean first = newLine;  // is this the first value on this line?\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    int end = offset + len;\n\n    printSep();    \n\n    char delim = this.strategy.getDelimiter();\n    char encapsulator = this.strategy.getEncapsulator();\n\n    if (len <= 0) {\n      // always quote an empty token that is the first\n      // on the line, as it may be the only thing on the\n      // line. If it were not quoted in that case,\n      // an empty line has no tokens.\n      if (first) {\n        quote = true;\n      }\n    } else {\n      char c = value[pos];\n\n      // Hmmm, where did this rule come from?\n      if (first\n          && (c < '0'\n          || (c > '9' && c < 'A')\n          || (c > 'Z' && c < 'a')\n          || (c > 'z'))) {\n        quote = true;\n      // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n      } else if (c <= '#') {\n        // Some other chars at the start of a value caused the parser to fail, so for now\n        // encapsulate if we start in anything less than '#'.  We are being conservative\n        // by including the default comment char too.\n        quote = true;\n      } else {\n        while (pos < end) {\n          c = value[pos];\n          if (c=='\\n' || c=='\\r' || c==encapsulator || c==delim) {\n            quote = true;\n            break;\n          }\n          pos++;\n        }\n\n        if (!quote) {\n          pos = end-1;\n          c = value[pos];\n          // if (c == ' ' || c == '\\f' || c == '\\t') {\n          // Some other chars at the end caused the parser to fail, so for now\n          // encapsulate if we end in anything less than ' '\n          if (c <= ' ') {\n            quote = true;\n          }\n        }\n      }\n    }\n\n    if (!quote) {\n      // no encapsulation needed - write out the original value\n      out.write(value, offset, len);\n      return;\n    }\n\n    // we hit something that needed encapsulation\n    out.write(encapsulator);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos<end) {\n      char c = value[pos];\n      if (c==encapsulator) {\n        // write out the chunk up until this point\n\n        // add 1 to the length to write out the encapsulator also\n        out.write(value, start, pos-start+1);\n        // put the next starting position on the encapsulator so we will\n        // write it out again with the next string (effectively doubling it)\n        start = pos;\n      }\n      pos++;\n    }\n\n    // write the last segment\n    out.write(value, start, pos-start);\n    out.write(encapsulator);    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80931fa1f3b04650bde7b20e61b02063a7093ced":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["80931fa1f3b04650bde7b20e61b02063a7093ced"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["80931fa1f3b04650bde7b20e61b02063a7093ced"],"80931fa1f3b04650bde7b20e61b02063a7093ced":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}