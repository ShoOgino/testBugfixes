{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","commits":[{"id":"edf5b262a72d10530eb2f01dc8f19060355b213e","date":1557765866,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","pathOld":"/dev/null","sourceNew":"  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Collections.unmodifiableSet(new HashSet<>((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet())));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Number version = (Number)stateMap.remove(\"version\");\n    clusterState = ClusterState.load(version != null ? version.intValue() : null, stateMap, liveNodes, ZkStateReader.CLUSTER_STATE);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7211cffa9ca30fcd9ff33fb1059543d95773b8b1","date":1566595888,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","sourceNew":"  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Set.copyOf((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet()));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Number version = (Number)stateMap.remove(\"version\");\n    clusterState = ClusterState.load(version != null ? version.intValue() : null, stateMap, liveNodes, ZkStateReader.CLUSTER_STATE);\n  }\n\n","sourceOld":"  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Collections.unmodifiableSet(new HashSet<>((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet())));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Number version = (Number)stateMap.remove(\"version\");\n    clusterState = ClusterState.load(version != null ? version.intValue() : null, stateMap, liveNodes, ZkStateReader.CLUSTER_STATE);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a","date":1589907167,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","sourceNew":"  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Set.copyOf((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet()));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Map<String, DocCollection> collectionStates = new HashMap<>();\n    // back-compat with format = 1\n    Integer stateVersion = Integer.valueOf(String.valueOf(stateMap.getOrDefault(\"version\", 0)));\n    stateMap.remove(\"version\");\n    stateMap.forEach((name, state) -> {\n      Map<String, Object> mutableState = (Map<String, Object>)state;\n      Map<String, Object> collMap = (Map<String, Object>) mutableState.get(name);\n      if (collMap == null) {\n        // snapshot in format 1\n        collMap = mutableState;\n        mutableState = Collections.singletonMap(name, state);\n      }\n      Integer version = Integer.parseInt(String.valueOf(collMap.getOrDefault(\"zNodeVersion\", stateVersion)));\n      String path = String.valueOf(collMap.getOrDefault(\"zNode\", ZkStateReader.getCollectionPath(name)));\n      collMap.remove(\"zNodeVersion\");\n      collMap.remove(\"zNode\");\n      byte[] data = Utils.toJSON(mutableState);\n      ClusterState collState = ClusterState.load(version, data, Collections.emptySet(), path);\n      collectionStates.put(name, collState.getCollection(name));\n    });\n    clusterState = new ClusterState(stateVersion, liveNodes, collectionStates);\n  }\n\n","sourceOld":"  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Set.copyOf((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet()));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Number version = (Number)stateMap.remove(\"version\");\n    clusterState = ClusterState.load(version != null ? version.intValue() : null, stateMap, liveNodes, ZkStateReader.CLUSTER_STATE);\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"daa0f21a44e235a2299ea1fa913898b182dd7cce","date":1590952026,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Set.copyOf((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet()));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Map<String, DocCollection> collectionStates = new HashMap<>();\n    // back-compat with format = 1\n    Integer stateVersion = Integer.valueOf(String.valueOf(stateMap.getOrDefault(\"version\", 0)));\n    stateMap.remove(\"version\");\n    stateMap.forEach((name, state) -> {\n      Map<String, Object> mutableState = (Map<String, Object>)state;\n      Map<String, Object> collMap = (Map<String, Object>) mutableState.get(name);\n      if (collMap == null) {\n        // snapshot in format 1\n        collMap = mutableState;\n        mutableState = Collections.singletonMap(name, state);\n      }\n      Integer version = Integer.parseInt(String.valueOf(collMap.getOrDefault(\"zNodeVersion\", stateVersion)));\n      String path = String.valueOf(collMap.getOrDefault(\"zNode\", ZkStateReader.getCollectionPath(name)));\n      collMap.remove(\"zNodeVersion\");\n      collMap.remove(\"zNode\");\n      byte[] data = Utils.toJSON(mutableState);\n      ClusterState collState = ClusterState.load(version, data, Collections.emptySet(), path);\n      collectionStates.put(name, collState.getCollection(name));\n    });\n    clusterState = new ClusterState(stateVersion, liveNodes, collectionStates);\n  }\n\n","sourceOld":"  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Set.copyOf((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet()));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Map<String, DocCollection> collectionStates = new HashMap<>();\n    // back-compat with format = 1\n    Integer stateVersion = Integer.valueOf(String.valueOf(stateMap.getOrDefault(\"version\", 0)));\n    stateMap.remove(\"version\");\n    stateMap.forEach((name, state) -> {\n      Map<String, Object> mutableState = (Map<String, Object>)state;\n      Map<String, Object> collMap = (Map<String, Object>) mutableState.get(name);\n      if (collMap == null) {\n        // snapshot in format 1\n        collMap = mutableState;\n        mutableState = Collections.singletonMap(name, state);\n      }\n      Integer version = Integer.parseInt(String.valueOf(collMap.getOrDefault(\"zNodeVersion\", stateVersion)));\n      String path = String.valueOf(collMap.getOrDefault(\"zNode\", ZkStateReader.getCollectionPath(name)));\n      collMap.remove(\"zNodeVersion\");\n      collMap.remove(\"zNode\");\n      byte[] data = Utils.toJSON(mutableState);\n      ClusterState collState = ClusterState.load(version, data, Collections.emptySet(), path);\n      collectionStates.put(name, collState.getCollection(name));\n    });\n    clusterState = new ClusterState(stateVersion, liveNodes, collectionStates);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Set.copyOf((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet()));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Map<String, DocCollection> collectionStates = new HashMap<>();\n    // back-compat with format = 1\n    Integer stateVersion = Integer.valueOf(String.valueOf(stateMap.getOrDefault(\"version\", 0)));\n    stateMap.remove(\"version\");\n    stateMap.forEach((name, state) -> {\n      Map<String, Object> mutableState = (Map<String, Object>)state;\n      Map<String, Object> collMap = (Map<String, Object>) mutableState.get(name);\n      if (collMap == null) {\n        // snapshot in format 1\n        collMap = mutableState;\n        mutableState = Collections.singletonMap(name, state);\n      }\n      int version = Integer.parseInt(String.valueOf(collMap.getOrDefault(\"zNodeVersion\", stateVersion)));\n      collMap.remove(\"zNodeVersion\");\n      byte[] data = Utils.toJSON(mutableState);\n      ClusterState collState = ClusterState.createFromJson(version, data, Collections.emptySet());\n      collectionStates.put(name, collState.getCollection(name));\n    });\n    clusterState = new ClusterState(liveNodes, collectionStates);\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Set.copyOf((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet()));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Map<String, DocCollection> collectionStates = new HashMap<>();\n    // back-compat with format = 1\n    Integer stateVersion = Integer.valueOf(String.valueOf(stateMap.getOrDefault(\"version\", 0)));\n    stateMap.remove(\"version\");\n    stateMap.forEach((name, state) -> {\n      Map<String, Object> mutableState = (Map<String, Object>)state;\n      Map<String, Object> collMap = (Map<String, Object>) mutableState.get(name);\n      if (collMap == null) {\n        // snapshot in format 1\n        collMap = mutableState;\n        mutableState = Collections.singletonMap(name, state);\n      }\n      Integer version = Integer.parseInt(String.valueOf(collMap.getOrDefault(\"zNodeVersion\", stateVersion)));\n      String path = String.valueOf(collMap.getOrDefault(\"zNode\", ZkStateReader.getCollectionPath(name)));\n      collMap.remove(\"zNodeVersion\");\n      collMap.remove(\"zNode\");\n      byte[] data = Utils.toJSON(mutableState);\n      ClusterState collState = ClusterState.load(version, data, Collections.emptySet(), path);\n      collectionStates.put(name, collState.getCollection(name));\n    });\n    clusterState = new ClusterState(stateVersion, liveNodes, collectionStates);\n  }\n\n","bugFix":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotClusterStateProvider#SnapshotClusterStateProvider(Map[String,Object]).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  public SnapshotClusterStateProvider(Map<String, Object> snapshot) {\n    Objects.requireNonNull(snapshot);\n    liveNodes = Set.copyOf((Collection<String>)snapshot.getOrDefault(\"liveNodes\", Collections.emptySet()));\n    clusterProperties = (Map<String, Object>)snapshot.getOrDefault(\"clusterProperties\", Collections.emptyMap());\n    Map<String, Object> stateMap = new HashMap<>((Map<String, Object>)snapshot.getOrDefault(\"clusterState\", Collections.emptyMap()));\n    Map<String, DocCollection> collectionStates = new HashMap<>();\n    // back-compat with format = 1\n    Integer stateVersion = Integer.valueOf(String.valueOf(stateMap.getOrDefault(\"version\", 0)));\n    stateMap.remove(\"version\");\n    stateMap.forEach((name, state) -> {\n      Map<String, Object> mutableState = (Map<String, Object>)state;\n      Map<String, Object> collMap = (Map<String, Object>) mutableState.get(name);\n      if (collMap == null) {\n        // snapshot in format 1\n        collMap = mutableState;\n        mutableState = Collections.singletonMap(name, state);\n      }\n      int version = Integer.parseInt(String.valueOf(collMap.getOrDefault(\"zNodeVersion\", stateVersion)));\n      collMap.remove(\"zNodeVersion\");\n      byte[] data = Utils.toJSON(mutableState);\n      ClusterState collState = ClusterState.createFromJson(version, data, Collections.emptySet());\n      collectionStates.put(name, collState.getCollection(name));\n    });\n    clusterState = new ClusterState(liveNodes, collectionStates);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"3f504512a03d978990cbff30db0522b354e846db":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"7211cffa9ca30fcd9ff33fb1059543d95773b8b1":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["7211cffa9ca30fcd9ff33fb1059543d95773b8b1"],"edf5b262a72d10530eb2f01dc8f19060355b213e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"7211cffa9ca30fcd9ff33fb1059543d95773b8b1":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"edf5b262a72d10530eb2f01dc8f19060355b213e":["7211cffa9ca30fcd9ff33fb1059543d95773b8b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}