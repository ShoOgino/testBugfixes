{"path":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      if (useIndexValues) {\n        return new FieldComparator.IntDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n      }\n\n    case FLOAT:\n      if (useIndexValues) {\n        return new FieldComparator.FloatDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n      }\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      if (useIndexValues) {\n        return new FieldComparator.TermOrdValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermOrdValComparator(numHits, field);\n      }\n\n    case STRING_VAL:\n      if (useIndexValues) {\n        return new FieldComparator.TermValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermValComparator(numHits, field);\n      }\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      if (useIndexValues) {\n        return new FieldComparator.IntDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n      }\n\n    case FLOAT:\n      if (useIndexValues) {\n        return new FieldComparator.FloatDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n      }\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      if (useIndexValues) {\n        return new FieldComparator.TermOrdValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermOrdValComparator(numHits, field);\n      }\n\n    case STRING_VAL:\n      if (useIndexValues) {\n        return new FieldComparator.TermValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermValComparator(numHits, field);\n      }\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      if (useIndexValues) {\n        return new FieldComparator.IntDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n      }\n\n    case FLOAT:\n      if (useIndexValues) {\n        return new FieldComparator.FloatDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n      }\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      if (useIndexValues) {\n        return new FieldComparator.TermOrdValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermOrdValComparator(numHits, field);\n      }\n\n    case STRING_VAL:\n      if (useIndexValues) {\n        return new FieldComparator.TermValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermValComparator(numHits, field);\n      }\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      if (useIndexValues) {\n        return new FieldComparator.IntDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n      }\n\n    case FLOAT:\n      if (useIndexValues) {\n        return new FieldComparator.FloatDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n      }\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      if (useIndexValues) {\n        return new FieldComparator.TermOrdValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermOrdValComparator(numHits, field);\n      }\n\n    case STRING_VAL:\n      if (useIndexValues) {\n        return new FieldComparator.TermValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermValComparator(numHits, field);\n      }\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      if (useIndexValues) {\n        return new FieldComparator.IntDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n      }\n\n    case FLOAT:\n      if (useIndexValues) {\n        return new FieldComparator.FloatDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n      }\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      if (useIndexValues) {\n        return new FieldComparator.TermOrdValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermOrdValComparator(numHits, field);\n      }\n\n    case STRING_VAL:\n      if (useIndexValues) {\n        return new FieldComparator.TermValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermValComparator(numHits, field);\n      }\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      if (useIndexValues) {\n        return new FieldComparator.IntDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n      }\n\n    case FLOAT:\n      if (useIndexValues) {\n        return new FieldComparator.FloatDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n      }\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      if (useIndexValues) {\n        return new FieldComparator.TermOrdValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermOrdValComparator(numHits, field);\n      }\n\n    case STRING_VAL:\n      if (useIndexValues) {\n        return new FieldComparator.TermValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermValComparator(numHits, field);\n      }\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e29774db46ad98ca4a8d7fcbfab633ebc01f358","date":1355170812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      if (useIndexValues) {\n        return new FieldComparator.IntDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n      }\n\n    case FLOAT:\n      if (useIndexValues) {\n        return new FieldComparator.FloatDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n      }\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      if (useIndexValues) {\n        return new FieldComparator.TermOrdValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermOrdValComparator(numHits, field);\n      }\n\n    case STRING_VAL:\n      if (useIndexValues) {\n        return new FieldComparator.TermValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermValComparator(numHits, field);\n      }\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      if (useIndexValues) {\n        return new FieldComparator.IntDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n      }\n\n    case FLOAT:\n      if (useIndexValues) {\n        return new FieldComparator.FloatDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n      }\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      if (useIndexValues) {\n        return new FieldComparator.TermOrdValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermOrdValComparator(numHits, field);\n      }\n\n    case STRING_VAL:\n      if (useIndexValues) {\n        return new FieldComparator.TermValDocValuesComparator(numHits, field);\n      } else {\n        return new FieldComparator.TermValComparator(numHits, field);\n      }\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":["01f60198ece724a6e96cd0b45f289cf42ff83d4f","e7d432db6b63a4974306a3d1bc4e9a09d00eb4d5","382fe3a6ca9745891afebda9b9a57cc158305545","28088b0a688977b79dec2cc9119cff2fb4aab7ee"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a0020b413d44dd79d85d7a66ed5004265fb453","date":1371758877,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case BYTE:\n      return new FieldComparator.ByteComparator(numHits, field, parser, (Byte) missingValue);\n\n    case SHORT:\n      return new FieldComparator.ShortComparator(numHits, field, parser, (Short) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7615b855702e008d91a95a2578bf05d27372f599","date":1389802891,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      // TODO: should we remove this?  who really uses it?\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27ab7b234eab0cbc020836989b96ed430e1065bb","date":1389894025,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      // TODO: should we remove this?  who really uses it?\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      // TODO: should we remove this?  who really uses it?\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      // TODO: should we remove this?  who really uses it?\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      // TODO: should we remove this?  who really uses it?\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      // TODO: should we remove this?  who really uses it?\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      // TODO: should we remove this?  who really uses it?\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, parser, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      // TODO: should we remove this?  who really uses it?\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"400558e34d57baf6a8e8c42d60fc1a87b5acb596","date":1405940665,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      // TODO: should we remove this?  who really uses it?\n      return new FieldComparator.TermValComparator(numHits, field);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03e38c6374c23083c93e212a9498ff0a9c255476","date":1484767039,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) throws IOException {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241","date":1599588987,"type":3,"author":"Mayya Sharipova","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortField#getComparator(int,int).mjava","sourceNew":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new DocComparator(numHits, reverse, sortPos);\n\n    case INT:\n      return new IntComparator(numHits, field, (Integer) missingValue, reverse, sortPos);\n\n    case FLOAT:\n      return new FloatComparator(numHits, field, (Float) missingValue, reverse, sortPos);\n\n    case LONG:\n      return new LongComparator(numHits, field, (Long) missingValue, reverse, sortPos);\n\n    case DOUBLE:\n      return new DoubleComparator(numHits, field, (Double) missingValue, reverse, sortPos);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","sourceOld":"  /** Returns the {@link FieldComparator} to use for\n   * sorting.\n   *\n   * @lucene.experimental\n   *\n   * @param numHits number of top hits the queue will store\n   * @param sortPos position of this SortField within {@link\n   *   Sort}.  The comparator is primary if sortPos==0,\n   *   secondary if sortPos==1, etc.  Some comparators can\n   *   optimize themselves when they are the primary sort.\n   * @return {@link FieldComparator} to use when sorting\n   */\n  public FieldComparator<?> getComparator(final int numHits, final int sortPos) {\n\n    switch (type) {\n    case SCORE:\n      return new FieldComparator.RelevanceComparator(numHits);\n\n    case DOC:\n      return new FieldComparator.DocComparator(numHits);\n\n    case INT:\n      return new FieldComparator.IntComparator(numHits, field, (Integer) missingValue);\n\n    case FLOAT:\n      return new FieldComparator.FloatComparator(numHits, field, (Float) missingValue);\n\n    case LONG:\n      return new FieldComparator.LongComparator(numHits, field, (Long) missingValue);\n\n    case DOUBLE:\n      return new FieldComparator.DoubleComparator(numHits, field, (Double) missingValue);\n\n    case CUSTOM:\n      assert comparatorSource != null;\n      return comparatorSource.newComparator(field, numHits, sortPos, reverse);\n\n    case STRING:\n      return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case STRING_VAL:\n      return new FieldComparator.TermValComparator(numHits, field, missingValue == STRING_LAST);\n\n    case REWRITEABLE:\n      throw new IllegalStateException(\"SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)\");\n        \n    default:\n      throw new IllegalStateException(\"Illegal sort type: \" + type);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":["d4d69c535930b5cce125cff868d40f6373dc27d4","59a0020b413d44dd79d85d7a66ed5004265fb453"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["59a0020b413d44dd79d85d7a66ed5004265fb453","7615b855702e008d91a95a2578bf05d27372f599"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"400558e34d57baf6a8e8c42d60fc1a87b5acb596":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"56572ec06f1407c066d6b7399413178b33176cd8":["27ab7b234eab0cbc020836989b96ed430e1065bb","93dd449115a9247533e44bab47e8429e5dccbc6d"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["400558e34d57baf6a8e8c42d60fc1a87b5acb596","03e38c6374c23083c93e212a9498ff0a9c255476"],"e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241":["03e38c6374c23083c93e212a9498ff0a9c255476"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["f08557cdb6c60ac7b88a9342c983a20cd236e74f","3e29774db46ad98ca4a8d7fcbfab633ebc01f358"],"03e38c6374c23083c93e212a9498ff0a9c255476":["400558e34d57baf6a8e8c42d60fc1a87b5acb596"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["27ab7b234eab0cbc020836989b96ed430e1065bb","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"59a0020b413d44dd79d85d7a66ed5004265fb453":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"7615b855702e008d91a95a2578bf05d27372f599":["59a0020b413d44dd79d85d7a66ed5004265fb453"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241"]},"commit2Childs":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"27ab7b234eab0cbc020836989b96ed430e1065bb":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","3e29774db46ad98ca4a8d7fcbfab633ebc01f358","d4d69c535930b5cce125cff868d40f6373dc27d4"],"400558e34d57baf6a8e8c42d60fc1a87b5acb596":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","03e38c6374c23083c93e212a9498ff0a9c255476"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["37a0f60745e53927c4c876cfe5b5a58170f0646c","59a0020b413d44dd79d85d7a66ed5004265fb453"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["400558e34d57baf6a8e8c42d60fc1a87b5acb596","56572ec06f1407c066d6b7399413178b33176cd8"],"03e38c6374c23083c93e212a9498ff0a9c255476":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","e3d1c24d2bbe79dcf77ffcb104706e42ae3c9241"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["37a0f60745e53927c4c876cfe5b5a58170f0646c","27ab7b234eab0cbc020836989b96ed430e1065bb","7615b855702e008d91a95a2578bf05d27372f599"],"7615b855702e008d91a95a2578bf05d27372f599":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","56572ec06f1407c066d6b7399413178b33176cd8","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}