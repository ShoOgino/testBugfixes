{"path":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        if (t == null || tenum.seek(t, useTermsCache) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"449aa3166f747982f507c48782901cde8693b608","date":1285560445,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, useTermsCache) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        if (t == null || tenum.seek(t, useTermsCache) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"825bcb488bc228d1fb6a19c1f441a2181f7d766d","date":1285691504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, useTermsCache) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1c25e111e7f6a7353d2b9b46643b7f7507c6584","date":1286049515,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8dd2a69747e9f2922fd8b6970bd1661b26a692d","date":1291080135,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n    if (tenum == null)\n      return null;\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        if (t == null || tenum.seek(t, useTermsCache) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9cc9d77712aba3662f24632df7539ab75e3667","date":1309095238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seekCeil(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seekCeil(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seekCeil(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seek(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    //System.out.println(\"FTE.next doSeek=\" + doSeek);\n    //new Throwable().printStackTrace(System.out);\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        //System.out.println(\"  seek to t=\" + (t == null ? \"null\" : t.utf8ToString()) + \" tenum=\" + tenum);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seekCeil(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          //System.out.println(\"  return null\");\n          return null;\n        }\n        actualTerm = tenum.term();\n        //System.out.println(\"  got term=\" + actualTerm.utf8ToString());\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seekCeil(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          return null;\n        }\n        actualTerm = tenum.term();\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef5cb5bb242392bf1b62f64e8645c090d51cc77a","date":1316168618,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/FilteredTermsEnum#next().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredTermsEnum#next().mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    //System.out.println(\"FTE.next doSeek=\" + doSeek);\n    //new Throwable().printStackTrace(System.out);\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        //System.out.println(\"  seek to t=\" + (t == null ? \"null\" : t.utf8ToString()) + \" tenum=\" + tenum);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seekCeil(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          //System.out.println(\"  return null\");\n          return null;\n        }\n        actualTerm = tenum.term();\n        //System.out.println(\"  got term=\" + actualTerm.utf8ToString());\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  @Override\n  public BytesRef next() throws IOException {\n    //System.out.println(\"FTE.next doSeek=\" + doSeek);\n    //new Throwable().printStackTrace(System.out);\n    for (;;) {\n      // Seek or forward the iterator\n      if (doSeek) {\n        doSeek = false;\n        final BytesRef t = nextSeekTerm(actualTerm);\n        //System.out.println(\"  seek to t=\" + (t == null ? \"null\" : t.utf8ToString()) + \" tenum=\" + tenum);\n        // Make sure we always seek forward:\n        assert actualTerm == null || t == null || getComparator().compare(t, actualTerm) > 0: \"curTerm=\" + actualTerm + \" seekTerm=\" + t;\n        if (t == null || tenum.seekCeil(t, false) == SeekStatus.END) {\n          // no more terms to seek to or enum exhausted\n          //System.out.println(\"  return null\");\n          return null;\n        }\n        actualTerm = tenum.term();\n        //System.out.println(\"  got term=\" + actualTerm.utf8ToString());\n      } else {\n        actualTerm = tenum.next();\n        if (actualTerm == null) {\n          // enum exhausted\n          return null;\n        }\n      }\n      \n      // check if term is accepted\n      switch (accept(actualTerm)) {\n        case YES_AND_SEEK:\n          doSeek = true;\n          // term accepted, but we need to seek so fall-through\n        case YES:\n          // term accepted\n          return actualTerm;\n        case NO_AND_SEEK:\n          // invalid term, seek next time\n          doSeek = true;\n          break;\n        case END:\n          // we are supposed to end the enum\n          return null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["449aa3166f747982f507c48782901cde8693b608"],"449aa3166f747982f507c48782901cde8693b608":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2553b00f699380c64959ccb27991289aae87be2e":["e8dd2a69747e9f2922fd8b6970bd1661b26a692d","fd9cc9d77712aba3662f24632df7539ab75e3667"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["e8dd2a69747e9f2922fd8b6970bd1661b26a692d","fd9cc9d77712aba3662f24632df7539ab75e3667"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"ef5cb5bb242392bf1b62f64e8645c090d51cc77a":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd9cc9d77712aba3662f24632df7539ab75e3667":["e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"a1c25e111e7f6a7353d2b9b46643b7f7507c6584":["825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"e8dd2a69747e9f2922fd8b6970bd1661b26a692d":["a1c25e111e7f6a7353d2b9b46643b7f7507c6584"],"3bb13258feba31ab676502787ab2e1779f129b7a":["a1c25e111e7f6a7353d2b9b46643b7f7507c6584","e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ef5cb5bb242392bf1b62f64e8645c090d51cc77a"]},"commit2Childs":{"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["a1c25e111e7f6a7353d2b9b46643b7f7507c6584"],"449aa3166f747982f507c48782901cde8693b608":["825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["449aa3166f747982f507c48782901cde8693b608","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"2553b00f699380c64959ccb27991289aae87be2e":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"60ba444201d2570214b6fcf1d15600dc1a01f548":["ef5cb5bb242392bf1b62f64e8645c090d51cc77a"],"ef5cb5bb242392bf1b62f64e8645c090d51cc77a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","60ba444201d2570214b6fcf1d15600dc1a01f548"],"a1c25e111e7f6a7353d2b9b46643b7f7507c6584":["e8dd2a69747e9f2922fd8b6970bd1661b26a692d","3bb13258feba31ab676502787ab2e1779f129b7a"],"e8dd2a69747e9f2922fd8b6970bd1661b26a692d":["2553b00f699380c64959ccb27991289aae87be2e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c","fd9cc9d77712aba3662f24632df7539ab75e3667","3bb13258feba31ab676502787ab2e1779f129b7a"],"3bb13258feba31ab676502787ab2e1779f129b7a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c","3bb13258feba31ab676502787ab2e1779f129b7a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}