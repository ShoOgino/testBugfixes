{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#getDocCollection(String,Integer).mjava","commits":[{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":1,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shouldRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shouldRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shouldRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shouldRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shouldRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shouldRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shouldRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shouldRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":["3eaeb36333664e8cb92108ef03f68a7b90beb759"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d","date":1592006776,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shouldRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shouldRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shouldRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shouldRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}