{"path":"src/test/org/apache/solr/search/TestSort#testSort().mjava","commits":[{"id":"8be74b6364187be2db818003ff6f492fce9a08b0","date":1266457611,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"/dev/null","sourceNew":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            System.out.println(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe","a78a90fc9701e511308346ea29f4f5e548bb39fe","a78a90fc9701e511308346ea29f4f5e548bb39fe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestSort#testSort().mjava","pathOld":"src/test/org/apache/solr/search/TestSort#testSort().mjava","sourceNew":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            System.out.println(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  public void testSort() throws Exception {\n    RAMDirectory dir = new RAMDirectory();\n    Document smallDoc = new Document();\n    // Field id = new Field(\"id\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    Field f = new Field(\"f\",\"0\", Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS);\n    smallDoc.add(f);\n\n    Document emptyDoc = new Document();\n\n    for (int iterCnt = 0; iterCnt<iter; iterCnt++) {\n      IndexWriter iw = new IndexWriter(dir, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);\n      final MyDoc[] mydocs = new MyDoc[ndocs];\n\n      int commitCountdown = commitCount;\n      for (int i=0; i< ndocs; i++) {\n        Document doc;\n        MyDoc mydoc = new MyDoc();\n        mydoc.doc = i;\n        mydocs[i] = mydoc;\n\n        if (r.nextInt(3)==0) {\n          doc = emptyDoc;\n          mydoc.val = null;\n        } else {\n          mydoc.val = Integer.toString(r.nextInt(maxval));\n          f.setValue(mydoc.val);\n          doc = smallDoc;\n        }\n        iw.addDocument(doc);\n        if (--commitCountdown <= 0) {\n          commitCountdown = commitCount;\n          iw.commit();\n        }\n      }\n      iw.close();\n\n      /***\n      Arrays.sort(mydocs, new Comparator<MyDoc>() {\n        public int compare(MyDoc o1, MyDoc o2) {\n          String v1 = o1.val==null ? \"zzz\" : o1.val;\n          String v2 = o2.val==null ? \"zzz\" : o2.val;\n          int cmp = v1.compareTo(v2);\n          cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n          return cmp;\n        }\n      });\n      ***/\n\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      // System.out.println(\"segments=\"+searcher.getIndexReader().getSequentialSubReaders().length);\n      assertTrue(searcher.getIndexReader().getSequentialSubReaders().length > 1);\n\n      for (int i=0; i<qiter; i++) {\n        Filter filt = new Filter() {\n          @Override\n          public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n            return randSet(reader.maxDoc());\n          }\n        };\n\n        int top = r.nextInt((ndocs>>3)+1)+1;\n        final boolean sortMissingLast = r.nextBoolean();\n        final boolean reverse = !sortMissingLast;\n        List<SortField> sfields = new ArrayList<SortField>();\n\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n        // hit both use-cases of sort-missing-last\n        sfields.add( Sorting.getStringSortField(\"f\", reverse, sortMissingLast, !sortMissingLast) );\n        int sortIdx = sfields.size() - 1;\n        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));\n\n        Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));\n\n        // final String nullRep = sortMissingLast ? \"zzz\" : \"\";\n        final String nullRep = \"zzz\";\n\n        boolean trackScores = r.nextBoolean();\n        boolean trackMaxScores = r.nextBoolean();\n        boolean scoreInOrder = r.nextBoolean();\n        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, scoreInOrder);\n\n        final List<MyDoc> collectedDocs = new ArrayList<MyDoc>();\n        // delegate and collect docs ourselves\n        Collector myCollector = new Collector() {\n          int docBase;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            topCollector.setScorer(scorer);\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            topCollector.collect(doc);\n            collectedDocs.add(mydocs[doc + docBase]);\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            topCollector.setNextReader(reader,docBase);\n            this.docBase = docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return topCollector.acceptsDocsOutOfOrder();\n          }\n        };\n\n        searcher.search(new MatchAllDocsQuery(), filt, myCollector);\n\n        Collections.sort(collectedDocs, new Comparator<MyDoc>() {\n          public int compare(MyDoc o1, MyDoc o2) {\n            String v1 = o1.val==null ? nullRep : o1.val;\n            String v2 = o2.val==null ? nullRep : o2.val;\n            int cmp = v1.compareTo(v2);\n            if (reverse) cmp = -cmp;\n            cmp = cmp==0 ? o1.doc-o2.doc : cmp;\n            return cmp;\n          }\n        });\n\n\n        TopDocs topDocs = topCollector.topDocs();\n        ScoreDoc[] sdocs = topDocs.scoreDocs;\n        for (int j=0; j<sdocs.length; j++) {\n          int id = sdocs[j].doc;\n          String s = (String)((FieldDoc)sdocs[j]).fields[sortIdx];\n          if (id != collectedDocs.get(j).doc) {\n            System.out.println(\"Error at pos \" + j);\n          }\n          assertEquals(id, collectedDocs.get(j).doc);\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"8be74b6364187be2db818003ff6f492fce9a08b0":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"ad94625fb8d088209f46650c8097196fec67f00c":["8be74b6364187be2db818003ff6f492fce9a08b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["8be74b6364187be2db818003ff6f492fce9a08b0"],"8be74b6364187be2db818003ff6f492fce9a08b0":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}