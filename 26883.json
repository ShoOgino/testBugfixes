{"path":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","commits":[{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      if (scoreDocsInOrder) {\n        return new ScorerLeafCollector(scoreDocsInOrder) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n\n            // This collector cannot handle these scores:\n            assert score != Float.NEGATIVE_INFINITY;\n            assert !Float.isNaN(score);\n\n            totalHits++;\n            if (score <= pqTop.score) {\n              // Since docs are returned in-order (i.e., increasing doc Id), a document\n              // with equal score to pqTop.score cannot compete since HitQueue favors\n              // documents with lower doc Ids. Therefore reject those docs too.\n              return;\n            }\n            pqTop.doc = doc + docBase;\n            pqTop.score = score;\n            pqTop = pq.updateTop();\n          }\n\n        };\n      } else {\n        return new ScorerLeafCollector(scoreDocsInOrder) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n\n            // This collector cannot handle NaN\n            assert !Float.isNaN(score);\n\n            totalHits++;\n            if (score < pqTop.score) {\n              // Doesn't compete w/ bottom entry in queue\n              return;\n            }\n            doc += docBase;\n            if (score == pqTop.score && doc > pqTop.doc) {\n              // Break tie in score by doc ID:\n              return;\n            }\n            pqTop.doc = doc;\n            pqTop.score = score;\n            pqTop = pq.updateTop();\n          }\n\n        };\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector cannot handle these scores:\n          assert score != Float.NEGATIVE_INFINITY;\n          assert !Float.isNaN(score);\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      if (scoreDocsInOrder) {\n        return new ScorerLeafCollector(scoreDocsInOrder) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n\n            // This collector cannot handle these scores:\n            assert score != Float.NEGATIVE_INFINITY;\n            assert !Float.isNaN(score);\n\n            totalHits++;\n            if (score <= pqTop.score) {\n              // Since docs are returned in-order (i.e., increasing doc Id), a document\n              // with equal score to pqTop.score cannot compete since HitQueue favors\n              // documents with lower doc Ids. Therefore reject those docs too.\n              return;\n            }\n            pqTop.doc = doc + docBase;\n            pqTop.score = score;\n            pqTop = pq.updateTop();\n          }\n\n        };\n      } else {\n        return new ScorerLeafCollector(scoreDocsInOrder) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n\n            // This collector cannot handle NaN\n            assert !Float.isNaN(score);\n\n            totalHits++;\n            if (score < pqTop.score) {\n              // Doesn't compete w/ bottom entry in queue\n              return;\n            }\n            doc += docBase;\n            if (score == pqTop.score && doc > pqTop.doc) {\n              // Break tie in score by doc ID:\n              return;\n            }\n            pqTop.doc = doc;\n            pqTop.score = score;\n            pqTop = pq.updateTop();\n          }\n\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb","date":1512565563,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector cannot handle these scores:\n          assert score != Float.NEGATIVE_INFINITY;\n          assert !Float.isNaN(score);\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      sumMaxDoc += context.reader().maxDoc();\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          super.setScorer(scorer);\n          if (trackTotalHits == false\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (trackTotalHits == false && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n            if (maxCollectedExactly < 0) {\n              assert totalHits == numHits;\n              maxCollectedExactly = doc + docBase;\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      sumMaxDoc += context.reader().maxDoc();\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          super.setScorer(scorer);\n          if (trackTotalHits == false\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (trackTotalHits == false && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n            if (maxCollectedExactly < 0) {\n              assert totalHits == numHits;\n              maxCollectedExactly = doc + docBase;\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          super.setScorer(scorer);\n          if (trackTotalHits == false\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (trackTotalHits == false && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      sumMaxDoc += context.reader().maxDoc();\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          super.setScorer(scorer);\n          if (trackTotalHits == false\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (trackTotalHits == false && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n            if (maxCollectedExactly < 0) {\n              assert totalHits == numHits;\n              maxCollectedExactly = doc + docBase;\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        private void updateMinCompetitiveScore() {\n          // since we tie-break on doc id and collect in doc id order, we can require\n          // the next float\n          scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          super.setScorer(scorer);\n          if (totalHits >= totalHitsThreshold\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            updateMinCompetitiveScore();\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore();\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (totalHits >= totalHitsThreshold && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            updateMinCompetitiveScore();\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          super.setScorer(scorer);\n          if (trackTotalHits == false\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (trackTotalHits == false && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            // since we tie-break on doc id and collect in doc id order, we can require\n            // the next float\n            scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        private void updateMinCompetitiveScore() {\n          // since we tie-break on doc id and collect in doc id order, we can require\n          // the next float\n          scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          if (totalHits >= totalHitsThreshold\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            updateMinCompetitiveScore();\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore();\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (totalHits >= totalHitsThreshold && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            updateMinCompetitiveScore();\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        private void updateMinCompetitiveScore() {\n          // since we tie-break on doc id and collect in doc id order, we can require\n          // the next float\n          scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          super.setScorer(scorer);\n          if (totalHits >= totalHitsThreshold\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            updateMinCompetitiveScore();\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore();\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (totalHits >= totalHitsThreshold && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            updateMinCompetitiveScore();\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0dc52d2a83be9420989b1976a8e9d937160e1e5","date":1536062604,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        private void updateMinCompetitiveScore() throws IOException {\n          // since we tie-break on doc id and collect in doc id order, we can require\n          // the next float\n          scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          if (totalHits >= totalHitsThreshold\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            updateMinCompetitiveScore();\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore();\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (totalHits >= totalHitsThreshold && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            updateMinCompetitiveScore();\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        private void updateMinCompetitiveScore() {\n          // since we tie-break on doc id and collect in doc id order, we can require\n          // the next float\n          scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          if (totalHits >= totalHitsThreshold\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            updateMinCompetitiveScore();\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore();\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (totalHits >= totalHitsThreshold && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            updateMinCompetitiveScore();\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5003664d14ef48a0557ce1d8a684b15d62efe912","date":1539883534,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context)\n        throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        private void updateMinCompetitiveScore() throws IOException {\n          // since we tie-break on doc id and collect in doc id order, we can require\n          // the next float\n          scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n          totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          if (totalHits >= totalHitsThreshold\n              && pqTop != null\n              && pqTop.score != Float.NEGATIVE_INFINITY) {\n            updateMinCompetitiveScore();\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore();\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          if (totalHits >= totalHitsThreshold && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n            updateMinCompetitiveScore();\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5374ec368ef9441d694af8df95b2ffbae3d7f03b","date":1548748689,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits > totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","bugFix":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19eef45a852c3316ae52fdf941731448ece967a","date":1567670879,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits > totalHitsThreshold) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5319c194edd3bf49f39c6d198107ed213c1d3670","date":1569842580,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            if ((totalHitsRelation == TotalHits.Relation.EQUAL_TO || shouldUpdateMinScore())\n                  && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f00d3f1ad3bbb957062c4871ec23f49edda800c6","date":1569925943,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            // the document is not competitive but we need to update the minimum competitive score\n            // if we just reached the total hits threshold or if the global minimum score (bottomValueChecker)\n            // has been updated\n            updateMinCompetitiveScore(scorer, totalHitsRelation == TotalHits.Relation.EQUAL_TO);\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            if ((totalHitsRelation == TotalHits.Relation.EQUAL_TO || shouldUpdateMinScore())\n                  && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db0ef4e326916fc107ab6e066754d3ecba5197b","date":1570005243,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            // the document is not competitive but we need to update the minimum competitive score\n            // if we just reached the total hits threshold or if the global minimum score (bottomValueChecker)\n            // has been updated\n            updateMinCompetitiveScore(scorer, totalHitsRelation == TotalHits.Relation.EQUAL_TO);\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c10c01b195758b50e02599868e4093eb712f57","date":1570008306,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"807314aa41c10866aec273a0e54fd0d24d8971de","date":1570435832,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      // reset the minimum competitive score\n      docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"344fda225893210c79fc615c612df728a78bfbc6","date":1571224186,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      // reset the minimum competitive score\n      docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      // reset the minimum competitive score\n      docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","date":1571662992,"type":3,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.SimpleTopScoreDocCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      // reset the minimum competitive score\n      docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      return new ScorerLeafCollector() {\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = scorer.score();\n\n          // This collector relies on the fact that scorers produce positive values:\n          assert score >= 0; // NOTE: false for NaN\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (score <= pqTop.score) {\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && hitsThresholdChecker.isThresholdReached()) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            // Since docs are returned in-order (i.e., increasing doc Id), a document\n            // with equal score to pqTop.score cannot compete since HitQueue favors\n            // documents with lower doc Ids. Therefore reject those docs too.\n            return;\n          }\n          pqTop.doc = doc + docBase;\n          pqTop.score = score;\n          pqTop = pq.updateTop();\n          updateMinCompetitiveScore(scorer);\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e19eef45a852c3316ae52fdf941731448ece967a":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"807314aa41c10866aec273a0e54fd0d24d8971de":["f0c10c01b195758b50e02599868e4093eb712f57"],"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"901e951cec2e6af4e503209a6721c8834db23279":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["d0dc52d2a83be9420989b1976a8e9d937160e1e5"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["5319c194edd3bf49f39c6d198107ed213c1d3670"],"417142ff08fda9cf0b72d5133e63097a166c6458":["784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb","9fc47cb7b4346802411bb432f501ed0673d7119e"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["e19eef45a852c3316ae52fdf941731448ece967a","344fda225893210c79fc615c612df728a78bfbc6"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"d0dc52d2a83be9420989b1976a8e9d937160e1e5":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["901e951cec2e6af4e503209a6721c8834db23279"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f0c10c01b195758b50e02599868e4093eb712f57":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["417142ff08fda9cf0b72d5133e63097a166c6458"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"344fda225893210c79fc615c612df728a78bfbc6":["807314aa41c10866aec273a0e54fd0d24d8971de"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["e19eef45a852c3316ae52fdf941731448ece967a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["83788ad129a5154d5c6562c4e8ce3db48793aada"]},"commit2Childs":{"e19eef45a852c3316ae52fdf941731448ece967a":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","5319c194edd3bf49f39c6d198107ed213c1d3670"],"807314aa41c10866aec273a0e54fd0d24d8971de":["344fda225893210c79fc615c612df728a78bfbc6"],"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb":["417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"901e951cec2e6af4e503209a6721c8834db23279":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"417142ff08fda9cf0b72d5133e63097a166c6458":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["f0c10c01b195758b50e02599868e4093eb712f57"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb"],"d0dc52d2a83be9420989b1976a8e9d937160e1e5":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["d0dc52d2a83be9420989b1976a8e9d937160e1e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["901e951cec2e6af4e503209a6721c8834db23279"],"f0c10c01b195758b50e02599868e4093eb712f57":["807314aa41c10866aec273a0e54fd0d24d8971de"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["e19eef45a852c3316ae52fdf941731448ece967a"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"344fda225893210c79fc615c612df728a78bfbc6":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}