{"path":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","commits":[{"id":"120bc33d5cbe83eca2e5fce597baf4fef208d579","date":1573735895,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","pathOld":"/dev/null","sourceNew":"  private boolean deployPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate, boolean noprompt,\n      List<String> collections, String overrides[]) {\n    for (String collection: collections) {\n\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        boolean packageParamsExist = ((Map)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + \"/api/collections/abc/config/params/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, \"/api/collections/\" + collection + \"/config/params\",\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, \"/api/collections/\" + collection + \"/config/params\",\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, \"/api/cluster/package\", \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version);\n\n        for (Plugin plugin: packageInstance.plugins) {\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  String userInput = new Scanner(System.in, \"UTF-8\").next();\n                  if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                    shouldExecute = false;\n                    PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                        + \" Please run this step manually or refer to package documentation.\");\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, \"/api/collections/\" + collection + \"/config/params\",\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    // Verify that package was successfully deployed\n    boolean success = verify(packageInstance, collections);\n    if (success) {\n      PackageUtils.printGreen(\"Deployed and verified package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n    return success;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62d55718cd611235e975fa73a6bdf263fbd58859","date":1576386842,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","sourceNew":"  private boolean deployPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate, boolean noprompt,\n      List<String> collections, String overrides[]) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        boolean packageParamsExist = ((Map)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version);\n\n        for (Plugin plugin: packageInstance.plugins) {\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  String userInput = new Scanner(System.in, \"UTF-8\").next();\n                  if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                    shouldExecute = false;\n                    PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                        + \" Please run this step manually or refer to package documentation.\");\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n\n    boolean success = true;\n    if (deployedCollections.isEmpty() == false) {\n      // Verify that package was successfully deployed\n      success = verify(packageInstance, deployedCollections);\n      if (success) {\n        PackageUtils.printGreen(\"Deployed on \" + deployedCollections + \" and verified package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n      }\n    }\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n    return previouslyDeployed.isEmpty() && success;\n  }\n\n","sourceOld":"  private boolean deployPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate, boolean noprompt,\n      List<String> collections, String overrides[]) {\n    for (String collection: collections) {\n\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        boolean packageParamsExist = ((Map)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + \"/api/collections/abc/config/params/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, \"/api/collections/\" + collection + \"/config/params\",\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, \"/api/collections/\" + collection + \"/config/params\",\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, \"/api/cluster/package\", \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version);\n\n        for (Plugin plugin: packageInstance.plugins) {\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  String userInput = new Scanner(System.in, \"UTF-8\").next();\n                  if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                    shouldExecute = false;\n                    PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                        + \" Please run this step manually or refer to package documentation.\");\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, \"/api/collections/\" + collection + \"/config/params\",\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    // Verify that package was successfully deployed\n    boolean success = verify(packageInstance, collections);\n    if (success) {\n      PackageUtils.printGreen(\"Deployed and verified package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n    return success;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06595b0c22c7d3075c4104d3820cccf95d9d8a43","date":1576491645,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","sourceNew":"  private boolean deployPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate, boolean noprompt,\n      List<String> collections, String overrides[]) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        boolean packageParamsExist = ((Map)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version);\n\n        for (Plugin plugin: packageInstance.plugins) {\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  String userInput = new Scanner(System.in, \"UTF-8\").next();\n                  if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                    shouldExecute = false;\n                    PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                        + \" Please run this step manually or refer to package documentation.\");\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n\n    boolean success = true;\n    if (deployedCollections.isEmpty() == false) {\n      // Verify that package was successfully deployed\n      success = verify(packageInstance, deployedCollections);\n      if (success) {\n        PackageUtils.printGreen(\"Deployed on \" + deployedCollections + \" and verified package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n      }\n    }\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n    return previouslyDeployed.isEmpty() && success;\n  }\n\n","sourceOld":"  private boolean deployPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate, boolean noprompt,\n      List<String> collections, String overrides[]) {\n    for (String collection: collections) {\n\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        boolean packageParamsExist = ((Map)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + \"/api/collections/abc/config/params/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, \"/api/collections/\" + collection + \"/config/params\",\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, \"/api/collections/\" + collection + \"/config/params\",\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, \"/api/cluster/package\", \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version);\n\n        for (Plugin plugin: packageInstance.plugins) {\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  String userInput = new Scanner(System.in, \"UTF-8\").next();\n                  if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                    shouldExecute = false;\n                    PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                        + \" Please run this step manually or refer to package documentation.\");\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, \"/api/collections/\" + collection + \"/config/params\",\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    // Verify that package was successfully deployed\n    boolean success = verify(packageInstance, collections);\n    if (success) {\n      PackageUtils.printGreen(\"Deployed and verified package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n    return success;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private boolean deployPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate, boolean noprompt,\n      List<String> collections, String[] overrides) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        boolean packageParamsExist = ((Map)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version);\n\n        for (Plugin plugin: packageInstance.plugins) {\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  String userInput = new Scanner(System.in, \"UTF-8\").next();\n                  if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                    shouldExecute = false;\n                    PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                        + \" Please run this step manually or refer to package documentation.\");\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n\n    boolean success = true;\n    if (deployedCollections.isEmpty() == false) {\n      // Verify that package was successfully deployed\n      success = verify(packageInstance, deployedCollections);\n      if (success) {\n        PackageUtils.printGreen(\"Deployed on \" + deployedCollections + \" and verified package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n      }\n    }\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n    return previouslyDeployed.isEmpty() && success;\n  }\n\n","sourceOld":"  private boolean deployPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate, boolean noprompt,\n      List<String> collections, String overrides[]) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        boolean packageParamsExist = ((Map)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version);\n\n        for (Plugin plugin: packageInstance.plugins) {\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  String userInput = new Scanner(System.in, \"UTF-8\").next();\n                  if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                    shouldExecute = false;\n                    PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                        + \" Please run this step manually or refer to package documentation.\");\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n\n    boolean success = true;\n    if (deployedCollections.isEmpty() == false) {\n      // Verify that package was successfully deployed\n      success = verify(packageInstance, deployedCollections);\n      if (success) {\n        PackageUtils.printGreen(\"Deployed on \" + deployedCollections + \" and verified package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n      }\n    }\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n    return previouslyDeployed.isEmpty() && success;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a688687cbff91a8f44c95d31697c3ba8a47c8c25","date":1593512440,"type":5,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployCollectionPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],boolean,String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","sourceNew":"  /**\n   * @return list of collections on which packages deployed on\n   */\n  private Pair<List<String>, List<String>> deployCollectionPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate,\n      boolean noprompt, List<String> collections, boolean shouldDeployClusterPlugins, String[] overrides) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        @SuppressWarnings(\"unchecked\")\n        boolean packageParamsExist = ((Map<Object, Object>)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        for (Plugin plugin: packageInstance.plugins) {\n          if (\"collection\".equalsIgnoreCase(plugin.type) == false || collections.isEmpty()) continue;\n          Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version, \"plugin-name\", plugin.name);\n\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  try (Scanner scanner = new Scanner(System.in, \"UTF-8\")) {\n                    String userInput = scanner.next();\n                    if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                      shouldExecute = false;\n                      PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                          + \" Please run this step manually or refer to package documentation.\");\n                    }\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n    return new Pair<List<String>, List<String>>(deployedCollections, previouslyDeployed);\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  private boolean deployPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate, boolean noprompt,\n      List<String> collections, String[] overrides) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        boolean packageParamsExist = ((Map)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version);\n\n        for (Plugin plugin: packageInstance.plugins) {\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  String userInput = new Scanner(System.in, \"UTF-8\").next();\n                  if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                    shouldExecute = false;\n                    PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                        + \" Please run this step manually or refer to package documentation.\");\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n\n    boolean success = true;\n    if (deployedCollections.isEmpty() == false) {\n      // Verify that package was successfully deployed\n      success = verify(packageInstance, deployedCollections);\n      if (success) {\n        PackageUtils.printGreen(\"Deployed on \" + deployedCollections + \" and verified package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n      }\n    }\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n    return previouslyDeployed.isEmpty() && success;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06595b0c22c7d3075c4104d3820cccf95d9d8a43":["120bc33d5cbe83eca2e5fce597baf4fef208d579","62d55718cd611235e975fa73a6bdf263fbd58859"],"62d55718cd611235e975fa73a6bdf263fbd58859":["120bc33d5cbe83eca2e5fce597baf4fef208d579"],"120bc33d5cbe83eca2e5fce597baf4fef208d579":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a688687cbff91a8f44c95d31697c3ba8a47c8c25":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["62d55718cd611235e975fa73a6bdf263fbd58859"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a688687cbff91a8f44c95d31697c3ba8a47c8c25"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["120bc33d5cbe83eca2e5fce597baf4fef208d579"],"06595b0c22c7d3075c4104d3820cccf95d9d8a43":[],"62d55718cd611235e975fa73a6bdf263fbd58859":["06595b0c22c7d3075c4104d3820cccf95d9d8a43","bd25fa3647fa73152703b8dccb4fb5f43633de20"],"120bc33d5cbe83eca2e5fce597baf4fef208d579":["06595b0c22c7d3075c4104d3820cccf95d9d8a43","62d55718cd611235e975fa73a6bdf263fbd58859"],"a688687cbff91a8f44c95d31697c3ba8a47c8c25":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["a688687cbff91a8f44c95d31697c3ba8a47c8c25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["06595b0c22c7d3075c4104d3820cccf95d9d8a43","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}