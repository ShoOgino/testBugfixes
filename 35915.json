{"path":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","commits":[{"id":"fb8457dd0880f5547d70dbf40ea4f1c5e7787798","date":1363378339,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    if (reader instanceof AtomicReader) {\n      topReader = (AtomicReader) reader;\n    } else {\n      topReader = new SlowCompositeReaderWrapper((CompositeReader) reader);\n    }\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c557e6f970bbfb1e81bf6b491874ed620a4bb5","date":1373906832,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","sourceNew":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    if (reader instanceof AtomicReader) {\n      topReader = (AtomicReader) reader;\n    } else {\n      topReader = new SlowCompositeReaderWrapper((CompositeReader) reader);\n    }\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    if (reader instanceof AtomicReader) {\n      topReader = (AtomicReader) reader;\n    } else {\n      topReader = new SlowCompositeReaderWrapper((CompositeReader) reader);\n    }\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","sourceNew":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    if (reader instanceof AtomicReader) {\n      topReader = (AtomicReader) reader;\n    } else {\n      topReader = new SlowCompositeReaderWrapper((CompositeReader) reader);\n    }\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    if (reader instanceof AtomicReader) {\n      topReader = (AtomicReader) reader;\n    } else {\n      topReader = new SlowCompositeReaderWrapper((CompositeReader) reader);\n    }\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392","date":1377503666,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","sourceNew":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    if (reader instanceof AtomicReader) {\n      topReader = (AtomicReader) reader;\n    } else {\n      topReader = new SlowCompositeReaderWrapper((CompositeReader) reader);\n    }\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","sourceNew":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    if (reader instanceof AtomicReader) {\n      topReader = (AtomicReader) reader;\n    } else {\n      topReader = new SlowCompositeReaderWrapper((CompositeReader) reader);\n    }\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8428426152984b387a961487efefbe9cf62acf","date":1385332540,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","sourceNew":null,"sourceOld":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(FacetIndexingParams,IndexReader).mjava","sourceNew":null,"sourceOld":"  /** Create an instance, scanning the {@link\n   *  SortedSetDocValues} from the provided reader and\n   *  {@link FacetIndexingParams}. */\n  public SortedSetDocValuesReaderState(FacetIndexingParams fip, IndexReader reader) throws IOException {\n\n    this.field = fip.getCategoryListParams(null).field + FACET_FIELD_EXTENSION;\n    this.separator = fip.getFacetDelimChar();\n    this.separatorRegex = Pattern.quote(Character.toString(separator));\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = spare.utf8ToString().split(separatorRegex, 2);\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798","a3c557e6f970bbfb1e81bf6b491874ed620a4bb5"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["37a0f60745e53927c4c876cfe5b5a58170f0646c","df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392"],"a3c557e6f970bbfb1e81bf6b491874ed620a4bb5":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392":["a3c557e6f970bbfb1e81bf6b491874ed620a4bb5"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392","2e8428426152984b387a961487efefbe9cf62acf"],"2e8428426152984b387a961487efefbe9cf62acf":["df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"a3c557e6f970bbfb1e81bf6b491874ed620a4bb5":["37a0f60745e53927c4c876cfe5b5a58170f0646c","df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","3cc728b07df73b197e6d940d27f9b08b63918f13","2e8428426152984b387a961487efefbe9cf62acf"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2e8428426152984b387a961487efefbe9cf62acf":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["37a0f60745e53927c4c876cfe5b5a58170f0646c","a3c557e6f970bbfb1e81bf6b491874ed620a4bb5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}