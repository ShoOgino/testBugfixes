{"path":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene70/Lucene70RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","commits":[{"id":"773bf150032d3ef6c95997a154fb914b82875cb8","date":1590150786,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene70/Lucene70RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene70SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n          Lucene70SegmentInfoFormat.CODEC_NAME,\n          Lucene70SegmentInfoFormat.VERSION_CURRENT,\n          si.getId(),\n          \"\");\n      Version version = si.getVersion();\n      if (version.major < 7) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 7 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n\n      // Write the min Lucene version that contributed docs to the segment, since 7.0\n      if (si.getMinVersion() != null) {\n        output.writeByte((byte) 1);\n        Version minVersion = si.getMinVersion();\n        output.writeInt(minVersion.major);\n        output.writeInt(minVersion.minor);\n        output.writeInt(minVersion.bugfix);\n      } else {\n        output.writeByte((byte) 0);\n      }\n\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value\n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n            case STRING:\n              if (missingValue == SortField.STRING_LAST) {\n                output.writeByte((byte) 1);\n              } else if (missingValue == SortField.STRING_FIRST) {\n                output.writeByte((byte) 2);\n              } else {\n                throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n              }\n              break;\n            case LONG:\n              output.writeByte((byte) 1);\n              output.writeLong(((Long) missingValue).longValue());\n              break;\n            case INT:\n              output.writeByte((byte) 1);\n              output.writeInt(((Integer) missingValue).intValue());\n              break;\n            case DOUBLE:\n              output.writeByte((byte) 1);\n              output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n              break;\n            case FLOAT:\n              output.writeByte((byte) 1);\n              output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n              break;\n            default:\n              throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene70SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene70SegmentInfoFormat.CODEC_NAME,\n                                   Lucene70SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 7) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 7 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n\n      // Write the min Lucene version that contributed docs to the segment, since 7.0\n      if (si.getMinVersion() != null) {\n        output.writeByte((byte) 1);\n        Version minVersion = si.getMinVersion();\n        output.writeInt(minVersion.major);\n        output.writeInt(minVersion.minor);\n        output.writeInt(minVersion.bugfix);\n      } else {\n        output.writeByte((byte) 0);\n      }\n\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"773bf150032d3ef6c95997a154fb914b82875cb8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["773bf150032d3ef6c95997a154fb914b82875cb8"]},"commit2Childs":{"773bf150032d3ef6c95997a154fb914b82875cb8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["773bf150032d3ef6c95997a154fb914b82875cb8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}