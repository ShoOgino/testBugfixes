{"path":"solr/contrib/analysis-extras/src/java/org/apache/solr/update/processor/OpenNLPExtractNamedEntitiesUpdateProcessorFactory#initSimpleRegexReplacement(NamedList).mjava","commits":[{"id":"afc5b4b2446e392448f36ae4f5a164540f2ccb65","date":1513355058,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/contrib/analysis-extras/src/java/org/apache/solr/update/processor/OpenNLPExtractNamedEntitiesUpdateProcessorFactory#initSimpleRegexReplacement(NamedList).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * init helper method that should only be called when we know for certain that both the\n   * \"source\" and \"dest\" init params do <em>not</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSimpleRegexReplacement(NamedList args) {\n    // The syntactic sugar for the case where there is only one regex pattern for source and the same pattern\n    // is used for the destination pattern...\n    //\n    //  pattern != null && replacement != null\n    //\n    // ...as top level elements, with no other config options specified\n\n    // if we got here we know we had pattern and replacement, now check for the other two  so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(SOURCE_PARAM, 0) || 0 <= args.indexOf(DEST_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" +\n          PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \" but also found \" + SOURCE_PARAM + \" or \" + DEST_PARAM);\n    }\n\n    assert args.indexOf(SOURCE_PARAM, 0) < 0;\n\n    Object patt = args.remove(PATTERN_PARAM);\n    Object replacement = args.remove(REPLACEMENT_PARAM);\n\n    if (null == patt || null == replacement) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + PATTERN_PARAM + \"' and '\" +\n          REPLACEMENT_PARAM + \"' are both mandatory if '\" + SOURCE_PARAM + \"' and '\"+\n          DEST_PARAM + \"' are not both specified\");\n    }\n\n    if (0 != args.size()) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + REPLACEMENT_PARAM + \"' and '\" +\n          PATTERN_PARAM + \"' must be children of '\" + DEST_PARAM +\n          \"' to be combined with other options.\");\n    }\n\n    if (!(replacement instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + REPLACEMENT_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n    if (!(patt instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + PATTERN_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n\n    dest = replacement.toString();\n    try {\n      this.pattern = Pattern.compile(patt.toString());\n    } catch (PatternSyntaxException pe) {\n      throw new SolrException(SERVER_ERROR, \"Init param \" + PATTERN_PARAM +\n          \" is not a valid regex pattern: \" + patt, pe);\n\n    }\n    srcInclusions = new SelectorParams();\n    srcInclusions.fieldRegex = Collections.singletonList(this.pattern);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc","date":1591973782,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/analysis-extras/src/java/org/apache/solr/update/processor/OpenNLPExtractNamedEntitiesUpdateProcessorFactory#initSimpleRegexReplacement(NamedList).mjava","pathOld":"solr/contrib/analysis-extras/src/java/org/apache/solr/update/processor/OpenNLPExtractNamedEntitiesUpdateProcessorFactory#initSimpleRegexReplacement(NamedList).mjava","sourceNew":"  /**\n   * init helper method that should only be called when we know for certain that both the\n   * \"source\" and \"dest\" init params do <em>not</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSimpleRegexReplacement(@SuppressWarnings({\"rawtypes\"})NamedList args) {\n    // The syntactic sugar for the case where there is only one regex pattern for source and the same pattern\n    // is used for the destination pattern...\n    //\n    //  pattern != null && replacement != null\n    //\n    // ...as top level elements, with no other config options specified\n\n    // if we got here we know we had pattern and replacement, now check for the other two  so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(SOURCE_PARAM, 0) || 0 <= args.indexOf(DEST_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" +\n          PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \" but also found \" + SOURCE_PARAM + \" or \" + DEST_PARAM);\n    }\n\n    assert args.indexOf(SOURCE_PARAM, 0) < 0;\n\n    Object patt = args.remove(PATTERN_PARAM);\n    Object replacement = args.remove(REPLACEMENT_PARAM);\n\n    if (null == patt || null == replacement) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + PATTERN_PARAM + \"' and '\" +\n          REPLACEMENT_PARAM + \"' are both mandatory if '\" + SOURCE_PARAM + \"' and '\"+\n          DEST_PARAM + \"' are not both specified\");\n    }\n\n    if (0 != args.size()) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + REPLACEMENT_PARAM + \"' and '\" +\n          PATTERN_PARAM + \"' must be children of '\" + DEST_PARAM +\n          \"' to be combined with other options.\");\n    }\n\n    if (!(replacement instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + REPLACEMENT_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n    if (!(patt instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + PATTERN_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n\n    dest = replacement.toString();\n    try {\n      this.pattern = Pattern.compile(patt.toString());\n    } catch (PatternSyntaxException pe) {\n      throw new SolrException(SERVER_ERROR, \"Init param \" + PATTERN_PARAM +\n          \" is not a valid regex pattern: \" + patt, pe);\n\n    }\n    srcInclusions = new SelectorParams();\n    srcInclusions.fieldRegex = Collections.singletonList(this.pattern);\n  }\n\n","sourceOld":"  /**\n   * init helper method that should only be called when we know for certain that both the\n   * \"source\" and \"dest\" init params do <em>not</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSimpleRegexReplacement(NamedList args) {\n    // The syntactic sugar for the case where there is only one regex pattern for source and the same pattern\n    // is used for the destination pattern...\n    //\n    //  pattern != null && replacement != null\n    //\n    // ...as top level elements, with no other config options specified\n\n    // if we got here we know we had pattern and replacement, now check for the other two  so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(SOURCE_PARAM, 0) || 0 <= args.indexOf(DEST_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" +\n          PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \" but also found \" + SOURCE_PARAM + \" or \" + DEST_PARAM);\n    }\n\n    assert args.indexOf(SOURCE_PARAM, 0) < 0;\n\n    Object patt = args.remove(PATTERN_PARAM);\n    Object replacement = args.remove(REPLACEMENT_PARAM);\n\n    if (null == patt || null == replacement) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + PATTERN_PARAM + \"' and '\" +\n          REPLACEMENT_PARAM + \"' are both mandatory if '\" + SOURCE_PARAM + \"' and '\"+\n          DEST_PARAM + \"' are not both specified\");\n    }\n\n    if (0 != args.size()) {\n      throw new SolrException(SERVER_ERROR, \"Init params '\" + REPLACEMENT_PARAM + \"' and '\" +\n          PATTERN_PARAM + \"' must be children of '\" + DEST_PARAM +\n          \"' to be combined with other options.\");\n    }\n\n    if (!(replacement instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + REPLACEMENT_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n    if (!(patt instanceof String)) {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + PATTERN_PARAM + \"' must be a string (i.e. <str>)\");\n    }\n\n    dest = replacement.toString();\n    try {\n      this.pattern = Pattern.compile(patt.toString());\n    } catch (PatternSyntaxException pe) {\n      throw new SolrException(SERVER_ERROR, \"Init param \" + PATTERN_PARAM +\n          \" is not a valid regex pattern: \" + patt, pe);\n\n    }\n    srcInclusions = new SelectorParams();\n    srcInclusions.fieldRegex = Collections.singletonList(this.pattern);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc":["afc5b4b2446e392448f36ae4f5a164540f2ccb65"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc"],"afc5b4b2446e392448f36ae4f5a164540f2ccb65":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["afc5b4b2446e392448f36ae4f5a164540f2ccb65"],"c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"afc5b4b2446e392448f36ae4f5a164540f2ccb65":["c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}