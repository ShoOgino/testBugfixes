{"path":"solr/core/src/java/org/apache/solr/internal/csv/CSVParser#encapsulatedTokenLexer(Token,int).mjava","commits":[{"id":"80931fa1f3b04650bde7b20e61b02063a7093ced","date":1333130683,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/CSVParser#encapsulatedTokenLexer(Token,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * An encapsulated token lexer\n   * \n   * Encapsulated tokens are surrounded by the given encapsulating-string.\n   * The encapsulator itself might be included in the token using a\n   * doubling syntax (as \"\", '') or using escaping (as in \\\", \\').\n   * Whitespaces before and after an encapsulated token are ignored.\n   * \n   * @param tkn    the current token\n   * @param c      the current character\n   * @return a valid token object\n   * @throws IOException on invalid state\n   */\n  private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {\n    // save current line\n    int startLineNumber = getLineNumber();\n    // ignore the given delimiter\n    // assert c == delimiter;\n    for (;;) {\n      c = in.read();\n\n      if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead()=='u') {\n        tkn.content.append((char) unicodeEscapeLexer(c));\n      } else if (c == strategy.getEscape()) {\n        tkn.content.append((char)readEscape(c));\n      } else if (c == strategy.getEncapsulator()) {\n        if (in.lookAhead() == strategy.getEncapsulator()) {\n          // double or escaped encapsulator -> add single encapsulator to token\n          c = in.read();\n          tkn.content.append((char) c);\n        } else {\n          // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n          for (;;) {\n            c = in.read();\n            if (c == strategy.getDelimiter()) {\n              tkn.type = TT_TOKEN;\n              tkn.isReady = true;\n              return tkn;\n            } else if (isEndOfFile(c)) {\n              tkn.type = TT_EOF;\n              tkn.isReady = true;\n              return tkn;\n            } else if (isEndOfLine(c)) {\n              // ok eo token reached\n              tkn.type = TT_EORECORD;\n              tkn.isReady = true;\n              return tkn;\n            } else if (!isWhitespace(c)) {\n              // error invalid char between token and next delimiter\n              throw new IOException(\n                      \"(line \" + getLineNumber()\n                              + \") invalid char between encapsulated token end delimiter\"\n              );\n            }\n          }\n        }\n      } else if (isEndOfFile(c)) {\n        // error condition (end of file before end of token)\n        throw new IOException(\n                \"(startline \" + startLineNumber + \")\"\n                        + \"eof reached before encapsulated token finished\"\n        );\n      } else {\n        // consume character\n        tkn.content.append((char) c);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80931fa1f3b04650bde7b20e61b02063a7093ced":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["80931fa1f3b04650bde7b20e61b02063a7093ced"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["80931fa1f3b04650bde7b20e61b02063a7093ced"],"80931fa1f3b04650bde7b20e61b02063a7093ced":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}