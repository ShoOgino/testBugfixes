{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testRefreshAndRollbackConcurrently().mjava","commits":[{"id":"183c6c48c88f771980fbee167337abf9932c6f80","date":1558625128,"type":0,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testRefreshAndRollbackConcurrently().mjava","pathOld":"/dev/null","sourceNew":"  public void testRefreshAndRollbackConcurrently() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    AtomicBoolean stopped = new AtomicBoolean();\n    Semaphore indexedDocs = new Semaphore(0);\n    Thread indexer = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          String id = Integer.toString(random().nextInt(100));\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", id, Field.Store.YES));\n          w.updateDocument(new Term(\"id\", id), doc);\n          indexedDocs.release(1);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    SearcherManager sm = new SearcherManager(w, new SearcherFactory());\n    Thread refresher = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          sm.maybeRefreshBlocking();\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    try {\n      indexer.start();\n      refresher.start();\n      indexedDocs.acquire(1 + random().nextInt(100));\n      w.rollback();\n    } finally {\n      stopped.set(true);\n      indexer.join();\n      refresher.join();\n      IOUtils.close(sm, dir);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bdc52ba55664e70ae5a247af51566dd96fc2a1c","date":1583869220,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testRefreshAndRollbackConcurrently().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testRefreshAndRollbackConcurrently().mjava","sourceNew":"  public void testRefreshAndRollbackConcurrently() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    AtomicBoolean stopped = new AtomicBoolean();\n    Semaphore indexedDocs = new Semaphore(0);\n    Thread indexer = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          String id = Integer.toString(random().nextInt(100));\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", id, Field.Store.YES));\n          w.updateDocument(new Term(\"id\", id), doc);\n          indexedDocs.release(1);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    SearcherManager sm = new SearcherManager(w, new SearcherFactory());\n    Thread refresher = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          sm.maybeRefreshBlocking();\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    try {\n      indexer.start();\n      refresher.start();\n      indexedDocs.acquire(1 + random().nextInt(100));\n      w.rollback();\n    } finally {\n      stopped.set(true);\n      indexer.join();\n      refresher.join();\n      assertNull(\"should not consider ACE a tragedy on a closed IW\", w.getTragicException());\n      IOUtils.close(sm, dir);\n    }\n  }\n\n","sourceOld":"  public void testRefreshAndRollbackConcurrently() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    AtomicBoolean stopped = new AtomicBoolean();\n    Semaphore indexedDocs = new Semaphore(0);\n    Thread indexer = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          String id = Integer.toString(random().nextInt(100));\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", id, Field.Store.YES));\n          w.updateDocument(new Term(\"id\", id), doc);\n          indexedDocs.release(1);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    SearcherManager sm = new SearcherManager(w, new SearcherFactory());\n    Thread refresher = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          sm.maybeRefreshBlocking();\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    try {\n      indexer.start();\n      refresher.start();\n      indexedDocs.acquire(1 + random().nextInt(100));\n      w.rollback();\n    } finally {\n      stopped.set(true);\n      indexer.join();\n      refresher.join();\n      IOUtils.close(sm, dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testRefreshAndRollbackConcurrently().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testRefreshAndRollbackConcurrently().mjava","sourceNew":"  public void testRefreshAndRollbackConcurrently() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    AtomicBoolean stopped = new AtomicBoolean();\n    Semaphore indexedDocs = new Semaphore(0);\n    Thread indexer = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          String id = Integer.toString(random().nextInt(100));\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", id, Field.Store.YES));\n          w.updateDocument(new Term(\"id\", id), doc);\n          indexedDocs.release(1);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    SearcherManager sm = new SearcherManager(w, new SearcherFactory());\n    Thread refresher = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          sm.maybeRefreshBlocking();\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    try {\n      indexer.start();\n      refresher.start();\n      indexedDocs.acquire(1 + random().nextInt(100));\n      w.rollback();\n    } finally {\n      stopped.set(true);\n      indexer.join();\n      refresher.join();\n      Throwable e = w.getTragicException();\n      IOSupplier<String> supplier = () -> {\n        if (e != null) {\n          StringWriter writer = new StringWriter();\n          try (PrintWriter printWriter = new PrintWriter(writer)) {\n            e.printStackTrace(printWriter);\n          }\n          return writer.toString();\n        } else {\n          return \"\";\n        }\n      };\n      assertNull(\"should not consider ACE a tragedy on a closed IW: \" + supplier.get(), w.getTragicException());\n      IOUtils.close(sm, dir);\n    }\n  }\n\n","sourceOld":"  public void testRefreshAndRollbackConcurrently() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());\n    AtomicBoolean stopped = new AtomicBoolean();\n    Semaphore indexedDocs = new Semaphore(0);\n    Thread indexer = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          String id = Integer.toString(random().nextInt(100));\n          Document doc = new Document();\n          doc.add(new StringField(\"id\", id, Field.Store.YES));\n          w.updateDocument(new Term(\"id\", id), doc);\n          indexedDocs.release(1);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    SearcherManager sm = new SearcherManager(w, new SearcherFactory());\n    Thread refresher = new Thread(() -> {\n      while (stopped.get() == false) {\n        try {\n          sm.maybeRefreshBlocking();\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        } catch (AlreadyClosedException ignored) {\n          return;\n        }\n      }\n    });\n\n    try {\n      indexer.start();\n      refresher.start();\n      indexedDocs.acquire(1 + random().nextInt(100));\n      w.rollback();\n    } finally {\n      stopped.set(true);\n      indexer.join();\n      refresher.join();\n      assertNull(\"should not consider ACE a tragedy on a closed IW\", w.getTragicException());\n      IOUtils.close(sm, dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"264935965977b4a9e2f3920420647072c9c49176":["3bdc52ba55664e70ae5a247af51566dd96fc2a1c"],"183c6c48c88f771980fbee167337abf9932c6f80":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3bdc52ba55664e70ae5a247af51566dd96fc2a1c":["183c6c48c88f771980fbee167337abf9932c6f80"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["264935965977b4a9e2f3920420647072c9c49176"]},"commit2Childs":{"264935965977b4a9e2f3920420647072c9c49176":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"183c6c48c88f771980fbee167337abf9932c6f80":["3bdc52ba55664e70ae5a247af51566dd96fc2a1c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["183c6c48c88f771980fbee167337abf9932c6f80"],"3bdc52ba55664e70ae5a247af51566dd96fc2a1c":["264935965977b4a9e2f3920420647072c9c49176"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}