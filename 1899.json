{"path":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","commits":[{"id":"c1c1dd5dce93e4fa48898dabc7e012560acda425","date":1381334364,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      BooleanQuery bq = (BooleanQuery) query;\n      bq.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));\n    }\n    return query;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","sourceNew":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      BooleanQuery bq = (BooleanQuery) query;\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setDisableCoord(bq.isCoordDisabled());\n      builder.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));\n      for (BooleanClause clause : bq) {\n        builder.add(clause);\n      }\n      query = builder.build();\n    }\n    return query;\n  }\n\n","sourceOld":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      BooleanQuery bq = (BooleanQuery) query;\n      bq.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","sourceNew":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      BooleanQuery bq = (BooleanQuery) query;\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));\n      for (BooleanClause clause : bq) {\n        builder.add(clause);\n      }\n      query = builder.build();\n    }\n    return query;\n  }\n\n","sourceOld":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      BooleanQuery bq = (BooleanQuery) query;\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setDisableCoord(bq.isCoordDisabled());\n      builder.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));\n      for (BooleanClause clause : bq) {\n        builder.add(clause);\n      }\n      query = builder.build();\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","sourceNew":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      BooleanQuery bq = (BooleanQuery) query;\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));\n      for (BooleanClause clause : bq) {\n        builder.add(clause);\n      }\n      query = builder.build();\n    }\n    return query;\n  }\n\n","sourceOld":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      BooleanQuery bq = (BooleanQuery) query;\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setDisableCoord(bq.isCoordDisabled());\n      builder.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));\n      for (BooleanClause clause : bq) {\n        builder.add(clause);\n      }\n      query = builder.build();\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52c30617998e1bc2a946cc226f52e9b35162b1e","date":1483438353,"type":3,"author":"Matt Weber","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","sourceNew":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      query = addMinShouldMatchToBoolean((BooleanQuery) query, fraction);\n    } else if (query instanceof GraphQuery && ((GraphQuery) query).hasBoolean()) {\n      // we have a graph query that has at least one boolean sub-query\n      // re-build and set minimum should match on each boolean found\n      List<Query> oldQueries = ((GraphQuery) query).getQueries();\n      Query[] queries = new Query[oldQueries.size()];\n      for (int i = 0; i < queries.length; i++) {\n        Query oldQuery = oldQueries.get(i);\n        if (oldQuery instanceof BooleanQuery) {\n          queries[i] = addMinShouldMatchToBoolean((BooleanQuery) oldQuery, fraction);\n        } else {\n          queries[i] = oldQuery;\n        }\n      }\n\n      query = new GraphQuery(queries);\n    }\n    return query;\n  }\n\n","sourceOld":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      BooleanQuery bq = (BooleanQuery) query;\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));\n      for (BooleanClause clause : bq) {\n        builder.add(clause);\n      }\n      query = builder.build();\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","sourceNew":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      query = addMinShouldMatchToBoolean((BooleanQuery) query, fraction);\n    } else if (query instanceof GraphQuery && ((GraphQuery) query).hasBoolean()) {\n      // we have a graph query that has at least one boolean sub-query\n      // re-build and set minimum should match on each boolean found\n      List<Query> oldQueries = ((GraphQuery) query).getQueries();\n      Query[] queries = new Query[oldQueries.size()];\n      for (int i = 0; i < queries.length; i++) {\n        Query oldQuery = oldQueries.get(i);\n        if (oldQuery instanceof BooleanQuery) {\n          queries[i] = addMinShouldMatchToBoolean((BooleanQuery) oldQuery, fraction);\n        } else {\n          queries[i] = oldQuery;\n        }\n      }\n\n      query = new GraphQuery(queries);\n    }\n    return query;\n  }\n\n","sourceOld":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      BooleanQuery bq = (BooleanQuery) query;\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch((int) (fraction * bq.clauses().size()));\n      for (BooleanClause clause : bq) {\n        builder.add(clause);\n      }\n      query = builder.build();\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db","date":1486463279,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#createMinShouldMatchQuery(String,String,float).mjava","sourceNew":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: weird that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      query = addMinShouldMatchToBoolean((BooleanQuery) query, fraction);\n    }\n    return query;\n  }\n\n","sourceOld":"  /** \n   * Creates a minimum-should-match query from the query text.\n   * <p>\n   * @param field field name\n   * @param queryText text to be passed to the analyzer\n   * @param fraction of query terms {@code [0..1]} that should match \n   * @return {@code TermQuery} or {@code BooleanQuery}, based on the analysis \n   *         of {@code queryText}\n   */\n  public Query createMinShouldMatchQuery(String field, String queryText, float fraction) {\n    if (Float.isNaN(fraction) || fraction < 0 || fraction > 1) {\n      throw new IllegalArgumentException(\"fraction should be >= 0 and <= 1\");\n    }\n    \n    // TODO: wierd that BQ equals/rewrite/scorer doesn't handle this?\n    if (fraction == 1) {\n      return createBooleanQuery(field, queryText, BooleanClause.Occur.MUST);\n    }\n    \n    Query query = createFieldQuery(analyzer, BooleanClause.Occur.SHOULD, field, queryText, false, 0);\n    if (query instanceof BooleanQuery) {\n      query = addMinShouldMatchToBoolean((BooleanQuery) query, fraction);\n    } else if (query instanceof GraphQuery && ((GraphQuery) query).hasBoolean()) {\n      // we have a graph query that has at least one boolean sub-query\n      // re-build and set minimum should match on each boolean found\n      List<Query> oldQueries = ((GraphQuery) query).getQueries();\n      Query[] queries = new Query[oldQueries.size()];\n      for (int i = 0; i < queries.length; i++) {\n        Query oldQuery = oldQueries.get(i);\n        if (oldQuery instanceof BooleanQuery) {\n          queries[i] = addMinShouldMatchToBoolean((BooleanQuery) oldQuery, fraction);\n        } else {\n          queries[i] = oldQuery;\n        }\n      }\n\n      query = new GraphQuery(queries);\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["c1c1dd5dce93e4fa48898dabc7e012560acda425"],"e52c30617998e1bc2a946cc226f52e9b35162b1e":["c8a0e442f7b61f811680273b25da95994a724466"],"c1c1dd5dce93e4fa48898dabc7e012560acda425":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c8a0e442f7b61f811680273b25da95994a724466":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","c8a0e442f7b61f811680273b25da95994a724466"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db"],"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db":["e52c30617998e1bc2a946cc226f52e9b35162b1e"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e52c30617998e1bc2a946cc226f52e9b35162b1e"]},"commit2Childs":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["c8a0e442f7b61f811680273b25da95994a724466","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"e52c30617998e1bc2a946cc226f52e9b35162b1e":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"c1c1dd5dce93e4fa48898dabc7e012560acda425":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c1c1dd5dce93e4fa48898dabc7e012560acda425"],"c8a0e442f7b61f811680273b25da95994a724466":["e52c30617998e1bc2a946cc226f52e9b35162b1e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}