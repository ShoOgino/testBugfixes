{"path":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","commits":[{"id":"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79","date":1509089658,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testLatLonRetrieval() throws Exception {\n    assertU(adoc(\"id\", \"0\",\n        \"llp_1_dv_st\", \"-75,41\",\n        \"llp_1_dv\", \"-80,20\",\n        \"llp_1_dv_dvasst\", \"10,-30\"));\n    assertU(commit());\n    assertJQ(req(\"q\",\"*:*\", \"fl\",\"*\"),\n        \"response/docs/[0]/llp_1_dv_st=='-75,41'\",\n        // Right now we do not support decoding point value from dv field\n        \"!response/docs/[0]/llp_1_dv=='-80,20'\",\n        \"!response/docs/[0]/llp_1_dv_dvasst=='10,-30'\");\n    assertJQ(req(\"q\",\"*:*\", \"fl\",\"llp_1_dv_st, llp_1_dv, llp_1_dv_dvasst\"),\n        \"response/docs/[0]/llp_1_dv_st=='-75,41'\",\n        // Even when these fields are specified, we won't return them\n        \"!response/docs/[0]/llp_1_dv=='-80,20'\",\n        \"!response/docs/[0]/llp_1_dv_dvasst=='10,-30'\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e664487f12f836ec07e7c44c5ddc682388a15cf","date":1521303713,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","sourceNew":"  @Test\n  public void testLatLonRetrieval() throws Exception {\n    final String ptHighPrecision = \"40.2996543270,-74.0824956673\";\n    final String ptLossOfPrecision = \"40.2996544,-74.0824957\"; // rounded version of the one above, losing precision\n\n    // \"_1\" is single, \"_N\" is multiValued\n    // \"_dv\" is docValues (otherwise not),  \"_dvasst\" is useDocValuesAsStored (otherwise not)\n    // \"_st\" is stored\" (otherwise not)\n\n    List<RetrievalCombo> combos = Arrays.asList(\n        new RetrievalCombo(\"llp_1_dv_st\", ptHighPrecision),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\", \"-45,45\")),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\")), // multiValued but 1 value\n\n        new RetrievalCombo(\"llp_1_dv_dvasst\", ptHighPrecision, ptLossOfPrecision),\n        // this one comes back in a different order since it gets sorted low to high\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\"-40,40\", \"-45,45\"), Arrays.asList(\"-45,45\", \"-40,40\")),\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\"-40,40\")), // multiValued but 1 value\n        // edge cases.  (note we sorted it as Lucene will internally)\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\n            \"-90,180\", \"-90,-180\",\n            \"0,0\", \"0,180\", \"0,-180\",\n            \"90,0\", \"90,180\", \"90,-180\")),\n\n        new RetrievalCombo(\"llp_1_dv\", ptHighPrecision, ptLossOfPrecision),\n        new RetrievalCombo(\"llp_N_dv\", Arrays.asList(\"-45,45\", \"-40,40\"))\n\n        );\n    Collections.shuffle(combos, random());\n\n    // add and commit\n    for (RetrievalCombo combo : combos) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", \"\" + combo.id);\n      for (String indexValue : combo.indexValues) {\n        doc.addField(combo.fieldName, indexValue);\n      }\n      assertU(adoc(doc));\n      if (TestUtils.rarely()) { // induce segments to potentially change internal behavior\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // create an assertJQ assertion string, once for fl=*, another for when the field is listed\n    List<String> assertJQsFlListed = new ArrayList<>();\n    List<String> assertJQsFlStar = new ArrayList<>();\n    for (RetrievalCombo combo : combos) {\n      String expect = \"response/docs/[\" + combo.id + \"]/\" + combo.fieldName + \"==\" + combo.expectReturnJSON;\n      assertJQsFlListed.add(expect);\n      if (combo.fieldName.endsWith(\"_dv\")) {\n        expect =  \"response/docs/[\" + combo.id + \"]=={'id':'\" + combo.id + \"'}\"; // only the id, nothing else\n      }\n      assertJQsFlStar.add(expect);\n    }\n    // check\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\",\"*\"),\n        assertJQsFlStar.toArray(new String[0]));\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\", \"id,\" + combos.stream().map(c -> c.fieldName).collect(Collectors.joining(\",\"))),\n        assertJQsFlListed.toArray(new String[0]));\n  }\n\n","sourceOld":"  @Test\n  public void testLatLonRetrieval() throws Exception {\n    assertU(adoc(\"id\", \"0\",\n        \"llp_1_dv_st\", \"-75,41\",\n        \"llp_1_dv\", \"-80,20\",\n        \"llp_1_dv_dvasst\", \"10,-30\"));\n    assertU(commit());\n    assertJQ(req(\"q\",\"*:*\", \"fl\",\"*\"),\n        \"response/docs/[0]/llp_1_dv_st=='-75,41'\",\n        // Right now we do not support decoding point value from dv field\n        \"!response/docs/[0]/llp_1_dv=='-80,20'\",\n        \"!response/docs/[0]/llp_1_dv_dvasst=='10,-30'\");\n    assertJQ(req(\"q\",\"*:*\", \"fl\",\"llp_1_dv_st, llp_1_dv, llp_1_dv_dvasst\"),\n        \"response/docs/[0]/llp_1_dv_st=='-75,41'\",\n        // Even when these fields are specified, we won't return them\n        \"!response/docs/[0]/llp_1_dv=='-80,20'\",\n        \"!response/docs/[0]/llp_1_dv_dvasst=='10,-30'\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","sourceNew":"  @Test\n  public void testLatLonRetrieval() throws Exception {\n    final String ptHighPrecision = \"40.2996543270,-74.0824956673\";\n    final String ptLossOfPrecision = \"40.2996544,-74.0824957\"; // rounded version of the one above, losing precision\n\n    // \"_1\" is single, \"_N\" is multiValued\n    // \"_dv\" is docValues (otherwise not),  \"_dvasst\" is useDocValuesAsStored (otherwise not)\n    // \"_st\" is stored\" (otherwise not)\n\n    List<RetrievalCombo> combos = Arrays.asList(\n        new RetrievalCombo(\"llp_1_dv_st\", ptHighPrecision),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\", \"-45,45\")),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\")), // multiValued but 1 value\n\n        new RetrievalCombo(\"llp_1_dv_dvasst\", ptHighPrecision, ptLossOfPrecision),\n        // this one comes back in a different order since it gets sorted low to high\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\"-40,40\", \"-45,45\"), Arrays.asList(\"-45,45\", \"-40,40\")),\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\"-40,40\")), // multiValued but 1 value\n        // edge cases.  (note we sorted it as Lucene will internally)\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\n            \"-90,180\", \"-90,-180\",\n            \"0,0\", \"0,180\", \"0,-180\",\n            \"90,0\", \"90,180\", \"90,-180\")),\n\n        new RetrievalCombo(\"llp_1_dv\", ptHighPrecision, ptLossOfPrecision),\n        new RetrievalCombo(\"llp_N_dv\", Arrays.asList(\"-45,45\", \"-40,40\"))\n\n        );\n    Collections.shuffle(combos, random());\n\n    // add and commit\n    for (RetrievalCombo combo : combos) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", \"\" + combo.id);\n      for (String indexValue : combo.indexValues) {\n        doc.addField(combo.fieldName, indexValue);\n      }\n      assertU(adoc(doc));\n      if (TestUtils.rarely()) { // induce segments to potentially change internal behavior\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // create an assertJQ assertion string, once for fl=*, another for when the field is listed\n    List<String> assertJQsFlListed = new ArrayList<>();\n    List<String> assertJQsFlStar = new ArrayList<>();\n    for (RetrievalCombo combo : combos) {\n      String expect = \"response/docs/[\" + combo.id + \"]/\" + combo.fieldName + \"==\" + combo.expectReturnJSON;\n      assertJQsFlListed.add(expect);\n      if (combo.fieldName.endsWith(\"_dv\")) {\n        expect =  \"response/docs/[\" + combo.id + \"]=={'id':'\" + combo.id + \"'}\"; // only the id, nothing else\n      }\n      assertJQsFlStar.add(expect);\n    }\n    // check\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\",\"*\"),\n        assertJQsFlStar.toArray(new String[0]));\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\", \"id,\" + combos.stream().map(c -> c.fieldName).collect(Collectors.joining(\",\"))),\n        assertJQsFlListed.toArray(new String[0]));\n  }\n\n","sourceOld":"  @Test\n  public void testLatLonRetrieval() throws Exception {\n    assertU(adoc(\"id\", \"0\",\n        \"llp_1_dv_st\", \"-75,41\",\n        \"llp_1_dv\", \"-80,20\",\n        \"llp_1_dv_dvasst\", \"10,-30\"));\n    assertU(commit());\n    assertJQ(req(\"q\",\"*:*\", \"fl\",\"*\"),\n        \"response/docs/[0]/llp_1_dv_st=='-75,41'\",\n        // Right now we do not support decoding point value from dv field\n        \"!response/docs/[0]/llp_1_dv=='-80,20'\",\n        \"!response/docs/[0]/llp_1_dv_dvasst=='10,-30'\");\n    assertJQ(req(\"q\",\"*:*\", \"fl\",\"llp_1_dv_st, llp_1_dv, llp_1_dv_dvasst\"),\n        \"response/docs/[0]/llp_1_dv_st=='-75,41'\",\n        // Even when these fields are specified, we won't return them\n        \"!response/docs/[0]/llp_1_dv=='-80,20'\",\n        \"!response/docs/[0]/llp_1_dv_dvasst=='10,-30'\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30624fc97c03dcee86ae05dc59c16f5febcf0b0a","date":1523717511,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","sourceNew":"  @Test\n  public void testLatLonRetrieval() throws Exception {\n    final String ptHighPrecision =   \"40.2996543270,-74.0824956673\";\n    final String ptLossOfPrecision = \"40.2996544,-74.0824957\"; // rounded version of the one above, losing precision\n\n    // \"_1\" is single, \"_N\" is multiValued\n    // \"_dv\" is docValues (otherwise not),  \"_dvasst\" is useDocValuesAsStored (otherwise not)\n    // \"_st\" is stored\" (otherwise not)\n\n    // a random point using the number of decimal places we support for round-tripping.\n    String randPointStr =\n        new BigDecimal(GeoTestUtil.nextLatitude()).setScale(7, BigDecimal.ROUND_HALF_UP).stripTrailingZeros().toPlainString() +\n        \",\" + new BigDecimal(GeoTestUtil.nextLongitude()).setScale(7, BigDecimal.ROUND_HALF_UP).stripTrailingZeros().toPlainString();\n\n    List<RetrievalCombo> combos = Arrays.asList(\n        new RetrievalCombo(\"llp_1_dv_st\", ptHighPrecision),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\", \"-45,45\")),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\")), // multiValued but 1 value\n\n        new RetrievalCombo(\"llp_1_dv_dvasst\", ptHighPrecision, ptLossOfPrecision),\n        // this one comes back in a different order since it gets sorted low to high\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\"-40,40\", \"-45,45\"), Arrays.asList(\"-45,45\", \"-40,40\")),\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(randPointStr)), // multiValued but 1 value\n        // edge cases.  (note we sorted it as Lucene will internally)\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\n            \"-90,180\", \"-90,-180\",\n            \"0,0\", \"0,180\", \"0,-180\",\n            \"90,0\", \"90,180\", \"90,-180\")),\n\n        new RetrievalCombo(\"llp_1_dv\", ptHighPrecision, ptLossOfPrecision),\n        new RetrievalCombo(\"llp_N_dv\", Arrays.asList(\"-45,45\", \"-40,40\"))\n\n        );\n    Collections.shuffle(combos, random());\n\n    // add and commit\n    for (RetrievalCombo combo : combos) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", \"\" + combo.id);\n      for (String indexValue : combo.indexValues) {\n        doc.addField(combo.fieldName, indexValue);\n      }\n      assertU(adoc(doc));\n      if (TestUtils.rarely()) { // induce segments to potentially change internal behavior\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // create an assertJQ assertion string, once for fl=*, another for when the field is listed\n    List<String> assertJQsFlListed = new ArrayList<>();\n    List<String> assertJQsFlStar = new ArrayList<>();\n    for (RetrievalCombo combo : combos) {\n      String expect = \"response/docs/[\" + combo.id + \"]/\" + combo.fieldName + \"==\" + combo.expectReturnJSON;\n      assertJQsFlListed.add(expect);\n      if (combo.fieldName.endsWith(\"_dv\")) {\n        expect =  \"response/docs/[\" + combo.id + \"]=={'id':'\" + combo.id + \"'}\"; // only the id, nothing else\n      }\n      assertJQsFlStar.add(expect);\n    }\n    // check\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\",\"*\"),\n        assertJQsFlStar.toArray(new String[0]));\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\", \"id,\" + combos.stream().map(c -> c.fieldName).collect(Collectors.joining(\",\"))),\n        assertJQsFlListed.toArray(new String[0]));\n  }\n\n","sourceOld":"  @Test\n  public void testLatLonRetrieval() throws Exception {\n    final String ptHighPrecision = \"40.2996543270,-74.0824956673\";\n    final String ptLossOfPrecision = \"40.2996544,-74.0824957\"; // rounded version of the one above, losing precision\n\n    // \"_1\" is single, \"_N\" is multiValued\n    // \"_dv\" is docValues (otherwise not),  \"_dvasst\" is useDocValuesAsStored (otherwise not)\n    // \"_st\" is stored\" (otherwise not)\n\n    List<RetrievalCombo> combos = Arrays.asList(\n        new RetrievalCombo(\"llp_1_dv_st\", ptHighPrecision),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\", \"-45,45\")),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\")), // multiValued but 1 value\n\n        new RetrievalCombo(\"llp_1_dv_dvasst\", ptHighPrecision, ptLossOfPrecision),\n        // this one comes back in a different order since it gets sorted low to high\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\"-40,40\", \"-45,45\"), Arrays.asList(\"-45,45\", \"-40,40\")),\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\"-40,40\")), // multiValued but 1 value\n        // edge cases.  (note we sorted it as Lucene will internally)\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\n            \"-90,180\", \"-90,-180\",\n            \"0,0\", \"0,180\", \"0,-180\",\n            \"90,0\", \"90,180\", \"90,-180\")),\n\n        new RetrievalCombo(\"llp_1_dv\", ptHighPrecision, ptLossOfPrecision),\n        new RetrievalCombo(\"llp_N_dv\", Arrays.asList(\"-45,45\", \"-40,40\"))\n\n        );\n    Collections.shuffle(combos, random());\n\n    // add and commit\n    for (RetrievalCombo combo : combos) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", \"\" + combo.id);\n      for (String indexValue : combo.indexValues) {\n        doc.addField(combo.fieldName, indexValue);\n      }\n      assertU(adoc(doc));\n      if (TestUtils.rarely()) { // induce segments to potentially change internal behavior\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // create an assertJQ assertion string, once for fl=*, another for when the field is listed\n    List<String> assertJQsFlListed = new ArrayList<>();\n    List<String> assertJQsFlStar = new ArrayList<>();\n    for (RetrievalCombo combo : combos) {\n      String expect = \"response/docs/[\" + combo.id + \"]/\" + combo.fieldName + \"==\" + combo.expectReturnJSON;\n      assertJQsFlListed.add(expect);\n      if (combo.fieldName.endsWith(\"_dv\")) {\n        expect =  \"response/docs/[\" + combo.id + \"]=={'id':'\" + combo.id + \"'}\"; // only the id, nothing else\n      }\n      assertJQsFlStar.add(expect);\n    }\n    // check\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\",\"*\"),\n        assertJQsFlStar.toArray(new String[0]));\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\", \"id,\" + combos.stream().map(c -> c.fieldName).collect(Collectors.joining(\",\"))),\n        assertJQsFlListed.toArray(new String[0]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLatLonRetrieval().mjava","sourceNew":"  @Test\n  public void testLatLonRetrieval() throws Exception {\n    final String ptHighPrecision =   \"40.2996543270,-74.0824956673\";\n    final String ptLossOfPrecision = \"40.2996544,-74.0824957\"; // rounded version of the one above, losing precision\n\n    // \"_1\" is single, \"_N\" is multiValued\n    // \"_dv\" is docValues (otherwise not),  \"_dvasst\" is useDocValuesAsStored (otherwise not)\n    // \"_st\" is stored\" (otherwise not)\n\n    // a random point using the number of decimal places we support for round-tripping.\n    String randPointStr =\n        new BigDecimal(GeoTestUtil.nextLatitude()).setScale(7, RoundingMode.HALF_UP).stripTrailingZeros().toPlainString() +\n        \",\" + new BigDecimal(GeoTestUtil.nextLongitude()).setScale(7, RoundingMode.HALF_UP).stripTrailingZeros().toPlainString();\n\n    List<RetrievalCombo> combos = Arrays.asList(\n        new RetrievalCombo(\"llp_1_dv_st\", ptHighPrecision),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\", \"-45,45\")),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\")), // multiValued but 1 value\n\n        new RetrievalCombo(\"llp_1_dv_dvasst\", ptHighPrecision, ptLossOfPrecision),\n        // this one comes back in a different order since it gets sorted low to high\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\"-40,40\", \"-45,45\"), Arrays.asList(\"-45,45\", \"-40,40\")),\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(randPointStr)), // multiValued but 1 value\n        // edge cases.  (note we sorted it as Lucene will internally)\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\n            \"-90,180\", \"-90,-180\",\n            \"0,0\", \"0,180\", \"0,-180\",\n            \"90,0\", \"90,180\", \"90,-180\")),\n\n        new RetrievalCombo(\"llp_1_dv\", ptHighPrecision, ptLossOfPrecision),\n        new RetrievalCombo(\"llp_N_dv\", Arrays.asList(\"-45,45\", \"-40,40\"))\n\n        );\n    Collections.shuffle(combos, random());\n\n    // add and commit\n    for (RetrievalCombo combo : combos) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", \"\" + combo.id);\n      for (String indexValue : combo.indexValues) {\n        doc.addField(combo.fieldName, indexValue);\n      }\n      assertU(adoc(doc));\n      if (TestUtils.rarely()) { // induce segments to potentially change internal behavior\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // create an assertJQ assertion string, once for fl=*, another for when the field is listed\n    List<String> assertJQsFlListed = new ArrayList<>();\n    List<String> assertJQsFlStar = new ArrayList<>();\n    for (RetrievalCombo combo : combos) {\n      String expect = \"response/docs/[\" + combo.id + \"]/\" + combo.fieldName + \"==\" + combo.expectReturnJSON;\n      assertJQsFlListed.add(expect);\n      if (combo.fieldName.endsWith(\"_dv\")) {\n        expect =  \"response/docs/[\" + combo.id + \"]=={'id':'\" + combo.id + \"'}\"; // only the id, nothing else\n      }\n      assertJQsFlStar.add(expect);\n    }\n    // check\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\",\"*\"),\n        assertJQsFlStar.toArray(new String[0]));\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\", \"id,\" + combos.stream().map(c -> c.fieldName).collect(Collectors.joining(\",\"))),\n        assertJQsFlListed.toArray(new String[0]));\n  }\n\n","sourceOld":"  @Test\n  public void testLatLonRetrieval() throws Exception {\n    final String ptHighPrecision =   \"40.2996543270,-74.0824956673\";\n    final String ptLossOfPrecision = \"40.2996544,-74.0824957\"; // rounded version of the one above, losing precision\n\n    // \"_1\" is single, \"_N\" is multiValued\n    // \"_dv\" is docValues (otherwise not),  \"_dvasst\" is useDocValuesAsStored (otherwise not)\n    // \"_st\" is stored\" (otherwise not)\n\n    // a random point using the number of decimal places we support for round-tripping.\n    String randPointStr =\n        new BigDecimal(GeoTestUtil.nextLatitude()).setScale(7, BigDecimal.ROUND_HALF_UP).stripTrailingZeros().toPlainString() +\n        \",\" + new BigDecimal(GeoTestUtil.nextLongitude()).setScale(7, BigDecimal.ROUND_HALF_UP).stripTrailingZeros().toPlainString();\n\n    List<RetrievalCombo> combos = Arrays.asList(\n        new RetrievalCombo(\"llp_1_dv_st\", ptHighPrecision),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\", \"-45,45\")),\n        new RetrievalCombo(\"llp_N_dv_st\", Arrays.asList(\"-40,40\")), // multiValued but 1 value\n\n        new RetrievalCombo(\"llp_1_dv_dvasst\", ptHighPrecision, ptLossOfPrecision),\n        // this one comes back in a different order since it gets sorted low to high\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\"-40,40\", \"-45,45\"), Arrays.asList(\"-45,45\", \"-40,40\")),\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(randPointStr)), // multiValued but 1 value\n        // edge cases.  (note we sorted it as Lucene will internally)\n        new RetrievalCombo(\"llp_N_dv_dvasst\", Arrays.asList(\n            \"-90,180\", \"-90,-180\",\n            \"0,0\", \"0,180\", \"0,-180\",\n            \"90,0\", \"90,180\", \"90,-180\")),\n\n        new RetrievalCombo(\"llp_1_dv\", ptHighPrecision, ptLossOfPrecision),\n        new RetrievalCombo(\"llp_N_dv\", Arrays.asList(\"-45,45\", \"-40,40\"))\n\n        );\n    Collections.shuffle(combos, random());\n\n    // add and commit\n    for (RetrievalCombo combo : combos) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", \"\" + combo.id);\n      for (String indexValue : combo.indexValues) {\n        doc.addField(combo.fieldName, indexValue);\n      }\n      assertU(adoc(doc));\n      if (TestUtils.rarely()) { // induce segments to potentially change internal behavior\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // create an assertJQ assertion string, once for fl=*, another for when the field is listed\n    List<String> assertJQsFlListed = new ArrayList<>();\n    List<String> assertJQsFlStar = new ArrayList<>();\n    for (RetrievalCombo combo : combos) {\n      String expect = \"response/docs/[\" + combo.id + \"]/\" + combo.fieldName + \"==\" + combo.expectReturnJSON;\n      assertJQsFlListed.add(expect);\n      if (combo.fieldName.endsWith(\"_dv\")) {\n        expect =  \"response/docs/[\" + combo.id + \"]=={'id':'\" + combo.id + \"'}\"; // only the id, nothing else\n      }\n      assertJQsFlStar.add(expect);\n    }\n    // check\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\",\"*\"),\n        assertJQsFlStar.toArray(new String[0]));\n    assertJQ(req(\"q\",\"*:*\", \"sort\", \"id asc\",\n        \"fl\", \"id,\" + combos.stream().map(c -> c.fieldName).collect(Collectors.joining(\",\"))),\n        assertJQsFlListed.toArray(new String[0]));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["30624fc97c03dcee86ae05dc59c16f5febcf0b0a"],"30624fc97c03dcee86ae05dc59c16f5febcf0b0a":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79","8e664487f12f836ec07e7c44c5ddc682388a15cf"],"8e664487f12f836ec07e7c44c5ddc682388a15cf":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b88a121b875f9ae2ac50f85cf46dcb680f126357"]},"commit2Childs":{"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79":["203e3fcf513c02ee2c07015f2ce277e26dc60907","8e664487f12f836ec07e7c44c5ddc682388a15cf"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79"],"30624fc97c03dcee86ae05dc59c16f5febcf0b0a":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["30624fc97c03dcee86ae05dc59c16f5febcf0b0a"],"8e664487f12f836ec07e7c44c5ddc682388a15cf":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}