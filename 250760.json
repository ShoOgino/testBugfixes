{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","commits":[{"id":"58b93c361b4f6fe193e84bfd27ea523366eada52","date":1490100167,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","sourceNew":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6988da66623294290c462497023bea04c868b48","date":1490226830,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean needDocSet = (skip==false && freq.getFacetStats().size() > 0) || freq.getSubFacets().size() > 0;\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d521256ce8fafb493c52a0492eba155bb8accd6e","date":1490229097,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean needDocSet = (skip==false && freq.getFacetStats().size() > 0) || freq.getSubFacets().size() > 0;\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8908009aaa8e9318b455c1c22b83e0e87738228a","date":1490280013,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","sourceNew":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a96802490db67d4c9ab246b020af9ab07efb2207","date":1490280013,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean needDocSet = (skip==false && freq.getFacetStats().size() > 0) || freq.getSubFacets().size() > 0;\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  // TODO: rather than just have a raw \"response\", perhaps we should model as a bucket object that contains the response plus extra info?\n  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    // TODO: we don't need the DocSet if we've already calculated everything during the first phase\n    boolean needDocSet = freq.getFacetStats().size() > 0 || freq.getSubFacets().size() > 0;\n\n    // TODO: put info in for the merger (like \"skip=true\"?) Maybe we don't need to if we leave out all extraneous info?\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c705a0d590cf911e7c942df49563ca2ea176e22","date":1526916174,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean needDocSet = (skip==false && freq.getFacetStats().size() > 0) || freq.getSubFacets().size() > 0;\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, q, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean needDocSet = (skip==false && freq.getFacetStats().size() > 0) || freq.getSubFacets().size() > 0;\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c841e27891873cab110ebeb89f124a8ec470176","date":1586527220,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#fillBucket(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean needDocSet = (skip==false && freq.getFacetStats().size() > 0) || freq.getSubFacets().size() > 0;\n\n    long count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, q, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","sourceOld":"  void fillBucket(SimpleOrderedMap<Object> bucket, Query q, DocSet result, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean needDocSet = (skip==false && freq.getFacetStats().size() > 0) || freq.getSubFacets().size() > 0;\n\n    int count;\n\n    if (result != null) {\n      count = result.size();\n    } else if (needDocSet) {\n      if (q == null) {\n        result = fcontext.base;\n        // result.incref(); // OFF-HEAP\n      } else {\n        result = fcontext.searcher.getDocSet(q, fcontext.base);\n      }\n      count = result.size();  // don't really need this if we are skipping, but it's free.\n    } else {\n      if (q == null) {\n        count = fcontext.base.size();\n      } else {\n        count = fcontext.searcher.numDocs(q, fcontext.base);\n      }\n    }\n\n    try {\n      if (!skip) {\n        processStats(bucket, q, result, count);\n      }\n      processSubs(bucket, q, result, skip, facetInfo);\n    } finally {\n      if (result != null) {\n        // result.decref(); // OFF-HEAP\n        result = null;\n      }\n    }\n  }\n\n","bugFix":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1c841e27891873cab110ebeb89f124a8ec470176":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["d521256ce8fafb493c52a0492eba155bb8accd6e"],"58b93c361b4f6fe193e84bfd27ea523366eada52":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d521256ce8fafb493c52a0492eba155bb8accd6e":["58b93c361b4f6fe193e84bfd27ea523366eada52","e6988da66623294290c462497023bea04c868b48"],"a96802490db67d4c9ab246b020af9ab07efb2207":["8908009aaa8e9318b455c1c22b83e0e87738228a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e6988da66623294290c462497023bea04c868b48":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1c841e27891873cab110ebeb89f124a8ec470176"]},"commit2Childs":{"1c841e27891873cab110ebeb89f124a8ec470176":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["1c841e27891873cab110ebeb89f124a8ec470176"],"58b93c361b4f6fe193e84bfd27ea523366eada52":["d521256ce8fafb493c52a0492eba155bb8accd6e","e6988da66623294290c462497023bea04c868b48"],"d521256ce8fafb493c52a0492eba155bb8accd6e":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"a96802490db67d4c9ab246b020af9ab07efb2207":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["58b93c361b4f6fe193e84bfd27ea523366eada52","8908009aaa8e9318b455c1c22b83e0e87738228a"],"e6988da66623294290c462497023bea04c868b48":["d521256ce8fafb493c52a0492eba155bb8accd6e"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["a96802490db67d4c9ab246b020af9ab07efb2207"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a96802490db67d4c9ab246b020af9ab07efb2207","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}