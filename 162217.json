{"path":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,ClusterDataProvider,CoreContainer).mjava","commits":[{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,ClusterDataProvider,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, ClusterDataProvider cdp, CoreContainer cc) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO nocommit: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cdp.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cdp, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cc.getZkController().zkStateReader.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().zkStateReader, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,ClusterDataProvider,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cc.getZkController().zkStateReader.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().zkStateReader, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, ClusterDataProvider cdp, CoreContainer cc) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO nocommit: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cdp.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cdp, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b869898f50ca80263bac2e3ae0949f7700e5c977":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b869898f50ca80263bac2e3ae0949f7700e5c977","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}