{"path":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#nextPointAroundLine(double,double,double,double).mjava","commits":[{"id":"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2","date":1460953142,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#nextPointAroundLine(double,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the next point around a line (more or less) */\n  private static double[] nextPointAroundLine(double lat1, double lon1, double lat2, double lon2) {\n    double x1 = lon1;\n    double x2 = lon2;\n    double y1 = lat1;\n    double y2 = lat2;\n    double minX = Math.min(x1, x2);\n    double maxX = Math.max(x1, x2);\n    double minY = Math.min(y1, y2);\n    double maxY = Math.max(y1, y2);\n    if (minX == maxX) {\n      return new double[] { nextLatitudeBetween(minY, maxY), nextLongitudeNear(minX, 0.01 * (maxY - minY)) };\n    } else if (minY == maxY) {\n      return new double[] { nextLatitudeNear(minY, 0.01 * (maxX - minX)), nextLongitudeBetween(minX, maxX) };\n    } else {\n      double x = nextLongitudeBetween(minX, maxX);\n      double y = (y1 - y2) / (x1 - x2) * (x-x1) + y1;\n      double delta = (maxY - minY) * 0.01;\n      // our formula may put the targeted Y out of bounds\n      y = Math.min(90, y);\n      y = Math.max(-90, y);\n      return new double[] { nextLatitudeNear(y, delta), x };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"feec2558dce008018367efcc6d3a19d69fce3873","date":1460985304,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#nextPointAroundLine(double,double,double,double).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#nextPointAroundLine(double,double,double,double).mjava","sourceNew":"  /** Returns the next point around a line (more or less) */\n  private static double[] nextPointAroundLine(double lat1, double lon1, double lat2, double lon2) {\n    double x1 = lon1;\n    double x2 = lon2;\n    double y1 = lat1;\n    double y2 = lat2;\n    double minX = Math.min(x1, x2);\n    double maxX = Math.max(x1, x2);\n    double minY = Math.min(y1, y2);\n    double maxY = Math.max(y1, y2);\n    if (minX == maxX) {\n      return new double[] { nextLatitudeBetween(minY, maxY), nextLongitudeNear(minX, 0.01 * (maxY - minY)) };\n    } else if (minY == maxY) {\n      return new double[] { nextLatitudeNear(minY, 0.01 * (maxX - minX)), nextLongitudeBetween(minX, maxX) };\n    } else {\n      double x = nextLongitudeBetween(minX, maxX);\n      double y = (y1 - y2) / (x1 - x2) * (x-x1) + y1;\n      if (Double.isFinite(y) == false) {\n        // this can happen due to underflow when delta between x values is wonderfully tiny!\n        y = Math.copySign(90, x1);\n      }\n      double delta = (maxY - minY) * 0.01;\n      // our formula may put the targeted Y out of bounds\n      y = Math.min(90, y);\n      y = Math.max(-90, y);\n      return new double[] { nextLatitudeNear(y, delta), x };\n    }\n  }\n\n","sourceOld":"  /** Returns the next point around a line (more or less) */\n  private static double[] nextPointAroundLine(double lat1, double lon1, double lat2, double lon2) {\n    double x1 = lon1;\n    double x2 = lon2;\n    double y1 = lat1;\n    double y2 = lat2;\n    double minX = Math.min(x1, x2);\n    double maxX = Math.max(x1, x2);\n    double minY = Math.min(y1, y2);\n    double maxY = Math.max(y1, y2);\n    if (minX == maxX) {\n      return new double[] { nextLatitudeBetween(minY, maxY), nextLongitudeNear(minX, 0.01 * (maxY - minY)) };\n    } else if (minY == maxY) {\n      return new double[] { nextLatitudeNear(minY, 0.01 * (maxX - minX)), nextLongitudeBetween(minX, maxX) };\n    } else {\n      double x = nextLongitudeBetween(minX, maxX);\n      double y = (y1 - y2) / (x1 - x2) * (x-x1) + y1;\n      double delta = (maxY - minY) * 0.01;\n      // our formula may put the targeted Y out of bounds\n      y = Math.min(90, y);\n      y = Math.max(-90, y);\n      return new double[] { nextLatitudeNear(y, delta), x };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76b27bc4e241a6dd8c185cdb62b458a0562564f0","date":1460988862,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#nextPointAroundLine(double,double,double,double).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#nextPointAroundLine(double,double,double,double).mjava","sourceNew":"  /** Returns the next point around a line (more or less) */\n  private static double[] nextPointAroundLine(double lat1, double lon1, double lat2, double lon2) {\n    double x1 = lon1;\n    double x2 = lon2;\n    double y1 = lat1;\n    double y2 = lat2;\n    double minX = Math.min(x1, x2);\n    double maxX = Math.max(x1, x2);\n    double minY = Math.min(y1, y2);\n    double maxY = Math.max(y1, y2);\n    if (minX == maxX) {\n      return new double[] { nextLatitudeBetween(minY, maxY), nextLongitudeNear(minX, 0.01 * (maxY - minY)) };\n    } else if (minY == maxY) {\n      return new double[] { nextLatitudeNear(minY, 0.01 * (maxX - minX)), nextLongitudeBetween(minX, maxX) };\n    } else {\n      double x = nextLongitudeBetween(minX, maxX);\n      double y = (y1 - y2) / (x1 - x2) * (x-x1) + y1;\n      if (Double.isFinite(y) == false) {\n        // this can happen due to underflow when delta between x values is wonderfully tiny!\n        y = Math.copySign(90, x1);\n      }\n      double delta = (maxY - minY) * 0.01;\n      // our formula may put the targeted Y out of bounds\n      y = Math.min(90, y);\n      y = Math.max(-90, y);\n      return new double[] { nextLatitudeNear(y, delta), x };\n    }\n  }\n\n","sourceOld":"  /** Returns the next point around a line (more or less) */\n  private static double[] nextPointAroundLine(double lat1, double lon1, double lat2, double lon2) {\n    double x1 = lon1;\n    double x2 = lon2;\n    double y1 = lat1;\n    double y2 = lat2;\n    double minX = Math.min(x1, x2);\n    double maxX = Math.max(x1, x2);\n    double minY = Math.min(y1, y2);\n    double maxY = Math.max(y1, y2);\n    if (minX == maxX) {\n      return new double[] { nextLatitudeBetween(minY, maxY), nextLongitudeNear(minX, 0.01 * (maxY - minY)) };\n    } else if (minY == maxY) {\n      return new double[] { nextLatitudeNear(minY, 0.01 * (maxX - minX)), nextLongitudeBetween(minX, maxX) };\n    } else {\n      double x = nextLongitudeBetween(minX, maxX);\n      double y = (y1 - y2) / (x1 - x2) * (x-x1) + y1;\n      double delta = (maxY - minY) * 0.01;\n      // our formula may put the targeted Y out of bounds\n      y = Math.min(90, y);\n      y = Math.max(-90, y);\n      return new double[] { nextLatitudeNear(y, delta), x };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"713122036535651642e6d4fe57ce12b449e18473","date":1461000510,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil#nextPointAroundLine(double,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the next point around a line (more or less) */\n  private static double[] nextPointAroundLine(double lat1, double lon1, double lat2, double lon2) {\n    double x1 = lon1;\n    double x2 = lon2;\n    double y1 = lat1;\n    double y2 = lat2;\n    double minX = Math.min(x1, x2);\n    double maxX = Math.max(x1, x2);\n    double minY = Math.min(y1, y2);\n    double maxY = Math.max(y1, y2);\n    if (minX == maxX) {\n      return new double[] { nextLatitudeBetween(minY, maxY), nextLongitudeNear(minX, 0.01 * (maxY - minY)) };\n    } else if (minY == maxY) {\n      return new double[] { nextLatitudeNear(minY, 0.01 * (maxX - minX)), nextLongitudeBetween(minX, maxX) };\n    } else {\n      double x = nextLongitudeBetween(minX, maxX);\n      double y = (y1 - y2) / (x1 - x2) * (x-x1) + y1;\n      if (Double.isFinite(y) == false) {\n        // this can happen due to underflow when delta between x values is wonderfully tiny!\n        y = Math.copySign(90, x1);\n      }\n      double delta = (maxY - minY) * 0.01;\n      // our formula may put the targeted Y out of bounds\n      y = Math.min(90, y);\n      y = Math.max(-90, y);\n      return new double[] { nextLatitudeNear(y, delta), x };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"713122036535651642e6d4fe57ce12b449e18473":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","76b27bc4e241a6dd8c185cdb62b458a0562564f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"76b27bc4e241a6dd8c185cdb62b458a0562564f0":["3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2","feec2558dce008018367efcc6d3a19d69fce3873"],"feec2558dce008018367efcc6d3a19d69fce3873":["3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["713122036535651642e6d4fe57ce12b449e18473"]},"commit2Childs":{"713122036535651642e6d4fe57ce12b449e18473":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["713122036535651642e6d4fe57ce12b449e18473","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"76b27bc4e241a6dd8c185cdb62b458a0562564f0":["713122036535651642e6d4fe57ce12b449e18473"],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["76b27bc4e241a6dd8c185cdb62b458a0562564f0","feec2558dce008018367efcc6d3a19d69fce3873"],"feec2558dce008018367efcc6d3a19d69fce3873":["76b27bc4e241a6dd8c185cdb62b458a0562564f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}