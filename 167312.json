{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeTLong(DataOutput,long).mjava","commits":[{"id":"078fa9e94da55eaa1aa1e7393aa84ba7cc986864","date":1418310060,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeTLong(DataOutput,long).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Writes a long in a variable-length format.  Writes between one and \n   * ten bytes. Small values or values representing timestamps with day,\n   * hour or second precision typically require fewer bytes.\n   * <p>\n   * ZLong --&gt; Header, Bytes*?\n   * <ul>\n   *    <li>Header --&gt; The first two bits indicate the compression scheme:\n   *       <ul>\n   *          <li>00 - uncompressed\n   *          <li>01 - multiple of 1000 (second)\n   *          <li>10 - multiple of 3600000 (hour)\n   *          <li>11 - multiple of 86400000 (day)\n   *       </ul>\n   *       Then the next bit is a continuation bit, indicating whether more\n   *       bytes need to be read, and the last 5 bits are the lower bits of\n   *       the encoded value. In order to reconstruct the value, you need to\n   *       combine the 5 lower bits of the header with a vLong in the next\n   *       bytes (if the continuation bit is set to 1). Then\n   *       {@link BitUtil#zigZagDecode(int) zigzag-decode} it and finally\n   *       multiply by the multiple corresponding to the compression scheme.\n   *    <li>Bytes --&gt; Potential additional bytes to read depending on the\n   *       header.\n   * </ul>\n   * <p>\n   */\n  // T for \"timestamp\"\n  static void writeTLong(DataOutput out, long l) throws IOException {\n    int header; \n    if (l % SECOND != 0) {\n      header = 0;\n    } else if (l % DAY == 0) {\n      // timestamp with day precision\n      header = DAY_ENCODING;\n      l /= DAY;\n    } else if (l % HOUR == 0) {\n      // timestamp with hour precision, or day precision with a timezone\n      header = HOUR_ENCODING;\n      l /= HOUR;\n    } else {\n      // timestamp with second precision\n      header = SECOND_ENCODING;\n      l /= SECOND;\n    }\n\n    final long zigZagL = BitUtil.zigZagEncode(l);\n    header |= (zigZagL & 0x1F); // last 5 bits\n    final long upperBits = zigZagL >>> 5;\n    if (upperBits != 0) {\n      header |= 0x20;\n    }\n    out.writeByte((byte) header);\n    if (upperBits != 0) {\n      out.writeVLong(upperBits);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["83caedc5d9e910bc771bdecafbe0430361462397"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83caedc5d9e910bc771bdecafbe0430361462397","date":1440445428,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeTLong(DataOutput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeTLong(DataOutput,long).mjava","sourceNew":"  /** \n   * Writes a long in a variable-length format.  Writes between one and \n   * ten bytes. Small values or values representing timestamps with day,\n   * hour or second precision typically require fewer bytes.\n   * <p>\n   * ZLong --&gt; Header, Bytes*?\n   * <ul>\n   *    <li>Header --&gt; The first two bits indicate the compression scheme:\n   *       <ul>\n   *          <li>00 - uncompressed\n   *          <li>01 - multiple of 1000 (second)\n   *          <li>10 - multiple of 3600000 (hour)\n   *          <li>11 - multiple of 86400000 (day)\n   *       </ul>\n   *       Then the next bit is a continuation bit, indicating whether more\n   *       bytes need to be read, and the last 5 bits are the lower bits of\n   *       the encoded value. In order to reconstruct the value, you need to\n   *       combine the 5 lower bits of the header with a vLong in the next\n   *       bytes (if the continuation bit is set to 1). Then\n   *       {@link BitUtil#zigZagDecode(int) zigzag-decode} it and finally\n   *       multiply by the multiple corresponding to the compression scheme.\n   *    <li>Bytes --&gt; Potential additional bytes to read depending on the\n   *       header.\n   * </ul>\n   */\n  // T for \"timestamp\"\n  static void writeTLong(DataOutput out, long l) throws IOException {\n    int header; \n    if (l % SECOND != 0) {\n      header = 0;\n    } else if (l % DAY == 0) {\n      // timestamp with day precision\n      header = DAY_ENCODING;\n      l /= DAY;\n    } else if (l % HOUR == 0) {\n      // timestamp with hour precision, or day precision with a timezone\n      header = HOUR_ENCODING;\n      l /= HOUR;\n    } else {\n      // timestamp with second precision\n      header = SECOND_ENCODING;\n      l /= SECOND;\n    }\n\n    final long zigZagL = BitUtil.zigZagEncode(l);\n    header |= (zigZagL & 0x1F); // last 5 bits\n    final long upperBits = zigZagL >>> 5;\n    if (upperBits != 0) {\n      header |= 0x20;\n    }\n    out.writeByte((byte) header);\n    if (upperBits != 0) {\n      out.writeVLong(upperBits);\n    }\n  }\n\n","sourceOld":"  /** \n   * Writes a long in a variable-length format.  Writes between one and \n   * ten bytes. Small values or values representing timestamps with day,\n   * hour or second precision typically require fewer bytes.\n   * <p>\n   * ZLong --&gt; Header, Bytes*?\n   * <ul>\n   *    <li>Header --&gt; The first two bits indicate the compression scheme:\n   *       <ul>\n   *          <li>00 - uncompressed\n   *          <li>01 - multiple of 1000 (second)\n   *          <li>10 - multiple of 3600000 (hour)\n   *          <li>11 - multiple of 86400000 (day)\n   *       </ul>\n   *       Then the next bit is a continuation bit, indicating whether more\n   *       bytes need to be read, and the last 5 bits are the lower bits of\n   *       the encoded value. In order to reconstruct the value, you need to\n   *       combine the 5 lower bits of the header with a vLong in the next\n   *       bytes (if the continuation bit is set to 1). Then\n   *       {@link BitUtil#zigZagDecode(int) zigzag-decode} it and finally\n   *       multiply by the multiple corresponding to the compression scheme.\n   *    <li>Bytes --&gt; Potential additional bytes to read depending on the\n   *       header.\n   * </ul>\n   * <p>\n   */\n  // T for \"timestamp\"\n  static void writeTLong(DataOutput out, long l) throws IOException {\n    int header; \n    if (l % SECOND != 0) {\n      header = 0;\n    } else if (l % DAY == 0) {\n      // timestamp with day precision\n      header = DAY_ENCODING;\n      l /= DAY;\n    } else if (l % HOUR == 0) {\n      // timestamp with hour precision, or day precision with a timezone\n      header = HOUR_ENCODING;\n      l /= HOUR;\n    } else {\n      // timestamp with second precision\n      header = SECOND_ENCODING;\n      l /= SECOND;\n    }\n\n    final long zigZagL = BitUtil.zigZagEncode(l);\n    header |= (zigZagL & 0x1F); // last 5 bits\n    final long upperBits = zigZagL >>> 5;\n    if (upperBits != 0) {\n      header |= 0x20;\n    }\n    out.writeByte((byte) header);\n    if (upperBits != 0) {\n      out.writeVLong(upperBits);\n    }\n  }\n\n","bugFix":["078fa9e94da55eaa1aa1e7393aa84ba7cc986864"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"078fa9e94da55eaa1aa1e7393aa84ba7cc986864":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83caedc5d9e910bc771bdecafbe0430361462397"],"83caedc5d9e910bc771bdecafbe0430361462397":["078fa9e94da55eaa1aa1e7393aa84ba7cc986864"]},"commit2Childs":{"078fa9e94da55eaa1aa1e7393aa84ba7cc986864":["83caedc5d9e910bc771bdecafbe0430361462397"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["078fa9e94da55eaa1aa1e7393aa84ba7cc986864"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"83caedc5d9e910bc771bdecafbe0430361462397":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}