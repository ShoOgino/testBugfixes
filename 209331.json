{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","commits":[{"id":"d0ce568448269aad19a317e537eefc0993934c9d","date":1361139215,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09c8567c25c02eeeb3e719841606a1269f3538ca","date":1361155063,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a114c79cee12feb72f81641925268f6e3e4f051e","date":1364002322,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r = (r == null ? getReader(core, config, directoryFactory, path) : r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b906bdda81aff118473358c14c280e6f07feeda","date":1412632498,"type":1,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,SolrIndexConfig,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, SolrIndexConfig config, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a94e45463a0089149b0d148ae5369140e7f54b8c","date":1419231934,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n\n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d794632af132b14d34418fc85c80044801ce40cb","date":1425119363,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n\n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n\n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n\n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n\n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ec0d45746967f32f35c0461dec63476e30b720","date":1437468606,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n\n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n\n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bdac0dff04219451c7511d62225080a93a0181ea","date":1451212020,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n\n    fieldNames = new HashSet<>();\n    Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    Set<String> allNonStoredDVs = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n      SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n\n    fieldNames = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n                           boolean closeReader, boolean enableCache, boolean reserveDirectory,\n                           DirectoryFactory directoryFactory) throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\" + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(\n          reader.getIndexCommit().getGeneration());\n    }\n    \n    Directory dir = getIndexReader().directory();\n    \n    this.reserveDirectory = reserveDirectory;\n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n\n    fieldNames = new HashSet<>();\n    Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    Set<String> allNonStoredDVs = new HashSet<>();\n    fieldInfos = leafReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n      SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b93c47fd6615608aaba7a18f08614cc169de66a","date":1461873142,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15f9a498a407241cefcbd00ca7fc84d5e7fa573e","date":1470840868,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","6d6338c87060be5f66757a94945975f3bbd377a9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"462165462a7ae6ca998de69e7d2953022762c932","date":1474606099,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05569170a222447d3aec8fad773feedf4429fdd5","date":1476800012,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.getTopReaderContext().reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ace476116331d7a88cbd7142a4e5ac1433db5033","date":1476805182,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.getTopReaderContext().reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed2d3cbea990a1cd6c54a591a294f629964b01be","date":1488991463,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12f7f335611574989edc8f87d25d91e89aa385b6","date":1489690739,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n    final Set<String> storedLargeFields = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) { // can find materialized dynamic fields, unlike using the Solr IndexSchema.\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField == null) {\n        continue;\n      }\n      if (!schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n      if (schemaField.stored() && schemaField.isLarge()) {\n        storedLargeFields.add(schemaField.getName());\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n    this.largeFields = Collections.unmodifiableSet(storedLargeFields);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b4eb0a25318cc756077fbde9bd3052690aed03d","date":1490280009,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n    final Set<String> storedLargeFields = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) { // can find materialized dynamic fields, unlike using the Solr IndexSchema.\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField == null) {\n        continue;\n      }\n      if (!schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n      if (schemaField.stored() && schemaField.isLarge()) {\n        storedLargeFields.add(schemaField.getName());\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n    this.largeFields = Collections.unmodifiableSet(storedLargeFields);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField != null && !schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63a9344cff6a72bc4c1ef080c69e10ad0635b811","date":1490410892,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n    final Set<String> storedLargeFields = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) { // can find materialized dynamic fields, unlike using the Solr IndexSchema.\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField == null) {\n        continue;\n      }\n      if (!schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n      if (schemaField.stored() && schemaField.isLarge()) {\n        storedLargeFields.add(schemaField.getName());\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n    this.largeFields = Collections.unmodifiableSet(storedLargeFields);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":["7bc10aeb596994a4cbfa5801932a4dac9fdd2afc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de548de3ce5405595899f548152d4b93ac9eb9cc","date":1490594650,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    this.enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig == null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.documentCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    final Set<String> nonStoredDVsUsedAsStored = new HashSet<>();\n    final Set<String> allNonStoredDVs = new HashSet<>();\n    final Set<String> nonStoredDVsWithoutCopyTargets = new HashSet<>();\n    final Set<String> storedLargeFields = new HashSet<>();\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    for (FieldInfo fieldInfo : fieldInfos) { // can find materialized dynamic fields, unlike using the Solr IndexSchema.\n      final SchemaField schemaField = schema.getFieldOrNull(fieldInfo.name);\n      if (schemaField == null) {\n        continue;\n      }\n      if (!schemaField.stored() && schemaField.hasDocValues()) {\n        if (schemaField.useDocValuesAsStored()) {\n          nonStoredDVsUsedAsStored.add(fieldInfo.name);\n        }\n        allNonStoredDVs.add(fieldInfo.name);\n        if (!schema.isCopyFieldTarget(schemaField)) {\n          nonStoredDVsWithoutCopyTargets.add(fieldInfo.name);\n        }\n      }\n      if (schemaField.stored() && schemaField.isLarge()) {\n        storedLargeFields.add(schemaField.getName());\n      }\n    }\n\n    this.nonStoredDVsUsedAsStored = Collections.unmodifiableSet(nonStoredDVsUsedAsStored);\n    this.allNonStoredDVs = Collections.unmodifiableSet(allNonStoredDVs);\n    this.nonStoredDVsWithoutCopyTargets = Collections.unmodifiableSet(nonStoredDVsWithoutCopyTargets);\n    this.largeFields = Collections.unmodifiableSet(storedLargeFields);\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    readerStats = snapStatistics(reader);\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7bc10aeb596994a4cbfa5801932a4dac9fdd2afc","date":1541533532,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.fieldInfos = leafReader.getFieldInfos();\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"053c4cbd30d228154839dc536ca5a15a5f0c48bf","date":1564559417,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance(core);\n      if (fieldValueCache != null) clist.add( fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance(core);\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance(core);\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String, CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance(core);\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance(core);\n      if (fieldValueCache != null) clist.add( fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance(core);\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance(core);\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String, CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance(core);\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c44cc06c26e456fe9c215072b79fce30babe3975","date":1570365040,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance(core);\n      if (fieldValueCache != null) clist.add( fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance(core);\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance(core);\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String, CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance(core);\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df72a23fb74bebe914e3f3972063a884327c0436","date":1570470832,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.statsCache = core.createStatsCache();\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.statsCache = core.createStatsCache();\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance(core);\n      if (fieldValueCache != null) clist.add( fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance(core);\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance(core);\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String, CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance(core);\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19f02bb04467ed179738a398a7da80bbbe161c16","date":1573660732,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.statsCache = core.createStatsCache();\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      // TODO: This may not be safe w/softCommit, see SOLR-13908\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.statsCache = core.createStatsCache();\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0dfcb99e767e8eafdede3faac6831984ac849fc","date":1589042999,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.statsCache = core.createStatsCache();\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.debug(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      // TODO: This may not be safe w/softCommit, see SOLR-13908\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.statsCache = core.createStatsCache();\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.info(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      // TODO: This may not be safe w/softCommit, see SOLR-13908\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50dfd19525c8d73e856dca6edb64b7aea074037f","date":1591579225,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.statsCache = core.createStatsCache();\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.debug(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      // TODO: This may not be safe w/softCommit, see SOLR-13908\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r,\n      boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory)\n          throws IOException {\n    super(wrapReader(core, r));\n\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = (DirectoryReader) super.readerContext.reader();\n    this.rawReader = r;\n    this.leafReader = SlowCompositeReaderWrapper.wrap(this.reader);\n    this.core = core;\n    this.statsCache = core.createStatsCache();\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + \"[\" + core.getName() + \"]\"\n        + (name != null ? \" \" + name : \"\");\n    log.debug(\"Opening [{}]\", this.name);\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      // reserve commit point for life of searcher\n      // TODO: This may not be safe w/softCommit, see SOLR-13908\n      core.getDeletionPolicy().saveCommitPoint(reader.getIndexCommit().getGeneration());\n    }\n\n    if (reserveDirectory) {\n      // Keep the directory from being released while we use it.\n      directoryFactory.incRef(getIndexReader().directory());\n      // Make sure to release it when closing.\n      this.releaseDirectory = true;\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    final SolrConfig solrConfig = core.getSolrConfig();\n    this.queryResultWindowSize = solrConfig.queryResultWindowSize;\n    this.queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    this.useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n\n    this.docFetcher = new SolrDocumentFetcher(this, solrConfig, enableCache);\n\n    this.cachingEnabled = enableCache;\n    if (cachingEnabled) {\n      final ArrayList<SolrCache> clist = new ArrayList<>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig == null ? null\n          : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache != null) clist.add(fieldValueCache);\n      filterCache = solrConfig.filterCacheConfig == null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache != null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig == null ? null\n          : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache != null) clist.add(queryResultCache);\n      SolrCache<Integer, Document> documentCache = docFetcher.getDocumentCache();\n      if (documentCache != null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs.isEmpty()) {\n        cacheMap = NO_GENERIC_CACHES;\n      } else {\n        cacheMap = new HashMap<>(solrConfig.userCacheConfigs.size());\n        for (Map.Entry<String,CacheConfig> e : solrConfig.userCacheConfigs.entrySet()) {\n          SolrCache cache = e.getValue().newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      this.filterCache = null;\n      this.queryResultCache = null;\n      this.fieldValueCache = null;\n      this.cacheMap = NO_GENERIC_CACHES;\n      this.cacheList = NO_CACHES;\n    }\n\n    // We already have our own filter cache\n    setQueryCache(null);\n\n    // do this at the end since an exception in the constructor means we won't close\n    numOpens.incrementAndGet();\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["de548de3ce5405595899f548152d4b93ac9eb9cc"],"b0dfcb99e767e8eafdede3faac6831984ac849fc":["19f02bb04467ed179738a398a7da80bbbe161c16"],"053c4cbd30d228154839dc536ca5a15a5f0c48bf":["7bc10aeb596994a4cbfa5801932a4dac9fdd2afc"],"ace476116331d7a88cbd7142a4e5ac1433db5033":["05569170a222447d3aec8fad773feedf4429fdd5"],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["12f7f335611574989edc8f87d25d91e89aa385b6"],"8b93c47fd6615608aaba7a18f08614cc169de66a":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"bdac0dff04219451c7511d62225080a93a0181ea":["94ec0d45746967f32f35c0461dec63476e30b720"],"462165462a7ae6ca998de69e7d2953022762c932":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"c44cc06c26e456fe9c215072b79fce30babe3975":["053c4cbd30d228154839dc536ca5a15a5f0c48bf"],"12f7f335611574989edc8f87d25d91e89aa385b6":["ed2d3cbea990a1cd6c54a591a294f629964b01be"],"05569170a222447d3aec8fad773feedf4429fdd5":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"09c8567c25c02eeeb3e719841606a1269f3538ca":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d0ce568448269aad19a317e537eefc0993934c9d"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["ac9de183adbc9483681f275ac1e2d92ed19f52e1","8b93c47fd6615608aaba7a18f08614cc169de66a"],"7bc10aeb596994a4cbfa5801932a4dac9fdd2afc":["816521ebaad5add9cb96bb88c577394e2938c40b"],"15f9a498a407241cefcbd00ca7fc84d5e7fa573e":["8b93c47fd6615608aaba7a18f08614cc169de66a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a94e45463a0089149b0d148ae5369140e7f54b8c","d794632af132b14d34418fc85c80044801ce40cb"],"19f02bb04467ed179738a398a7da80bbbe161c16":["df72a23fb74bebe914e3f3972063a884327c0436"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["403d05f7f8d69b65659157eff1bc1d2717f04c66","462165462a7ae6ca998de69e7d2953022762c932"],"d794632af132b14d34418fc85c80044801ce40cb":["a94e45463a0089149b0d148ae5369140e7f54b8c"],"a114c79cee12feb72f81641925268f6e3e4f051e":["d0ce568448269aad19a317e537eefc0993934c9d"],"d0ce568448269aad19a317e537eefc0993934c9d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["8b93c47fd6615608aaba7a18f08614cc169de66a","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"55980207f1977bd1463465de1659b821347e2fa8":["a114c79cee12feb72f81641925268f6e3e4f051e","6b906bdda81aff118473358c14c280e6f07feeda"],"de548de3ce5405595899f548152d4b93ac9eb9cc":["7b4eb0a25318cc756077fbde9bd3052690aed03d"],"94ec0d45746967f32f35c0461dec63476e30b720":["d794632af132b14d34418fc85c80044801ce40cb"],"6b906bdda81aff118473358c14c280e6f07feeda":["a114c79cee12feb72f81641925268f6e3e4f051e"],"df72a23fb74bebe914e3f3972063a884327c0436":["c44cc06c26e456fe9c215072b79fce30babe3975"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["bdac0dff04219451c7511d62225080a93a0181ea"],"816521ebaad5add9cb96bb88c577394e2938c40b":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"f8061ddd97f3352007d927dae445884a6f3d857b":["7bc10aeb596994a4cbfa5801932a4dac9fdd2afc","053c4cbd30d228154839dc536ca5a15a5f0c48bf"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","ace476116331d7a88cbd7142a4e5ac1433db5033"],"a94e45463a0089149b0d148ae5369140e7f54b8c":["6b906bdda81aff118473358c14c280e6f07feeda"],"ed2d3cbea990a1cd6c54a591a294f629964b01be":["ace476116331d7a88cbd7142a4e5ac1433db5033"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["b0dfcb99e767e8eafdede3faac6831984ac849fc"],"7b4eb0a25318cc756077fbde9bd3052690aed03d":["ed2d3cbea990a1cd6c54a591a294f629964b01be"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["8b93c47fd6615608aaba7a18f08614cc169de66a","15f9a498a407241cefcbd00ca7fc84d5e7fa573e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"b0b597c65628ca9e73913a07e81691f8229bae35":["053c4cbd30d228154839dc536ca5a15a5f0c48bf","df72a23fb74bebe914e3f3972063a884327c0436"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"b0dfcb99e767e8eafdede3faac6831984ac849fc":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"053c4cbd30d228154839dc536ca5a15a5f0c48bf":["c44cc06c26e456fe9c215072b79fce30babe3975","f8061ddd97f3352007d927dae445884a6f3d857b","b0b597c65628ca9e73913a07e81691f8229bae35"],"ace476116331d7a88cbd7142a4e5ac1433db5033":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","ed2d3cbea990a1cd6c54a591a294f629964b01be"],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["816521ebaad5add9cb96bb88c577394e2938c40b"],"8b93c47fd6615608aaba7a18f08614cc169de66a":["55b50463286869f584cf849d1587a0fcd54d1dfa","15f9a498a407241cefcbd00ca7fc84d5e7fa573e","403d05f7f8d69b65659157eff1bc1d2717f04c66","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"bdac0dff04219451c7511d62225080a93a0181ea":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"462165462a7ae6ca998de69e7d2953022762c932":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"12f7f335611574989edc8f87d25d91e89aa385b6":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"c44cc06c26e456fe9c215072b79fce30babe3975":["df72a23fb74bebe914e3f3972063a884327c0436"],"05569170a222447d3aec8fad773feedf4429fdd5":["ace476116331d7a88cbd7142a4e5ac1433db5033"],"09c8567c25c02eeeb3e719841606a1269f3538ca":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"7bc10aeb596994a4cbfa5801932a4dac9fdd2afc":["053c4cbd30d228154839dc536ca5a15a5f0c48bf","f8061ddd97f3352007d927dae445884a6f3d857b"],"15f9a498a407241cefcbd00ca7fc84d5e7fa573e":["3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"19f02bb04467ed179738a398a7da80bbbe161c16":["b0dfcb99e767e8eafdede3faac6831984ac849fc"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["05569170a222447d3aec8fad773feedf4429fdd5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09c8567c25c02eeeb3e719841606a1269f3538ca","d0ce568448269aad19a317e537eefc0993934c9d"],"d794632af132b14d34418fc85c80044801ce40cb":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","94ec0d45746967f32f35c0461dec63476e30b720"],"a114c79cee12feb72f81641925268f6e3e4f051e":["55980207f1977bd1463465de1659b821347e2fa8","6b906bdda81aff118473358c14c280e6f07feeda"],"d0ce568448269aad19a317e537eefc0993934c9d":["09c8567c25c02eeeb3e719841606a1269f3538ca","a114c79cee12feb72f81641925268f6e3e4f051e"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["462165462a7ae6ca998de69e7d2953022762c932","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"55980207f1977bd1463465de1659b821347e2fa8":[],"de548de3ce5405595899f548152d4b93ac9eb9cc":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"94ec0d45746967f32f35c0461dec63476e30b720":["bdac0dff04219451c7511d62225080a93a0181ea"],"6b906bdda81aff118473358c14c280e6f07feeda":["55980207f1977bd1463465de1659b821347e2fa8","a94e45463a0089149b0d148ae5369140e7f54b8c"],"df72a23fb74bebe914e3f3972063a884327c0436":["19f02bb04467ed179738a398a7da80bbbe161c16","b0b597c65628ca9e73913a07e81691f8229bae35"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["8b93c47fd6615608aaba7a18f08614cc169de66a","55b50463286869f584cf849d1587a0fcd54d1dfa"],"816521ebaad5add9cb96bb88c577394e2938c40b":["7bc10aeb596994a4cbfa5801932a4dac9fdd2afc"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a94e45463a0089149b0d148ae5369140e7f54b8c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d794632af132b14d34418fc85c80044801ce40cb"],"ed2d3cbea990a1cd6c54a591a294f629964b01be":["12f7f335611574989edc8f87d25d91e89aa385b6","7b4eb0a25318cc756077fbde9bd3052690aed03d"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7b4eb0a25318cc756077fbde9bd3052690aed03d":["de548de3ce5405595899f548152d4b93ac9eb9cc"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","09c8567c25c02eeeb3e719841606a1269f3538ca","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","55980207f1977bd1463465de1659b821347e2fa8","f8061ddd97f3352007d927dae445884a6f3d857b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}