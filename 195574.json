{"path":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","commits":[{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"/dev/null","sourceNew":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) throw new IllegalStateException(\"No queued updates to execute\");\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = ZkStateReader.toJSON(new ClusterState(-1, Collections.<String>emptySet(), singletonMap(c.getName(), c)));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {}\", path);\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(singletonMap(name, newCollection));\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(singletonMap(name, newCollection));\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = ZkStateReader.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["06263309947a9804c326e35ce627be8768e123a4","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","28ac6f4e1415bdb37652b37bbf30c3c571c97688","1e5f642aea415d0cbee35d1b3208b193a62d7f15"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3717889cd0547a234e5fb8db6934848a727cdf19","date":1417289098,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) throw new IllegalStateException(\"No queued updates to execute\");\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = ZkStateReader.toJSON(new ClusterState(-1, Collections.<String>emptySet(), singletonMap(c.getName(), c)));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {}\", path);\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = ZkStateReader.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) throw new IllegalStateException(\"No queued updates to execute\");\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = ZkStateReader.toJSON(new ClusterState(-1, Collections.<String>emptySet(), singletonMap(c.getName(), c)));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {}\", path);\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(singletonMap(name, newCollection));\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(singletonMap(name, newCollection));\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = ZkStateReader.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"584c1ee8712b5af28075d98028ccab111d6eeda2","date":1417444624,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = ZkStateReader.toJSON(new ClusterState(-1, Collections.<String>emptySet(), singletonMap(c.getName(), c)));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = ZkStateReader.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) throw new IllegalStateException(\"No queued updates to execute\");\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = ZkStateReader.toJSON(new ClusterState(-1, Collections.<String>emptySet(), singletonMap(c.getName(), c)));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {}\", path);\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = ZkStateReader.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28ac6f4e1415bdb37652b37bbf30c3c571c97688","date":1422364884,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = ZkStateReader.toJSON(singletonMap(c.getName(),c));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = ZkStateReader.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = ZkStateReader.toJSON(new ClusterState(-1, Collections.<String>emptySet(), singletonMap(c.getName(), c)));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = ZkStateReader.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = ZkStateReader.toJSON(singletonMap(c.getName(),c));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = ZkStateReader.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e5f642aea415d0cbee35d1b3208b193a62d7f15","date":1439490669,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  public ClusterState writePendingUpdates() throws KeeperException, InterruptedException {\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8bf04c3f77a2936f29948b9c0dd215d82d43f5cf","date":1440482195,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n              isClusterStateModified = true;\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        lastUpdatedTime = System.nanoTime();\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04c8df3f10a676c3de5dbf390f17a2de2d45cacd","date":1461615626,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              assert c.getZNodeVersion() >= 0;\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              assert c.getZNodeVersion() >= 0;\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              assert c.getZNodeVersion() >= 0;\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3eaf6502248c2d6fadda33bfd9feb21a08caade","date":1462405599,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              assert c.getZNodeVersion() >= 0;\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9974f61802aea1d15849a1053f88f5e89fc32b4","date":1462405923,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              assert c.getZNodeVersion() >= 0;\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              assert c.getZNodeVersion() >= 0;\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              assert c.getZNodeVersion() >= 0;\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Set<String> collectionNames = clusterState.getCollections();\n        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());\n        for (String c : collectionNames) {\n          collectionStates.put(c, clusterState.getCollection(c));\n        }\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":["06263309947a9804c326e35ce627be8768e123a4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.info(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.info(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.info(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f3e7752e8a5e963c6939aaa99c36134147a5ece","date":1479805653,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    TimerContext timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e42079c4c34cc1868518eff79f79ebaeb6d1965","date":1507883024,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n        numUpdates = 0;\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06263309947a9804c326e35ce627be8768e123a4","date":1517286624,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the state.json of this collection only, the rest should be clean by delete collection cmd\n            log.debug(\"going to delete state.json {}\", path);\n            reader.getZkClient().clean(path);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n        numUpdates = 0;\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the collections path for this collection\n            log.debug(\"going to delete_collection {}\", path);\n            reader.getZkClient().clean(\"/collections/\" + name);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n        numUpdates = 0;\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","bugFix":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a","962cd4f5e313777f35da8f521265323e84184929"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the state.json of this collection only, the rest should be clean by delete collection cmd\n            log.debug(\"going to delete state.json {}\", path);\n            reader.getZkClient().clean(path);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              }\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n        numUpdates = 0;\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the state.json of this collection only, the rest should be clean by delete collection cmd\n            log.debug(\"going to delete state.json {}\", path);\n            reader.getZkClient().clean(path);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n        numUpdates = 0;\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter#writePendingUpdates().mjava","sourceNew":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the state.json of this collection only, the rest should be clean by delete collection cmd\n            log.debug(\"going to delete state.json {}\", path);\n            reader.getZkClient().clean(path);\n          } else {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              }\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion());\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          }\n        }\n\n        updates.clear();\n        numUpdates = 0;\n      }\n\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","sourceOld":"  /**\n   * Writes all pending updates to ZooKeeper and returns the modified cluster state\n   *\n   * @return the modified cluster state\n   * @throws IllegalStateException if the current instance is no longer usable and must be discarded\n   * @throws KeeperException       if any ZooKeeper operation results in an error\n   * @throws InterruptedException  if the current thread is interrupted\n   */\n  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {\n    if (invalidState) {\n      throw new IllegalStateException(\"ZkStateWriter has seen a tragic error, this instance can no longer be used\");\n    }\n    if (!hasPendingUpdates()) return clusterState;\n    Timer.Context timerContext = stats.time(\"update_state\");\n    boolean success = false;\n    try {\n      if (!updates.isEmpty()) {\n        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {\n          String name = entry.getKey();\n          String path = ZkStateReader.getCollectionPath(name);\n          DocCollection c = entry.getValue();\n\n          if (c == null) {\n            // let's clean up the state.json of this collection only, the rest should be clean by delete collection cmd\n            log.debug(\"going to delete state.json {}\", path);\n            reader.getZkClient().clean(path);\n          } else if (c.getStateFormat() > 1) {\n            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));\n            if (reader.getZkClient().exists(path, true)) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"going to update_collection {} version: {}\", path, c.getZNodeVersion());\n              }\n              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            } else {\n              log.debug(\"going to create_collection {}\", path);\n              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);\n              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);\n              clusterState = clusterState.copyWith(name, newCollection);\n            }\n          } else if (c.getStateFormat() == 1) {\n            isClusterStateModified = true;\n          }\n        }\n\n        updates.clear();\n        numUpdates = 0;\n      }\n\n      if (isClusterStateModified) {\n        assert clusterState.getZkClusterStateVersion() >= 0;\n        byte[] data = Utils.toJSON(clusterState);\n        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);\n        Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n        // use the reader's live nodes because our cluster state's live nodes may be stale\n        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collections);\n        isClusterStateModified = false;\n      }\n      lastUpdatedTime = System.nanoTime();\n      success = true;\n    } catch (KeeperException.BadVersionException bve) {\n      // this is a tragic error, we must disallow usage of this instance\n      invalidState = true;\n      throw bve;\n    } finally {\n      timerContext.stop();\n      if (success) {\n        stats.success(\"update_state\");\n      } else {\n        stats.error(\"update_state\");\n      }\n    }\n\n    log.trace(\"New Cluster State is: {}\", clusterState);\n    return clusterState;\n  }\n\n","bugFix":["b693a83132c9e45afcd564fd65a25b60ed80388b","e9974f61802aea1d15849a1053f88f5e89fc32b4","24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f3e7752e8a5e963c6939aaa99c36134147a5ece":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4e42079c4c34cc1868518eff79f79ebaeb6d1965":["61c45e99cf6676da48f19d7511c73712ad39402b"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["8bf04c3f77a2936f29948b9c0dd215d82d43f5cf","04c8df3f10a676c3de5dbf390f17a2de2d45cacd"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["0f3e7752e8a5e963c6939aaa99c36134147a5ece","61c45e99cf6676da48f19d7511c73712ad39402b"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28ac6f4e1415bdb37652b37bbf30c3c571c97688":["584c1ee8712b5af28075d98028ccab111d6eeda2"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","73450c0955930295d34703e7ddbfc6973b7a121a"],"584c1ee8712b5af28075d98028ccab111d6eeda2":["3717889cd0547a234e5fb8db6934848a727cdf19"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["73450c0955930295d34703e7ddbfc6973b7a121a","962cd4f5e313777f35da8f521265323e84184929"],"8bf04c3f77a2936f29948b9c0dd215d82d43f5cf":["1e5f642aea415d0cbee35d1b3208b193a62d7f15"],"962cd4f5e313777f35da8f521265323e84184929":["73450c0955930295d34703e7ddbfc6973b7a121a"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["4abf821a41a2fdca2a1dea148999931d22e20529"],"61c45e99cf6676da48f19d7511c73712ad39402b":["0f3e7752e8a5e963c6939aaa99c36134147a5ece"],"73450c0955930295d34703e7ddbfc6973b7a121a":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"e3eaf6502248c2d6fadda33bfd9feb21a08caade":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","73450c0955930295d34703e7ddbfc6973b7a121a"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["28ac6f4e1415bdb37652b37bbf30c3c571c97688"],"1e5f642aea415d0cbee35d1b3208b193a62d7f15":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"04c8df3f10a676c3de5dbf390f17a2de2d45cacd":["8bf04c3f77a2936f29948b9c0dd215d82d43f5cf"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"06263309947a9804c326e35ce627be8768e123a4":["4e42079c4c34cc1868518eff79f79ebaeb6d1965"],"4abf821a41a2fdca2a1dea148999931d22e20529":["06263309947a9804c326e35ce627be8768e123a4"],"727bb765ff2542275f6d31f67be18d7104bae148":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0f3e7752e8a5e963c6939aaa99c36134147a5ece"],"3717889cd0547a234e5fb8db6934848a727cdf19":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["e3eaf6502248c2d6fadda33bfd9feb21a08caade"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"0f3e7752e8a5e963c6939aaa99c36134147a5ece":["e9017cf144952056066919f1ebc7897ff9bd71b1","61c45e99cf6676da48f19d7511c73712ad39402b","727bb765ff2542275f6d31f67be18d7104bae148"],"4e42079c4c34cc1868518eff79f79ebaeb6d1965":["06263309947a9804c326e35ce627be8768e123a4"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","73450c0955930295d34703e7ddbfc6973b7a121a","e3eaf6502248c2d6fadda33bfd9feb21a08caade","7dc08f02757dd10637b16a5c65eaaef839a91a9a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["3717889cd0547a234e5fb8db6934848a727cdf19"],"28ac6f4e1415bdb37652b37bbf30c3c571c97688":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["0f3e7752e8a5e963c6939aaa99c36134147a5ece","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"584c1ee8712b5af28075d98028ccab111d6eeda2":["28ac6f4e1415bdb37652b37bbf30c3c571c97688"],"8bf04c3f77a2936f29948b9c0dd215d82d43f5cf":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","04c8df3f10a676c3de5dbf390f17a2de2d45cacd"],"962cd4f5e313777f35da8f521265323e84184929":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"61c45e99cf6676da48f19d7511c73712ad39402b":["4e42079c4c34cc1868518eff79f79ebaeb6d1965","e9017cf144952056066919f1ebc7897ff9bd71b1"],"73450c0955930295d34703e7ddbfc6973b7a121a":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","962cd4f5e313777f35da8f521265323e84184929","7dc08f02757dd10637b16a5c65eaaef839a91a9a"],"e3eaf6502248c2d6fadda33bfd9feb21a08caade":["e9974f61802aea1d15849a1053f88f5e89fc32b4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["1e5f642aea415d0cbee35d1b3208b193a62d7f15"],"1e5f642aea415d0cbee35d1b3208b193a62d7f15":["8bf04c3f77a2936f29948b9c0dd215d82d43f5cf"],"04c8df3f10a676c3de5dbf390f17a2de2d45cacd":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["727bb765ff2542275f6d31f67be18d7104bae148"],"06263309947a9804c326e35ce627be8768e123a4":["4abf821a41a2fdca2a1dea148999931d22e20529"],"4abf821a41a2fdca2a1dea148999931d22e20529":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"3717889cd0547a234e5fb8db6934848a727cdf19":["584c1ee8712b5af28075d98028ccab111d6eeda2"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}