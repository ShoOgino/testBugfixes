{"path":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","commits":[{"id":"4cc45c615dbb82bf79d5f9550286098367874fbf","date":1409571423,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbc3688252d4a8045d69a164236b2cf87b721f17","date":1409846185,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      IOUtils.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":["5eb2511ababf862ea11e10761c70ee560cd84510"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataPath(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      IOUtils.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"509b34c7d48bc90eb4ec5e8757e0f879a19f22ee","date":1410650745,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataPath(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7523916a1350712e1ae710affd4e88ccd7c431d","date":1412161942,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f3189d15ef66702bbb45771403a68793d5cd137","date":1433872507,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7cd425b41357fc2d22c92654fb7c614761ca6fa","date":1438618930,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44a0466296f4b2d9deac60e3e524628c97aa5191","date":1454532248,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n      IOUtils.rm(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14654be3f7a82c9a3c52169e365baa55bfe64f66","date":1587212697,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      Path oldIndexDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataInputStream(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndexDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndexDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        if (e.getReason() != null) {\n          assertNull(e.getVersion());\n          assertNull(e.getMinVersion());\n          assertNull(e.getMaxVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getReason()).getMessage());\n        } else {\n          assertNotNull(e.getVersion());\n          assertNotNull(e.getMinVersion());\n          assertNotNull(e.getMaxVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() >= e.getMinVersion());\n          assertTrue(e.getMessage(), e.getMaxVersion() < e.getVersion() || e.getVersion() < e.getMinVersion());\n          assertEquals(e.getMessage(), new IndexFormatTooOldException(e.getResourceDescription(), e.getVersion(), e.getMinVersion(), e.getMaxVersion()).getMessage());\n        }\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n      checker.close();\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5a207d19eac354d649c3f0e2cce070017c78125e":["a7cd425b41357fc2d22c92654fb7c614761ca6fa","b470f36a9372c97283360b1304eacbde22df6c0d"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a7cd425b41357fc2d22c92654fb7c614761ca6fa","b470f36a9372c97283360b1304eacbde22df6c0d"],"f7523916a1350712e1ae710affd4e88ccd7c431d":["509b34c7d48bc90eb4ec5e8757e0f879a19f22ee"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["509b34c7d48bc90eb4ec5e8757e0f879a19f22ee","f7523916a1350712e1ae710affd4e88ccd7c431d"],"8f3189d15ef66702bbb45771403a68793d5cd137":["f7523916a1350712e1ae710affd4e88ccd7c431d"],"f4abec28b874149a7223e32cc7a01704c27790de":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4cc45c615dbb82bf79d5f9550286098367874fbf"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["5a207d19eac354d649c3f0e2cce070017c78125e"],"a7cd425b41357fc2d22c92654fb7c614761ca6fa":["8f3189d15ef66702bbb45771403a68793d5cd137"],"b470f36a9372c97283360b1304eacbde22df6c0d":["a7cd425b41357fc2d22c92654fb7c614761ca6fa","44a0466296f4b2d9deac60e3e524628c97aa5191"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cc45c615dbb82bf79d5f9550286098367874fbf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"509b34c7d48bc90eb4ec5e8757e0f879a19f22ee":["f4abec28b874149a7223e32cc7a01704c27790de"],"44a0466296f4b2d9deac60e3e524628c97aa5191":["a7cd425b41357fc2d22c92654fb7c614761ca6fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["14654be3f7a82c9a3c52169e365baa55bfe64f66"]},"commit2Childs":{"5a207d19eac354d649c3f0e2cce070017c78125e":["14654be3f7a82c9a3c52169e365baa55bfe64f66"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"f7523916a1350712e1ae710affd4e88ccd7c431d":["d9a47902d6207303f5ed3e7aaca62ca33433af66","8f3189d15ef66702bbb45771403a68793d5cd137"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"8f3189d15ef66702bbb45771403a68793d5cd137":["a7cd425b41357fc2d22c92654fb7c614761ca6fa"],"f4abec28b874149a7223e32cc7a01704c27790de":["509b34c7d48bc90eb4ec5e8757e0f879a19f22ee"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["f4abec28b874149a7223e32cc7a01704c27790de"],"a7cd425b41357fc2d22c92654fb7c614761ca6fa":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b470f36a9372c97283360b1304eacbde22df6c0d","44a0466296f4b2d9deac60e3e524628c97aa5191"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","4cc45c615dbb82bf79d5f9550286098367874fbf"],"4cc45c615dbb82bf79d5f9550286098367874fbf":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"509b34c7d48bc90eb4ec5e8757e0f879a19f22ee":["f7523916a1350712e1ae710affd4e88ccd7c431d","d9a47902d6207303f5ed3e7aaca62ca33433af66"],"44a0466296f4b2d9deac60e3e524628c97aa5191":["b470f36a9372c97283360b1304eacbde22df6c0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","d9a47902d6207303f5ed3e7aaca62ca33433af66","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}