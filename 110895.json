{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","commits":[{"id":"deea3439de4f487ae553317e50d5d641ca386374","date":1537522941,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      if (tlogReplicas + pullReplicas > 0)  {\n        throw new AssignmentException(Replica.Type.TLOG + \" or \" + Replica.Type.PULL +\n            \" replica types not supported with placement rules\");\n      }\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, tlogReplicas, pullReplicas,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1fec8b37cbb6884a64d39565e9dd7b4522a0598","date":1537699559,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      if (tlogReplicas + pullReplicas > 0)  {\n        throw new AssignmentException(Replica.Type.TLOG + \" or \" + Replica.Type.PULL +\n            \" replica types not supported with placement rules\");\n      }\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, tlogReplicas, pullReplicas,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"426f1d22a8cdb6c24e7b24a8a8b06f34c4a6489b","date":1537857856,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      if (tlogReplicas + pullReplicas > 0)  {\n        throw new AssignmentException(Replica.Type.TLOG + \" or \" + Replica.Type.PULL +\n            \" replica types not supported with placement rules\");\n      }\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, tlogReplicas, pullReplicas,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      if (tlogReplicas + pullReplicas > 0)  {\n        throw new AssignmentException(Replica.Type.TLOG + \" or \" + Replica.Type.PULL +\n            \" replica types not supported with placement rules\");\n      }\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, tlogReplicas, pullReplicas,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea","date":1538045138,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      if (tlogReplicas + pullReplicas > 0)  {\n        throw new AssignmentException(Replica.Type.TLOG + \" or \" + Replica.Type.PULL +\n            \" replica types not supported with placement rules\");\n      }\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cloudManager, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, tlogReplicas, pullReplicas,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\", shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76574dac4558817234ef087dd38728569cc93bff","date":1591547057,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    throwIfAnyNotLive(createNodeList,clusterState);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, null);\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8946843123ed22c63230024259fe1a8bfa7ab71","date":1591549365,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    throwIfAnyNotLive(createNodeList,clusterState);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, null);\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"762e7d1b8822c5271a29e9f308660638d1501c08","date":1592065068,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, null);\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = coll.getMaxShardsPerNode() == -1 ? Integer.MAX_VALUE : coll.getMaxShardsPerNode();\n    List<String> createNodeList;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, null);\n      long availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas + tlogReplicas + pullReplicas) {\n        throw new AssignmentException(\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of eligible live nodes %d and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, nodeNameVsShardCount.size(), maxShardsPerNode));\n      }\n    }\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,CloudConfig,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, CloudConfig cloudConfig, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, cloudConfig, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,CloudConfig,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, CloudConfig cloudConfig, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, cloudConfig, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f5d9700b23e8e9b11b845fcecef89dbdf21373d9","date":1600294231,"type":3,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategy assignStrategy = createAssignStrategy(cloudManager, clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65352f844eb9e9a677ec4eb2abced4404f08181d","date":1600297608,"type":3,"author":"noblepaul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategy assignStrategy = createAssignStrategy(cloudManager, clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["e7b17e79a71117668ecbf8d3417c876e41396565"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["426f1d22a8cdb6c24e7b24a8a8b06f34c4a6489b"],"426f1d22a8cdb6c24e7b24a8a8b06f34c4a6489b":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"65352f844eb9e9a677ec4eb2abced4404f08181d":["e7b17e79a71117668ecbf8d3417c876e41396565","f5d9700b23e8e9b11b845fcecef89dbdf21373d9"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["e35f2dde06b35aa9904949a3a93fabd090371077"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["762e7d1b8822c5271a29e9f308660638d1501c08"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","deea3439de4f487ae553317e50d5d641ca386374"],"76574dac4558817234ef087dd38728569cc93bff":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e35f2dde06b35aa9904949a3a93fabd090371077":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"deea3439de4f487ae553317e50d5d641ca386374":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"762e7d1b8822c5271a29e9f308660638d1501c08":["e8946843123ed22c63230024259fe1a8bfa7ab71"],"e8946843123ed22c63230024259fe1a8bfa7ab71":["76574dac4558817234ef087dd38728569cc93bff"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65352f844eb9e9a677ec4eb2abced4404f08181d"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["f5d9700b23e8e9b11b845fcecef89dbdf21373d9","65352f844eb9e9a677ec4eb2abced4404f08181d"],"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["65352f844eb9e9a677ec4eb2abced4404f08181d"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["e35f2dde06b35aa9904949a3a93fabd090371077"],"426f1d22a8cdb6c24e7b24a8a8b06f34c4a6489b":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"65352f844eb9e9a677ec4eb2abced4404f08181d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["c526352db87264a72a7a9ad68c1b769b81e54305"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["76574dac4558817234ef087dd38728569cc93bff"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["426f1d22a8cdb6c24e7b24a8a8b06f34c4a6489b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598","deea3439de4f487ae553317e50d5d641ca386374"],"76574dac4558817234ef087dd38728569cc93bff":["e8946843123ed22c63230024259fe1a8bfa7ab71"],"e35f2dde06b35aa9904949a3a93fabd090371077":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"deea3439de4f487ae553317e50d5d641ca386374":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"762e7d1b8822c5271a29e9f308660638d1501c08":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e8946843123ed22c63230024259fe1a8bfa7ab71":["762e7d1b8822c5271a29e9f308660638d1501c08"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}