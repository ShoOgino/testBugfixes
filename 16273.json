{"path":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","commits":[{"id":"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","date":1520143025,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adding doc when replicas (not leader) are network partitioned with leader,\n   * These replicas are out-of-sync hence they should not become leader even when current leader is DOWN.\n   * Leader should be on node - 0\n   */\n  private void addDocWhenOtherReplicasAreNetworkPartitioned(String collection, Replica leader, int docId) throws Exception {\n    for (int i = 0; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).close();\n    }\n    addDoc(collection, docId, cluster.getJettySolrRunner(0));\n    ChaosMonkey.stop(cluster.getJettySolrRunner(0));\n    for (int i = 1; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).reopen();\n    }\n    waitForState(\"Timeout waiting for leader goes DOWN\", collection, (liveNodes, collectionState)\n        -> collectionState.getReplica(leader.getName()).getState() == Replica.State.DOWN);\n\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.CURRENT_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica newLeader = getCollectionState(collection).getLeader(\"shard1\");\n      if (newLeader != null && !newLeader.getName().equals(leader.getName()) && newLeader.getState() == Replica.State.ACTIVE) {\n        fail(\"Out of sync replica became leader \" + newLeader);\n      }\n    }\n\n    proxies.get(cluster.getJettySolrRunner(0)).reopen();\n    ChaosMonkey.start(cluster.getJettySolrRunner(0));\n    waitForState(\"Timeout waiting for leader\", collection, (liveNodes, collectionState) -> {\n      Replica newLeader = collectionState.getLeader(\"shard1\");\n      return newLeader != null && newLeader.getName().equals(leader.getName());\n    });\n    waitForState(\"Timeout waiting for active collection\", collection, clusterShape(1, 3));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","sourceNew":"  /**\n   * Adding doc when replicas (not leader) are network partitioned with leader,\n   * These replicas are out-of-sync hence they should not become leader even when current leader is DOWN.\n   * Leader should be on node - 0\n   */\n  private void addDocWhenOtherReplicasAreNetworkPartitioned(String collection, Replica leader, int docId) throws Exception {\n    for (int i = 0; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).close();\n    }\n    addDoc(collection, docId, cluster.getJettySolrRunner(0));\n    JettySolrRunner j1 = cluster.getJettySolrRunner(0);\n    j1.stop();\n    cluster.waitForJettyToStop(j1);\n    for (int i = 1; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).reopen();\n    }\n    waitForState(\"Timeout waiting for leader goes DOWN\", collection, (liveNodes, collectionState)\n        -> collectionState.getReplica(leader.getName()).getState() == Replica.State.DOWN);\n\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.CURRENT_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica newLeader = getCollectionState(collection).getLeader(\"shard1\");\n      if (newLeader != null && !newLeader.getName().equals(leader.getName()) && newLeader.getState() == Replica.State.ACTIVE) {\n        fail(\"Out of sync replica became leader \" + newLeader);\n      }\n    }\n\n    proxies.get(cluster.getJettySolrRunner(0)).reopen();\n    cluster.getJettySolrRunner(0).start();\n    cluster.waitForAllNodes(30);;\n    waitForState(\"Timeout waiting for leader\", collection, (liveNodes, collectionState) -> {\n      Replica newLeader = collectionState.getLeader(\"shard1\");\n      return newLeader != null && newLeader.getName().equals(leader.getName());\n    });\n    waitForState(\"Timeout waiting for active collection\", collection, clusterShape(1, 3));\n  }\n\n","sourceOld":"  /**\n   * Adding doc when replicas (not leader) are network partitioned with leader,\n   * These replicas are out-of-sync hence they should not become leader even when current leader is DOWN.\n   * Leader should be on node - 0\n   */\n  private void addDocWhenOtherReplicasAreNetworkPartitioned(String collection, Replica leader, int docId) throws Exception {\n    for (int i = 0; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).close();\n    }\n    addDoc(collection, docId, cluster.getJettySolrRunner(0));\n    ChaosMonkey.stop(cluster.getJettySolrRunner(0));\n    for (int i = 1; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).reopen();\n    }\n    waitForState(\"Timeout waiting for leader goes DOWN\", collection, (liveNodes, collectionState)\n        -> collectionState.getReplica(leader.getName()).getState() == Replica.State.DOWN);\n\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.CURRENT_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica newLeader = getCollectionState(collection).getLeader(\"shard1\");\n      if (newLeader != null && !newLeader.getName().equals(leader.getName()) && newLeader.getState() == Replica.State.ACTIVE) {\n        fail(\"Out of sync replica became leader \" + newLeader);\n      }\n    }\n\n    proxies.get(cluster.getJettySolrRunner(0)).reopen();\n    ChaosMonkey.start(cluster.getJettySolrRunner(0));\n    waitForState(\"Timeout waiting for leader\", collection, (liveNodes, collectionState) -> {\n      Replica newLeader = collectionState.getLeader(\"shard1\");\n      return newLeader != null && newLeader.getName().equals(leader.getName());\n    });\n    waitForState(\"Timeout waiting for active collection\", collection, clusterShape(1, 3));\n  }\n\n","bugFix":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abfeda0a9738b1b31db7c43aa5f067596bf5c9e1","date":1544401888,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","sourceNew":"  /**\n   * Adding doc when replicas (not leader) are network partitioned with leader,\n   * These replicas are out-of-sync hence they should not become leader even when current leader is DOWN.\n   * Leader should be on node - 0\n   */\n  private void addDocWhenOtherReplicasAreNetworkPartitioned(String collection, Replica leader, int docId) throws Exception {\n    for (int i = 0; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).close();\n    }\n    addDoc(collection, docId, cluster.getJettySolrRunner(0));\n    JettySolrRunner j1 = cluster.getJettySolrRunner(0);\n    j1.stop();\n    cluster.waitForJettyToStop(j1);\n    for (int i = 1; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).reopen();\n    }\n    waitForState(\"Timeout waiting for leader goes DOWN\", collection, (liveNodes, collectionState)\n        -> collectionState.getReplica(leader.getName()).getState() == Replica.State.DOWN);\n\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.CURRENT_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica newLeader = getCollectionState(collection).getLeader(\"shard1\");\n      if (newLeader != null && !newLeader.getName().equals(leader.getName()) && newLeader.getState() == Replica.State.ACTIVE) {\n        fail(\"Out of sync replica became leader \" + newLeader);\n      }\n    }\n\n    proxies.get(cluster.getJettySolrRunner(0)).reopen();\n    cluster.getJettySolrRunner(0).start();\n    cluster.waitForAllNodes(30);;\n    waitForState(\"Timeout waiting for leader\", collection, (liveNodes, collectionState) -> {\n      Replica newLeader = collectionState.getLeader(\"shard1\");\n      return newLeader != null && newLeader.getName().equals(leader.getName());\n    });\n    waitForState(\"Timeout waiting for active collection\", collection, clusterShape(1, 3));\n    \n    cluster.waitForActiveCollection(collection, 1, 3);\n  }\n\n","sourceOld":"  /**\n   * Adding doc when replicas (not leader) are network partitioned with leader,\n   * These replicas are out-of-sync hence they should not become leader even when current leader is DOWN.\n   * Leader should be on node - 0\n   */\n  private void addDocWhenOtherReplicasAreNetworkPartitioned(String collection, Replica leader, int docId) throws Exception {\n    for (int i = 0; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).close();\n    }\n    addDoc(collection, docId, cluster.getJettySolrRunner(0));\n    JettySolrRunner j1 = cluster.getJettySolrRunner(0);\n    j1.stop();\n    cluster.waitForJettyToStop(j1);\n    for (int i = 1; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).reopen();\n    }\n    waitForState(\"Timeout waiting for leader goes DOWN\", collection, (liveNodes, collectionState)\n        -> collectionState.getReplica(leader.getName()).getState() == Replica.State.DOWN);\n\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.CURRENT_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica newLeader = getCollectionState(collection).getLeader(\"shard1\");\n      if (newLeader != null && !newLeader.getName().equals(leader.getName()) && newLeader.getState() == Replica.State.ACTIVE) {\n        fail(\"Out of sync replica became leader \" + newLeader);\n      }\n    }\n\n    proxies.get(cluster.getJettySolrRunner(0)).reopen();\n    cluster.getJettySolrRunner(0).start();\n    cluster.waitForAllNodes(30);;\n    waitForState(\"Timeout waiting for leader\", collection, (liveNodes, collectionState) -> {\n      Replica newLeader = collectionState.getLeader(\"shard1\");\n      return newLeader != null && newLeader.getName().equals(leader.getName());\n    });\n    waitForState(\"Timeout waiting for active collection\", collection, clusterShape(1, 3));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc201e01d035a7370848d9d2451e0e27ee77df2e","date":1544724144,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","sourceNew":"  /**\n   * Adding doc when replicas (not leader) are network partitioned with leader,\n   * These replicas are out-of-sync hence they should not become leader even when current leader is DOWN.\n   * Leader should be on node - 0\n   */\n  private void addDocWhenOtherReplicasAreNetworkPartitioned(String collection, Replica leader, int docId) throws Exception {\n    for (int i = 0; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).close();\n    }\n    addDoc(collection, docId, cluster.getJettySolrRunner(0));\n    JettySolrRunner j1 = cluster.getJettySolrRunner(0);\n    j1.stop();\n    cluster.waitForJettyToStop(j1);\n    for (int i = 1; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).reopen();\n    }\n    waitForState(\"Timeout waiting for leader goes DOWN\", collection, (liveNodes, collectionState)\n        -> collectionState.getReplica(leader.getName()).getState() == Replica.State.DOWN);\n\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica newLeader = getCollectionState(collection).getLeader(\"shard1\");\n      if (newLeader != null && !newLeader.getName().equals(leader.getName()) && newLeader.getState() == Replica.State.ACTIVE) {\n        fail(\"Out of sync replica became leader \" + newLeader);\n      }\n    }\n\n    proxies.get(cluster.getJettySolrRunner(0)).reopen();\n    cluster.getJettySolrRunner(0).start();\n    cluster.waitForAllNodes(30);;\n    waitForState(\"Timeout waiting for leader\", collection, (liveNodes, collectionState) -> {\n      Replica newLeader = collectionState.getLeader(\"shard1\");\n      return newLeader != null && newLeader.getName().equals(leader.getName());\n    });\n    waitForState(\"Timeout waiting for active collection\", collection, clusterShape(1, 3));\n    \n    cluster.waitForActiveCollection(collection, 1, 3);\n  }\n\n","sourceOld":"  /**\n   * Adding doc when replicas (not leader) are network partitioned with leader,\n   * These replicas are out-of-sync hence they should not become leader even when current leader is DOWN.\n   * Leader should be on node - 0\n   */\n  private void addDocWhenOtherReplicasAreNetworkPartitioned(String collection, Replica leader, int docId) throws Exception {\n    for (int i = 0; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).close();\n    }\n    addDoc(collection, docId, cluster.getJettySolrRunner(0));\n    JettySolrRunner j1 = cluster.getJettySolrRunner(0);\n    j1.stop();\n    cluster.waitForJettyToStop(j1);\n    for (int i = 1; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).reopen();\n    }\n    waitForState(\"Timeout waiting for leader goes DOWN\", collection, (liveNodes, collectionState)\n        -> collectionState.getReplica(leader.getName()).getState() == Replica.State.DOWN);\n\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.CURRENT_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica newLeader = getCollectionState(collection).getLeader(\"shard1\");\n      if (newLeader != null && !newLeader.getName().equals(leader.getName()) && newLeader.getState() == Replica.State.ACTIVE) {\n        fail(\"Out of sync replica became leader \" + newLeader);\n      }\n    }\n\n    proxies.get(cluster.getJettySolrRunner(0)).reopen();\n    cluster.getJettySolrRunner(0).start();\n    cluster.waitForAllNodes(30);;\n    waitForState(\"Timeout waiting for leader\", collection, (liveNodes, collectionState) -> {\n      Replica newLeader = collectionState.getLeader(\"shard1\");\n      return newLeader != null && newLeader.getName().equals(leader.getName());\n    });\n    waitForState(\"Timeout waiting for active collection\", collection, clusterShape(1, 3));\n    \n    cluster.waitForActiveCollection(collection, 1, 3);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82917f9ea58e77078cb7b18e9195b383aeec1b60","date":1579729496,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudConsistency#addDocWhenOtherReplicasAreNetworkPartitioned(String,Replica,int).mjava","sourceNew":"  /**\n   * Adding doc when replicas (not leader) are network partitioned with leader,\n   * These replicas are out-of-sync hence they should not become leader even when current leader is DOWN.\n   * Leader should be on node - 0\n   */\n  private void addDocWhenOtherReplicasAreNetworkPartitioned(String collection, Replica leader, int docId) throws Exception {\n    for (int i = 0; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).close();\n    }\n    addDoc(collection, docId, cluster.getJettySolrRunner(0));\n    JettySolrRunner j1 = cluster.getJettySolrRunner(0);\n    j1.stop();\n    cluster.waitForJettyToStop(j1);\n    for (int i = 1; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).reopen();\n    }\n    waitForState(\"Timeout waiting for leader goes DOWN\", collection, (liveNodes, collectionState)\n        -> collectionState.getReplica(leader.getName()).getState() == Replica.State.DOWN);\n\n    // the meat of the test -- wait to see if a different replica become a leader\n    // the correct behavior is that this should time out, if it succeeds we have a problem...\n    expectThrows(TimeoutException.class,\n                 \"Did not time out waiting for new leader, out of sync replica became leader\",\n                 () -> {\n                   cluster.getSolrClient().waitForState(collection, 10, TimeUnit.SECONDS, (state) -> {\n            Replica newLeader = state.getSlice(\"shard1\").getLeader();\n            if (newLeader != null && !newLeader.getName().equals(leader.getName()) && newLeader.getState() == Replica.State.ACTIVE) {\n              // this is is the bad case, our \"bad\" state was found before timeout\n              log.error(\"WTF: New Leader={}\", newLeader);\n              return true;\n            }\n            return false; // still no bad state, wait for timeout\n          });\n      });\n\n    proxies.get(cluster.getJettySolrRunner(0)).reopen();\n    cluster.getJettySolrRunner(0).start();\n    cluster.waitForAllNodes(30);;\n    waitForState(\"Timeout waiting for leader\", collection, (liveNodes, collectionState) -> {\n      Replica newLeader = collectionState.getLeader(\"shard1\");\n      return newLeader != null && newLeader.getName().equals(leader.getName());\n    });\n    waitForState(\"Timeout waiting for active collection\", collection, clusterShape(1, 3));\n    \n    cluster.waitForActiveCollection(collection, 1, 3);\n  }\n\n","sourceOld":"  /**\n   * Adding doc when replicas (not leader) are network partitioned with leader,\n   * These replicas are out-of-sync hence they should not become leader even when current leader is DOWN.\n   * Leader should be on node - 0\n   */\n  private void addDocWhenOtherReplicasAreNetworkPartitioned(String collection, Replica leader, int docId) throws Exception {\n    for (int i = 0; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).close();\n    }\n    addDoc(collection, docId, cluster.getJettySolrRunner(0));\n    JettySolrRunner j1 = cluster.getJettySolrRunner(0);\n    j1.stop();\n    cluster.waitForJettyToStop(j1);\n    for (int i = 1; i < 3; i++) {\n      proxies.get(cluster.getJettySolrRunner(i)).reopen();\n    }\n    waitForState(\"Timeout waiting for leader goes DOWN\", collection, (liveNodes, collectionState)\n        -> collectionState.getReplica(leader.getName()).getState() == Replica.State.DOWN);\n\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      Replica newLeader = getCollectionState(collection).getLeader(\"shard1\");\n      if (newLeader != null && !newLeader.getName().equals(leader.getName()) && newLeader.getState() == Replica.State.ACTIVE) {\n        fail(\"Out of sync replica became leader \" + newLeader);\n      }\n    }\n\n    proxies.get(cluster.getJettySolrRunner(0)).reopen();\n    cluster.getJettySolrRunner(0).start();\n    cluster.waitForAllNodes(30);;\n    waitForState(\"Timeout waiting for leader\", collection, (liveNodes, collectionState) -> {\n      Replica newLeader = collectionState.getLeader(\"shard1\");\n      return newLeader != null && newLeader.getName().equals(leader.getName());\n    });\n    waitForState(\"Timeout waiting for active collection\", collection, clusterShape(1, 3));\n    \n    cluster.waitForActiveCollection(collection, 1, 3);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"abfeda0a9738b1b31db7c43aa5f067596bf5c9e1":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"82917f9ea58e77078cb7b18e9195b383aeec1b60":["bc201e01d035a7370848d9d2451e0e27ee77df2e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["abfeda0a9738b1b31db7c43aa5f067596bf5c9e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["82917f9ea58e77078cb7b18e9195b383aeec1b60"]},"commit2Childs":{"abfeda0a9738b1b31db7c43aa5f067596bf5c9e1":["bc201e01d035a7370848d9d2451e0e27ee77df2e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["abfeda0a9738b1b31db7c43aa5f067596bf5c9e1"],"82917f9ea58e77078cb7b18e9195b383aeec1b60":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["82917f9ea58e77078cb7b18e9195b383aeec1b60"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}