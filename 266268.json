{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": merge end\");\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": merge end\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": merge end\");\n  }\n\n","bugFix":["850aca8525380ccb7df9626d7caa89678005dd31"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": merge end\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.docCount + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"203d7d3cb7712e10ef33009a63247ae40c302d7a","date":1337798111,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.docCount + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.docCount + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf","09b6beb7329eb1b75a38c94b1c5ab4e840743c59"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge)\n    throws CorruptIndexException, IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f24f21e70a092329fc6f920115592dc9529d379","date":1349391034,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"181b1aa5a99534972fbfd5595cdbb38bba5f39ee","date":1350576187,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee59f646cf24586a449cad77391a60a3ac8d8959","date":1408015131,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && !merge.isAborted() && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && !merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.getDocCount() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950882a2bd2a5f9dc16a154871584eaa643d882a","date":1436366563,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          mergeFinish(merge);\n\n          if (!success) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9e22bdf0692bfa61e342b04a6ac7078670c1e16","date":1436866730,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          } else if (merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          }\n\n          // This merge (and, generally, any change to the\n          // segments) may now enable new merges, so we call\n          // merge policy & update pending merges.\n          if (success && merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"merge\");\n    }\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aac05884852c2a15a6aa9153063de70dea4fbcae","date":1441829939,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n            if (merge.info != null && !segmentInfos.contains(merge.info)) {\n              deleter.refresh(merge.info.info.name);\n            }\n          } else if (merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","date":1477166077,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != -1 || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1ee9437ba5a8297220428d48a6bb823d1fcd57b","date":1489137809,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    rateLimiters.set(merge.rateLimiter);\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (merge.rateLimiter.getAbort() == false && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.rateLimiter.getAbort() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          //if (merge.info != null) {\n          //System.out.println(\"MERGE: \" + merge.info.info.name);\n          //}\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n      throw t;\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89697e7abc9807639c384eecf5a2a6eef1080426","date":1587733375,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  protected void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n      throw t;\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  public void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n      throw t;\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#merge(MergePolicy.OneMerge).mjava","sourceNew":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  protected void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n          // Readers are already closed in commitMerge if we didn't hit\n          // an exc:\n          if (success == false) {\n            closeMergeReaders(merge, true, false);\n          }\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n      throw t;\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Merges the indicated segments, replacing them in the stack with a\n   * single segment.\n   * \n   * @lucene.experimental\n   */\n  protected void merge(MergePolicy.OneMerge merge) throws IOException {\n\n    boolean success = false;\n\n    final long t0 = System.currentTimeMillis();\n\n    final MergePolicy mergePolicy = config.getMergePolicy();\n    try {\n      try {\n        try {\n          mergeInit(merge);\n\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"now merge\\n  merge=\" + segString(merge.segments) + \"\\n  index=\" + segString());\n          }\n\n          mergeMiddle(merge, mergePolicy);\n          mergeSuccess(merge);\n          success = true;\n        } catch (Throwable t) {\n          handleMergeException(t, merge);\n        }\n      } finally {\n        synchronized(this) {\n\n          mergeFinish(merge);\n\n          if (success == false) {\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"hit exception during merge\");\n            }\n          } else if (!merge.isAborted() && (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS || (!closed && !closing))) {\n            // This merge (and, generally, any change to the\n            // segments) may now enable new merges, so we call\n            // merge policy & update pending merges.\n            updatePendingMerges(mergePolicy, MergeTrigger.MERGE_FINISHED, merge.maxNumSegments);\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // Important that tragicEvent is called after mergeFinish, else we hang\n      // waiting for our merge thread to be removed from runningMerges:\n      tragicEvent(t, \"merge\");\n      throw t;\n    }\n\n    if (merge.info != null && merge.isAborted() == false) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merge time \" + (System.currentTimeMillis()-t0) + \" msec for \" + merge.info.info.maxDoc() + \" docs\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["28288370235ed02234a64753cdbf0c6ec096304a"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["181b1aa5a99534972fbfd5595cdbb38bba5f39ee"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"89697e7abc9807639c384eecf5a2a6eef1080426":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["5faf65b6692f15cca0f87bf8666c87899afc619f","b0267c69e2456a3477a1ad785723f2135da3117e"],"6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c":["aac05884852c2a15a6aa9153063de70dea4fbcae"],"b06445ae1731e049327712db0454e5643ca9b7fe":["5faf65b6692f15cca0f87bf8666c87899afc619f","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"5f24f21e70a092329fc6f920115592dc9529d379":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"b0267c69e2456a3477a1ad785723f2135da3117e":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["89697e7abc9807639c384eecf5a2a6eef1080426"],"aac05884852c2a15a6aa9153063de70dea4fbcae":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["950882a2bd2a5f9dc16a154871584eaa643d882a"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","203d7d3cb7712e10ef33009a63247ae40c302d7a"],"62e52115b56781006682fd92c6938efaf174304d":["5f24f21e70a092329fc6f920115592dc9529d379","181b1aa5a99534972fbfd5595cdbb38bba5f39ee"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["aac05884852c2a15a6aa9153063de70dea4fbcae","6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c"],"950882a2bd2a5f9dc16a154871584eaa643d882a":["b0267c69e2456a3477a1ad785723f2135da3117e"],"181b1aa5a99534972fbfd5595cdbb38bba5f39ee":["5f24f21e70a092329fc6f920115592dc9529d379"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"]},"commit2Childs":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["89697e7abc9807639c384eecf5a2a6eef1080426"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","38e3b736c7ca086d61b7dbb841c905ee115490da"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"c1ee9437ba5a8297220428d48a6bb823d1fcd57b":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["38e3b736c7ca086d61b7dbb841c905ee115490da","9d153abcf92dc5329d98571a8c3035df9bd80648","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"89697e7abc9807639c384eecf5a2a6eef1080426":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c":["c1ee9437ba5a8297220428d48a6bb823d1fcd57b","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["5f24f21e70a092329fc6f920115592dc9529d379","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"5f24f21e70a092329fc6f920115592dc9529d379":["62e52115b56781006682fd92c6938efaf174304d","181b1aa5a99534972fbfd5595cdbb38bba5f39ee"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"b0267c69e2456a3477a1ad785723f2135da3117e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","950882a2bd2a5f9dc16a154871584eaa643d882a"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aac05884852c2a15a6aa9153063de70dea4fbcae":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["aac05884852c2a15a6aa9153063de70dea4fbcae"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"62e52115b56781006682fd92c6938efaf174304d":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"181b1aa5a99534972fbfd5595cdbb38bba5f39ee":["ee59f646cf24586a449cad77391a60a3ac8d8959","62e52115b56781006682fd92c6938efaf174304d"],"950882a2bd2a5f9dc16a154871584eaa643d882a":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","b0267c69e2456a3477a1ad785723f2135da3117e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","38e3b736c7ca086d61b7dbb841c905ee115490da","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","62e52115b56781006682fd92c6938efaf174304d","fe33227f6805edab2036cbb80645cc4e2d1fa424","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}