{"path":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n\n    final String actualCodec = in.readString();\n    if (!actualCodec.equals(codec)) {\n      throw new CorruptIndexException(\"codec mismatch: actual codec=\" + actualCodec + \" vs expected codec=\" + codec + \" (resource: \" + in + \")\");\n    }\n\n    final int actualVersion = in.readInt();\n    if (actualVersion < minVersion) {\n      throw new IndexFormatTooOldException(in, actualVersion, minVersion, maxVersion);\n    }\n    if (actualVersion > maxVersion) {\n      throw new IndexFormatTooNewException(in, actualVersion, minVersion, maxVersion);\n    }\n\n    return actualVersion;\n  }\n\n","sourceOld":"  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n\n    final String actualCodec = in.readString();\n    if (!actualCodec.equals(codec)) {\n      throw new CorruptIndexException(\"codec mismatch: actual codec=\" + actualCodec + \" vs expected codec=\" + codec + \" (resource: \" + in + \")\");\n    }\n\n    final int actualVersion = in.readInt();\n    if (actualVersion < minVersion) {\n      throw new IndexFormatTooOldException(in, actualVersion, minVersion, maxVersion);\n    }\n    if (actualVersion > maxVersion) {\n      throw new IndexFormatTooNewException(in, actualVersion, minVersion, maxVersion);\n    }\n\n    return actualVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc26e52010f57ac92820f8d306f030144ab7b9d4","date":1335539557,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n\n    final String actualCodec = in.readString();\n    if (!actualCodec.equals(codec)) {\n      throw new CorruptIndexException(\"codec mismatch: actual codec=\" + actualCodec + \" vs expected codec=\" + codec + \" (resource: \" + in + \")\");\n    }\n\n    final int actualVersion = in.readInt();\n    if (actualVersion < minVersion) {\n      throw new IndexFormatTooOldException(in, actualVersion, minVersion, maxVersion);\n    }\n    if (actualVersion > maxVersion) {\n      throw new IndexFormatTooNewException(in, actualVersion, minVersion, maxVersion);\n    }\n\n    return actualVersion;\n  }\n\n","sourceOld":"  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n\n    final String actualCodec = in.readString();\n    if (!actualCodec.equals(codec)) {\n      throw new CorruptIndexException(\"codec mismatch: actual codec=\" + actualCodec + \" vs expected codec=\" + codec + \" (resource: \" + in + \")\");\n    }\n\n    final int actualVersion = in.readInt();\n    if (actualVersion < minVersion) {\n      throw new IndexFormatTooOldException(in, actualVersion, minVersion, maxVersion);\n    }\n    if (actualVersion > maxVersion) {\n      throw new IndexFormatTooNewException(in, actualVersion, minVersion, maxVersion);\n    }\n\n    return actualVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n\n    final String actualCodec = in.readString();\n    if (!actualCodec.equals(codec)) {\n      throw new CorruptIndexException(\"codec mismatch: actual codec=\" + actualCodec + \" vs expected codec=\" + codec + \" (resource: \" + in + \")\");\n    }\n\n    final int actualVersion = in.readInt();\n    if (actualVersion < minVersion) {\n      throw new IndexFormatTooOldException(in, actualVersion, minVersion, maxVersion);\n    }\n    if (actualVersion > maxVersion) {\n      throw new IndexFormatTooNewException(in, actualVersion, minVersion, maxVersion);\n    }\n\n    return actualVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n\n    final String actualCodec = in.readString();\n    if (!actualCodec.equals(codec)) {\n      throw new CorruptIndexException(\"codec mismatch: actual codec=\" + actualCodec + \" vs expected codec=\" + codec + \" (resource: \" + in + \")\");\n    }\n\n    final int actualVersion = in.readInt();\n    if (actualVersion < minVersion) {\n      throw new IndexFormatTooOldException(in, actualVersion, minVersion, maxVersion);\n    }\n    if (actualVersion > maxVersion) {\n      throw new IndexFormatTooNewException(in, actualVersion, minVersion, maxVersion);\n    }\n\n    return actualVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bcce0e518c0546269a896ca6124ba4313059185f","date":1340381078,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bcce0e518c0546269a896ca6124ba4313059185f":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["fc26e52010f57ac92820f8d306f030144ab7b9d4","4356000e349e38c9fb48034695b7c309abd54557"],"4356000e349e38c9fb48034695b7c309abd54557":["fc26e52010f57ac92820f8d306f030144ab7b9d4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","bcce0e518c0546269a896ca6124ba4313059185f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fc26e52010f57ac92820f8d306f030144ab7b9d4":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bcce0e518c0546269a896ca6124ba4313059185f"]},"commit2Childs":{"bcce0e518c0546269a896ca6124ba4313059185f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["bcce0e518c0546269a896ca6124ba4313059185f","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"4356000e349e38c9fb48034695b7c309abd54557":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fc26e52010f57ac92820f8d306f030144ab7b9d4"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"fc26e52010f57ac92820f8d306f030144ab7b9d4":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4356000e349e38c9fb48034695b7c309abd54557"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}