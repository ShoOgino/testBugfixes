{"path":"lucene/core/src/java/org/apache/lucene/document/LatLonPointDistanceFeatureQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","commits":[{"id":"607e7af5082700f0a5d1b5e92452084cf94058d4","date":1537346996,"type":0,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointDistanceFeatureQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    return new Weight(this) {\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return false;\n      }\n\n      @Override\n      public void extractTerms(Set<Term> terms) {}\n\n      @Override\n      public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n        SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        if (multiDocValues.advanceExact(doc) == false) {\n          return Explanation.noMatch(\"Document \" + doc + \" doesn't have a value for field \" + field);\n        }\n        long encoded = selectValue(multiDocValues);\n        int latitudeBits = (int)(encoded >> 32);\n        int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n        double lat = GeoEncodingUtils.decodeLatitude(latitudeBits);\n        double lon = GeoEncodingUtils.decodeLongitude(longitudeBits);\n        double distance = SloppyMath.haversinMeters(originLat, originLon, lat, lon);\n        float score = (float) (boost * (pivotDistance / (pivotDistance + distance)));\n        return Explanation.match(score, \"Distance score, computed as weight * pivotDistance / (pivotDistance + abs(distance)) from:\",\n            Explanation.match(boost, \"weight\"),\n            Explanation.match(pivotDistance, \"pivotDistance\"),\n            Explanation.match(originLat, \"originLat\"),\n            Explanation.match(originLon, \"originLon\"),\n            Explanation.match(lat, \"current lat\"),\n            Explanation.match(lon, \"current lon\"),\n            Explanation.match(distance, \"distance\"));\n      }\n\n      private long selectValue(SortedNumericDocValues multiDocValues) throws IOException {\n        int count = multiDocValues.docValueCount();\n        long value = multiDocValues.nextValue();\n        if (count == 1) {\n          return value;\n        }\n        // compute exact sort key: avoid any asin() computations\n        double distance = getDistanceKeyFromEncoded(value);\n        for (int i = 1; i < count; ++i) {\n          long nextValue = multiDocValues.nextValue();\n          double nextDistance = getDistanceKeyFromEncoded(nextValue);\n          if (nextDistance < distance) {\n            distance = nextDistance;\n            value = nextValue;\n          }\n        }\n        return value;\n      }\n\n      private NumericDocValues selectValues(SortedNumericDocValues multiDocValues) {\n        final NumericDocValues singleton = DocValues.unwrapSingleton(multiDocValues);\n        if (singleton != null) {\n          return singleton;\n        }\n        return  new NumericDocValues() {\n\n          long value;\n\n          @Override\n          public long longValue() throws IOException {\n            return value;\n          }\n\n          @Override\n          public boolean advanceExact(int target) throws IOException {\n            if (multiDocValues.advanceExact(target)) {\n              value = selectValue(multiDocValues);\n              return true;\n            } else {\n              return false;\n            }\n          }\n\n          @Override\n          public int docID() {\n            return multiDocValues.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return multiDocValues.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return multiDocValues.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return multiDocValues.cost();\n          }\n\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        PointValues pointValues = context.reader().getPointValues(field);\n        if (pointValues == null) {\n          // No data on this segment\n          return null;\n        }\n        final SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        final NumericDocValues docValues = selectValues(multiDocValues);\n\n        final Weight weight = this;\n        return new ScorerSupplier() {\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return new DistanceScorer(weight, context.reader().maxDoc(), leadCost, boost, pointValues, docValues);\n          }\n\n          @Override\n          public long cost() {\n            return docValues.cost();\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7","date":1552575873,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPointDistanceFeatureQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/LatLonPointDistanceFeatureQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    return new Weight(this) {\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return false;\n      }\n\n      @Override\n      public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n        SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        if (multiDocValues.advanceExact(doc) == false) {\n          return Explanation.noMatch(\"Document \" + doc + \" doesn't have a value for field \" + field);\n        }\n        long encoded = selectValue(multiDocValues);\n        int latitudeBits = (int)(encoded >> 32);\n        int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n        double lat = GeoEncodingUtils.decodeLatitude(latitudeBits);\n        double lon = GeoEncodingUtils.decodeLongitude(longitudeBits);\n        double distance = SloppyMath.haversinMeters(originLat, originLon, lat, lon);\n        float score = (float) (boost * (pivotDistance / (pivotDistance + distance)));\n        return Explanation.match(score, \"Distance score, computed as weight * pivotDistance / (pivotDistance + abs(distance)) from:\",\n            Explanation.match(boost, \"weight\"),\n            Explanation.match(pivotDistance, \"pivotDistance\"),\n            Explanation.match(originLat, \"originLat\"),\n            Explanation.match(originLon, \"originLon\"),\n            Explanation.match(lat, \"current lat\"),\n            Explanation.match(lon, \"current lon\"),\n            Explanation.match(distance, \"distance\"));\n      }\n\n      private long selectValue(SortedNumericDocValues multiDocValues) throws IOException {\n        int count = multiDocValues.docValueCount();\n        long value = multiDocValues.nextValue();\n        if (count == 1) {\n          return value;\n        }\n        // compute exact sort key: avoid any asin() computations\n        double distance = getDistanceKeyFromEncoded(value);\n        for (int i = 1; i < count; ++i) {\n          long nextValue = multiDocValues.nextValue();\n          double nextDistance = getDistanceKeyFromEncoded(nextValue);\n          if (nextDistance < distance) {\n            distance = nextDistance;\n            value = nextValue;\n          }\n        }\n        return value;\n      }\n\n      private NumericDocValues selectValues(SortedNumericDocValues multiDocValues) {\n        final NumericDocValues singleton = DocValues.unwrapSingleton(multiDocValues);\n        if (singleton != null) {\n          return singleton;\n        }\n        return  new NumericDocValues() {\n\n          long value;\n\n          @Override\n          public long longValue() throws IOException {\n            return value;\n          }\n\n          @Override\n          public boolean advanceExact(int target) throws IOException {\n            if (multiDocValues.advanceExact(target)) {\n              value = selectValue(multiDocValues);\n              return true;\n            } else {\n              return false;\n            }\n          }\n\n          @Override\n          public int docID() {\n            return multiDocValues.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return multiDocValues.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return multiDocValues.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return multiDocValues.cost();\n          }\n\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        PointValues pointValues = context.reader().getPointValues(field);\n        if (pointValues == null) {\n          // No data on this segment\n          return null;\n        }\n        final SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        final NumericDocValues docValues = selectValues(multiDocValues);\n\n        final Weight weight = this;\n        return new ScorerSupplier() {\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return new DistanceScorer(weight, context.reader().maxDoc(), leadCost, boost, pointValues, docValues);\n          }\n\n          @Override\n          public long cost() {\n            return docValues.cost();\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    return new Weight(this) {\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return false;\n      }\n\n      @Override\n      public void extractTerms(Set<Term> terms) {}\n\n      @Override\n      public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n        SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        if (multiDocValues.advanceExact(doc) == false) {\n          return Explanation.noMatch(\"Document \" + doc + \" doesn't have a value for field \" + field);\n        }\n        long encoded = selectValue(multiDocValues);\n        int latitudeBits = (int)(encoded >> 32);\n        int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n        double lat = GeoEncodingUtils.decodeLatitude(latitudeBits);\n        double lon = GeoEncodingUtils.decodeLongitude(longitudeBits);\n        double distance = SloppyMath.haversinMeters(originLat, originLon, lat, lon);\n        float score = (float) (boost * (pivotDistance / (pivotDistance + distance)));\n        return Explanation.match(score, \"Distance score, computed as weight * pivotDistance / (pivotDistance + abs(distance)) from:\",\n            Explanation.match(boost, \"weight\"),\n            Explanation.match(pivotDistance, \"pivotDistance\"),\n            Explanation.match(originLat, \"originLat\"),\n            Explanation.match(originLon, \"originLon\"),\n            Explanation.match(lat, \"current lat\"),\n            Explanation.match(lon, \"current lon\"),\n            Explanation.match(distance, \"distance\"));\n      }\n\n      private long selectValue(SortedNumericDocValues multiDocValues) throws IOException {\n        int count = multiDocValues.docValueCount();\n        long value = multiDocValues.nextValue();\n        if (count == 1) {\n          return value;\n        }\n        // compute exact sort key: avoid any asin() computations\n        double distance = getDistanceKeyFromEncoded(value);\n        for (int i = 1; i < count; ++i) {\n          long nextValue = multiDocValues.nextValue();\n          double nextDistance = getDistanceKeyFromEncoded(nextValue);\n          if (nextDistance < distance) {\n            distance = nextDistance;\n            value = nextValue;\n          }\n        }\n        return value;\n      }\n\n      private NumericDocValues selectValues(SortedNumericDocValues multiDocValues) {\n        final NumericDocValues singleton = DocValues.unwrapSingleton(multiDocValues);\n        if (singleton != null) {\n          return singleton;\n        }\n        return  new NumericDocValues() {\n\n          long value;\n\n          @Override\n          public long longValue() throws IOException {\n            return value;\n          }\n\n          @Override\n          public boolean advanceExact(int target) throws IOException {\n            if (multiDocValues.advanceExact(target)) {\n              value = selectValue(multiDocValues);\n              return true;\n            } else {\n              return false;\n            }\n          }\n\n          @Override\n          public int docID() {\n            return multiDocValues.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return multiDocValues.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return multiDocValues.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return multiDocValues.cost();\n          }\n\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        PointValues pointValues = context.reader().getPointValues(field);\n        if (pointValues == null) {\n          // No data on this segment\n          return null;\n        }\n        final SortedNumericDocValues multiDocValues = DocValues.getSortedNumeric(context.reader(), field);\n        final NumericDocValues docValues = selectValues(multiDocValues);\n\n        final Weight weight = this;\n        return new ScorerSupplier() {\n\n          @Override\n          public Scorer get(long leadCost) throws IOException {\n            return new DistanceScorer(weight, context.reader().maxDoc(), leadCost, boost, pointValues, docValues);\n          }\n\n          @Override\n          public long cost() {\n            return docValues.cost();\n          }\n        };\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"607e7af5082700f0a5d1b5e92452084cf94058d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["607e7af5082700f0a5d1b5e92452084cf94058d4"]},"commit2Childs":{"607e7af5082700f0a5d1b5e92452084cf94058d4":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["607e7af5082700f0a5d1b5e92452084cf94058d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}