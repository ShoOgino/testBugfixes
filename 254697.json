{"path":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","commits":[{"id":"0325de99180d346d61d36938843a5c8451fe26ae","date":1447368726,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n        \n        final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n        for (SolrDocument doc : mainRsp.getResults()) {\n          final Object groupHeadId = doc.getFieldValue(\"id\");\n          final Object collapseVal = doc.getFieldValue(collapseField);\n          \n          if (null == collapseVal) {\n            if (NULL_EXPAND.equals(nullPolicy)) {\n              // nothing to check for this doc, it's in it's own group\n              continue;\n            }\n            \n            assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                        \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                        NULL_IGNORE.equals(nullPolicy));\n          }\n\n          // work arround for SOLR-8082...\n          //\n          // what's important is that we already did the collapsing on the *real* collapseField\n          // to verify the groupHead returned is really the best our verification filter\n          // on docs with that value in a differnet ifeld containing the exact same values\n          final String checkField = collapseField.replace(\"float_dv\", \"float\");\n          \n          final String checkFQ = ((null == collapseVal)\n                                  ? (\"-\" + checkField + \":[* TO *]\")\n                                  : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n          \n          final SolrParams checkP = params(\"fq\", checkFQ,\n                                           \"rows\", \"1\",\n                                           \"sort\", collapseSort);\n          \n          final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n\n          assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                     ! checkRsp.getResults().isEmpty());\n          final SolrDocument firstMatch = checkRsp.getResults().get(0);\n          final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n          assertEquals(\"first match for filtered group '\"+ collapseVal +\n                       \"' not matching expected group head ... \" +\n                       \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                       groupHeadId, firstMatchId);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0201bd24de8c2e43ffd97115399c48fbcc83836","date":1447713745,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","sourceNew":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in it's own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // work arround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a differnet ifeld containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n        \n        final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n        for (SolrDocument doc : mainRsp.getResults()) {\n          final Object groupHeadId = doc.getFieldValue(\"id\");\n          final Object collapseVal = doc.getFieldValue(collapseField);\n          \n          if (null == collapseVal) {\n            if (NULL_EXPAND.equals(nullPolicy)) {\n              // nothing to check for this doc, it's in it's own group\n              continue;\n            }\n            \n            assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                        \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                        NULL_IGNORE.equals(nullPolicy));\n          }\n\n          // work arround for SOLR-8082...\n          //\n          // what's important is that we already did the collapsing on the *real* collapseField\n          // to verify the groupHead returned is really the best our verification filter\n          // on docs with that value in a differnet ifeld containing the exact same values\n          final String checkField = collapseField.replace(\"float_dv\", \"float\");\n          \n          final String checkFQ = ((null == collapseVal)\n                                  ? (\"-\" + checkField + \":[* TO *]\")\n                                  : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n          \n          final SolrParams checkP = params(\"fq\", checkFQ,\n                                           \"rows\", \"1\",\n                                           \"sort\", collapseSort);\n          \n          final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n\n          assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                     ! checkRsp.getResults().isEmpty());\n          final SolrDocument firstMatch = checkRsp.getResults().get(0);\n          final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n          assertEquals(\"first match for filtered group '\"+ collapseVal +\n                       \"' not matching expected group head ... \" +\n                       \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                       groupHeadId, firstMatchId);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz KrasiÅ„ski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","sourceNew":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in it's own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // workaround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a different field containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in it's own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // work arround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a differnet ifeld containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","sourceNew":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in it's own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // workaround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a different field containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in it's own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // work arround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a differnet ifeld containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","sourceNew":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in it's own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // workaround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a different field containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in it's own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // work arround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a differnet ifeld containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c342e04e879b5c549539944338f5ec0ff3000f3","date":1539630497,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","sourceNew":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in its own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // workaround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a different field containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in it's own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // workaround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a different field containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a813b523bf76aa0a68013d636b6eb53cedb142a4","date":1601387389,"type":3,"author":"Guna Sekhar Dora Kovvuru","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRandomCollapseQParserPlugin#testRandomCollpaseWithSort().mjava","sourceNew":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs =  nullPolicy.equals(CollapsingQParserPlugin.NullPolicy.IGNORE.getName())\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (nullPolicy.equals(CollapsingQParserPlugin.NullPolicy.EXPAND.getName())) {\n                // nothing to check for this doc, it's in its own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          nullPolicy.equals(CollapsingQParserPlugin.NullPolicy.IGNORE.getName()));\n            }\n            \n            // workaround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a different field containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandomCollpaseWithSort() throws Exception {\n    \n    final int numMainQueriesPerCollapseField = atLeast(5);\n    \n    for (String collapseField : ALL_COLLAPSE_FIELD_NAMES) {\n      for (int i = 0; i < numMainQueriesPerCollapseField; i++) {\n\n        final String topSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        final String collapseSort = CursorPagingTest.buildRandomSort(ALL_SORT_FIELD_NAMES);\n        \n        final String q = random().nextBoolean() ? \"*:*\" : CursorPagingTest.buildRandomQuery();\n        \n        final SolrParams mainP = params(\"q\", q, \"fl\", \"id,\"+collapseField);\n\n        final String csize = random().nextBoolean() ?\n          \"\" : \" size=\" + TestUtil.nextInt(random(),1,10000);\n\n        final String nullPolicy = randomNullPolicy();\n        final String nullPs = NULL_IGNORE.equals(nullPolicy)\n          // ignore is default, randomly be explicit about it\n          ? (random().nextBoolean() ? \"\" : \" nullPolicy=ignore\")\n          : (\" nullPolicy=\" + nullPolicy);\n        \n        final SolrParams collapseP\n          = params(\"sort\", topSort,\n                   \"rows\", \"200\",\n                   \"fq\", (\"{!collapse\" + csize + nullPs +\n                          \" field=\"+collapseField+\" sort='\"+collapseSort+\"'}\"));\n\n        try {\n          final QueryResponse mainRsp = SOLR.query(SolrParams.wrapDefaults(collapseP, mainP));\n\n          for (SolrDocument doc : mainRsp.getResults()) {\n            final Object groupHeadId = doc.getFieldValue(\"id\");\n            final Object collapseVal = doc.getFieldValue(collapseField);\n            \n            if (null == collapseVal) {\n              if (NULL_EXPAND.equals(nullPolicy)) {\n                // nothing to check for this doc, it's in its own group\n                continue;\n              }\n              \n              assertFalse(groupHeadId + \" has null collapseVal but nullPolicy==ignore; \" + \n                          \"mainP: \" + mainP + \", collapseP: \" + collapseP,\n                          NULL_IGNORE.equals(nullPolicy));\n            }\n            \n            // workaround for SOLR-8082...\n            //\n            // what's important is that we already did the collapsing on the *real* collapseField\n            // to verify the groupHead returned is really the best our verification filter\n            // on docs with that value in a different field containing the exact same values\n            final String checkField = collapseField.replace(\"float_dv\", \"float\");\n            \n            final String checkFQ = ((null == collapseVal)\n                                    ? (\"-\" + checkField + \":[* TO *]\")\n                                    : (\"{!field f=\"+checkField+\"}\" + collapseVal.toString()));\n            \n            final SolrParams checkP = params(\"fq\", checkFQ,\n                                             \"rows\", \"1\",\n                                             \"sort\", collapseSort);\n            \n            final QueryResponse checkRsp = SOLR.query(SolrParams.wrapDefaults(checkP, mainP));\n            \n            assertTrue(\"not even 1 match for sanity check query? expected: \" + doc,\n                       ! checkRsp.getResults().isEmpty());\n            final SolrDocument firstMatch = checkRsp.getResults().get(0);\n            final Object firstMatchId = firstMatch.getFieldValue(\"id\");\n            assertEquals(\"first match for filtered group '\"+ collapseVal +\n                         \"' not matching expected group head ... \" +\n                         \"mainP: \" + mainP + \", collapseP: \" + collapseP + \", checkP: \" + checkP,\n                         groupHeadId, firstMatchId);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(\"BUG using params: \" + collapseP + \" + \" + mainP, e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a813b523bf76aa0a68013d636b6eb53cedb142a4":["5c342e04e879b5c549539944338f5ec0ff3000f3"],"a0201bd24de8c2e43ffd97115399c48fbcc83836":["0325de99180d346d61d36938843a5c8451fe26ae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5c342e04e879b5c549539944338f5ec0ff3000f3":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"0325de99180d346d61d36938843a5c8451fe26ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0201bd24de8c2e43ffd97115399c48fbcc83836","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a813b523bf76aa0a68013d636b6eb53cedb142a4"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0201bd24de8c2e43ffd97115399c48fbcc83836","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["a0201bd24de8c2e43ffd97115399c48fbcc83836"]},"commit2Childs":{"a813b523bf76aa0a68013d636b6eb53cedb142a4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0201bd24de8c2e43ffd97115399c48fbcc83836":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0325de99180d346d61d36938843a5c8451fe26ae"],"5c342e04e879b5c549539944338f5ec0ff3000f3":["a813b523bf76aa0a68013d636b6eb53cedb142a4"],"0325de99180d346d61d36938843a5c8451fe26ae":["a0201bd24de8c2e43ffd97115399c48fbcc83836"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["5c342e04e879b5c549539944338f5ec0ff3000f3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}