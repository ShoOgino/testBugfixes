{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","commits":[{"id":"3f4ef2de7b0fd59ef22e20888773ad260c90bfb4","date":1400183621,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"183f03e816db8a4c3db0ede28b1679d50aee7f52","date":1405935700,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bcc4b6a839799ea8a62ca12ac44438c5607f786","date":1406654443,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            // nocommit?\n            //if (exactOnly) {\n            //fillTerm();\n            //}\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f","date":1406654493,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            // nocommit?\n            //if (exactOnly) {\n            //fillTerm();\n            //}\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d305023fa6a3a568a5d704ecfcf8c9b1dff83415","date":1578578961,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    do {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      // Loop over bytes in the suffix, comparing to the target\n      final int cmp = Arrays.compareUnsigned(\n          suffixBytes, startBytePos, startBytePos + suffix,\n          target.bytes, target.offset + prefix, target.offset + target.length);\n\n      if (cmp < 0) {\n        // Current entry is still before the target;\n        // keep scanning\n      } else if (cmp > 0) {\n        // Done!  Current entry is after target --\n        // return NOT_FOUND:\n        fillTerm();\n\n        //if (DEBUG) System.out.println(\"        not found\");\n        return SeekStatus.NOT_FOUND;\n      } else {\n        // Exact match!\n\n        // This cannot be a sub-block because we\n        // would have followed the index to this\n        // sub-block from the start:\n\n        assert ste.termExists;\n        fillTerm();\n        //if (DEBUG) System.out.println(\"        found!\");\n        return SeekStatus.FOUND;\n      }\n    } while (nextEnt < entCount);\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24dab91095bdf34d602ca5a18f81df6cb308709f","date":1578594129,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    do {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      // Loop over bytes in the suffix, comparing to the target\n      final int cmp = Arrays.compareUnsigned(\n          suffixBytes, startBytePos, startBytePos + suffix,\n          target.bytes, target.offset + prefix, target.offset + target.length);\n\n      if (cmp < 0) {\n        // Current entry is still before the target;\n        // keep scanning\n      } else if (cmp > 0) {\n        // Done!  Current entry is after target --\n        // return NOT_FOUND:\n        fillTerm();\n\n        //if (DEBUG) System.out.println(\"        not found\");\n        return SeekStatus.NOT_FOUND;\n      } else {\n        // Exact match!\n\n        // This cannot be a sub-block because we\n        // would have followed the index to this\n        // sub-block from the start:\n\n        assert ste.termExists;\n        fillTerm();\n        //if (DEBUG) System.out.println(\"        found!\");\n        return SeekStatus.FOUND;\n      }\n    } while (nextEnt < entCount);\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9407318969e8504257b4c5764c65755a043e5404","date":1579873617,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // TODO: binary search when all terms have the same length, which is common for ID fields,\n    // which are also the most sensitive to lookup performance?\n    // Loop over each entry (term or sub-block) in this block:\n    do {\n      nextEnt++;\n\n      suffix = suffixLengthsReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      // Loop over bytes in the suffix, comparing to the target\n      final int cmp = Arrays.compareUnsigned(\n          suffixBytes, startBytePos, startBytePos + suffix,\n          target.bytes, target.offset + prefix, target.offset + target.length);\n\n      if (cmp < 0) {\n        // Current entry is still before the target;\n        // keep scanning\n      } else if (cmp > 0) {\n        // Done!  Current entry is after target --\n        // return NOT_FOUND:\n        fillTerm();\n\n        //if (DEBUG) System.out.println(\"        not found\");\n        return SeekStatus.NOT_FOUND;\n      } else {\n        // Exact match!\n\n        // This cannot be a sub-block because we\n        // would have followed the index to this\n        // sub-block from the start:\n\n        assert ste.termExists;\n        fillTerm();\n        //if (DEBUG) System.out.println(\"        found!\");\n        return SeekStatus.FOUND;\n      }\n    } while (nextEnt < entCount);\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    ste.termExists = true;\n    subCode = 0;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    do {\n      nextEnt++;\n\n      suffix = suffixesReader.readVInt();\n\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n\n      // Loop over bytes in the suffix, comparing to the target\n      final int cmp = Arrays.compareUnsigned(\n          suffixBytes, startBytePos, startBytePos + suffix,\n          target.bytes, target.offset + prefix, target.offset + target.length);\n\n      if (cmp < 0) {\n        // Current entry is still before the target;\n        // keep scanning\n      } else if (cmp > 0) {\n        // Done!  Current entry is after target --\n        // return NOT_FOUND:\n        fillTerm();\n\n        //if (DEBUG) System.out.println(\"        not found\");\n        return SeekStatus.NOT_FOUND;\n      } else {\n        // Exact match!\n\n        // This cannot be a sub-block because we\n        // would have followed the index to this\n        // sub-block from the start:\n\n        assert ste.termExists;\n        fillTerm();\n        //if (DEBUG) System.out.println(\"        found!\");\n        return SeekStatus.FOUND;\n      }\n    } while (nextEnt < entCount);\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6bcc4b6a839799ea8a62ca12ac44438c5607f786":["183f03e816db8a4c3db0ede28b1679d50aee7f52"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f4ef2de7b0fd59ef22e20888773ad260c90bfb4"],"f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f":["6bcc4b6a839799ea8a62ca12ac44438c5607f786"],"3f4ef2de7b0fd59ef22e20888773ad260c90bfb4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"183f03e816db8a4c3db0ede28b1679d50aee7f52":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f","3e8715d826e588419327562287d5d6a8040d63d6"],"9407318969e8504257b4c5764c65755a043e5404":["d305023fa6a3a568a5d704ecfcf8c9b1dff83415"],"24dab91095bdf34d602ca5a18f81df6cb308709f":["3e8715d826e588419327562287d5d6a8040d63d6","d305023fa6a3a568a5d704ecfcf8c9b1dff83415"],"3e8715d826e588419327562287d5d6a8040d63d6":["f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f"],"d305023fa6a3a568a5d704ecfcf8c9b1dff83415":["3e8715d826e588419327562287d5d6a8040d63d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9407318969e8504257b4c5764c65755a043e5404"]},"commit2Childs":{"6bcc4b6a839799ea8a62ca12ac44438c5607f786":["f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["183f03e816db8a4c3db0ede28b1679d50aee7f52"],"3f4ef2de7b0fd59ef22e20888773ad260c90bfb4":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"183f03e816db8a4c3db0ede28b1679d50aee7f52":["6bcc4b6a839799ea8a62ca12ac44438c5607f786"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d637064d608752565d4f9f41b2497dfdfdde50e","3f4ef2de7b0fd59ef22e20888773ad260c90bfb4"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"9407318969e8504257b4c5764c65755a043e5404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"24dab91095bdf34d602ca5a18f81df6cb308709f":[],"3e8715d826e588419327562287d5d6a8040d63d6":["d2638f781be724518ff6c2263d14a48cf6e68017","24dab91095bdf34d602ca5a18f81df6cb308709f","d305023fa6a3a568a5d704ecfcf8c9b1dff83415"],"d305023fa6a3a568a5d704ecfcf8c9b1dff83415":["9407318969e8504257b4c5764c65755a043e5404","24dab91095bdf34d602ca5a18f81df6cb308709f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","24dab91095bdf34d602ca5a18f81df6cb308709f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}