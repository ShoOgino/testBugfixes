{"path":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","commits":[{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateCloudState(true);\n                CloudState cloudState = reader.getCloudState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  cloudState = processMessage(cloudState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(cloudState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateCloudState(true);\n              CloudState cloudState = reader.getCloudState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                cloudState = processMessage(cloudState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(cloudState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d","date":1344892928,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(amILeader() && !Overseer.this.isClosed) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (amILeader() && !isClosed) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"314edcfba84a78d1a59020136cd92031e76a6bed","date":1346327282,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                stateUpdateQueue.remove();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":["a5093a9e893633cc091cf2f729d7863671c2b715"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                stateUpdateQueue.remove();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                byte[] processed = stateUpdateQueue.remove();\n                workQueue.offer(processed);\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                stateUpdateQueue.remove();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .get(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.get(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                stateUpdateQueue.remove();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7b9732f22b8f9f34018e8f7710c12fca43b7ac0","date":1355709729,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll();\n                  \n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                stateUpdateQueue.remove();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll();\n                  \n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  workQueue.remove();\n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                stateUpdateQueue.remove();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f0ebe4956ab158d9fbe10c7101f3992656b48a22","date":1357934684,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if (!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null && amILeader()) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                clusterState = processMessage(clusterState, message, operation);\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(clusterState), true);\n                \n                workQueue.poll();\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll();\n                  \n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":["7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d","d0492616b11aace806d95ec9df44f57a60160bf7","3f767f8c99eaedb984df754fe61f21c5de260f94","fa64435b5902ce266c23755a4a00691a3285dab8","7fc3dbbe93b8019e6a9343b07d0a2fe503282f32","a5093a9e893633cc091cf2f729d7863671c2b715","b7b9732f22b8f9f34018e8f7710c12fca43b7ac0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      if (!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null && amILeader()) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                clusterState = processMessage(clusterState, message, operation);\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(clusterState), true);\n                \n                workQueue.poll();\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if(!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n          synchronized (reader.getUpdateLock()) { //XXX this only protects against edits inside single node\n            try {\n              byte[] head = workQueue.peek();\n              \n              if (head != null) {\n                reader.updateClusterState(true);\n                ClusterState clusterState = reader.getClusterState();\n                log.info(\"Replaying operations from work queue.\");\n                \n                while (head != null && amILeader()) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message\n                      .getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll();\n                  \n                  head = workQueue.peek();\n                }\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                  || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                log.warn(\"Solr cannot talk to ZK\");\n                return;\n              }\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            }\n          }\n        }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"Overseer cannot talk to ZK\");\n              return;\n            }\n            SolrException.log(log, \"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"270612d8e1a51cded91704d7af12f8979de0f584","date":1381502089,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);                  \n          continue; // not a no, not a yes, try ask again\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      if (!this.isClosed && amILeader()) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null && amILeader()) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                clusterState = processMessage(clusterState, message, operation);\n                zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                    ZkStateReader.toJSON(clusterState), true);\n                \n                workQueue.poll();\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed && amILeader()) {\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e6c873b95174ff04c895232927baa76a95925eb","date":1385054916,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n\n              clusterState = processMessage(clusterState, message, operation);\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.currentTimeMillis() - lastUpdatedTime > STATE_UPDATE_DELAY) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.currentTimeMillis();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);                  \n          continue; // not a no, not a yes, try ask again\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n        \n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n\n              clusterState = processMessage(clusterState, message, operation);\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.currentTimeMillis() - lastUpdatedTime > STATE_UPDATE_DELAY) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.currentTimeMillis();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);                  \n          continue; // not a no, not a yes, try ask again\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            byte[] head = stateUpdateQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              \n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head);\n                final String operation = message.getStr(QUEUE_OPERATION);\n                \n                clusterState = processMessage(clusterState, message, operation);\n                workQueue.offer(head);\n                \n                stateUpdateQueue.poll();\n                head = stateUpdateQueue.peek();\n              }\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n            }\n            // clean work queue\n            while (workQueue.poll() != null);\n            \n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n        try {\n          Thread.sleep(STATE_UPDATE_DELAY);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dedd8b6e67b7ac7a77554562fddcf90e0031a95c","date":1391930936,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n\n              clusterState = processMessage(clusterState, message, operation);\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.currentTimeMillis() - lastUpdatedTime > STATE_UPDATE_DELAY) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.currentTimeMillis();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n        \n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n\n              clusterState = processMessage(clusterState, message, operation);\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.currentTimeMillis() - lastUpdatedTime > STATE_UPDATE_DELAY) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.currentTimeMillis();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n\n              clusterState = processMessage(clusterState, message, operation);\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n\n              clusterState = processMessage(clusterState, message, operation);\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.currentTimeMillis() - lastUpdatedTime > STATE_UPDATE_DELAY) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.currentTimeMillis();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29f5eaf296600e1665151e7929d42a3cbe22e481","date":1393983215,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Could not process Overseer message\", e);\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Could not process Overseer message\", e);\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n\n              clusterState = processMessage(clusterState, message, operation);\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f30ced5df221e945e2ff4ea4abe6d29b36de1613","date":1394072983,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Could not process Overseer message\", e);\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Could not process Overseer message\", e);\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  clusterState = processMessage(clusterState, message, operation);\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n\n              clusterState = processMessage(clusterState, message, operation);\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f45f67a018421da088ea39274f23ad5d339b97d","date":1395559348,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              final TimerContext timerContext = stats.time(operation);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n                stats.success(operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                stats.error(operation);\n              } finally {\n                timerContext.stop();\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b15576cafd8b5d06857055c28f26912321937e3","date":1396452121,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              lastUpdatedTime = System.nanoTime();\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              final TimerContext timerContext = stats.time(operation);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n                stats.success(operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                stats.error(operation);\n              } finally {\n                timerContext.stop();\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8295a0e649f894ba19be89ef3b8887648978525f","date":1396508870,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              lastUpdatedTime = System.nanoTime();\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              lastUpdatedTime = System.nanoTime();\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              lastUpdatedTime = System.nanoTime();\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      while (!this.isClosed) {\n        isLeader = amILeader();\n        if (LeaderStatus.NO == isLeader) {\n          break;\n        }\n        else if (LeaderStatus.YES != isLeader) {\n          log.debug(\"am_i_leader unclear {}\", isLeader);\n          continue; // not a no, not a yes, try ask again\n        }\n        DistributedQueue.QueueEvent head = null;\n        try {\n          head = stateUpdateQueue.peek(true);\n        } catch (KeeperException e) {\n          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n            log.warn(\n                \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          }\n          log.error(\"Exception in Overseer main queue loop\", e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n          \n        } catch (Exception e) {\n          log.error(\"Exception in Overseer main queue loop\", e);\n        }\n        synchronized (reader.getUpdateLock()) {\n          try {\n            reader.updateClusterState(true);\n            ClusterState clusterState = reader.getClusterState();\n\n            while (head != null) {\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              final String operation = message.getStr(QUEUE_OPERATION);\n              final TimerContext timerContext = stats.time(operation);\n              try {\n                clusterState = processMessage(clusterState, message, operation);\n                stats.success(operation);\n              } catch (Exception e) {\n                // generally there is nothing we can do - in most cases, we have\n                // an issue that will fail again on retry or we cannot communicate with\n                // ZooKeeper in which case another Overseer should take over\n                // TODO: if ordering for the message is not important, we could\n                // track retries and put it back on the end of the queue\n                log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                stats.error(operation);\n              } finally {\n                timerContext.stop();\n              }\n              workQueue.offer(head.getBytes());\n\n              stateUpdateQueue.poll();\n\n              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n              \n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100); \n            }\n            lastUpdatedTime = System.nanoTime();\n            zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                ZkStateReader.toJSON(clusterState), true);\n            // clean work queue\n            while (workQueue.poll() != null) ;\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                      ZkStateReader.toJSON(clusterState), true);\n\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              lastUpdatedTime = System.nanoTime();\n              zkClient.setData(ZkStateReader.CLUSTER_STATE,\n                  ZkStateReader.toJSON(clusterState), true);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fc87768c8910548f5a0b938e01a4d401b15eaca","date":1414443401,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      int lastStateFormat = -1; // sentinel\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n\n                // we batch updates for the main cluster state together (stateFormat=1)\n                // but if we encounter a message for a collection with a stateFormat different than the last\n                // then we stop batching at that point\n                String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n                if (collection == null) collection = message.getStr(\"name\");\n                if (collection != null) {\n                  DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n                  if (lastStateFormat != -1 && docCollection != null && docCollection.getStateFormat() != lastStateFormat)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                    break;\n                  }\n                  if (docCollection != null)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                  }\n                }\n\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfb6f3c8c119796b6a4ca83753599e3064b65305","date":1416760830,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      int lastStateFormat = -1; // sentinel\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n\n                // we batch updates for the main cluster state together (stateFormat=1)\n                // but if we encounter a message for a collection with a stateFormat different than the last\n                // then we stop batching at that point\n                String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n                if (collection == null) collection = message.getStr(\"name\");\n                if (collection != null) {\n                  DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n                  if (lastStateFormat != -1 && docCollection != null && docCollection.getStateFormat() != lastStateFormat)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                    break;\n                  }\n                  if (docCollection != null)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                  }\n                }\n\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      int lastStateFormat = -1; // sentinel\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n\n                // we batch updates for the main cluster state together (stateFormat=1)\n                // but if we encounter a message for a collection with a stateFormat different than the last\n                // then we stop batching at that point\n                String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n                if (collection == null) collection = message.getStr(\"name\");\n                if (collection != null) {\n                  DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n                  if (lastStateFormat != -1 && docCollection != null && docCollection.getStateFormat() != lastStateFormat)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                    break;\n                  }\n                  if (docCollection != null)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                  }\n                }\n\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ffcbf6f5d2f38f98426978f6efda243615600247","date":1417052599,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      int lastStateFormat = -1; // sentinel\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n\n                // we batch updates for the main cluster state together (stateFormat=1)\n                // but if we encounter a message for a collection with a stateFormat different than the last\n                // then we stop batching at that point\n                String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n                if (collection == null) collection = message.getStr(\"name\");\n                if (collection != null) {\n                  DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n                  if (lastStateFormat != -1 && docCollection != null && docCollection.getStateFormat() != lastStateFormat)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                    break;\n                  }\n                  if (docCollection != null)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                  }\n                }\n\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation, stateUpdateQueue.getStats().getQueueLength());\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      int lastStateFormat = -1; // sentinel\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n\n                // we batch updates for the main cluster state together (stateFormat=1)\n                // but if we encounter a message for a collection with a stateFormat different than the last\n                // then we stop batching at that point\n                String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n                if (collection == null) collection = message.getStr(\"name\");\n                if (collection != null) {\n                  DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n                  if (lastStateFormat != -1 && docCollection != null && docCollection.getStateFormat() != lastStateFormat)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                    break;\n                  }\n                  if (docCollection != null)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                  }\n                }\n\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n\n              ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n\n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    ZkWriteCommand zkWriteCommand = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                    clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  if (zkStateWriter.hasPendingUpdates())  {\n                    clusterState = zkStateWriter.writePendingUpdates();\n                  }\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      int lastStateFormat = -1; // sentinel\n      String lastCollectionName = null;\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              if (refreshClusterState) {\n                reader.updateClusterState(true);\n                clusterState = reader.getClusterState();\n                refreshClusterState = false;\n\n                // if there were any errors while processing\n                // the state queue, items would have been left in the\n                // work queue so let's process those first\n                byte[] data = workQueue.peek();\n                while (data != null)  {\n                  final ZkNodeProps message = ZkNodeProps.load(data);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    ZkWriteCommand zkWriteCommand = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                    clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  if (zkStateWriter.hasPendingUpdates())  {\n                    clusterState = zkStateWriter.writePendingUpdates();\n                  }\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                  data = workQueue.peek();\n                }\n              }\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n\n                // we batch updates for the main cluster state together (stateFormat=1)\n                // but if we encounter a message for a collection with a stateFormat different than the last\n                // then we stop batching at that point\n                String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n                if (collection == null) collection = message.getStr(\"name\");\n                if (collection != null) {\n                  DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n                  if (lastStateFormat != -1 && docCollection != null && docCollection.getStateFormat() != lastStateFormat)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                    // we don't want to mix batching of different state formats together because that makes\n                    // it harder to guarantee atomicity of ZK writes\n                    break;\n                  }\n                  if (docCollection != null)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                  }\n                }\n\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  ZkWriteCommand zkWriteCommand = processMessage(clusterState, message, operation, stateUpdateQueue.getStats().getQueueLength());\n                  clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if (!updateNodes.isEmpty() && !collection.equals(lastCollectionName)) {\n                  lastCollectionName = collection;\n                  break;\n                }\n                lastCollectionName = collection;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              if (zkStateWriter.hasPendingUpdates())  {\n                clusterState = zkStateWriter.writePendingUpdates();\n                lastUpdatedTime = zkStateWriter.getLastUpdatedTime();\n              }\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n              \n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    clusterState = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  updateZkStates(clusterState);\n                  \n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      int lastStateFormat = -1; // sentinel\n      try {\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n\n                // we batch updates for the main cluster state together (stateFormat=1)\n                // but if we encounter a message for a collection with a stateFormat different than the last\n                // then we stop batching at that point\n                String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n                if (collection == null) collection = message.getStr(\"name\");\n                if (collection != null) {\n                  DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n                  if (lastStateFormat != -1 && docCollection != null && docCollection.getStateFormat() != lastStateFormat)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                    break;\n                  }\n                  if (docCollection != null)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                  }\n                }\n\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  clusterState = processMessage(clusterState, message, operation, stateUpdateQueue.getStats().getQueueLength());\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if(!updateNodes.isEmpty()) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              updateZkStates(clusterState);\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":["1e5f642aea415d0cbee35d1b3208b193a62d7f15"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"584c1ee8712b5af28075d98028ccab111d6eeda2","date":1417444624,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n\n              ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n\n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  log.info(\"processMessage: queueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter);\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                head = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              clusterState = zkStateWriter.writePendingUpdates();\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              if (refreshClusterState) {\n                reader.updateClusterState(true);\n                clusterState = reader.getClusterState();\n                refreshClusterState = false;\n\n                // if there were any errors while processing\n                // the state queue, items would have been left in the\n                // work queue so let's process those first\n                byte[] data = workQueue.peek();\n                boolean hadWorkItems = data != null;\n                while (data != null)  {\n                  final ZkNodeProps message = ZkNodeProps.load(data);\n                  log.info(\"processMessage: queueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter);\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                  data = workQueue.peek();\n                }\n                // force flush at the end of the loop\n                if (hadWorkItems) {\n                  clusterState = zkStateWriter.writePendingUpdates();\n                }\n              }\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n                clusterState = processQueueItem(message, clusterState, zkStateWriter);\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              // we should force write all pending updates because the next iteration might sleep until there\n              // are more items in the main queue\n              clusterState = zkStateWriter.writePendingUpdates();\n              // clean work queue\n              while (workQueue.poll() != null);\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n\n              ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n\n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    ZkWriteCommand zkWriteCommand = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                    clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  if (zkStateWriter.hasPendingUpdates())  {\n                    clusterState = zkStateWriter.writePendingUpdates();\n                  }\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                \n                head = workQueue.peek();\n              }\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      int lastStateFormat = -1; // sentinel\n      String lastCollectionName = null;\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              if (refreshClusterState) {\n                reader.updateClusterState(true);\n                clusterState = reader.getClusterState();\n                refreshClusterState = false;\n\n                // if there were any errors while processing\n                // the state queue, items would have been left in the\n                // work queue so let's process those first\n                byte[] data = workQueue.peek();\n                while (data != null)  {\n                  final ZkNodeProps message = ZkNodeProps.load(data);\n                  final String operation = message.getStr(QUEUE_OPERATION);\n                  final TimerContext timerContext = stats.time(operation);\n                  try {\n                    ZkWriteCommand zkWriteCommand = processMessage(clusterState, message, operation, workQueue.getStats().getQueueLength());\n                    clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand);\n                    stats.success(operation);\n                  } catch (Exception e) {\n                    // generally there is nothing we can do - in most cases, we have\n                    // an issue that will fail again on retry or we cannot communicate with     a\n                    // ZooKeeper in which case another Overseer should take over\n                    // TODO: if ordering for the message is not important, we could\n                    // track retries and put it back on the end of the queue\n                    log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                    stats.error(operation);\n                  } finally {\n                    timerContext.stop();\n                  }\n                  if (zkStateWriter.hasPendingUpdates())  {\n                    clusterState = zkStateWriter.writePendingUpdates();\n                  }\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                  data = workQueue.peek();\n                }\n              }\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                final String operation = message.getStr(QUEUE_OPERATION);\n\n                // we batch updates for the main cluster state together (stateFormat=1)\n                // but if we encounter a message for a collection with a stateFormat different than the last\n                // then we stop batching at that point\n                String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n                if (collection == null) collection = message.getStr(\"name\");\n                if (collection != null) {\n                  DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n                  if (lastStateFormat != -1 && docCollection != null && docCollection.getStateFormat() != lastStateFormat)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                    // we don't want to mix batching of different state formats together because that makes\n                    // it harder to guarantee atomicity of ZK writes\n                    break;\n                  }\n                  if (docCollection != null)  {\n                    lastStateFormat = docCollection.getStateFormat();\n                  }\n                }\n\n                final TimerContext timerContext = stats.time(operation);\n                try {\n                  ZkWriteCommand zkWriteCommand = processMessage(clusterState, message, operation, stateUpdateQueue.getStats().getQueueLength());\n                  clusterState = zkStateWriter.enqueueUpdate(clusterState, zkWriteCommand);\n                  stats.success(operation);\n                } catch (Exception e) {\n                  // generally there is nothing we can do - in most cases, we have\n                  // an issue that will fail again on retry or we cannot communicate with\n                  // ZooKeeper in which case another Overseer should take over\n                  // TODO: if ordering for the message is not important, we could\n                  // track retries and put it back on the end of the queue\n                  log.error(\"Overseer could not process the current clusterstate state update message, skipping the message.\", e);\n                  stats.error(operation);\n                } finally {\n                  timerContext.stop();\n                }\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;\n                if (!updateNodes.isEmpty() && !collection.equals(lastCollectionName)) {\n                  lastCollectionName = collection;\n                  break;\n                }\n                lastCollectionName = collection;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              if (zkStateWriter.hasPendingUpdates())  {\n                clusterState = zkStateWriter.writePendingUpdates();\n                lastUpdatedTime = zkStateWriter.getLastUpdatedTime();\n              }\n              // clean work queue\n              while (workQueue.poll() != null) ;\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9088bc86d5a0e967da50b566ea1dd0c5458ba6f5","date":1418915621,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n\n              ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n\n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  log.info(\"processMessage: queueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                head = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              clusterState = zkStateWriter.writePendingUpdates();\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              if (refreshClusterState) {\n                reader.updateClusterState(true);\n                clusterState = reader.getClusterState();\n                refreshClusterState = false;\n\n                // if there were any errors while processing\n                // the state queue, items would have been left in the\n                // work queue so let's process those first\n                byte[] data = workQueue.peek();\n                boolean hadWorkItems = data != null;\n                while (data != null)  {\n                  final ZkNodeProps message = ZkNodeProps.load(data);\n                  log.info(\"processMessage: queueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                  // force flush to ZK after each message because there is no fallback if workQueue items\n                  // are removed from workQueue but fail to be written to ZK\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                  data = workQueue.peek();\n                }\n                // force flush at the end of the loop\n                if (hadWorkItems) {\n                  clusterState = zkStateWriter.writePendingUpdates();\n                }\n              }\n\n              while (head != null) {\n                final byte[] data = head.getBytes();\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n                // we can batch here because workQueue is our fallback in case a ZK write failed\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                  @Override\n                  public void onEnqueue() throws Exception {\n                    workQueue.offer(data);\n                  }\n\n                  @Override\n                  public void onWrite() throws Exception {\n                    // remove everything from workQueue\n                    while (workQueue.poll() != null);\n                  }\n                });\n\n                // it is safer to keep this poll here because an invalid message might never be queued\n                // and therefore we can't rely on the ZkWriteCallback to remove the item\n                stateUpdateQueue.poll();\n\n                if (isClosed) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              // we should force write all pending updates because the next iteration might sleep until there\n              // are more items in the main queue\n              clusterState = zkStateWriter.writePendingUpdates();\n              // clean work queue\n              while (workQueue.poll() != null);\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n\n              ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n\n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  log.info(\"processMessage: queueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter);\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                head = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              clusterState = zkStateWriter.writePendingUpdates();\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              if (refreshClusterState) {\n                reader.updateClusterState(true);\n                clusterState = reader.getClusterState();\n                refreshClusterState = false;\n\n                // if there were any errors while processing\n                // the state queue, items would have been left in the\n                // work queue so let's process those first\n                byte[] data = workQueue.peek();\n                boolean hadWorkItems = data != null;\n                while (data != null)  {\n                  final ZkNodeProps message = ZkNodeProps.load(data);\n                  log.info(\"processMessage: queueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter);\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                  data = workQueue.peek();\n                }\n                // force flush at the end of the loop\n                if (hadWorkItems) {\n                  clusterState = zkStateWriter.writePendingUpdates();\n                }\n              }\n\n              while (head != null) {\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n                clusterState = processQueueItem(message, clusterState, zkStateWriter);\n                workQueue.offer(head.getBytes());\n\n                stateUpdateQueue.poll();\n\n                if (isClosed) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              // we should force write all pending updates because the next iteration might sleep until there\n              // are more items in the main queue\n              clusterState = zkStateWriter.writePendingUpdates();\n              // clean work queue\n              while (workQueue.poll() != null);\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2686a7d33e6cba9dd5d997d5366c199de8f91a00","date":1424193043,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState(true);\n              clusterState = reader.getClusterState();\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              final byte[] data = head.getBytes();\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n      if (!this.isClosed && LeaderStatus.YES == isLeader) {\n        // see if there's something left from the previous Overseer and re\n        // process all events that were not persisted into cloud state\n        synchronized (reader.getUpdateLock()) { // XXX this only protects\n                                                // against edits inside single\n                                                // node\n          try {\n            byte[] head = workQueue.peek();\n            \n            if (head != null) {\n              reader.updateClusterState(true);\n              ClusterState clusterState = reader.getClusterState();\n              log.info(\"Replaying operations from work queue.\");\n\n              ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n\n              while (head != null) {\n                isLeader = amILeader();\n                if (LeaderStatus.NO == isLeader) {\n                  break;\n                }\n                else if (LeaderStatus.YES == isLeader) {\n                  final ZkNodeProps message = ZkNodeProps.load(head);\n                  log.info(\"processMessage: queueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                }\n                else {\n                  log.info(\"am_i_leader unclear {}\", isLeader);                  \n                  // re-peek below in case our 'head' value is out-of-date by now\n                }\n                head = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              clusterState = zkStateWriter.writePendingUpdates();\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer work queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n            \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer work queue loop\", e);\n          }\n        }\n        \n      }\n      \n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          synchronized (reader.getUpdateLock()) {\n            try {\n              if (refreshClusterState) {\n                reader.updateClusterState(true);\n                clusterState = reader.getClusterState();\n                refreshClusterState = false;\n\n                // if there were any errors while processing\n                // the state queue, items would have been left in the\n                // work queue so let's process those first\n                byte[] data = workQueue.peek();\n                boolean hadWorkItems = data != null;\n                while (data != null)  {\n                  final ZkNodeProps message = ZkNodeProps.load(data);\n                  log.info(\"processMessage: queueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                  // force flush to ZK after each message because there is no fallback if workQueue items\n                  // are removed from workQueue but fail to be written to ZK\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                  workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                  data = workQueue.peek();\n                }\n                // force flush at the end of the loop\n                if (hadWorkItems) {\n                  clusterState = zkStateWriter.writePendingUpdates();\n                }\n              }\n\n              while (head != null) {\n                final byte[] data = head.getBytes();\n                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n                log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n                // we can batch here because workQueue is our fallback in case a ZK write failed\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                  @Override\n                  public void onEnqueue() throws Exception {\n                    workQueue.offer(data);\n                  }\n\n                  @Override\n                  public void onWrite() throws Exception {\n                    // remove everything from workQueue\n                    while (workQueue.poll() != null);\n                  }\n                });\n\n                // it is safer to keep this poll here because an invalid message might never be queued\n                // and therefore we can't rely on the ZkWriteCallback to remove the item\n                stateUpdateQueue.poll();\n\n                if (isClosed) break;\n                // if an event comes in the next 100ms batch it together\n                head = stateUpdateQueue.peek(100);\n              }\n              // we should force write all pending updates because the next iteration might sleep until there\n              // are more items in the main queue\n              clusterState = zkStateWriter.writePendingUpdates();\n              // clean work queue\n              while (workQueue.poll() != null);\n\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer main queue loop\", e);\n              refreshClusterState = true; // it might have been a bad version error\n            }\n          }\n\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":["224821deeb481fa237ac4f146f3b94e9f274aabc","1e5f642aea415d0cbee35d1b3208b193a62d7f15"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              final byte[] data = head.getBytes();\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState(true);\n              clusterState = reader.getClusterState();\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              final byte[] data = head.getBytes();\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e5f642aea415d0cbee35d1b3208b193a62d7f15","date":1439490669,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              final byte[] data = head.getBytes();\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              final byte[] data = head.getBytes();\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":["2686a7d33e6cba9dd5d997d5366c199de8f91a00","24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a282020d6c9a4ea32a359539e283e4771a2fda8","date":1440047542,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          DistributedQueue.QueueEvent head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              final byte[] data = head.getBytes();\n              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6186d706db01cb7da7962595b44a09266e63d96b","date":1459880131,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc69baf14413994ccde897681e5ce1d393cf7156","date":1468245555,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5d615d62cd8aff3690943d765e46942551f98b6","date":1474881754,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.info(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\n                  \"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.info(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state\", bve);\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        new Thread(\"OverseerExitThread\"){\n          //do this in a separate thread because any wait is interrupted in this main thread\n          @Override\n          public void run() {\n            checkIfIamStillLeader();\n          }\n        }.start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"224821deeb481fa237ac4f146f3b94e9f274aabc","date":1499299312,"type":3,"author":"Scott Blum","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                    workQueue.offer(data);\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":["2686a7d33e6cba9dd5d997d5366c199de8f91a00"],"bugIntro":["cbe78d3a2f3502a69a49837cc3eeee2cbb4f7033"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e73d8d559120669b47658108d818b637df5456ea","date":1499401413,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                    workQueue.offer(data);\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            while (head != null) {\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  workQueue.offer(data);\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // it is safer to keep this poll here because an invalid message might never be queued\n              // and therefore we can't rely on the ZkWriteCallback to remove the item\n              stateUpdateQueue.poll();\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbe78d3a2f3502a69a49837cc3eeee2cbb4f7033","date":1499457369,"type":3,"author":"Scott Blum","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                    workQueue.offer(data);\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":["224821deeb481fa237ac4f146f3b94e9f274aabc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9a989a32a073c55e3aef6f807a3474184bbcf49","date":1499930209,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                    workQueue.offer(data);\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb569fd721c41eafc2a2d788499a7df490c7f1a5","date":1499930871,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                    workQueue.offer(data);\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6","date":1501264759,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.updateClusterState();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0acfa728bc42d7e2f275b294280ebfe610828af7","date":1507795704,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    workQueue.poll();\n                  }\n                  throw e;\n                }\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException e) {\n              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n                log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n                return;\n              }\n              log.error(\"Exception in Overseer work queue loop\", e);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer work queue loop\", e);\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.BadVersionException bve) {\n            log.warn(\"Bad version writing to ZK using compare-and-set, will force refresh cluster state: {}\", bve.getMessage());\n            refreshClusterState = true;\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n              return;\n            }\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // force refresh state in case of all errors\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"781bec8380d3b76fa7ca27eceb50019c8c160e02","date":1507948397,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, Long.MAX_VALUE, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = workQueue.peek();\n              boolean hadWorkItems = data != null;\n              while (data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: workQueueSize: {}, message = {}\", workQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    workQueue.poll();\n                  }\n                  throw e;\n                }\n                workQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = workQueue.peek();\n              }\n              // force flush at the end of the loop\n              if (hadWorkItems) {\n                clusterState = zkStateWriter.writePendingUpdates();\n              }\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          byte[] head = null;\n          try {\n            head = stateUpdateQueue.peek(true);\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            boolean[] itemWasMoved = new boolean[1];\n            while (head != null) {\n              itemWasMoved[0] = false;\n              byte[] data = head;\n              final ZkNodeProps message = ZkNodeProps.load(data);\n              log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n              // we can batch here because workQueue is our fallback in case a ZK write failed\n              clusterState = processQueueItem(message, clusterState, zkStateWriter, true, new ZkStateWriter.ZkWriteCallback() {\n                @Override\n                public void onEnqueue() throws Exception {\n                  if (!itemWasMoved[0]) {\n                    workQueue.offer(data);\n                    stateUpdateQueue.poll();\n                    itemWasMoved[0] = true;\n                  }\n                }\n\n                @Override\n                public void onWrite() throws Exception {\n                  // remove everything from workQueue\n                  while (workQueue.poll() != null);\n                }\n              });\n\n              // If the ZkWriteCallback never fired, just dump the item, it might be an invalid message.\n              if (!itemWasMoved[0]) {\n                stateUpdateQueue.poll();\n              }\n\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              head = stateUpdateQueue.peek(100);\n            }\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            while (workQueue.poll() != null);\n\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, Long.MAX_VALUE, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, Long.MAX_VALUE, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a63e9ddc18e0ec8efab1ee0d885b9378ff4dfb50","date":1515204314,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, Long.MAX_VALUE, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, Long.MAX_VALUE, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27e471964e04aba0265130e510f878b1a91d4c7a","date":1531854971,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.debug(\"Starting to work on the main queue\");\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"042da0877b8e28fd372a8ed80d11c4506a466ad7","date":1534516670,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n      MDCLoggingContext.setNode(zkController.getNodeName() );\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n      MDCLoggingContext.setNode(zkController.getNodeName() );\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (AlreadyClosedException e) {\n              return;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n  \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      MDCLoggingContext.setNode(zkController.getNodeName() );\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n      MDCLoggingContext.setNode(zkController.getNodeName() );\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      if (log.isInfoEnabled()) {\n        log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      }\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                if (log.isDebugEnabled()) {\n                  log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                }\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (AlreadyClosedException e) {\n              return;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                if (log.isDebugEnabled()) {\n                  log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n                }\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n  \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        if (log.isInfoEnabled()) {\n          log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        }\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      MDCLoggingContext.setNode(zkController.getNodeName() );\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (AlreadyClosedException e) {\n              return;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n  \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#run().mjava","sourceNew":"    @Override\n    public void run() {\n      MDCLoggingContext.setNode(zkController.getNodeName() );\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      if (log.isInfoEnabled()) {\n        log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      }\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                if (log.isDebugEnabled()) {\n                  log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                }\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (AlreadyClosedException e) {\n              return;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                if (log.isDebugEnabled()) {\n                  log.debug(\"processMessage: queueSize: {}, message = {}\", stateUpdateQueue.getZkStats().getQueueLength(), message);\n                }\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n  \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        if (log.isInfoEnabled()) {\n          log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        }\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      MDCLoggingContext.setNode(zkController.getNodeName() );\n\n      LeaderStatus isLeader = amILeader();\n      while (isLeader == LeaderStatus.DONT_KNOW) {\n        log.debug(\"am_i_leader unclear {}\", isLeader);\n        isLeader = amILeader();  // not a no, not a yes, try ask again\n      }\n\n      if (log.isInfoEnabled()) {\n        log.info(\"Starting to work on the main queue : {}\", LeaderElector.getNodeName(myId));\n      }\n      try {\n        ZkStateWriter zkStateWriter = null;\n        ClusterState clusterState = null;\n        boolean refreshClusterState = true; // let's refresh in the first iteration\n        // we write updates in batch, but if an exception is thrown when writing new clusterstate,\n        // we do not sure which message is bad message, therefore we will re-process node one by one\n        int fallbackQueueSize = Integer.MAX_VALUE;\n        ZkDistributedQueue fallbackQueue = workQueue;\n        while (!this.isClosed) {\n          isLeader = amILeader();\n          if (LeaderStatus.NO == isLeader) {\n            break;\n          }\n          else if (LeaderStatus.YES != isLeader) {\n            log.debug(\"am_i_leader unclear {}\", isLeader);\n            continue; // not a no, not a yes, try ask again\n          }\n\n          //TODO consider removing 'refreshClusterState' and simply check if clusterState is null\n          if (refreshClusterState) {\n            try {\n              reader.forciblyRefreshAllClusterStateSlow();\n              clusterState = reader.getClusterState();\n              zkStateWriter = new ZkStateWriter(reader, stats);\n              refreshClusterState = false;\n\n              // if there were any errors while processing\n              // the state queue, items would have been left in the\n              // work queue so let's process those first\n              byte[] data = fallbackQueue.peek();\n              while (fallbackQueueSize > 0 && data != null)  {\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                if (log.isDebugEnabled()) {\n                  log.debug(\"processMessage: fallbackQueueSize: {}, message = {}\", fallbackQueue.getZkStats().getQueueLength(), message);\n                }\n                // force flush to ZK after each message because there is no fallback if workQueue items\n                // are removed from workQueue but fail to be written to ZK\n                try {\n                  clusterState = processQueueItem(message, clusterState, zkStateWriter, false, null);\n                } catch (Exception e) {\n                  if (isBadMessage(e)) {\n                    log.warn(\"Exception when process message = {}, consider as bad message and poll out from the queue\", message);\n                    fallbackQueue.poll();\n                  }\n                  throw e;\n                }\n                fallbackQueue.poll(); // poll-ing removes the element we got by peek-ing\n                data = fallbackQueue.peek();\n                fallbackQueueSize--;\n              }\n              // force flush at the end of the loop, if there are no pending updates, this is a no op call\n              clusterState = zkStateWriter.writePendingUpdates();\n              // the workQueue is empty now, use stateUpdateQueue as fallback queue\n              fallbackQueue = stateUpdateQueue;\n              fallbackQueueSize = 0;\n            } catch (AlreadyClosedException e) {\n              return;\n            } catch (KeeperException.SessionExpiredException e) {\n              log.warn(\"Solr cannot talk to ZK, exiting Overseer work queue loop\", e);\n              return;\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n              return;\n            } catch (Exception e) {\n              log.error(\"Exception in Overseer when process message from work queue, retrying\", e);\n              refreshClusterState = true;\n              continue;\n            }\n          }\n\n          LinkedList<Pair<String, byte[]>> queue = null;\n          try {\n            // We do not need to filter any nodes here cause all processed nodes are removed once we flush clusterstate\n            queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 3000L, (x) -> true));\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n\n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n          }\n          try {\n            Set<String> processedNodes = new HashSet<>();\n            while (queue != null && !queue.isEmpty()) {\n              for (Pair<String, byte[]> head : queue) {\n                byte[] data = head.second();\n                final ZkNodeProps message = ZkNodeProps.load(data);\n                if (log.isDebugEnabled()) {\n                  log.debug(\"processMessage: queueSize: {}, message = {} current state version: {}\", stateUpdateQueue.getZkStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());\n                }\n\n                processedNodes.add(head.first());\n                fallbackQueueSize = processedNodes.size();\n                // The callback always be called on this thread\n                clusterState = processQueueItem(message, clusterState, zkStateWriter, true, () -> {\n                  stateUpdateQueue.remove(processedNodes);\n                  processedNodes.clear();\n                });\n              }\n              if (isClosed) break;\n              // if an event comes in the next 100ms batch it together\n              queue = new LinkedList<>(stateUpdateQueue.peekElements(1000, 100, node -> !processedNodes.contains(node)));\n            }\n            fallbackQueueSize = processedNodes.size();\n            // we should force write all pending updates because the next iteration might sleep until there\n            // are more items in the main queue\n            clusterState = zkStateWriter.writePendingUpdates();\n            // clean work queue\n            stateUpdateQueue.remove(processedNodes);\n            processedNodes.clear();\n          } catch (KeeperException.SessionExpiredException e) {\n            log.warn(\"Solr cannot talk to ZK, exiting Overseer main queue loop\", e);\n            return;\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n          } catch (AlreadyClosedException e) {\n  \n          } catch (Exception e) {\n            log.error(\"Exception in Overseer main queue loop\", e);\n            refreshClusterState = true; // it might have been a bad version error\n          }\n        }\n      } finally {\n        if (log.isInfoEnabled()) {\n          log.info(\"Overseer Loop exiting : {}\", LeaderElector.getNodeName(myId));\n        }\n        //do this in a separate thread because any wait is interrupted in this main thread\n        new Thread(this::checkIfIamStillLeader, \"OverseerExitThread\").start();\n      }\n    }\n\n","bugFix":["ad4957cde742defe6db19689abdc267c5d948066"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a63e9ddc18e0ec8efab1ee0d885b9378ff4dfb50":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"b94236357aaa22b76c10629851fe4e376e0cea82":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8","a63e9ddc18e0ec8efab1ee0d885b9378ff4dfb50"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["fd5bc858b8426d40bbe90b94120ead37c77d7954","f30ced5df221e945e2ff4ea4abe6d29b36de1613"],"9088bc86d5a0e967da50b566ea1dd0c5458ba6f5":["584c1ee8712b5af28075d98028ccab111d6eeda2"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["8fd5be977c105554c6a7b68afcdbc511439723ab","7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["f30ced5df221e945e2ff4ea4abe6d29b36de1613"],"6186d706db01cb7da7962595b44a09266e63d96b":["2a282020d6c9a4ea32a359539e283e4771a2fda8"],"f9a989a32a073c55e3aef6f807a3474184bbcf49":["e73d8d559120669b47658108d818b637df5456ea","cbe78d3a2f3502a69a49837cc3eeee2cbb4f7033"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["dedd8b6e67b7ac7a77554562fddcf90e0031a95c"],"29f5eaf296600e1665151e7929d42a3cbe22e481":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["ffcbf6f5d2f38f98426978f6efda243615600247"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["b94236357aaa22b76c10629851fe4e376e0cea82","27e471964e04aba0265130e510f878b1a91d4c7a"],"8295a0e649f894ba19be89ef3b8887648978525f":["5b15576cafd8b5d06857055c28f26912321937e3"],"ffcbf6f5d2f38f98426978f6efda243615600247":["bfb6f3c8c119796b6a4ca83753599e3064b65305"],"bfb6f3c8c119796b6a4ca83753599e3064b65305":["8fc87768c8910548f5a0b938e01a4d401b15eaca"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["781bec8380d3b76fa7ca27eceb50019c8c160e02"],"f30ced5df221e945e2ff4ea4abe6d29b36de1613":["29f5eaf296600e1665151e7929d42a3cbe22e481"],"1e5f642aea415d0cbee35d1b3208b193a62d7f15":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","314edcfba84a78d1a59020136cd92031e76a6bed"],"0acfa728bc42d7e2f275b294280ebfe610828af7":["e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6"],"314edcfba84a78d1a59020136cd92031e76a6bed":["7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d"],"a5d615d62cd8aff3690943d765e46942551f98b6":["962cd4f5e313777f35da8f521265323e84184929"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["fb569fd721c41eafc2a2d788499a7df490c7f1a5","e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6"],"b6284684320a9808c41a5e43de958b2da22f89bd":["2a282020d6c9a4ea32a359539e283e4771a2fda8","6186d706db01cb7da7962595b44a09266e63d96b"],"cbe78d3a2f3502a69a49837cc3eeee2cbb4f7033":["224821deeb481fa237ac4f146f3b94e9f274aabc"],"27e471964e04aba0265130e510f878b1a91d4c7a":["b94236357aaa22b76c10629851fe4e376e0cea82"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["270612d8e1a51cded91704d7af12f8979de0f584","9e6c873b95174ff04c895232927baa76a95925eb"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["8295a0e649f894ba19be89ef3b8887648978525f"],"270612d8e1a51cded91704d7af12f8979de0f584":["f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["fa64435b5902ce266c23755a4a00691a3285dab8","b7b9732f22b8f9f34018e8f7710c12fca43b7ac0"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["042da0877b8e28fd372a8ed80d11c4506a466ad7"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"ad4957cde742defe6db19689abdc267c5d948066":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"9f45f67a018421da088ea39274f23ad5d339b97d":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d6f074e73200c07d54f242d3880a8da5a35ff97b","7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d"],"cc69baf14413994ccde897681e5ce1d393cf7156":["b6284684320a9808c41a5e43de958b2da22f89bd"],"2686a7d33e6cba9dd5d997d5366c199de8f91a00":["9088bc86d5a0e967da50b566ea1dd0c5458ba6f5"],"8fc87768c8910548f5a0b938e01a4d401b15eaca":["9279b175e5e66258442d2123a50f052219a9cc1b"],"5b15576cafd8b5d06857055c28f26912321937e3":["9f45f67a018421da088ea39274f23ad5d339b97d"],"7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"584c1ee8712b5af28075d98028ccab111d6eeda2":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["cc69baf14413994ccde897681e5ce1d393cf7156","a5d615d62cd8aff3690943d765e46942551f98b6"],"dedd8b6e67b7ac7a77554562fddcf90e0031a95c":["9e6c873b95174ff04c895232927baa76a95925eb"],"781bec8380d3b76fa7ca27eceb50019c8c160e02":["0acfa728bc42d7e2f275b294280ebfe610828af7"],"5eb2511ababf862ea11e10761c70ee560cd84510":["9f45f67a018421da088ea39274f23ad5d339b97d","8295a0e649f894ba19be89ef3b8887648978525f"],"b7b9732f22b8f9f34018e8f7710c12fca43b7ac0":["fa64435b5902ce266c23755a4a00691a3285dab8"],"962cd4f5e313777f35da8f521265323e84184929":["cc69baf14413994ccde897681e5ce1d393cf7156"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["ad4957cde742defe6db19689abdc267c5d948066"],"f0ebe4956ab158d9fbe10c7101f3992656b48a22":["b7b9732f22b8f9f34018e8f7710c12fca43b7ac0"],"224821deeb481fa237ac4f146f3b94e9f274aabc":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["2686a7d33e6cba9dd5d997d5366c199de8f91a00"],"fa64435b5902ce266c23755a4a00691a3285dab8":["314edcfba84a78d1a59020136cd92031e76a6bed"],"e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6":["cbe78d3a2f3502a69a49837cc3eeee2cbb4f7033"],"fb569fd721c41eafc2a2d788499a7df490c7f1a5":["e73d8d559120669b47658108d818b637df5456ea","f9a989a32a073c55e3aef6f807a3474184bbcf49"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b6284684320a9808c41a5e43de958b2da22f89bd","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"042da0877b8e28fd372a8ed80d11c4506a466ad7":["27e471964e04aba0265130e510f878b1a91d4c7a"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"9e6c873b95174ff04c895232927baa76a95925eb":["270612d8e1a51cded91704d7af12f8979de0f584"],"e73d8d559120669b47658108d818b637df5456ea":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","224821deeb481fa237ac4f146f3b94e9f274aabc"],"2a282020d6c9a4ea32a359539e283e4771a2fda8":["1e5f642aea415d0cbee35d1b3208b193a62d7f15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"a63e9ddc18e0ec8efab1ee0d885b9378ff4dfb50":["b94236357aaa22b76c10629851fe4e376e0cea82"],"b94236357aaa22b76c10629851fe4e376e0cea82":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","27e471964e04aba0265130e510f878b1a91d4c7a"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"9088bc86d5a0e967da50b566ea1dd0c5458ba6f5":["2686a7d33e6cba9dd5d997d5366c199de8f91a00"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["9f45f67a018421da088ea39274f23ad5d339b97d"],"6186d706db01cb7da7962595b44a09266e63d96b":["b6284684320a9808c41a5e43de958b2da22f89bd"],"f9a989a32a073c55e3aef6f807a3474184bbcf49":["fb569fd721c41eafc2a2d788499a7df490c7f1a5"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["96ea64d994d340044e0d57aeb6a5871539d10ca5","29f5eaf296600e1665151e7929d42a3cbe22e481"],"29f5eaf296600e1665151e7929d42a3cbe22e481":["f30ced5df221e945e2ff4ea4abe6d29b36de1613"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["584c1ee8712b5af28075d98028ccab111d6eeda2"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"8295a0e649f894ba19be89ef3b8887648978525f":["0622fbd990643ae4cacb693db6a0c82cf8916ae2","5eb2511ababf862ea11e10761c70ee560cd84510"],"ffcbf6f5d2f38f98426978f6efda243615600247":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bfb6f3c8c119796b6a4ca83753599e3064b65305":["ffcbf6f5d2f38f98426978f6efda243615600247"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["a63e9ddc18e0ec8efab1ee0d885b9378ff4dfb50","b94236357aaa22b76c10629851fe4e376e0cea82"],"f30ced5df221e945e2ff4ea4abe6d29b36de1613":["96ea64d994d340044e0d57aeb6a5871539d10ca5","058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"1e5f642aea415d0cbee35d1b3208b193a62d7f15":["2a282020d6c9a4ea32a359539e283e4771a2fda8"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"0acfa728bc42d7e2f275b294280ebfe610828af7":["781bec8380d3b76fa7ca27eceb50019c8c160e02"],"314edcfba84a78d1a59020136cd92031e76a6bed":["05a14b2611ead08655a2b2bdc61632eb31316e57","fa64435b5902ce266c23755a4a00691a3285dab8"],"a5d615d62cd8aff3690943d765e46942551f98b6":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"b6284684320a9808c41a5e43de958b2da22f89bd":["cc69baf14413994ccde897681e5ce1d393cf7156","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cbe78d3a2f3502a69a49837cc3eeee2cbb4f7033":["f9a989a32a073c55e3aef6f807a3474184bbcf49","e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6"],"27e471964e04aba0265130e510f878b1a91d4c7a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","042da0877b8e28fd372a8ed80d11c4506a466ad7"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"270612d8e1a51cded91704d7af12f8979de0f584":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","9e6c873b95174ff04c895232927baa76a95925eb"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["ad4957cde742defe6db19689abdc267c5d948066"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"ad4957cde742defe6db19689abdc267c5d948066":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"9f45f67a018421da088ea39274f23ad5d339b97d":["5b15576cafd8b5d06857055c28f26912321937e3","5eb2511ababf862ea11e10761c70ee560cd84510"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"8fc87768c8910548f5a0b938e01a4d401b15eaca":["bfb6f3c8c119796b6a4ca83753599e3064b65305"],"cc69baf14413994ccde897681e5ce1d393cf7156":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","962cd4f5e313777f35da8f521265323e84184929"],"2686a7d33e6cba9dd5d997d5366c199de8f91a00":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","314edcfba84a78d1a59020136cd92031e76a6bed","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"5b15576cafd8b5d06857055c28f26912321937e3":["8295a0e649f894ba19be89ef3b8887648978525f"],"584c1ee8712b5af28075d98028ccab111d6eeda2":["9088bc86d5a0e967da50b566ea1dd0c5458ba6f5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d6f074e73200c07d54f242d3880a8da5a35ff97b","8fd5be977c105554c6a7b68afcdbc511439723ab","3f767f8c99eaedb984df754fe61f21c5de260f94"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["224821deeb481fa237ac4f146f3b94e9f274aabc","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e73d8d559120669b47658108d818b637df5456ea"],"dedd8b6e67b7ac7a77554562fddcf90e0031a95c":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"781bec8380d3b76fa7ca27eceb50019c8c160e02":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"962cd4f5e313777f35da8f521265323e84184929":["a5d615d62cd8aff3690943d765e46942551f98b6"],"b7b9732f22b8f9f34018e8f7710c12fca43b7ac0":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f0ebe4956ab158d9fbe10c7101f3992656b48a22"],"f0ebe4956ab158d9fbe10c7101f3992656b48a22":["8917bfede3b4ca30f4305c1e391e9218959cd723","270612d8e1a51cded91704d7af12f8979de0f584"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"224821deeb481fa237ac4f146f3b94e9f274aabc":["cbe78d3a2f3502a69a49837cc3eeee2cbb4f7033","e73d8d559120669b47658108d818b637df5456ea"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["1e5f642aea415d0cbee35d1b3208b193a62d7f15"],"fa64435b5902ce266c23755a4a00691a3285dab8":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b7b9732f22b8f9f34018e8f7710c12fca43b7ac0"],"e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6":["0acfa728bc42d7e2f275b294280ebfe610828af7","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"fb569fd721c41eafc2a2d788499a7df490c7f1a5":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"042da0877b8e28fd372a8ed80d11c4506a466ad7":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"9279b175e5e66258442d2123a50f052219a9cc1b":["8fc87768c8910548f5a0b938e01a4d401b15eaca"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["d6f074e73200c07d54f242d3880a8da5a35ff97b","7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d","8fd5be977c105554c6a7b68afcdbc511439723ab"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"9e6c873b95174ff04c895232927baa76a95925eb":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","dedd8b6e67b7ac7a77554562fddcf90e0031a95c"],"e73d8d559120669b47658108d818b637df5456ea":["f9a989a32a073c55e3aef6f807a3474184bbcf49","fb569fd721c41eafc2a2d788499a7df490c7f1a5"],"2a282020d6c9a4ea32a359539e283e4771a2fda8":["6186d706db01cb7da7962595b44a09266e63d96b","b6284684320a9808c41a5e43de958b2da22f89bd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","b05c56a41b733e02a189c48895922b5bd8c7f3d1","8917bfede3b4ca30f4305c1e391e9218959cd723","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","05a14b2611ead08655a2b2bdc61632eb31316e57","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","74f45af4339b0daf7a95c820ab88c1aea74fbce0","5eb2511ababf862ea11e10761c70ee560cd84510","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}