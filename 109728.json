{"path":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","commits":[{"id":"120bc33d5cbe83eca2e5fce597baf4fef208d579","date":1573735895,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public void install(String packageName, String version) throws SolrException {\n    String latestVersion = getLastPackageRelease(packageName).version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> peggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!peggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+peggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n    boolean res = packageManager.verify(updatedPackage, peggedToLatest);\n    PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n        \" on \" + peggedToLatest + \", result: \" + res);\n    if (!res) throw new SolrException(ErrorCode.BAD_REQUEST, \"Failed verification after deployment\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62d55718cd611235e975fa73a6bdf263fbd58859","date":1576386842,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","sourceNew":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public void install(String packageName, String version) throws SolrException {\n    String latestVersion = getLastPackageRelease(packageName).version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> peggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!peggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+peggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    if (peggedToLatest.isEmpty() == false) {\n      SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n      boolean res = packageManager.verify(updatedPackage, peggedToLatest);\n      PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n          \" on \" + peggedToLatest + \", result: \" + res);\n      if (!res) throw new SolrException(ErrorCode.BAD_REQUEST, \"Failed verification after deployment\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public void install(String packageName, String version) throws SolrException {\n    String latestVersion = getLastPackageRelease(packageName).version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> peggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!peggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+peggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n    boolean res = packageManager.verify(updatedPackage, peggedToLatest);\n    PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n        \" on \" + peggedToLatest + \", result: \" + res);\n    if (!res) throw new SolrException(ErrorCode.BAD_REQUEST, \"Failed verification after deployment\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06595b0c22c7d3075c4104d3820cccf95d9d8a43","date":1576491645,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","sourceNew":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public void install(String packageName, String version) throws SolrException {\n    String latestVersion = getLastPackageRelease(packageName).version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> peggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!peggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+peggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    if (peggedToLatest.isEmpty() == false) {\n      SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n      boolean res = packageManager.verify(updatedPackage, peggedToLatest);\n      PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n          \" on \" + peggedToLatest + \", result: \" + res);\n      if (!res) throw new SolrException(ErrorCode.BAD_REQUEST, \"Failed verification after deployment\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public void install(String packageName, String version) throws SolrException {\n    String latestVersion = getLastPackageRelease(packageName).version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> peggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!peggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+peggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n    boolean res = packageManager.verify(updatedPackage, peggedToLatest);\n    PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n        \" on \" + peggedToLatest + \", result: \" + res);\n    if (!res) throw new SolrException(ErrorCode.BAD_REQUEST, \"Failed verification after deployment\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a688687cbff91a8f44c95d31697c3ba8a47c8c25","date":1593512440,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","sourceNew":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public void install(String packageName, String version) throws SolrException {\n    String latestVersion = getLastPackageRelease(packageName).version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> collectionsPeggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!collectionsPeggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+collectionsPeggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    if (collectionsPeggedToLatest.isEmpty() == false) {\n      SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n      boolean res = packageManager.verify(updatedPackage, collectionsPeggedToLatest, false, new String[] {}); // Cluster level plugins don't work with peggedToLatest functionality\n      PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n          \" on \" + collectionsPeggedToLatest + \", result: \" + res);\n      if (!res) throw new SolrException(ErrorCode.BAD_REQUEST, \"Failed verification after deployment\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public void install(String packageName, String version) throws SolrException {\n    String latestVersion = getLastPackageRelease(packageName).version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> peggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!peggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+peggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    if (peggedToLatest.isEmpty() == false) {\n      SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n      boolean res = packageManager.verify(updatedPackage, peggedToLatest);\n      PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n          \" on \" + peggedToLatest + \", result: \" + res);\n      if (!res) throw new SolrException(ErrorCode.BAD_REQUEST, \"Failed verification after deployment\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4","date":1594087785,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","sourceNew":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public boolean install(String packageName, String version) throws SolrException {\n    SolrPackageRelease pkg = getLastPackageRelease(packageName);\n    if (pkg == null) {\n      PackageUtils.printRed(\"Package \" + packageName + \" not found in any repository. Check list of available packages via \\\"solr package list-available\\\".\");\n      return false;\n    }\n    String latestVersion = pkg.version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> collectionsPeggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!collectionsPeggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+collectionsPeggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    if (collectionsPeggedToLatest.isEmpty() == false) {\n      SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n      boolean res = packageManager.verify(updatedPackage, collectionsPeggedToLatest, false, new String[] {}); // Cluster level plugins don't work with peggedToLatest functionality\n      PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n          \" on \" + collectionsPeggedToLatest + \", result: \" + res);\n      if (!res) {\n        PackageUtils.printRed(\"Failed verification after deployment\");\n        return false;\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public void install(String packageName, String version) throws SolrException {\n    String latestVersion = getLastPackageRelease(packageName).version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> collectionsPeggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!collectionsPeggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+collectionsPeggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    if (collectionsPeggedToLatest.isEmpty() == false) {\n      SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n      boolean res = packageManager.verify(updatedPackage, collectionsPeggedToLatest, false, new String[] {}); // Cluster level plugins don't work with peggedToLatest functionality\n      PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n          \" on \" + collectionsPeggedToLatest + \", result: \" + res);\n      if (!res) throw new SolrException(ErrorCode.BAD_REQUEST, \"Failed verification after deployment\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2ed9b72e5fa27a7bd4857f222ca815341979d4a","date":1594879524,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/RepositoryManager#install(String,String).mjava","sourceNew":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackageLoader#LATEST} version of this package and got auto-updated.\n   */\n  public boolean install(String packageName, String version) throws SolrException {\n    SolrPackageRelease pkg = getLastPackageRelease(packageName);\n    if (pkg == null) {\n      PackageUtils.printRed(\"Package \" + packageName + \" not found in any repository. Check list of available packages via \\\"solr package list-available\\\".\");\n      return false;\n    }\n    String latestVersion = pkg.version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> collectionsPeggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackageLoader.LATEST)).collect(Collectors.toList());\n    if (!collectionsPeggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+collectionsPeggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    if (collectionsPeggedToLatest.isEmpty() == false) {\n      SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n      boolean res = packageManager.verify(updatedPackage, collectionsPeggedToLatest, false, new String[] {}); // Cluster level plugins don't work with peggedToLatest functionality\n      PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n          \" on \" + collectionsPeggedToLatest + \", result: \" + res);\n      if (!res) {\n        PackageUtils.printRed(\"Failed verification after deployment\");\n        return false;\n      }\n    }\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Install a version of the package. Also, run verify commands in case some\n   * collection was using {@link PackagePluginHolder#LATEST} version of this package and got auto-updated.\n   */\n  public boolean install(String packageName, String version) throws SolrException {\n    SolrPackageRelease pkg = getLastPackageRelease(packageName);\n    if (pkg == null) {\n      PackageUtils.printRed(\"Package \" + packageName + \" not found in any repository. Check list of available packages via \\\"solr package list-available\\\".\");\n      return false;\n    }\n    String latestVersion = pkg.version;\n\n    Map<String, String> collectionsDeployedIn = packageManager.getDeployedCollections(packageName);\n    List<String> collectionsPeggedToLatest = collectionsDeployedIn.keySet().stream().\n        filter(collection -> collectionsDeployedIn.get(collection).equals(PackagePluginHolder.LATEST)).collect(Collectors.toList());\n    if (!collectionsPeggedToLatest.isEmpty()) {\n      PackageUtils.printGreen(\"Collections that will be affected (since they are configured to use $LATEST): \"+collectionsPeggedToLatest);\n    }\n\n    if (version == null || version.equals(PackageUtils.LATEST)) {\n      installPackage(packageName, latestVersion);\n    } else {\n      installPackage(packageName, version);\n    }\n\n    if (collectionsPeggedToLatest.isEmpty() == false) {\n      SolrPackageInstance updatedPackage = packageManager.getPackageInstance(packageName, PackageUtils.LATEST);\n      boolean res = packageManager.verify(updatedPackage, collectionsPeggedToLatest, false, new String[] {}); // Cluster level plugins don't work with peggedToLatest functionality\n      PackageUtils.printGreen(\"Verifying version \" + updatedPackage.version + \n          \" on \" + collectionsPeggedToLatest + \", result: \" + res);\n      if (!res) {\n        PackageUtils.printRed(\"Failed verification after deployment\");\n        return false;\n      }\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4"],"4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4":["a688687cbff91a8f44c95d31697c3ba8a47c8c25"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06595b0c22c7d3075c4104d3820cccf95d9d8a43":["120bc33d5cbe83eca2e5fce597baf4fef208d579","62d55718cd611235e975fa73a6bdf263fbd58859"],"62d55718cd611235e975fa73a6bdf263fbd58859":["120bc33d5cbe83eca2e5fce597baf4fef208d579"],"120bc33d5cbe83eca2e5fce597baf4fef208d579":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a688687cbff91a8f44c95d31697c3ba8a47c8c25":["62d55718cd611235e975fa73a6bdf263fbd58859"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"]},"commit2Childs":{"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["120bc33d5cbe83eca2e5fce597baf4fef208d579"],"06595b0c22c7d3075c4104d3820cccf95d9d8a43":[],"62d55718cd611235e975fa73a6bdf263fbd58859":["06595b0c22c7d3075c4104d3820cccf95d9d8a43","a688687cbff91a8f44c95d31697c3ba8a47c8c25"],"120bc33d5cbe83eca2e5fce597baf4fef208d579":["06595b0c22c7d3075c4104d3820cccf95d9d8a43","62d55718cd611235e975fa73a6bdf263fbd58859"],"a688687cbff91a8f44c95d31697c3ba8a47c8c25":["4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["06595b0c22c7d3075c4104d3820cccf95d9d8a43","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}