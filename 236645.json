{"path":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","commits":[{"id":"39d69912999d6e0acfb6eb6be558fcc165eee0b2","date":1308066875,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Call this when you need the NRT reader to reopen.\n   *\n   * @param applyDeletes If true, the newly opened reader\n   *        will reflect all deletes\n   */\n  public boolean reopen(boolean applyDeletes) throws IOException {\n\n    // Mark gen as of when reopen started:\n    final long newSearcherGen = indexingGen.getAndIncrement();\n\n    if (applyDeletes && currentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent both force gen=\" + newSearcherGen + \" vs current gen=\" + searchingGen);\n      searchingGen.set(newSearcherGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    } else if (!applyDeletes && noDeletesCurrentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent force gen=\" + newSearcherGen + \" vs current gen=\" + noDeletesSearchingGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    }\n\n    //System.out.println(\"indexingGen now \" + indexingGen);\n\n    // .reopen() returns a new reference:\n\n    // Start from whichever searcher is most current:\n    final IndexSearcher startSearcher = noDeletesSearchingGen.get() > searchingGen.get() ? noDeletesCurrentSearcher : currentSearcher;\n    final IndexReader nextReader = startSearcher.getIndexReader().reopen(writer, applyDeletes);\n\n    warm(nextReader);\n\n    // Transfer reference to swapSearcher:\n    swapSearcher(new IndexSearcher(nextReader, es),\n                 newSearcherGen,\n                 applyDeletes);\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ed208afa1e7aa98899ddb1dedfddedddf898253","date":1308079587,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Call this when you need the NRT reader to reopen.\n   *\n   * @param applyDeletes If true, the newly opened reader\n   *        will reflect all deletes\n   */\n  public boolean reopen(boolean applyDeletes) throws IOException {\n\n    // Mark gen as of when reopen started:\n    final long newSearcherGen = indexingGen.getAndIncrement();\n\n    if (applyDeletes && currentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent both force gen=\" + newSearcherGen + \" vs current gen=\" + searchingGen);\n      searchingGen.set(newSearcherGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    } else if (!applyDeletes && noDeletesCurrentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent force gen=\" + newSearcherGen + \" vs current gen=\" + noDeletesSearchingGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    }\n\n    //System.out.println(\"indexingGen now \" + indexingGen);\n\n    // .reopen() returns a new reference:\n\n    // Start from whichever searcher is most current:\n    final IndexSearcher startSearcher = noDeletesSearchingGen.get() > searchingGen.get() ? noDeletesCurrentSearcher : currentSearcher;\n    final IndexReader nextReader = startSearcher.getIndexReader().reopen(writer, applyDeletes);\n\n    warm(nextReader);\n\n    // Transfer reference to swapSearcher:\n    swapSearcher(new IndexSearcher(nextReader, es),\n                 newSearcherGen,\n                 applyDeletes);\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edcc2c2cbab6bf89ea584169ffb3ca83a31827f9","date":1316963893,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","sourceNew":"  /** Call this when you need the NRT reader to reopen.\n   *\n   * @param applyDeletes If true, the newly opened reader\n   *        will reflect all deletes\n   */\n  public boolean reopen(boolean applyDeletes) throws IOException {\n\n    // Mark gen as of when reopen started:\n    final long newSearcherGen = indexingGen.getAndIncrement();\n\n    if (applyDeletes && currentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent both force gen=\" + newSearcherGen + \" vs current gen=\" + searchingGen);\n      searchingGen.set(newSearcherGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    } else if (!applyDeletes && noDeletesCurrentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent force gen=\" + newSearcherGen + \" vs current gen=\" + noDeletesSearchingGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    }\n\n    //System.out.println(\"indexingGen now \" + indexingGen);\n\n    // .reopen() returns a new reference:\n\n    // Start from whichever searcher is most current:\n    final IndexSearcher startSearcher = noDeletesSearchingGen.get() > searchingGen.get() ? noDeletesCurrentSearcher : currentSearcher;\n    final IndexReader nextReader = startSearcher.getIndexReader().reopen(writer, applyDeletes);\n\n    final IndexSearcher nextSearcher = new IndexSearcher(nextReader, es);\n    if (warmer != null) {\n      warmer.warm(nextSearcher);\n    }\n\n    // Transfer reference to swapSearcher:\n    swapSearcher(nextSearcher,\n                 newSearcherGen,\n                 applyDeletes);\n\n    return true;\n  }\n\n","sourceOld":"  /** Call this when you need the NRT reader to reopen.\n   *\n   * @param applyDeletes If true, the newly opened reader\n   *        will reflect all deletes\n   */\n  public boolean reopen(boolean applyDeletes) throws IOException {\n\n    // Mark gen as of when reopen started:\n    final long newSearcherGen = indexingGen.getAndIncrement();\n\n    if (applyDeletes && currentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent both force gen=\" + newSearcherGen + \" vs current gen=\" + searchingGen);\n      searchingGen.set(newSearcherGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    } else if (!applyDeletes && noDeletesCurrentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent force gen=\" + newSearcherGen + \" vs current gen=\" + noDeletesSearchingGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    }\n\n    //System.out.println(\"indexingGen now \" + indexingGen);\n\n    // .reopen() returns a new reference:\n\n    // Start from whichever searcher is most current:\n    final IndexSearcher startSearcher = noDeletesSearchingGen.get() > searchingGen.get() ? noDeletesCurrentSearcher : currentSearcher;\n    final IndexReader nextReader = startSearcher.getIndexReader().reopen(writer, applyDeletes);\n\n    warm(nextReader);\n\n    // Transfer reference to swapSearcher:\n    swapSearcher(new IndexSearcher(nextReader, es),\n                 newSearcherGen,\n                 applyDeletes);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"576017a3864f5d8d12be8dc6b7b47dd9c41cc08d","date":1317143951,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","sourceNew":"  /** Call this when you need the NRT reader to reopen.\n   *\n   * @param applyDeletes If true, the newly opened reader\n   *        will reflect all deletes\n   */\n  public boolean reopen(boolean applyDeletes) throws IOException {\n\n    // Mark gen as of when reopen started:\n    final long newSearcherGen = indexingGen.getAndIncrement();\n\n    if (applyDeletes && currentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent both force gen=\" + newSearcherGen + \" vs current gen=\" + searchingGen);\n      searchingGen.set(newSearcherGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    } else if (!applyDeletes && noDeletesCurrentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent force gen=\" + newSearcherGen + \" vs current gen=\" + noDeletesSearchingGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    }\n\n    //System.out.println(\"indexingGen now \" + indexingGen);\n\n    // .reopen() returns a new reference:\n\n    // Start from whichever searcher is most current:\n    final IndexSearcher startSearcher = noDeletesSearchingGen.get() > searchingGen.get() ? noDeletesCurrentSearcher : currentSearcher;\n    final IndexReader nextReader = startSearcher.getIndexReader().reopen(writer, applyDeletes);\n\n    if (nextReader != startSearcher.getIndexReader()) {\n      final IndexSearcher nextSearcher = new IndexSearcher(nextReader, es);\n      if (warmer != null) {\n        boolean success = false;\n        try {\n          warmer.warm(nextSearcher);\n          success = true;\n        } finally {\n          if (!success) {\n            nextReader.decRef();\n          }\n        }\n      }\n\n      // Transfer reference to swapSearcher:\n      swapSearcher(nextSearcher,\n                   newSearcherGen,\n                   applyDeletes);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Call this when you need the NRT reader to reopen.\n   *\n   * @param applyDeletes If true, the newly opened reader\n   *        will reflect all deletes\n   */\n  public boolean reopen(boolean applyDeletes) throws IOException {\n\n    // Mark gen as of when reopen started:\n    final long newSearcherGen = indexingGen.getAndIncrement();\n\n    if (applyDeletes && currentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent both force gen=\" + newSearcherGen + \" vs current gen=\" + searchingGen);\n      searchingGen.set(newSearcherGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    } else if (!applyDeletes && noDeletesCurrentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent force gen=\" + newSearcherGen + \" vs current gen=\" + noDeletesSearchingGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    }\n\n    //System.out.println(\"indexingGen now \" + indexingGen);\n\n    // .reopen() returns a new reference:\n\n    // Start from whichever searcher is most current:\n    final IndexSearcher startSearcher = noDeletesSearchingGen.get() > searchingGen.get() ? noDeletesCurrentSearcher : currentSearcher;\n    final IndexReader nextReader = startSearcher.getIndexReader().reopen(writer, applyDeletes);\n\n    final IndexSearcher nextSearcher = new IndexSearcher(nextReader, es);\n    if (warmer != null) {\n      warmer.warm(nextSearcher);\n    }\n\n    // Transfer reference to swapSearcher:\n    swapSearcher(nextSearcher,\n                 newSearcherGen,\n                 applyDeletes);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a8259c922a83abc544609227a60d48e5ee93e7e","date":1317679620,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","sourceNew":"  /** Call this when you need the NRT reader to reopen.\n   *\n   * @param applyDeletes If true, the newly opened reader\n   *        will reflect all deletes\n   */\n  public boolean reopen(boolean applyDeletes) throws IOException {\n\n    // Mark gen as of when reopen started:\n    final long newSearcherGen = indexingGen.getAndIncrement();\n\n    if (applyDeletes && currentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent both force gen=\" + newSearcherGen + \" vs current gen=\" + searchingGen);\n      searchingGen.set(newSearcherGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    } else if (!applyDeletes && noDeletesCurrentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent force gen=\" + newSearcherGen + \" vs current gen=\" + noDeletesSearchingGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    }\n\n    //System.out.println(\"indexingGen now \" + indexingGen);\n\n    // .reopen() returns a new reference:\n\n    // Start from whichever searcher is most current:\n    final IndexSearcher startSearcher = noDeletesSearchingGen.get() > searchingGen.get() ? noDeletesCurrentSearcher : currentSearcher;\n    IndexReader nextReader = IndexReader.openIfChanged(startSearcher.getIndexReader(), writer, applyDeletes);\n    if (nextReader == null) {\n      // NOTE: doesn't happen currently in Lucene (reopen on\n      // NRT reader always returns new reader), but could in\n      // the future:\n      nextReader = startSearcher.getIndexReader();\n      nextReader.incRef();\n    }\n\n    if (nextReader != startSearcher.getIndexReader()) {\n      final IndexSearcher nextSearcher = new IndexSearcher(nextReader, es);\n      if (warmer != null) {\n        boolean success = false;\n        try {\n          warmer.warm(nextSearcher);\n          success = true;\n        } finally {\n          if (!success) {\n            nextReader.decRef();\n          }\n        }\n      }\n\n      // Transfer reference to swapSearcher:\n      swapSearcher(nextSearcher,\n                   newSearcherGen,\n                   applyDeletes);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Call this when you need the NRT reader to reopen.\n   *\n   * @param applyDeletes If true, the newly opened reader\n   *        will reflect all deletes\n   */\n  public boolean reopen(boolean applyDeletes) throws IOException {\n\n    // Mark gen as of when reopen started:\n    final long newSearcherGen = indexingGen.getAndIncrement();\n\n    if (applyDeletes && currentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent both force gen=\" + newSearcherGen + \" vs current gen=\" + searchingGen);\n      searchingGen.set(newSearcherGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    } else if (!applyDeletes && noDeletesCurrentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent force gen=\" + newSearcherGen + \" vs current gen=\" + noDeletesSearchingGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    }\n\n    //System.out.println(\"indexingGen now \" + indexingGen);\n\n    // .reopen() returns a new reference:\n\n    // Start from whichever searcher is most current:\n    final IndexSearcher startSearcher = noDeletesSearchingGen.get() > searchingGen.get() ? noDeletesCurrentSearcher : currentSearcher;\n    final IndexReader nextReader = startSearcher.getIndexReader().reopen(writer, applyDeletes);\n\n    if (nextReader != startSearcher.getIndexReader()) {\n      final IndexSearcher nextSearcher = new IndexSearcher(nextReader, es);\n      if (warmer != null) {\n        boolean success = false;\n        try {\n          warmer.warm(nextSearcher);\n          success = true;\n        } finally {\n          if (!success) {\n            nextReader.decRef();\n          }\n        }\n      }\n\n      // Transfer reference to swapSearcher:\n      swapSearcher(nextSearcher,\n                   newSearcherGen,\n                   applyDeletes);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"606baff722a317c76a92b111d183b54b6e6e5741","date":1317974711,"type":4,"author":"Simon Willnauer","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/index/NRTManager#reopen(boolean).mjava","sourceNew":null,"sourceOld":"  /** Call this when you need the NRT reader to reopen.\n   *\n   * @param applyDeletes If true, the newly opened reader\n   *        will reflect all deletes\n   */\n  public boolean reopen(boolean applyDeletes) throws IOException {\n\n    // Mark gen as of when reopen started:\n    final long newSearcherGen = indexingGen.getAndIncrement();\n\n    if (applyDeletes && currentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent both force gen=\" + newSearcherGen + \" vs current gen=\" + searchingGen);\n      searchingGen.set(newSearcherGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    } else if (!applyDeletes && noDeletesCurrentSearcher.getIndexReader().isCurrent()) {\n      //System.out.println(\"reopen: skip: isCurrent force gen=\" + newSearcherGen + \" vs current gen=\" + noDeletesSearchingGen);\n      noDeletesSearchingGen.set(newSearcherGen);\n      synchronized(this) {\n        notifyAll();\n      }\n      //System.out.println(\"reopen: skip: return\");\n      return false;\n    }\n\n    //System.out.println(\"indexingGen now \" + indexingGen);\n\n    // .reopen() returns a new reference:\n\n    // Start from whichever searcher is most current:\n    final IndexSearcher startSearcher = noDeletesSearchingGen.get() > searchingGen.get() ? noDeletesCurrentSearcher : currentSearcher;\n    IndexReader nextReader = IndexReader.openIfChanged(startSearcher.getIndexReader(), writer, applyDeletes);\n    if (nextReader == null) {\n      // NOTE: doesn't happen currently in Lucene (reopen on\n      // NRT reader always returns new reader), but could in\n      // the future:\n      nextReader = startSearcher.getIndexReader();\n      nextReader.incRef();\n    }\n\n    if (nextReader != startSearcher.getIndexReader()) {\n      final IndexSearcher nextSearcher = new IndexSearcher(nextReader, es);\n      if (warmer != null) {\n        boolean success = false;\n        try {\n          warmer.warm(nextSearcher);\n          success = true;\n        } finally {\n          if (!success) {\n            nextReader.decRef();\n          }\n        }\n      }\n\n      // Transfer reference to swapSearcher:\n      swapSearcher(nextSearcher,\n                   newSearcherGen,\n                   applyDeletes);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8a8259c922a83abc544609227a60d48e5ee93e7e":["576017a3864f5d8d12be8dc6b7b47dd9c41cc08d"],"576017a3864f5d8d12be8dc6b7b47dd9c41cc08d":["edcc2c2cbab6bf89ea584169ffb3ca83a31827f9"],"39d69912999d6e0acfb6eb6be558fcc165eee0b2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edcc2c2cbab6bf89ea584169ffb3ca83a31827f9":["39d69912999d6e0acfb6eb6be558fcc165eee0b2"],"606baff722a317c76a92b111d183b54b6e6e5741":["8a8259c922a83abc544609227a60d48e5ee93e7e"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","39d69912999d6e0acfb6eb6be558fcc165eee0b2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["606baff722a317c76a92b111d183b54b6e6e5741"]},"commit2Childs":{"8a8259c922a83abc544609227a60d48e5ee93e7e":["606baff722a317c76a92b111d183b54b6e6e5741"],"576017a3864f5d8d12be8dc6b7b47dd9c41cc08d":["8a8259c922a83abc544609227a60d48e5ee93e7e"],"39d69912999d6e0acfb6eb6be558fcc165eee0b2":["edcc2c2cbab6bf89ea584169ffb3ca83a31827f9","9ed208afa1e7aa98899ddb1dedfddedddf898253"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["39d69912999d6e0acfb6eb6be558fcc165eee0b2","9ed208afa1e7aa98899ddb1dedfddedddf898253"],"edcc2c2cbab6bf89ea584169ffb3ca83a31827f9":["576017a3864f5d8d12be8dc6b7b47dd9c41cc08d"],"606baff722a317c76a92b111d183b54b6e6e5741":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9ed208afa1e7aa98899ddb1dedfddedddf898253","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}