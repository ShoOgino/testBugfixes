{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","commits":[{"id":"66b87d86427dfa19b2ef36b66de83aa9655cea33","date":1552627668,"type":1,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n                  s.getState(), collection, slice);\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n                  s.getState(), collection, slice);\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n                  s.getName(), clusterStateVersion, ri);\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    lock.lockInterruptibly();\n    try {\n      Replica leader = s.getLeader();\n      if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"Running leader election for {} / {}\", collection, s.getName());\n        if (s.getReplicas().isEmpty()) { // no replicas - punt\n          log.trace(\"-- no replicas in {} / {}\", collection, s.getName());\n          return;\n        }\n        ActionThrottle lt = getThrottle(collection, s.getName());\n        synchronized (lt) {\n          // collect all active and live\n          List<ReplicaInfo> active = new ArrayList<>();\n          AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n          s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n          if (alreadyHasLeader.get()) {\n            log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n            return;\n          }\n          if (active.isEmpty()) {\n            log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n            log.debug(\"-- liveNodes: {}\", liveNodes.get());\n            return;\n          }\n          // pick first active one\n          ReplicaInfo ri = null;\n          for (ReplicaInfo a : active) {\n            if (!a.getType().equals(Replica.Type.PULL)) {\n              ri = a;\n              break;\n            }\n          }\n          if (ri == null) {\n            log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n            return;\n          }\n          // now mark the leader election throttle\n          lt.minimumWaitBetweenActions();\n          lt.markAttemptingAction();\n          synchronized (ri) {\n            ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n          }\n          log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n              s.getName(), clusterStateVersion, ri);\n          stateChanged.set(true);\n        }\n      } else {\n        log.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","sourceNew":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n                  s.getState(), collection, slice);\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n                  s.getState(), collection, slice);\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n                  s.getName(), clusterStateVersion, ri);\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n                  s.getState(), collection, slice);\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n                  s.getState(), collection, slice);\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n                  s.getName(), clusterStateVersion, ri);\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"66b87d86427dfa19b2ef36b66de83aa9655cea33":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"]},"commit2Childs":{"66b87d86427dfa19b2ef36b66de83aa9655cea33":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}