{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionDelete(DeleteUpdateCommand,long,long,boolean,boolean,boolean,VersionBucket).mjava","commits":[{"id":"9b3824fcbd3256db359391630ae05b3917ab369a","date":1556656304,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionDelete(DeleteUpdateCommand,long,long,boolean,boolean,boolean,VersionBucket).mjava","pathOld":"/dev/null","sourceNew":"  private boolean doVersionDelete(DeleteUpdateCommand cmd, long versionOnUpdate, long signedVersionOnUpdate,\n      boolean isReplayOrPeersync, boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket)\n      throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      if (versionsStored) {\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            log.info(\"Removing version field from doc: \" + cmd.getId());\n            versionOnUpdate = signedVersionOnUpdate = 0;\n          }\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && !isReplayOrPeersync) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          if (signedVersionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                  + signedVersionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          bucket.updateHighest(version);\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          // if we aren't the leader, then we need to check that updates were not re-ordered\n          if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n            // we're OK... this update has a version higher than anything we've seen\n            // in this bucket so far, so we know that no reordering has yet occurred.\n            bucket.updateHighest(versionOnUpdate);\n          } else {\n            // there have been updates higher than the current update. we need to check\n            // the specific version for this id.\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n              // This update is a repeat, or was reordered. We need to drop this update.\n              log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n              return true;\n            }\n          }\n\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      doLocalDelete(cmd);\n      return false;\n    } finally {\n      bucket.unlock();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionDelete(DeleteUpdateCommand,long,long,boolean,boolean,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doVersionDelete(DeleteUpdateCommand,long,long,boolean,boolean,boolean,VersionBucket).mjava","sourceNew":"  private boolean doVersionDelete(DeleteUpdateCommand cmd, long versionOnUpdate, long signedVersionOnUpdate,\n      boolean isReplayOrPeersync, boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket)\n      throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      if (versionsStored) {\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            if (log.isInfoEnabled()) {\n              log.info(\"Removing version field from doc: {}\", cmd.getId());\n            }\n            versionOnUpdate = signedVersionOnUpdate = 0;\n          }\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && !isReplayOrPeersync) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader logic applied but update log is buffering: {}\", cmd.getId());\n            }\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          if (signedVersionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                  + signedVersionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          bucket.updateHighest(version);\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          // if we aren't the leader, then we need to check that updates were not re-ordered\n          if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n            // we're OK... this update has a version higher than anything we've seen\n            // in this bucket so far, so we know that no reordering has yet occurred.\n            bucket.updateHighest(versionOnUpdate);\n          } else {\n            // there have been updates higher than the current update. we need to check\n            // the specific version for this id.\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n              // This update is a repeat, or was reordered. We need to drop this update.\n              if (log.isDebugEnabled()) {\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n              }\n              return true;\n            }\n          }\n\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      doLocalDelete(cmd);\n      return false;\n    } finally {\n      bucket.unlock();\n    }\n  }\n\n","sourceOld":"  private boolean doVersionDelete(DeleteUpdateCommand cmd, long versionOnUpdate, long signedVersionOnUpdate,\n      boolean isReplayOrPeersync, boolean leaderLogic, boolean forwardedFromCollection, VersionBucket bucket)\n      throws IOException {\n    try {\n      BytesRef idBytes = cmd.getIndexedId();\n      if (versionsStored) {\n        long bucketVersion = bucket.highest;\n\n        if (leaderLogic) {\n\n          if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n            // forwarded from a collection but we are not buffering so strip original version and apply our own\n            // see SOLR-5308\n            log.info(\"Removing version field from doc: \" + cmd.getId());\n            versionOnUpdate = signedVersionOnUpdate = 0;\n          }\n\n          // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n          if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n              && !isReplayOrPeersync) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          if (signedVersionOnUpdate != 0) {\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            long foundVersion = lastVersion == null ? -1 : lastVersion;\n            if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n              // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n              // specified it must exist (versionOnUpdate==1) and it does.\n            } else {\n              throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                  + signedVersionOnUpdate + \" actual=\" + foundVersion);\n            }\n          }\n\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          bucket.updateHighest(version);\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.delete(cmd);\n            return true;\n          }\n\n          // if we aren't the leader, then we need to check that updates were not re-ordered\n          if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n            // we're OK... this update has a version higher than anything we've seen\n            // in this bucket so far, so we know that no reordering has yet occurred.\n            bucket.updateHighest(versionOnUpdate);\n          } else {\n            // there have been updates higher than the current update. we need to check\n            // the specific version for this id.\n            Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n            if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n              // This update is a repeat, or was reordered. We need to drop this update.\n              log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n              return true;\n            }\n          }\n\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n        }\n      }\n\n      doLocalDelete(cmd);\n      return false;\n    } finally {\n      bucket.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9b3824fcbd3256db359391630ae05b3917ab369a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"740d649f013f07efbeb73ca854f106c60166e7c0":["9b3824fcbd3256db359391630ae05b3917ab369a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"]},"commit2Childs":{"9b3824fcbd3256db359391630ae05b3917ab369a":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9b3824fcbd3256db359391630ae05b3917ab369a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}