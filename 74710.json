{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","commits":[{"id":"a41df1900c455d603b9d2d4b71084b4514af5e6c","date":1355146922,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, \"\", FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, \"\", FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25308800fd7565ab31e6353077a56bba68fb0668","date":1355337658,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47081d784f5fff71bb715c806c824b50901392fb","date":1378303234,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f3b037cd083286b2af89f96e768f85dcd8072d6","date":1396337805,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION), context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"389e8bca54f58e35576077f3ff46f123b3660018","date":1411859915,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeSegmentHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId());\n      CodecUtil.writeSegmentHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId());\n      assert CodecUtil.segmentHeaderLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.segmentHeaderLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78b813d9350cc28625598f6dbbb49b586a40618","date":1412073147,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeSegmentHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeSegmentHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.segmentHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.segmentHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeSegmentHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId());\n      CodecUtil.writeSegmentHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId());\n      assert CodecUtil.segmentHeaderLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.segmentHeaderLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeSegmentHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeSegmentHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.segmentHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.segmentHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeHeader(indexStream, codecNameIdx, VERSION_CURRENT);\n      CodecUtil.writeHeader(fieldsStream, codecNameDat, VERSION_CURRENT);\n      assert CodecUtil.headerLength(codecNameDat) == fieldsStream.getFilePointer();\n      assert CodecUtil.headerLength(codecNameIdx) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeIndexHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeIndexHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.indexHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.indexHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeSegmentHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeSegmentHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.segmentHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.segmentHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeIndexHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeIndexHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.indexHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.indexHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeSegmentHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeSegmentHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.segmentHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.segmentHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"474b77fc1ee62c3fc1c73ceb19cc975cb03667ac","date":1417363109,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeIndexHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeIndexHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.indexHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.indexHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(fieldsStream, indexStream, indexWriter);\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeIndexHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeIndexHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.indexHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.indexHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(indexStream);\n        abort();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"699a2199028b8eadcc558eebcf669e5fc708524a","date":1417544403,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#CompressingStoredFieldsWriter(Directory,SegmentInfo,String,IOContext,String,CompressionMode,int).mjava","sourceNew":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize, int maxDocsPerChunk) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.maxDocsPerChunk = maxDocsPerChunk;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeIndexHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeIndexHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.indexHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.indexHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(fieldsStream, indexStream, indexWriter);\n      }\n    }\n  }\n\n","sourceOld":"  /** Sole constructor. */\n  public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, String segmentSuffix, IOContext context,\n      String formatName, CompressionMode compressionMode, int chunkSize) throws IOException {\n    assert directory != null;\n    this.directory = directory;\n    this.segment = si.name;\n    this.segmentSuffix = segmentSuffix;\n    this.compressionMode = compressionMode;\n    this.compressor = compressionMode.newCompressor();\n    this.chunkSize = chunkSize;\n    this.docBase = 0;\n    this.bufferedDocs = new GrowableByteArrayDataOutput(chunkSize);\n    this.numStoredFields = new int[16];\n    this.endOffsets = new int[16];\n    this.numBufferedDocs = 0;\n\n    boolean success = false;\n    IndexOutput indexStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_INDEX_EXTENSION), \n                                                                     context);\n    try {\n      fieldsStream = directory.createOutput(IndexFileNames.segmentFileName(segment, segmentSuffix, FIELDS_EXTENSION),\n                                                    context);\n\n      final String codecNameIdx = formatName + CODEC_SFX_IDX;\n      final String codecNameDat = formatName + CODEC_SFX_DAT;\n      CodecUtil.writeIndexHeader(indexStream, codecNameIdx, VERSION_CURRENT, si.getId(), segmentSuffix);\n      CodecUtil.writeIndexHeader(fieldsStream, codecNameDat, VERSION_CURRENT, si.getId(), segmentSuffix);\n      assert CodecUtil.indexHeaderLength(codecNameDat, segmentSuffix) == fieldsStream.getFilePointer();\n      assert CodecUtil.indexHeaderLength(codecNameIdx, segmentSuffix) == indexStream.getFilePointer();\n\n      indexWriter = new CompressingStoredFieldsIndexWriter(indexStream);\n      indexStream = null;\n\n      fieldsStream.writeVInt(chunkSize);\n      fieldsStream.writeVInt(PackedInts.VERSION_CURRENT);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(fieldsStream, indexStream, indexWriter);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["47081d784f5fff71bb715c806c824b50901392fb","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","25308800fd7565ab31e6353077a56bba68fb0668"],"1f3b037cd083286b2af89f96e768f85dcd8072d6":["47081d784f5fff71bb715c806c824b50901392fb"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a41df1900c455d603b9d2d4b71084b4514af5e6c"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["a78b813d9350cc28625598f6dbbb49b586a40618"],"699a2199028b8eadcc558eebcf669e5fc708524a":["474b77fc1ee62c3fc1c73ceb19cc975cb03667ac"],"474b77fc1ee62c3fc1c73ceb19cc975cb03667ac":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"a78b813d9350cc28625598f6dbbb49b586a40618":["389e8bca54f58e35576077f3ff46f123b3660018"],"25308800fd7565ab31e6353077a56bba68fb0668":["a41df1900c455d603b9d2d4b71084b4514af5e6c"],"9bb9a29a5e71a90295f175df8919802993142c9a":["1f3b037cd083286b2af89f96e768f85dcd8072d6","a78b813d9350cc28625598f6dbbb49b586a40618"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a41df1900c455d603b9d2d4b71084b4514af5e6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["9bb9a29a5e71a90295f175df8919802993142c9a","3384e6013a93e4d11b7d75388693f8d0388602bf"],"389e8bca54f58e35576077f3ff46f123b3660018":["1f3b037cd083286b2af89f96e768f85dcd8072d6"],"47081d784f5fff71bb715c806c824b50901392fb":["25308800fd7565ab31e6353077a56bba68fb0668"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["699a2199028b8eadcc558eebcf669e5fc708524a"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"1f3b037cd083286b2af89f96e768f85dcd8072d6":["5eb2511ababf862ea11e10761c70ee560cd84510","9bb9a29a5e71a90295f175df8919802993142c9a","389e8bca54f58e35576077f3ff46f123b3660018"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"699a2199028b8eadcc558eebcf669e5fc708524a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a78b813d9350cc28625598f6dbbb49b586a40618":["3384e6013a93e4d11b7d75388693f8d0388602bf","9bb9a29a5e71a90295f175df8919802993142c9a"],"474b77fc1ee62c3fc1c73ceb19cc975cb03667ac":["699a2199028b8eadcc558eebcf669e5fc708524a"],"25308800fd7565ab31e6353077a56bba68fb0668":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","47081d784f5fff71bb715c806c824b50901392fb"],"9bb9a29a5e71a90295f175df8919802993142c9a":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["407687e67faf6e1f02a211ca078d8e3eed631027","a41df1900c455d603b9d2d4b71084b4514af5e6c"],"a41df1900c455d603b9d2d4b71084b4514af5e6c":["407687e67faf6e1f02a211ca078d8e3eed631027","25308800fd7565ab31e6353077a56bba68fb0668"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["474b77fc1ee62c3fc1c73ceb19cc975cb03667ac"],"389e8bca54f58e35576077f3ff46f123b3660018":["a78b813d9350cc28625598f6dbbb49b586a40618"],"47081d784f5fff71bb715c806c824b50901392fb":["5eb2511ababf862ea11e10761c70ee560cd84510","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}