{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"119bc02554a192b2954b73d79389ec441257b624","date":1337232699,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshInternalReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshInternalReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e771d3bb64bb6db325ca1c015b256d08ad74424","date":1338972370,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshInternalReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(directory, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshInternalReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshInternalReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_UNSTORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new Field(Consts.FULL, \"\", StringField.TYPE_STORED);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshInternalReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4","7e4db59c6b6c10e25322cfb41c4c19d78b4298bd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b7a1bc6030c258e47d63eff3455a2b1bbf32683","date":1339494023,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    reader = null;\n\n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n      refreshInternalReader();\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We chose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n    cacheMisses = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1891ff130d9d54192377049a0bdfac6326df16f","date":1340188663,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    this.nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78e3613d9274c0d98ca67d976e415c82e9f9cf46","date":1352285414,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    if (!DirectoryReader.indexExists(directory) || openMode==OpenMode.CREATE) {\n      createTime = Long.toString(System.nanoTime());\n    } else {\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        // It is ok if an existing index doesn't have commitData, or the\n        // INDEX_CREATE_TIME property. If ever it will be recreated, we'll set\n        // createTime accordingly in the above 'if'. \n        createTime = commitData.get(INDEX_CREATE_TIME);\n      } else {\n        createTime = null;\n      }\n    }\n    \n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n    \n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":["e26e3b5080bfb6fcabdc46d0072efe441de1a21b","20b26030b0883b7f045e3350bb97bee7146f1efd","233afcf63b8d53faa9a7993e911cc9873b0106d1","9faeb5fb9565674fd02b39d8fc365311961f1938"],"bugIntro":["d8a0be2353a06d1424e3eeafc4c72455204ce92d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","date":1357499264,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(CategoryPath.EMPTY);\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(CategoryPath.EMPTY);\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new CategoryPath());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8a0be2353a06d1424e3eeafc4c72455204ce92d","date":1367553170,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(CategoryPath.EMPTY);\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(CategoryPath.EMPTY);\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(FacetLabel.EMPTY);\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(CategoryPath.EMPTY);\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56d44586f4c409c6c6c5942b9f0227df806b7300","date":1386027853,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new FacetLabel());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(FacetLabel.EMPTY);\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new FacetLabel());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(CategoryPath.EMPTY);\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fafd23b8e49a461cdbc22b302dfdea2f2a08d953","date":1415887806,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new FacetLabel());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer. If it is known\n   *     that no other concurrent writer is active, the lock might\n   *     have been left around by an old dead process, and should be\n   *     removed using {@link #unlock(Directory)}.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new FacetLabel());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ae0982c0457fa3cfe0cda93a327c573fbe6f874","date":1507039114,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link UTF8TaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new FacetLabel());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link Cl2oTaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new FacetLabel());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"feb4029567b43f074ed7b6eb8fb126d355075dfd","date":1544812585,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#DirectoryTaxonomyWriter(Directory,OpenMode,TaxonomyWriterCache).mjava","sourceNew":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link UTF8TaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.getDocStats().maxDoc;\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new FacetLabel());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a Taxonomy writer.\n   * \n   * @param directory\n   *    The {@link Directory} in which to store the taxonomy. Note that\n   *    the taxonomy is written directly to that directory (not to a\n   *    subdirectory of it).\n   * @param openMode\n   *    Specifies how to open a taxonomy for writing: <code>APPEND</code>\n   *    means open an existing index for append (failing if the index does\n   *    not yet exist). <code>CREATE</code> means create a new index (first\n   *    deleting the old one if it already existed).\n   *    <code>APPEND_OR_CREATE</code> appends to an existing index if there\n   *    is one, otherwise it creates a new index.\n   * @param cache\n   *    A {@link TaxonomyWriterCache} implementation which determines\n   *    the in-memory caching policy. See for example\n   *    {@link LruTaxonomyWriterCache} and {@link UTF8TaxonomyWriterCache}.\n   *    If null or missing, {@link #defaultTaxonomyWriterCache()} is used.\n   * @throws CorruptIndexException\n   *     if the taxonomy is corrupted.\n   * @throws LockObtainFailedException\n   *     if the taxonomy is locked by another writer.\n   * @throws IOException\n   *     if another error occurred.\n   */\n  public DirectoryTaxonomyWriter(Directory directory, OpenMode openMode,\n      TaxonomyWriterCache cache) throws IOException {\n\n    dir = directory;\n    IndexWriterConfig config = createIndexWriterConfig(openMode);\n    indexWriter = openIndexWriter(dir, config);\n\n    // verify (to some extent) that merge policy in effect would preserve category docids \n    assert !(indexWriter.getConfig().getMergePolicy() instanceof TieredMergePolicy) : \n      \"for preserving category docids, merging none-adjacent segments is not allowed\";\n    \n    // after we opened the writer, and the index is locked, it's safe to check\n    // the commit data and read the index epoch\n    openMode = config.getOpenMode();\n    if (!DirectoryReader.indexExists(directory)) {\n      indexEpoch = 1;\n    } else {\n      String epochStr = null;\n      Map<String, String> commitData = readCommitData(directory);\n      if (commitData != null) {\n        epochStr = commitData.get(INDEX_EPOCH);\n      }\n      // no commit data, or no epoch in it means an old taxonomy, so set its epoch to 1, for lack\n      // of a better value.\n      indexEpoch = epochStr == null ? 1 : Long.parseLong(epochStr, 16);\n    }\n    \n    if (openMode == OpenMode.CREATE) {\n      ++indexEpoch;\n    }\n    \n    FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);\n    ft.setOmitNorms(true);\n    parentStreamField = new Field(Consts.FIELD_PAYLOADS, parentStream, ft);\n    fullPathField = new StringField(Consts.FULL, \"\", Field.Store.YES);\n\n    nextID = indexWriter.maxDoc();\n\n    if (cache == null) {\n      cache = defaultTaxonomyWriterCache();\n    }\n    this.cache = cache;\n\n    if (nextID == 0) {\n      cacheIsComplete = true;\n      // Make sure that the taxonomy always contain the root category\n      // with category id 0.\n      addCategory(new FacetLabel());\n    } else {\n      // There are some categories on the disk, which we have not yet\n      // read into the cache, and therefore the cache is incomplete.\n      // We choose not to read all the categories into the cache now,\n      // to avoid terrible performance when a taxonomy index is opened\n      // to add just a single category. We will do it later, after we\n      // notice a few cache misses.\n      cacheIsComplete = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ae0982c0457fa3cfe0cda93a327c573fbe6f874":["fafd23b8e49a461cdbc22b302dfdea2f2a08d953"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["78e3613d9274c0d98ca67d976e415c82e9f9cf46","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"d8a0be2353a06d1424e3eeafc4c72455204ce92d":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"c1891ff130d9d54192377049a0bdfac6326df16f":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683"],"56d44586f4c409c6c6c5942b9f0227df806b7300":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"119bc02554a192b2954b73d79389ec441257b624":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"fafd23b8e49a461cdbc22b302dfdea2f2a08d953":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["d8a0be2353a06d1424e3eeafc4c72455204ce92d"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["6e771d3bb64bb6db325ca1c015b256d08ad74424"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"feb4029567b43f074ed7b6eb8fb126d355075dfd":["2ae0982c0457fa3cfe0cda93a327c573fbe6f874"],"78e3613d9274c0d98ca67d976e415c82e9f9cf46":["c1891ff130d9d54192377049a0bdfac6326df16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6e771d3bb64bb6db325ca1c015b256d08ad74424":["119bc02554a192b2954b73d79389ec441257b624"],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["d8a0be2353a06d1424e3eeafc4c72455204ce92d","56d44586f4c409c6c6c5942b9f0227df806b7300"],"ef0d8a69209261514c5739c770bba706c2308450":["b89678825b68eccaf09e6ab71675fc0b0af1e099","119bc02554a192b2954b73d79389ec441257b624"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["feb4029567b43f074ed7b6eb8fb126d355075dfd"]},"commit2Childs":{"2ae0982c0457fa3cfe0cda93a327c573fbe6f874":["feb4029567b43f074ed7b6eb8fb126d355075dfd"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"d8a0be2353a06d1424e3eeafc4c72455204ce92d":["c190847801a50f4dd20fd639bdc29b54ea3b288b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"c1891ff130d9d54192377049a0bdfac6326df16f":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"56d44586f4c409c6c6c5942b9f0227df806b7300":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"119bc02554a192b2954b73d79389ec441257b624":["6e771d3bb64bb6db325ca1c015b256d08ad74424","ef0d8a69209261514c5739c770bba706c2308450"],"fafd23b8e49a461cdbc22b302dfdea2f2a08d953":["2ae0982c0457fa3cfe0cda93a327c573fbe6f874"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["56d44586f4c409c6c6c5942b9f0227df806b7300"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d8a0be2353a06d1424e3eeafc4c72455204ce92d"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["119bc02554a192b2954b73d79389ec441257b624","ef0d8a69209261514c5739c770bba706c2308450"],"feb4029567b43f074ed7b6eb8fb126d355075dfd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"78e3613d9274c0d98ca67d976e415c82e9f9cf46":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"6e771d3bb64bb6db325ca1c015b256d08ad74424":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["c1891ff130d9d54192377049a0bdfac6326df16f"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["fafd23b8e49a461cdbc22b302dfdea2f2a08d953"],"ef0d8a69209261514c5739c770bba706c2308450":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","ef0d8a69209261514c5739c770bba706c2308450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}