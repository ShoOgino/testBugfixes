{"path":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45","date":1342645458,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n    this.optIterator = optScorer.iterator();\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0","date":1514294096,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    this.reqMaxScore = reqScorer.maxScore();\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    final DocIdSetIterator reqApproximation;\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation= reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation= optTwoPhase.approximation();\n    }\n\n    approximation = new DocIdSetIterator() {\n\n      private int nextCommonDoc(int reqDoc) throws IOException {\n        int optDoc = optApproximation.docID();\n        if (optDoc > reqDoc) {\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n\n        while (true) { // invariant: reqDoc >= optDoc\n          if (reqDoc == optDoc) {\n            return reqDoc;\n          }\n\n          optDoc = optApproximation.advance(reqDoc);\n          if (optDoc == reqDoc) {\n            return reqDoc;\n          }\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        int doc = reqApproximation.nextDoc();\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        int doc = reqApproximation.advance(target);\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return reqApproximation.docID();\n      }\n\n      @Override\n      public long cost() {\n        return reqApproximation.cost();\n      }\n\n    };\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n    this.optIterator = optScorer.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c5054bf15748079a041f921a9178e8fe84f1806","date":1514554505,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    this.reqMaxScore = reqScorer.maxScore();\n    this.maxScorePropagator = new MaxScoreSumPropagator(Arrays.asList(reqScorer, optScorer));\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    final DocIdSetIterator reqApproximation;\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation= reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation= optTwoPhase.approximation();\n    }\n\n    approximation = new DocIdSetIterator() {\n\n      private int nextCommonDoc(int reqDoc) throws IOException {\n        int optDoc = optApproximation.docID();\n        if (optDoc > reqDoc) {\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n\n        while (true) { // invariant: reqDoc >= optDoc\n          if (reqDoc == optDoc) {\n            return reqDoc;\n          }\n\n          optDoc = optApproximation.advance(reqDoc);\n          if (optDoc == reqDoc) {\n            return reqDoc;\n          }\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        int doc = reqApproximation.nextDoc();\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        int doc = reqApproximation.advance(target);\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return reqApproximation.docID();\n      }\n\n      @Override\n      public long cost() {\n        return reqApproximation.cost();\n      }\n\n    };\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    this.reqMaxScore = reqScorer.maxScore();\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    final DocIdSetIterator reqApproximation;\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation= reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation= optTwoPhase.approximation();\n    }\n\n    approximation = new DocIdSetIterator() {\n\n      private int nextCommonDoc(int reqDoc) throws IOException {\n        int optDoc = optApproximation.docID();\n        if (optDoc > reqDoc) {\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n\n        while (true) { // invariant: reqDoc >= optDoc\n          if (reqDoc == optDoc) {\n            return reqDoc;\n          }\n\n          optDoc = optApproximation.advance(reqDoc);\n          if (optDoc == reqDoc) {\n            return reqDoc;\n          }\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        int doc = reqApproximation.nextDoc();\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        int doc = reqApproximation.advance(target);\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return reqApproximation.docID();\n      }\n\n      @Override\n      public long cost() {\n        return reqApproximation.cost();\n      }\n\n    };\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"523cc6563c99a55527ef7993efc5413c6648852d","date":1518704038,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer) throws IOException\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    this.reqMaxScore = reqScorer.getMaxScore(DocIdSetIterator.NO_MORE_DOCS);\n    this.maxScorePropagator = new MaxScoreSumPropagator(Arrays.asList(reqScorer, optScorer));\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    final DocIdSetIterator reqApproximation;\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation= reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation= optTwoPhase.approximation();\n    }\n\n    approximation = new DocIdSetIterator() {\n\n      private int nextCommonDoc(int reqDoc) throws IOException {\n        int optDoc = optApproximation.docID();\n        if (optDoc > reqDoc) {\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n\n        while (true) { // invariant: reqDoc >= optDoc\n          if (reqDoc == optDoc) {\n            return reqDoc;\n          }\n\n          optDoc = optApproximation.advance(reqDoc);\n          if (optDoc == reqDoc) {\n            return reqDoc;\n          }\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        int doc = reqApproximation.nextDoc();\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        int doc = reqApproximation.advance(target);\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return reqApproximation.docID();\n      }\n\n      @Override\n      public long cost() {\n        return reqApproximation.cost();\n      }\n\n    };\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer)\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    this.reqMaxScore = reqScorer.maxScore();\n    this.maxScorePropagator = new MaxScoreSumPropagator(Arrays.asList(reqScorer, optScorer));\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    final DocIdSetIterator reqApproximation;\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation= reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation= optTwoPhase.approximation();\n    }\n\n    approximation = new DocIdSetIterator() {\n\n      private int nextCommonDoc(int reqDoc) throws IOException {\n        int optDoc = optApproximation.docID();\n        if (optDoc > reqDoc) {\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n\n        while (true) { // invariant: reqDoc >= optDoc\n          if (reqDoc == optDoc) {\n            return reqDoc;\n          }\n\n          optDoc = optApproximation.advance(reqDoc);\n          if (optDoc == reqDoc) {\n            return reqDoc;\n          }\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        int doc = reqApproximation.nextDoc();\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        int doc = reqApproximation.advance(target);\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return reqApproximation.docID();\n      }\n\n      @Override\n      public long cost() {\n        return reqApproximation.cost();\n      }\n\n    };\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9d936767cccf71f03b9fe4ee80cb70e2dc39dd9","date":1525274442,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer) throws IOException\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    reqScorer.advanceShallow(0);\n    this.reqMaxScore = reqScorer.getMaxScore(DocIdSetIterator.NO_MORE_DOCS);\n    this.maxScorePropagator = new MaxScoreSumPropagator(Arrays.asList(reqScorer, optScorer));\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    final DocIdSetIterator reqApproximation;\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation= reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation= optTwoPhase.approximation();\n    }\n\n    approximation = new DocIdSetIterator() {\n\n      private int nextCommonDoc(int reqDoc) throws IOException {\n        int optDoc = optApproximation.docID();\n        if (optDoc > reqDoc) {\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n\n        while (true) { // invariant: reqDoc >= optDoc\n          if (reqDoc == optDoc) {\n            return reqDoc;\n          }\n\n          optDoc = optApproximation.advance(reqDoc);\n          if (optDoc == reqDoc) {\n            return reqDoc;\n          }\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        int doc = reqApproximation.nextDoc();\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        int doc = reqApproximation.advance(target);\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return reqApproximation.docID();\n      }\n\n      @Override\n      public long cost() {\n        return reqApproximation.cost();\n      }\n\n    };\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer) throws IOException\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    this.reqMaxScore = reqScorer.getMaxScore(DocIdSetIterator.NO_MORE_DOCS);\n    this.maxScorePropagator = new MaxScoreSumPropagator(Arrays.asList(reqScorer, optScorer));\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    final DocIdSetIterator reqApproximation;\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation= reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation= optTwoPhase.approximation();\n    }\n\n    approximation = new DocIdSetIterator() {\n\n      private int nextCommonDoc(int reqDoc) throws IOException {\n        int optDoc = optApproximation.docID();\n        if (optDoc > reqDoc) {\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n\n        while (true) { // invariant: reqDoc >= optDoc\n          if (reqDoc == optDoc) {\n            return reqDoc;\n          }\n\n          optDoc = optApproximation.advance(reqDoc);\n          if (optDoc == reqDoc) {\n            return reqDoc;\n          }\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        int doc = reqApproximation.nextDoc();\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        int doc = reqApproximation.advance(target);\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return reqApproximation.docID();\n      }\n\n      @Override\n      public long cost() {\n        return reqApproximation.cost();\n      }\n\n    };\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd80b885e3e9bdc61935e784f634562d13b81979","date":1533736198,"type":5,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer,ScoreMode).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /**\n   * Construct a <code>ReqOptScorer</code>.\n   *\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   * @param scoreMode  How the produced scorers will be consumed.\n   */\n  public ReqOptSumScorer(Scorer reqScorer, Scorer optScorer, ScoreMode scoreMode) throws IOException {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation = reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation = optTwoPhase.approximation();\n    }\n    if (scoreMode != ScoreMode.TOP_SCORES) {\n      approximation = reqApproximation;\n      this.reqMaxScore = Float.POSITIVE_INFINITY;\n    } else {\n      reqScorer.advanceShallow(0);\n      optScorer.advanceShallow(0);\n      this.reqMaxScore = reqScorer.getMaxScore(NO_MORE_DOCS);\n      this.approximation = new DocIdSetIterator() {\n        int upTo = -1;\n        float maxScore;\n\n        private void moveToNextBlock(int target) throws IOException {\n          upTo = advanceShallow(target);\n          float reqMaxScoreBlock = reqScorer.getMaxScore(upTo);\n          maxScore = getMaxScore(upTo);\n\n          // Potentially move to a conjunction\n          optIsRequired = reqMaxScoreBlock < minScore;\n        }\n\n        private int advanceImpacts(int target) throws IOException {\n          if (target > upTo) {\n            moveToNextBlock(target);\n          }\n\n          while (true) {\n            if (maxScore >= minScore) {\n              return target;\n            }\n\n            if (upTo == NO_MORE_DOCS) {\n              return NO_MORE_DOCS;\n            }\n\n            target = upTo + 1;\n\n            moveToNextBlock(target);\n          }\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advanceInternal(reqApproximation.docID()+1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          return advanceInternal(target);\n        }\n\n        private int advanceInternal(int target) throws IOException {\n          if (target == NO_MORE_DOCS) {\n            reqApproximation.advance(target);\n            return NO_MORE_DOCS;\n          }\n          int reqDoc = target;\n          advanceHead: for (;;) {\n            if (minScore != 0) {\n              reqDoc = advanceImpacts(reqDoc);\n            }\n            if (reqApproximation.docID() < reqDoc) {\n              reqDoc = reqApproximation.advance(reqDoc);\n            }\n            if (reqDoc == NO_MORE_DOCS || optIsRequired == false) {\n              return reqDoc;\n            }\n\n            int upperBound = reqMaxScore < minScore ? NO_MORE_DOCS : upTo;\n            if (reqDoc > upperBound) {\n              continue;\n            }\n\n            // Find the next common doc within the current block\n            for (;;) { // invariant: reqDoc >= optDoc\n              int optDoc = optApproximation.docID();\n              if (optDoc < reqDoc) {\n                optDoc = optApproximation.advance(reqDoc);\n              }\n              if (optDoc > upperBound) {\n                reqDoc = upperBound + 1;\n                continue advanceHead;\n              }\n\n              if (optDoc != reqDoc) {\n                reqDoc = reqApproximation.advance(optDoc);\n                if (reqDoc > upperBound) {\n                  continue advanceHead;\n                }\n              }\n\n              if (reqDoc == NO_MORE_DOCS || optDoc == reqDoc) {\n                return reqDoc;\n              }\n            }\n          }\n        }\n\n        @Override\n        public int docID() {\n          return reqApproximation.docID();\n        }\n\n        @Override\n        public long cost() {\n          return reqApproximation.cost();\n        }\n      };\n    }\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer) throws IOException\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    reqScorer.advanceShallow(0);\n    this.reqMaxScore = reqScorer.getMaxScore(DocIdSetIterator.NO_MORE_DOCS);\n    this.maxScorePropagator = new MaxScoreSumPropagator(Arrays.asList(reqScorer, optScorer));\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    final DocIdSetIterator reqApproximation;\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation= reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation= optTwoPhase.approximation();\n    }\n\n    approximation = new DocIdSetIterator() {\n\n      private int nextCommonDoc(int reqDoc) throws IOException {\n        int optDoc = optApproximation.docID();\n        if (optDoc > reqDoc) {\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n\n        while (true) { // invariant: reqDoc >= optDoc\n          if (reqDoc == optDoc) {\n            return reqDoc;\n          }\n\n          optDoc = optApproximation.advance(reqDoc);\n          if (optDoc == reqDoc) {\n            return reqDoc;\n          }\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        int doc = reqApproximation.nextDoc();\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        int doc = reqApproximation.advance(target);\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return reqApproximation.docID();\n      }\n\n      @Override\n      public long cost() {\n        return reqApproximation.cost();\n      }\n\n    };\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aba371508186796cc6151d8223a5b4e16d02e26e":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45"],"ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b9d936767cccf71f03b9fe4ee80cb70e2dc39dd9":["523cc6563c99a55527ef7993efc5413c6648852d"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45"],"523cc6563c99a55527ef7993efc5413c6648852d":["3c5054bf15748079a041f921a9178e8fe84f1806"],"3c5054bf15748079a041f921a9178e8fe84f1806":["a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0"],"fd80b885e3e9bdc61935e784f634562d13b81979":["b9d936767cccf71f03b9fe4ee80cb70e2dc39dd9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fd80b885e3e9bdc61935e784f634562d13b81979"],"a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0":["7dd748bb245633a8195281556bb0e68a6ea97d18"]},"commit2Childs":{"aba371508186796cc6151d8223a5b4e16d02e26e":[],"ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","7dd748bb245633a8195281556bb0e68a6ea97d18"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["aba371508186796cc6151d8223a5b4e16d02e26e","ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b9d936767cccf71f03b9fe4ee80cb70e2dc39dd9":["fd80b885e3e9bdc61935e784f634562d13b81979"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0"],"523cc6563c99a55527ef7993efc5413c6648852d":["b9d936767cccf71f03b9fe4ee80cb70e2dc39dd9"],"3c5054bf15748079a041f921a9178e8fe84f1806":["523cc6563c99a55527ef7993efc5413c6648852d"],"fd80b885e3e9bdc61935e784f634562d13b81979":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3f6e835e5d9dd77ae3684fd58db9dc00fb01ec0":["3c5054bf15748079a041f921a9178e8fe84f1806"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}