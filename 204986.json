{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#populateNextCursorMarkFromTopDocs(QueryResult,QueryCommand,TopDocs).mjava","commits":[{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#populateNextCursorMarkFromTopDocs(QueryResult,QueryCommand,TopDocs).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Helper method for extracting the {@link FieldDoc} sort values from a \n   * {@link TopFieldDocs} when available and making the appropriate call to \n   * {@link QueryResult#setNextCursorMark} when applicable.\n   *\n   * @param qr <code>QueryResult</code> to modify\n   * @param qc <code>QueryCommand</code> for context of method\n   * @param topDocs May or may not be a <code>TopFieldDocs</code> \n   */\n  private void populateNextCursorMarkFromTopDocs(QueryResult qr, QueryCommand qc, \n                                                 TopDocs topDocs) {\n    // TODO: would be nice to rename & generalize this method for non-cursor cases...\n    // ...would be handy to reuse the ScoreDoc/FieldDoc sort vals directly in distrib sort\n    // ...but that has non-trivial queryResultCache implications\n    // See: SOLR-5595\n    \n    if (null == qc.getCursorMark()) {\n      // nothing to do, short circuit out\n      return;\n    }\n\n    final CursorMark lastCursorMark = qc.getCursorMark();\n    \n    // if we have a cursor, then we have a sort that at minimum involves uniqueKey..\n    // so we must have a TopFieldDocs containing FieldDoc[]\n    assert topDocs instanceof TopFieldDocs : \"TopFieldDocs cursor constraint violated\";\n    final TopFieldDocs topFieldDocs = (TopFieldDocs) topDocs;\n    final ScoreDoc[] scoreDocs = topFieldDocs.scoreDocs;\n\n    if (0 == scoreDocs.length) {\n      // no docs on this page, re-use existing cursor mark\n      qr.setNextCursorMark(lastCursorMark);\n    } else {\n      ScoreDoc lastDoc = scoreDocs[scoreDocs.length-1];\n      assert lastDoc instanceof FieldDoc : \"FieldDoc cursor constraint violated\";\n      \n      List<Object> lastFields = Arrays.<Object>asList(((FieldDoc)lastDoc).fields);\n      CursorMark nextCursorMark = lastCursorMark.createNext(lastFields);\n      assert null != nextCursorMark : \"null nextCursorMark\";\n      qr.setNextCursorMark(nextCursorMark);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#populateNextCursorMarkFromTopDocs(QueryResult,QueryCommand,TopDocs).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#populateNextCursorMarkFromTopDocs(QueryResult,QueryCommand,TopDocs).mjava","sourceNew":"  /**\n   * Helper method for extracting the {@link FieldDoc} sort values from a {@link TopFieldDocs} when available and making\n   * the appropriate call to {@link QueryResult#setNextCursorMark} when applicable.\n   *\n   * @param qr\n   *          <code>QueryResult</code> to modify\n   * @param qc\n   *          <code>QueryCommand</code> for context of method\n   * @param topDocs\n   *          May or may not be a <code>TopFieldDocs</code>\n   */\n  private void populateNextCursorMarkFromTopDocs(QueryResult qr, QueryCommand qc, TopDocs topDocs) {\n    // TODO: would be nice to rename & generalize this method for non-cursor cases...\n    // ...would be handy to reuse the ScoreDoc/FieldDoc sort vals directly in distrib sort\n    // ...but that has non-trivial queryResultCache implications\n    // See: SOLR-5595\n\n    if (null == qc.getCursorMark()) {\n      // nothing to do, short circuit out\n      return;\n    }\n\n    final CursorMark lastCursorMark = qc.getCursorMark();\n\n    // if we have a cursor, then we have a sort that at minimum involves uniqueKey..\n    // so we must have a TopFieldDocs containing FieldDoc[]\n    assert topDocs instanceof TopFieldDocs : \"TopFieldDocs cursor constraint violated\";\n    final TopFieldDocs topFieldDocs = (TopFieldDocs) topDocs;\n    final ScoreDoc[] scoreDocs = topFieldDocs.scoreDocs;\n\n    if (0 == scoreDocs.length) {\n      // no docs on this page, re-use existing cursor mark\n      qr.setNextCursorMark(lastCursorMark);\n    } else {\n      ScoreDoc lastDoc = scoreDocs[scoreDocs.length - 1];\n      assert lastDoc instanceof FieldDoc : \"FieldDoc cursor constraint violated\";\n\n      List<Object> lastFields = Arrays.<Object> asList(((FieldDoc) lastDoc).fields);\n      CursorMark nextCursorMark = lastCursorMark.createNext(lastFields);\n      assert null != nextCursorMark : \"null nextCursorMark\";\n      qr.setNextCursorMark(nextCursorMark);\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method for extracting the {@link FieldDoc} sort values from a \n   * {@link TopFieldDocs} when available and making the appropriate call to \n   * {@link QueryResult#setNextCursorMark} when applicable.\n   *\n   * @param qr <code>QueryResult</code> to modify\n   * @param qc <code>QueryCommand</code> for context of method\n   * @param topDocs May or may not be a <code>TopFieldDocs</code> \n   */\n  private void populateNextCursorMarkFromTopDocs(QueryResult qr, QueryCommand qc, \n                                                 TopDocs topDocs) {\n    // TODO: would be nice to rename & generalize this method for non-cursor cases...\n    // ...would be handy to reuse the ScoreDoc/FieldDoc sort vals directly in distrib sort\n    // ...but that has non-trivial queryResultCache implications\n    // See: SOLR-5595\n    \n    if (null == qc.getCursorMark()) {\n      // nothing to do, short circuit out\n      return;\n    }\n\n    final CursorMark lastCursorMark = qc.getCursorMark();\n    \n    // if we have a cursor, then we have a sort that at minimum involves uniqueKey..\n    // so we must have a TopFieldDocs containing FieldDoc[]\n    assert topDocs instanceof TopFieldDocs : \"TopFieldDocs cursor constraint violated\";\n    final TopFieldDocs topFieldDocs = (TopFieldDocs) topDocs;\n    final ScoreDoc[] scoreDocs = topFieldDocs.scoreDocs;\n\n    if (0 == scoreDocs.length) {\n      // no docs on this page, re-use existing cursor mark\n      qr.setNextCursorMark(lastCursorMark);\n    } else {\n      ScoreDoc lastDoc = scoreDocs[scoreDocs.length-1];\n      assert lastDoc instanceof FieldDoc : \"FieldDoc cursor constraint violated\";\n      \n      List<Object> lastFields = Arrays.<Object>asList(((FieldDoc)lastDoc).fields);\n      CursorMark nextCursorMark = lastCursorMark.createNext(lastFields);\n      assert null != nextCursorMark : \"null nextCursorMark\";\n      qr.setNextCursorMark(nextCursorMark);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"]},"commit2Childs":{"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}