{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.RestartThread#run().mjava","commits":[{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.RestartThread#run().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication.RestartThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      List<Thread> startupThreads = Collections.synchronizedList(new ArrayList<>());\n\n      try {\n        while (stop.get() == false) {\n          Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n          message(\"top: restarter cycle\");\n\n          // Randomly crash full cluster:\n          if (DO_FULL_CLUSTER_CRASH && random().nextInt(50) == 17) {\n            message(\"top: full cluster crash\");\n            for(int i=0;i<nodes.length;i++) {\n              if (starting[i]) {\n                message(\"N\" + i + \": top: wait for startup so we can crash...\");\n                while (starting[i]) {\n                  Thread.sleep(10);\n                }\n                message(\"N\" + i + \": top: done wait for startup\");\n              }\n              NodeProcess node = nodes[i];\n              if (node != null) {\n                crashingNodes.add(i);\n                message(\"top: N\" + node.id + \": top: now crash node\");\n                node.crash();\n                message(\"top: N\" + node.id + \": top: done crash node\");\n              }\n            }\n          }\n\n          List<Integer> downNodes = new ArrayList<>();\n          StringBuilder b = new StringBuilder();\n          long nowNS = System.nanoTime();\n          for(int i=0;i<nodes.length;i++) {\n            b.append(' ');\n            double sec = (nowNS - nodeTimeStamps[i])/1000000000.0;\n            String prefix;\n            if (nodes[i] == null) {\n              downNodes.add(i);\n              if (starting[i]) {\n                prefix = \"s\";\n              } else {\n                prefix = \"x\";\n              }\n            } else {\n              prefix = \"\";\n            }\n            if (primary != null && nodes[i] == primary) {\n              prefix += \"p\";\n            }\n            b.append(String.format(Locale.ROOT, \"%s%d(%.1fs)\", prefix, i, sec));\n          }\n          message(\"node status\" + b.toString());\n          message(\"downNodes=\" + downNodes);\n\n          // If primary is down, promote a replica:\n          if (primary == null) {\n            if (anyNodesStarting()) {\n              message(\"top: skip promote replica: nodes are still starting\");\n              continue;\n            }\n            promoteReplica();\n          }\n\n          // Randomly start up a down a replica:\n\n          // Stop or start a replica\n          if (downNodes.isEmpty() == false) {\n            int idx = downNodes.get(random().nextInt(downNodes.size()));\n            if (starting[idx] == false) {\n              if (primary == null) {\n                if (downNodes.size() == nodes.length) {\n                  // Cold start: entire cluster is down, start this node up as the new primary\n                  message(\"N\" + idx + \": top: cold start as primary\");\n                  startPrimary(idx);\n                }\n              } else if (random().nextDouble() < ((double) downNodes.size())/nodes.length) {\n                // Start up replica:\n                starting[idx] = true;\n                message(\"N\" + idx + \": top: start up: launch thread\");\n                Thread t = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        message(\"N\" + idx + \": top: start up thread\");\n                        nodes[idx] = startNode(idx, indexPaths[idx], false, -1);\n                        sendReplicasToPrimary();\n                      } catch (Throwable t) {\n                        failed.set(true);\n                        stop.set(true);\n                        throw new RuntimeException(t);\n                      } finally {\n                        starting[idx] = false;\n                        startupThreads.remove(Thread.currentThread());\n                      }\n                    }\n                  };\n                t.setName(\"start R\" + idx);\n                t.start();\n                startupThreads.add(t);\n              }\n            } else {\n              message(\"node \" + idx + \" still starting\");\n            }\n          }\n        }\n\n        System.out.println(\"Restarter: now stop: join \" + startupThreads.size() + \" startup threads\");\n\n        while (startupThreads.size() > 0) {\n          Thread.sleep(10);\n        }\n\n      } catch (Throwable t) {\n        failed.set(true);\n        stop.set(true);\n        throw new RuntimeException(t);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      List<Thread> startupThreads = Collections.synchronizedList(new ArrayList<>());\n\n      try {\n        while (stop.get() == false) {\n          Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n          message(\"top: restarter cycle\");\n\n          // Randomly crash full cluster:\n          if (DO_FULL_CLUSTER_CRASH && random().nextInt(50) == 17) {\n            message(\"top: full cluster crash\");\n            for(int i=0;i<nodes.length;i++) {\n              if (starting[i]) {\n                message(\"N\" + i + \": top: wait for startup so we can crash...\");\n                while (starting[i]) {\n                  Thread.sleep(10);\n                }\n                message(\"N\" + i + \": top: done wait for startup\");\n              }\n              NodeProcess node = nodes[i];\n              if (node != null) {\n                crashingNodes.add(i);\n                message(\"top: N\" + node.id + \": top: now crash node\");\n                node.crash();\n                message(\"top: N\" + node.id + \": top: done crash node\");\n              }\n            }\n          }\n\n          List<Integer> downNodes = new ArrayList<>();\n          StringBuilder b = new StringBuilder();\n          long nowNS = System.nanoTime();\n          for(int i=0;i<nodes.length;i++) {\n            b.append(' ');\n            double sec = (nowNS - nodeTimeStamps[i])/1000000000.0;\n            String prefix;\n            if (nodes[i] == null) {\n              downNodes.add(i);\n              if (starting[i]) {\n                prefix = \"s\";\n              } else {\n                prefix = \"x\";\n              }\n            } else {\n              prefix = \"\";\n            }\n            if (primary != null && nodes[i] == primary) {\n              prefix += \"p\";\n            }\n            b.append(String.format(Locale.ROOT, \"%s%d(%.1fs)\", prefix, i, sec));\n          }\n          message(\"node status\" + b.toString());\n          message(\"downNodes=\" + downNodes);\n\n          // If primary is down, promote a replica:\n          if (primary == null) {\n            if (anyNodesStarting()) {\n              message(\"top: skip promote replica: nodes are still starting\");\n              continue;\n            }\n            promoteReplica();\n          }\n\n          // Randomly start up a down a replica:\n\n          // Stop or start a replica\n          if (downNodes.isEmpty() == false) {\n            int idx = downNodes.get(random().nextInt(downNodes.size()));\n            if (starting[idx] == false) {\n              if (primary == null) {\n                if (downNodes.size() == nodes.length) {\n                  // Cold start: entire cluster is down, start this node up as the new primary\n                  message(\"N\" + idx + \": top: cold start as primary\");\n                  startPrimary(idx);\n                }\n              } else if (random().nextDouble() < ((double) downNodes.size())/nodes.length) {\n                // Start up replica:\n                starting[idx] = true;\n                message(\"N\" + idx + \": top: start up: launch thread\");\n                Thread t = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        message(\"N\" + idx + \": top: start up thread\");\n                        nodes[idx] = startNode(idx, indexPaths[idx], false, -1);\n                        sendReplicasToPrimary();\n                      } catch (Throwable t) {\n                        failed.set(true);\n                        stop.set(true);\n                        throw new RuntimeException(t);\n                      } finally {\n                        starting[idx] = false;\n                        startupThreads.remove(Thread.currentThread());\n                      }\n                    }\n                  };\n                t.setName(\"start R\" + idx);\n                t.start();\n                startupThreads.add(t);\n              }\n            } else {\n              message(\"node \" + idx + \" still starting\");\n            }\n          }\n        }\n\n        System.out.println(\"Restarter: now stop: join \" + startupThreads.size() + \" startup threads\");\n\n        while (startupThreads.size() > 0) {\n          Thread.sleep(10);\n        }\n\n      } catch (Throwable t) {\n        failed.set(true);\n        stop.set(true);\n        throw new RuntimeException(t);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.RestartThread#run().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.RestartThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      List<Thread> startupThreads = Collections.synchronizedList(new ArrayList<>());\n\n      try {\n        while (stop.get() == false) {\n          Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n          message(\"top: restarter cycle\");\n\n          // Randomly crash full cluster:\n          if (DO_FULL_CLUSTER_CRASH && random().nextInt(500) == 17) {\n            message(\"top: full cluster crash\");\n            for(int i=0;i<nodes.length;i++) {\n              if (starting[i]) {\n                message(\"N\" + i + \": top: wait for startup so we can crash...\");\n                while (starting[i]) {\n                  Thread.sleep(10);\n                }\n                message(\"N\" + i + \": top: done wait for startup\");\n              }\n              NodeProcess node = nodes[i];\n              if (node != null) {\n                crashingNodes.add(i);\n                message(\"top: N\" + node.id + \": top: now crash node\");\n                node.crash();\n                message(\"top: N\" + node.id + \": top: done crash node\");\n              }\n            }\n          }\n\n          List<Integer> downNodes = new ArrayList<>();\n          StringBuilder b = new StringBuilder();\n          long nowNS = System.nanoTime();\n          for(int i=0;i<nodes.length;i++) {\n            b.append(' ');\n            double sec = (nowNS - nodeTimeStamps[i])/1000000000.0;\n            String prefix;\n            if (nodes[i] == null) {\n              downNodes.add(i);\n              if (starting[i]) {\n                prefix = \"s\";\n              } else {\n                prefix = \"x\";\n              }\n            } else {\n              prefix = \"\";\n            }\n            if (primary != null && nodes[i] == primary) {\n              prefix += \"p\";\n            }\n            b.append(String.format(Locale.ROOT, \"%s%d(%.1fs)\", prefix, i, sec));\n          }\n          message(\"node status\" + b.toString());\n          message(\"downNodes=\" + downNodes);\n\n          // If primary is down, promote a replica:\n          if (primary == null) {\n            if (anyNodesStarting()) {\n              message(\"top: skip promote replica: nodes are still starting\");\n              continue;\n            }\n            promoteReplica();\n          }\n\n          // Randomly start up a down a replica:\n\n          // Stop or start a replica\n          if (downNodes.isEmpty() == false) {\n            int idx = downNodes.get(random().nextInt(downNodes.size()));\n            if (starting[idx] == false) {\n              if (primary == null) {\n                if (downNodes.size() == nodes.length) {\n                  // Cold start: entire cluster is down, start this node up as the new primary\n                  message(\"N\" + idx + \": top: cold start as primary\");\n                  startPrimary(idx);\n                }\n              } else if (random().nextDouble() < ((double) downNodes.size())/nodes.length) {\n                // Start up replica:\n                starting[idx] = true;\n                message(\"N\" + idx + \": top: start up: launch thread\");\n                Thread t = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        message(\"N\" + idx + \": top: start up thread\");\n                        nodes[idx] = startNode(idx, indexPaths[idx], false, -1);\n                        sendReplicasToPrimary();\n                      } catch (Throwable t) {\n                        failed.set(true);\n                        stop.set(true);\n                        throw new RuntimeException(t);\n                      } finally {\n                        starting[idx] = false;\n                        startupThreads.remove(Thread.currentThread());\n                      }\n                    }\n                  };\n                t.setName(\"start R\" + idx);\n                t.start();\n                startupThreads.add(t);\n              }\n            } else {\n              message(\"node \" + idx + \" still starting\");\n            }\n          }\n        }\n\n        System.out.println(\"Restarter: now stop: join \" + startupThreads.size() + \" startup threads\");\n\n        while (startupThreads.size() > 0) {\n          Thread.sleep(10);\n        }\n\n      } catch (Throwable t) {\n        failed.set(true);\n        stop.set(true);\n        throw new RuntimeException(t);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      List<Thread> startupThreads = Collections.synchronizedList(new ArrayList<>());\n\n      try {\n        while (stop.get() == false) {\n          Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n          message(\"top: restarter cycle\");\n\n          // Randomly crash full cluster:\n          if (DO_FULL_CLUSTER_CRASH && random().nextInt(50) == 17) {\n            message(\"top: full cluster crash\");\n            for(int i=0;i<nodes.length;i++) {\n              if (starting[i]) {\n                message(\"N\" + i + \": top: wait for startup so we can crash...\");\n                while (starting[i]) {\n                  Thread.sleep(10);\n                }\n                message(\"N\" + i + \": top: done wait for startup\");\n              }\n              NodeProcess node = nodes[i];\n              if (node != null) {\n                crashingNodes.add(i);\n                message(\"top: N\" + node.id + \": top: now crash node\");\n                node.crash();\n                message(\"top: N\" + node.id + \": top: done crash node\");\n              }\n            }\n          }\n\n          List<Integer> downNodes = new ArrayList<>();\n          StringBuilder b = new StringBuilder();\n          long nowNS = System.nanoTime();\n          for(int i=0;i<nodes.length;i++) {\n            b.append(' ');\n            double sec = (nowNS - nodeTimeStamps[i])/1000000000.0;\n            String prefix;\n            if (nodes[i] == null) {\n              downNodes.add(i);\n              if (starting[i]) {\n                prefix = \"s\";\n              } else {\n                prefix = \"x\";\n              }\n            } else {\n              prefix = \"\";\n            }\n            if (primary != null && nodes[i] == primary) {\n              prefix += \"p\";\n            }\n            b.append(String.format(Locale.ROOT, \"%s%d(%.1fs)\", prefix, i, sec));\n          }\n          message(\"node status\" + b.toString());\n          message(\"downNodes=\" + downNodes);\n\n          // If primary is down, promote a replica:\n          if (primary == null) {\n            if (anyNodesStarting()) {\n              message(\"top: skip promote replica: nodes are still starting\");\n              continue;\n            }\n            promoteReplica();\n          }\n\n          // Randomly start up a down a replica:\n\n          // Stop or start a replica\n          if (downNodes.isEmpty() == false) {\n            int idx = downNodes.get(random().nextInt(downNodes.size()));\n            if (starting[idx] == false) {\n              if (primary == null) {\n                if (downNodes.size() == nodes.length) {\n                  // Cold start: entire cluster is down, start this node up as the new primary\n                  message(\"N\" + idx + \": top: cold start as primary\");\n                  startPrimary(idx);\n                }\n              } else if (random().nextDouble() < ((double) downNodes.size())/nodes.length) {\n                // Start up replica:\n                starting[idx] = true;\n                message(\"N\" + idx + \": top: start up: launch thread\");\n                Thread t = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        message(\"N\" + idx + \": top: start up thread\");\n                        nodes[idx] = startNode(idx, indexPaths[idx], false, -1);\n                        sendReplicasToPrimary();\n                      } catch (Throwable t) {\n                        failed.set(true);\n                        stop.set(true);\n                        throw new RuntimeException(t);\n                      } finally {\n                        starting[idx] = false;\n                        startupThreads.remove(Thread.currentThread());\n                      }\n                    }\n                  };\n                t.setName(\"start R\" + idx);\n                t.start();\n                startupThreads.add(t);\n              }\n            } else {\n              message(\"node \" + idx + \" still starting\");\n            }\n          }\n        }\n\n        System.out.println(\"Restarter: now stop: join \" + startupThreads.size() + \" startup threads\");\n\n        while (startupThreads.size() > 0) {\n          Thread.sleep(10);\n        }\n\n      } catch (Throwable t) {\n        failed.set(true);\n        stop.set(true);\n        throw new RuntimeException(t);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fc4da33180d50cc1cad94d72b86d7d0459c1740","date":1454977102,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.RestartThread#run().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.RestartThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      List<Thread> startupThreads = Collections.synchronizedList(new ArrayList<>());\n\n      try {\n        while (stop.get() == false) {\n          Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n          //message(\"top: restarter cycle\");\n\n          // Randomly crash full cluster:\n          if (DO_FULL_CLUSTER_CRASH && random().nextInt(500) == 17) {\n            message(\"top: full cluster crash\");\n            for(int i=0;i<nodes.length;i++) {\n              if (starting[i]) {\n                message(\"N\" + i + \": top: wait for startup so we can crash...\");\n                while (starting[i]) {\n                  Thread.sleep(10);\n                }\n                message(\"N\" + i + \": top: done wait for startup\");\n              }\n              NodeProcess node = nodes[i];\n              if (node != null) {\n                crashingNodes.add(i);\n                message(\"top: N\" + node.id + \": top: now crash node\");\n                node.crash();\n                message(\"top: N\" + node.id + \": top: done crash node\");\n              }\n            }\n          }\n\n          List<Integer> downNodes = new ArrayList<>();\n          StringBuilder b = new StringBuilder();\n          long nowNS = System.nanoTime();\n          for(int i=0;i<nodes.length;i++) {\n            b.append(' ');\n            double sec = (nowNS - nodeTimeStamps[i])/1000000000.0;\n            String prefix;\n            if (nodes[i] == null) {\n              downNodes.add(i);\n              if (starting[i]) {\n                prefix = \"s\";\n              } else {\n                prefix = \"x\";\n              }\n            } else {\n              prefix = \"\";\n            }\n            if (primary != null && nodes[i] == primary) {\n              prefix += \"p\";\n            }\n            b.append(String.format(Locale.ROOT, \"%s%d(%.1fs)\", prefix, i, sec));\n          }\n          message(\"node status\" + b.toString());\n          message(\"downNodes=\" + downNodes);\n\n          // If primary is down, promote a replica:\n          if (primary == null) {\n            if (anyNodesStarting()) {\n              message(\"top: skip promote replica: nodes are still starting\");\n              continue;\n            }\n            promoteReplica();\n          }\n\n          // Randomly start up a down a replica:\n\n          // Stop or start a replica\n          if (downNodes.isEmpty() == false) {\n            int idx = downNodes.get(random().nextInt(downNodes.size()));\n            if (starting[idx] == false) {\n              if (primary == null) {\n                if (downNodes.size() == nodes.length) {\n                  // Cold start: entire cluster is down, start this node up as the new primary\n                  message(\"N\" + idx + \": top: cold start as primary\");\n                  startPrimary(idx);\n                }\n              } else if (random().nextDouble() < ((double) downNodes.size())/nodes.length) {\n                // Start up replica:\n                starting[idx] = true;\n                message(\"N\" + idx + \": top: start up: launch thread\");\n                Thread t = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        message(\"N\" + idx + \": top: start up thread\");\n                        nodes[idx] = startNode(idx, indexPaths[idx], false, -1);\n                        sendReplicasToPrimary();\n                      } catch (Throwable t) {\n                        failed.set(true);\n                        stop.set(true);\n                        throw new RuntimeException(t);\n                      } finally {\n                        starting[idx] = false;\n                        startupThreads.remove(Thread.currentThread());\n                      }\n                    }\n                  };\n                t.setName(\"start R\" + idx);\n                t.start();\n                startupThreads.add(t);\n              }\n            } else {\n              message(\"node \" + idx + \" still starting\");\n            }\n          }\n        }\n\n        System.out.println(\"Restarter: now stop: join \" + startupThreads.size() + \" startup threads\");\n\n        while (startupThreads.size() > 0) {\n          Thread.sleep(10);\n        }\n\n      } catch (Throwable t) {\n        failed.set(true);\n        stop.set(true);\n        throw new RuntimeException(t);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      List<Thread> startupThreads = Collections.synchronizedList(new ArrayList<>());\n\n      try {\n        while (stop.get() == false) {\n          Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n          message(\"top: restarter cycle\");\n\n          // Randomly crash full cluster:\n          if (DO_FULL_CLUSTER_CRASH && random().nextInt(500) == 17) {\n            message(\"top: full cluster crash\");\n            for(int i=0;i<nodes.length;i++) {\n              if (starting[i]) {\n                message(\"N\" + i + \": top: wait for startup so we can crash...\");\n                while (starting[i]) {\n                  Thread.sleep(10);\n                }\n                message(\"N\" + i + \": top: done wait for startup\");\n              }\n              NodeProcess node = nodes[i];\n              if (node != null) {\n                crashingNodes.add(i);\n                message(\"top: N\" + node.id + \": top: now crash node\");\n                node.crash();\n                message(\"top: N\" + node.id + \": top: done crash node\");\n              }\n            }\n          }\n\n          List<Integer> downNodes = new ArrayList<>();\n          StringBuilder b = new StringBuilder();\n          long nowNS = System.nanoTime();\n          for(int i=0;i<nodes.length;i++) {\n            b.append(' ');\n            double sec = (nowNS - nodeTimeStamps[i])/1000000000.0;\n            String prefix;\n            if (nodes[i] == null) {\n              downNodes.add(i);\n              if (starting[i]) {\n                prefix = \"s\";\n              } else {\n                prefix = \"x\";\n              }\n            } else {\n              prefix = \"\";\n            }\n            if (primary != null && nodes[i] == primary) {\n              prefix += \"p\";\n            }\n            b.append(String.format(Locale.ROOT, \"%s%d(%.1fs)\", prefix, i, sec));\n          }\n          message(\"node status\" + b.toString());\n          message(\"downNodes=\" + downNodes);\n\n          // If primary is down, promote a replica:\n          if (primary == null) {\n            if (anyNodesStarting()) {\n              message(\"top: skip promote replica: nodes are still starting\");\n              continue;\n            }\n            promoteReplica();\n          }\n\n          // Randomly start up a down a replica:\n\n          // Stop or start a replica\n          if (downNodes.isEmpty() == false) {\n            int idx = downNodes.get(random().nextInt(downNodes.size()));\n            if (starting[idx] == false) {\n              if (primary == null) {\n                if (downNodes.size() == nodes.length) {\n                  // Cold start: entire cluster is down, start this node up as the new primary\n                  message(\"N\" + idx + \": top: cold start as primary\");\n                  startPrimary(idx);\n                }\n              } else if (random().nextDouble() < ((double) downNodes.size())/nodes.length) {\n                // Start up replica:\n                starting[idx] = true;\n                message(\"N\" + idx + \": top: start up: launch thread\");\n                Thread t = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        message(\"N\" + idx + \": top: start up thread\");\n                        nodes[idx] = startNode(idx, indexPaths[idx], false, -1);\n                        sendReplicasToPrimary();\n                      } catch (Throwable t) {\n                        failed.set(true);\n                        stop.set(true);\n                        throw new RuntimeException(t);\n                      } finally {\n                        starting[idx] = false;\n                        startupThreads.remove(Thread.currentThread());\n                      }\n                    }\n                  };\n                t.setName(\"start R\" + idx);\n                t.start();\n                startupThreads.add(t);\n              }\n            } else {\n              message(\"node \" + idx + \" still starting\");\n            }\n          }\n        }\n\n        System.out.println(\"Restarter: now stop: join \" + startupThreads.size() + \" startup threads\");\n\n        while (startupThreads.size() > 0) {\n          Thread.sleep(10);\n        }\n\n      } catch (Throwable t) {\n        failed.set(true);\n        stop.set(true);\n        throw new RuntimeException(t);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.RestartThread#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n\n      List<Thread> startupThreads = Collections.synchronizedList(new ArrayList<>());\n\n      try {\n        while (stop.get() == false) {\n          Thread.sleep(TestUtil.nextInt(random(), 50, 500));\n          //message(\"top: restarter cycle\");\n\n          // Randomly crash full cluster:\n          if (DO_FULL_CLUSTER_CRASH && random().nextInt(500) == 17) {\n            message(\"top: full cluster crash\");\n            for(int i=0;i<nodes.length;i++) {\n              if (starting[i]) {\n                message(\"N\" + i + \": top: wait for startup so we can crash...\");\n                while (starting[i]) {\n                  Thread.sleep(10);\n                }\n                message(\"N\" + i + \": top: done wait for startup\");\n              }\n              NodeProcess node = nodes[i];\n              if (node != null) {\n                crashingNodes.add(i);\n                message(\"top: N\" + node.id + \": top: now crash node\");\n                node.crash();\n                message(\"top: N\" + node.id + \": top: done crash node\");\n              }\n            }\n          }\n\n          List<Integer> downNodes = new ArrayList<>();\n          StringBuilder b = new StringBuilder();\n          long nowNS = System.nanoTime();\n          for(int i=0;i<nodes.length;i++) {\n            b.append(' ');\n            double sec = (nowNS - nodeTimeStamps[i])/1000000000.0;\n            String prefix;\n            if (nodes[i] == null) {\n              downNodes.add(i);\n              if (starting[i]) {\n                prefix = \"s\";\n              } else {\n                prefix = \"x\";\n              }\n            } else {\n              prefix = \"\";\n            }\n            if (primary != null && nodes[i] == primary) {\n              prefix += \"p\";\n            }\n            b.append(String.format(Locale.ROOT, \"%s%d(%.1fs)\", prefix, i, sec));\n          }\n          message(\"node status\" + b.toString());\n          message(\"downNodes=\" + downNodes);\n\n          // If primary is down, promote a replica:\n          if (primary == null) {\n            if (anyNodesStarting()) {\n              message(\"top: skip promote replica: nodes are still starting\");\n              continue;\n            }\n            promoteReplica();\n          }\n\n          // Randomly start up a down a replica:\n\n          // Stop or start a replica\n          if (downNodes.isEmpty() == false) {\n            int idx = downNodes.get(random().nextInt(downNodes.size()));\n            if (starting[idx] == false) {\n              if (primary == null) {\n                if (downNodes.size() == nodes.length) {\n                  // Cold start: entire cluster is down, start this node up as the new primary\n                  message(\"N\" + idx + \": top: cold start as primary\");\n                  startPrimary(idx);\n                }\n              } else if (random().nextDouble() < ((double) downNodes.size())/nodes.length) {\n                // Start up replica:\n                starting[idx] = true;\n                message(\"N\" + idx + \": top: start up: launch thread\");\n                Thread t = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        message(\"N\" + idx + \": top: start up thread\");\n                        nodes[idx] = startNode(idx, indexPaths[idx], false, -1);\n                        sendReplicasToPrimary();\n                      } catch (Throwable t) {\n                        failed.set(true);\n                        stop.set(true);\n                        throw new RuntimeException(t);\n                      } finally {\n                        starting[idx] = false;\n                        startupThreads.remove(Thread.currentThread());\n                      }\n                    }\n                  };\n                t.setName(\"start R\" + idx);\n                t.start();\n                startupThreads.add(t);\n              }\n            } else {\n              message(\"node \" + idx + \" still starting\");\n            }\n          }\n        }\n\n        System.out.println(\"Restarter: now stop: join \" + startupThreads.size() + \" startup threads\");\n\n        while (startupThreads.size() > 0) {\n          Thread.sleep(10);\n        }\n\n      } catch (Throwable t) {\n        failed.set(true);\n        stop.set(true);\n        throw new RuntimeException(t);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0fc4da33180d50cc1cad94d72b86d7d0459c1740":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0fc4da33180d50cc1cad94d72b86d7d0459c1740"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"]},"commit2Childs":{"0fc4da33180d50cc1cad94d72b86d7d0459c1740":["68496c2200e559fb7802f7575427b7a482659afb"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["0fc4da33180d50cc1cad94d72b86d7d0459c1740"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","68496c2200e559fb7802f7575427b7a482659afb"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}