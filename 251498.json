{"path":"lucene/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","commits":[{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}