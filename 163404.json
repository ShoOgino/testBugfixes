{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#sortOffLine(int,String,long,long).mjava","commits":[{"id":"5db3224bb6ba28cb735531b45593da725fa751d1","date":1547448966,"type":0,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#sortOffLine(int,String,long,long).mjava","pathOld":"/dev/null","sourceNew":"  // sort a given file on a given dimension for start to start + point count\n  private OfflinePointWriter sortOffLine(int dim, String inputName, final long start, final long pointCount) throws IOException {\n\n    final int offset = bytesPerDim * dim;\n\n    Comparator<BytesRef> cmp;\n    if (dim == numDataDims - 1) {\n      // in that case the bytes for the dimension and for the doc id are contiguous,\n      // so we don't need a branch\n      cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n        @Override\n        protected int byteAt(BytesRef ref, int i) {\n          return ref.bytes[ref.offset + offset + i] & 0xff;\n        }\n      };\n    } else {\n      cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n        @Override\n        protected int byteAt(BytesRef ref, int i) {\n          if (i < bytesPerDim) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          } else {\n            return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n          }\n        }\n      };\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc, null, 0) {\n      /**\n       * We write/read fixed-byte-width file that {@link OfflinePointReader} can read.\n       */\n      @Override\n      protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n        return new ByteSequencesWriter(out) {\n          @Override\n          public void write(byte[] bytes, int off, int len) throws IOException {\n            assert len == bytesPerDoc : \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n            out.writeBytes(bytes, off, len);\n          }\n        };\n      }\n\n      /**\n       * We write/read fixed-byte-width file that {@link OfflinePointReader} can read.\n       */\n      @Override\n      protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n        //This allows to read only a subset of the original file\n        long startPointer = (name.equals(inputName)) ? bytesPerDoc * start : in.getFilePointer();\n        long endPointer = (name.equals(inputName)) ? startPointer + bytesPerDoc * pointCount : Long.MAX_VALUE;\n        in.seek(startPointer);\n        return new ByteSequencesReader(in, name) {\n          final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n\n          @Override\n          public BytesRef next() throws IOException {\n            if (in.getFilePointer() >= end) {\n              return null;\n            } else if (in.getFilePointer() >= endPointer) {\n              in.seek(end);\n              return null;\n            }\n            in.readBytes(scratch.bytes, 0, bytesPerDoc);\n            return scratch;\n          }\n        };\n      }\n    };\n\n    String name = sorter.sort(inputName);\n    return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":4,"author":"iverase","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#sortOffLine(int,String,long,long).mjava","sourceNew":null,"sourceOld":"  // sort a given file on a given dimension for start to start + point count\n  private OfflinePointWriter sortOffLine(int dim, String inputName, final long start, final long pointCount) throws IOException {\n\n    final int offset = bytesPerDim * dim;\n\n    Comparator<BytesRef> cmp;\n    if (dim == numDataDims - 1) {\n      // in that case the bytes for the dimension and for the doc id are contiguous,\n      // so we don't need a branch\n      cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n        @Override\n        protected int byteAt(BytesRef ref, int i) {\n          return ref.bytes[ref.offset + offset + i] & 0xff;\n        }\n      };\n    } else {\n      cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {\n        @Override\n        protected int byteAt(BytesRef ref, int i) {\n          if (i < bytesPerDim) {\n            return ref.bytes[ref.offset + offset + i] & 0xff;\n          } else {\n            return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;\n          }\n        }\n      };\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + \"_bkd\" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc, null, 0) {\n      /**\n       * We write/read fixed-byte-width file that {@link OfflinePointReader} can read.\n       */\n      @Override\n      protected ByteSequencesWriter getWriter(IndexOutput out, long count) {\n        return new ByteSequencesWriter(out) {\n          @Override\n          public void write(byte[] bytes, int off, int len) throws IOException {\n            assert len == bytesPerDoc : \"len=\" + len + \" bytesPerDoc=\" + bytesPerDoc;\n            out.writeBytes(bytes, off, len);\n          }\n        };\n      }\n\n      /**\n       * We write/read fixed-byte-width file that {@link OfflinePointReader} can read.\n       */\n      @Override\n      protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {\n        //This allows to read only a subset of the original file\n        long startPointer = (name.equals(inputName)) ? bytesPerDoc * start : in.getFilePointer();\n        long endPointer = (name.equals(inputName)) ? startPointer + bytesPerDoc * pointCount : Long.MAX_VALUE;\n        in.seek(startPointer);\n        return new ByteSequencesReader(in, name) {\n          final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);\n\n          @Override\n          public BytesRef next() throws IOException {\n            if (in.getFilePointer() >= end) {\n              return null;\n            } else if (in.getFilePointer() >= endPointer) {\n              in.seek(end);\n              return null;\n            }\n            in.readBytes(scratch.bytes, 0, bytesPerDoc);\n            return scratch;\n          }\n        };\n      }\n    };\n\n    String name = sorter.sort(inputName);\n    return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5db3224bb6ba28cb735531b45593da725fa751d1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["5db3224bb6ba28cb735531b45593da725fa751d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"]},"commit2Childs":{"5db3224bb6ba28cb735531b45593da725fa751d1":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5db3224bb6ba28cb735531b45593da725fa751d1"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}