{"path":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","commits":[{"id":"2a2d5d7d5a5bc6b66022afef3bcc646148c796b2","date":1357911503,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<String, String>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<String, Object>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<String, String>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<String, Object>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","sourceNew":"  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<String, String>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<String, Object>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"024e13388acbf5562fcbb77a129620982a5e2d79","date":1591531835,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbbf50596596637ced705595b3e283b5da499bce","date":1591744371,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  @SuppressWarnings({\"unchecked\"})\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12823\")\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ea5ab7e7b4b94aba6a057f59cee528a1028b3b","date":1592841746,"type":3,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testZKPropertiesWriter() throws Exception {\n    CollectionAdminRequest.createCollectionWithImplicitRouter(\"collection1\", \"conf\", \"1\", 1)\n        .setMaxShardsPerNode(1)\n        .process(cluster.getSolrClient());\n\n    // DIH talks core, SolrCloud talks collection.\n    DocCollection coll = getCollectionState(\"collection1\");\n    Replica replica = coll.getReplicas().iterator().next();\n    JettySolrRunner jetty = minicluster.getReplicaJetty(replica);\n    SolrCore core = jetty.getCoreContainer().getCore(replica.getCoreName());\n\n    localAssertQ(\"test query on empty index\", request(core, \"qlkciyopsbgzyvkylsjhchghjrdf\"), \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    // These two calls are from SolrTestCaseJ4 and end up in TestHarness... That's ok they are static and do not reference\n    // the various variables that were not initialized (so not copying them to this test class as some other methods at the bottom).\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(core, \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List rows = new ArrayList();\n    rows.add(AbstractDataImportHandlerTestCase.createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    localQuery(\"/dataimport\", localMakeRequest(core, \"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    localAssertQ(\"Should have found 1 doc, year 2013\", request(core, \"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n    core.close();\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  @SuppressWarnings({\"unchecked\"})\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12823\")\n  public void testZKPropertiesWriter() throws Exception {\n    // test using ZooKeeper\n    assertTrue(\"Not using ZooKeeper\", h.getCoreContainer().isZooKeeperAware());\n\n    // for the really slow/busy computer, we wait to make sure we have a leader before starting\n    h.getCoreContainer().getZkController().getZkStateReader().getLeaderUrl(\"collection1\", \"shard1\", 30000);\n\n    assertQ(\"test query on empty index\", request(\"qlkciyopsbgzyvkylsjhchghjrdf\"),\n        \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(h.getCore(), \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List rows = new ArrayList();\n    rows.add(createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    h.query(\"/dataimport\", lrf.makeRequest(\"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    assertQ(request(\"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testZKPropertiesWriter() throws Exception {\n    CollectionAdminRequest.createCollectionWithImplicitRouter(\"collection1\", \"conf\", \"1\", 1)\n        .process(cluster.getSolrClient());\n\n    // DIH talks core, SolrCloud talks collection.\n    DocCollection coll = getCollectionState(\"collection1\");\n    Replica replica = coll.getReplicas().iterator().next();\n    JettySolrRunner jetty = minicluster.getReplicaJetty(replica);\n    SolrCore core = jetty.getCoreContainer().getCore(replica.getCoreName());\n\n    localAssertQ(\"test query on empty index\", request(core, \"qlkciyopsbgzyvkylsjhchghjrdf\"), \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    // These two calls are from SolrTestCaseJ4 and end up in TestHarness... That's ok they are static and do not reference\n    // the various variables that were not initialized (so not copying them to this test class as some other methods at the bottom).\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(core, \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List rows = new ArrayList();\n    rows.add(AbstractDataImportHandlerTestCase.createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    localQuery(\"/dataimport\", localMakeRequest(core, \"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    localAssertQ(\"Should have found 1 doc, year 2013\", request(core, \"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n    core.close();\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testZKPropertiesWriter() throws Exception {\n    CollectionAdminRequest.createCollectionWithImplicitRouter(\"collection1\", \"conf\", \"1\", 1)\n        .setMaxShardsPerNode(1)\n        .process(cluster.getSolrClient());\n\n    // DIH talks core, SolrCloud talks collection.\n    DocCollection coll = getCollectionState(\"collection1\");\n    Replica replica = coll.getReplicas().iterator().next();\n    JettySolrRunner jetty = minicluster.getReplicaJetty(replica);\n    SolrCore core = jetty.getCoreContainer().getCore(replica.getCoreName());\n\n    localAssertQ(\"test query on empty index\", request(core, \"qlkciyopsbgzyvkylsjhchghjrdf\"), \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    // These two calls are from SolrTestCaseJ4 and end up in TestHarness... That's ok they are static and do not reference\n    // the various variables that were not initialized (so not copying them to this test class as some other methods at the bottom).\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(core, \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List rows = new ArrayList();\n    rows.add(AbstractDataImportHandlerTestCase.createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    localQuery(\"/dataimport\", localMakeRequest(core, \"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    localAssertQ(\"Should have found 1 doc, year 2013\", request(core, \"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n    core.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b","date":1598712724,"type":4,"author":"Alexandre Rafalovitch","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestZKPropertiesWriter#testZKPropertiesWriter().mjava","sourceNew":null,"sourceOld":"  @SuppressForbidden(reason = \"Needs currentTimeMillis to construct date stamps\")\n  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testZKPropertiesWriter() throws Exception {\n    CollectionAdminRequest.createCollectionWithImplicitRouter(\"collection1\", \"conf\", \"1\", 1)\n        .process(cluster.getSolrClient());\n\n    // DIH talks core, SolrCloud talks collection.\n    DocCollection coll = getCollectionState(\"collection1\");\n    Replica replica = coll.getReplicas().iterator().next();\n    JettySolrRunner jetty = minicluster.getReplicaJetty(replica);\n    SolrCore core = jetty.getCoreContainer().getCore(replica.getCoreName());\n\n    localAssertQ(\"test query on empty index\", request(core, \"qlkciyopsbgzyvkylsjhchghjrdf\"), \"//result[@numFound='0']\");\n\n    SimpleDateFormat errMsgFormat = new SimpleDateFormat(dateFormat, Locale.ROOT);\n\n    // These two calls are from SolrTestCaseJ4 and end up in TestHarness... That's ok they are static and do not reference\n    // the various variables that were not initialized (so not copying them to this test class as some other methods at the bottom).\n    delQ(\"*:*\");\n    commit();\n    SimpleDateFormat df = new SimpleDateFormat(dateFormat, Locale.ROOT);\n    Date oneSecondAgo = new Date(System.currentTimeMillis() - 1000);\n\n    Map<String, String> init = new HashMap<>();\n    init.put(\"dateFormat\", dateFormat);\n    ZKPropertiesWriter spw = new ZKPropertiesWriter();\n    spw.init(new DataImporter(core, \"dataimport\"), init);\n    Map<String, Object> props = new HashMap<>();\n    props.put(\"SomeDates.last_index_time\", oneSecondAgo);\n    props.put(\"last_index_time\", oneSecondAgo);\n    spw.persist(props);\n\n    @SuppressWarnings({\"rawtypes\"})\n    List rows = new ArrayList();\n    rows.add(AbstractDataImportHandlerTestCase.createMap(\"id\", \"1\", \"year_s\", \"2013\"));\n    MockDataSource.setIterator(\"select \" + df.format(oneSecondAgo) + \" from dummy\", rows.iterator());\n\n    localQuery(\"/dataimport\", localMakeRequest(core, \"command\", \"full-import\", \"dataConfig\",\n        generateConfig(), \"clean\", \"true\", \"commit\", \"true\", \"synchronous\",\n        \"true\", \"indent\", \"true\"));\n    props = spw.readIndexerProperties();\n    Date entityDate = df.parse((String) props.get(\"SomeDates.last_index_time\"));\n    Date docDate = df.parse((String) props.get(\"last_index_time\"));\n\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the document date: \" + errMsgFormat.format(docDate), docDate.getTime() - oneSecondAgo.getTime() > 0);\n    Assert.assertTrue(\"This date: \" + errMsgFormat.format(oneSecondAgo) + \" should be prior to the entity date: \" + errMsgFormat.format(entityDate), entityDate.getTime() - oneSecondAgo.getTime() > 0);\n    localAssertQ(\"Should have found 1 doc, year 2013\", request(core, \"*:*\"), \"//*[@numFound='1']\", \"//doc/str[@name=\\\"year_s\\\"]=\\\"2013\\\"\");\n\n    core.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2a2d5d7d5a5bc6b66022afef3bcc646148c796b2"],"024e13388acbf5562fcbb77a129620982a5e2d79":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"60ea5ab7e7b4b94aba6a057f59cee528a1028b3b":["cbbf50596596637ced705595b3e283b5da499bce"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["60ea5ab7e7b4b94aba6a057f59cee528a1028b3b"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"2a2d5d7d5a5bc6b66022afef3bcc646148c796b2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cbbf50596596637ced705595b3e283b5da499bce":["024e13388acbf5562fcbb77a129620982a5e2d79"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2a2d5d7d5a5bc6b66022afef3bcc646148c796b2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"024e13388acbf5562fcbb77a129620982a5e2d79":["cbbf50596596637ced705595b3e283b5da499bce"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"60ea5ab7e7b4b94aba6a057f59cee528a1028b3b":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2a2d5d7d5a5bc6b66022afef3bcc646148c796b2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2a2d5d7d5a5bc6b66022afef3bcc646148c796b2","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["024e13388acbf5562fcbb77a129620982a5e2d79"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"cbbf50596596637ced705595b3e283b5da499bce":["60ea5ab7e7b4b94aba6a057f59cee528a1028b3b"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4e6354dd7c71fe122926fc53d7d29f715b1283db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}