{"path":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ?\n            (List<PluginInfo>) Collections.EMPTY_LIST:\n            result; \n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ?\n            (List<PluginInfo>) Collections.EMPTY_LIST:\n            result; \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ?\n            (List<PluginInfo>) Collections.EMPTY_LIST:\n            result; \n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ?\n            (List<PluginInfo>) Collections.EMPTY_LIST:\n            result; \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ?\n            (List<PluginInfo>) Collections.EMPTY_LIST:\n            result; \n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ?\n            (List<PluginInfo>) Collections.EMPTY_LIST:\n            result; \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9499b09dd7d06d975f31e59a9b00653a86f9cad2","date":1343325589,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ? Collections.<PluginInfo>emptyList(): result; \n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ?\n            (List<PluginInfo>) Collections.EMPTY_LIST:\n            result; \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ? Collections.<PluginInfo>emptyList(): result; \n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ?\n            (List<PluginInfo>) Collections.EMPTY_LIST:\n            result; \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ? Collections.<PluginInfo>emptyList(): result; \n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ?\n            (List<PluginInfo>) Collections.EMPTY_LIST:\n            result; \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1","date":1423220905,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = clsVsInfo.get(type);\n    if (info != null && info.options.contains(REQUIRE_NAME)) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.tag);\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) map.put(pluginInfo.name, pluginInfo);\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.tag, e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String  type){\n    List<PluginInfo> result = pluginStore.get(type);\n    return result == null ? Collections.<PluginInfo>emptyList(): result; \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9aea0485ecacb6734c17da2d02569816c23a69c1","date":1425707735,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null && info.options.contains(REQUIRE_NAME)) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.tag);\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) map.put(pluginInfo.name, pluginInfo);\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.tag, e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = clsVsInfo.get(type);\n    if (info != null && info.options.contains(REQUIRE_NAME)) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.tag);\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) map.put(pluginInfo.name, pluginInfo);\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.tag, e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae2f5be890d26585d438eba0b9cc7d3c0a9775be","date":1427387954,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) {\n          //just create a UUID for the time being so that map key is not null\n          String name = pluginInfo.name == null ?\n              UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n              pluginInfo.name;\n          map.put(name, pluginInfo);\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.getCleanTag(), e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null && info.options.contains(REQUIRE_NAME)) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.tag);\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) map.put(pluginInfo.name, pluginInfo);\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.tag, e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) {\n          //just create a UUID for the time being so that map key is not null\n          String name = pluginInfo.name == null ?\n              UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n              pluginInfo.name;\n          map.put(name, pluginInfo);\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.getCleanTag(), e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","sourceOld":"  /**SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   * SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   * SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   * IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = clsVsInfo.get(type);\n    if (info != null && info.options.contains(REQUIRE_NAME)) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.tag);\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) map.put(pluginInfo.name, pluginInfo);\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.tag, e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c","date":1566455239,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) {\n          for (PluginInfo pluginInfo : result) {\n            //just create a UUID for the time being so that map key is not null\n            String name = pluginInfo.name == null ?\n                UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n                pluginInfo.name;\n            map.put(name, pluginInfo);\n          }\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          PluginInfo value = new PluginInfo(info.getCleanTag(), e.getValue());\n          value.pathInConfig = Arrays.asList(info.getCleanTag(),e.getKey());\n          map.put(e.getKey(), value);\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.emptyList() : result;\n  }\n\n","sourceOld":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) {\n          //just create a UUID for the time being so that map key is not null\n          String name = pluginInfo.name == null ?\n              UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n              pluginInfo.name;\n          map.put(name, pluginInfo);\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.getCleanTag(), e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c44cc06c26e456fe9c215072b79fce30babe3975","date":1570365040,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) {\n          //just create a UUID for the time being so that map key is not null\n          String name = pluginInfo.name == null ?\n              UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n              pluginInfo.name;\n          map.put(name, pluginInfo);\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.getCleanTag(), e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","sourceOld":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) {\n          for (PluginInfo pluginInfo : result) {\n            //just create a UUID for the time being so that map key is not null\n            String name = pluginInfo.name == null ?\n                UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n                pluginInfo.name;\n            map.put(name, pluginInfo);\n          }\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          PluginInfo value = new PluginInfo(info.getCleanTag(), e.getValue());\n          value.pathInConfig = Arrays.asList(info.getCleanTag(),e.getKey());\n          map.put(e.getKey(), value);\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.emptyList() : result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) {\n          //just create a UUID for the time being so that map key is not null\n          String name = pluginInfo.name == null ?\n              UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n              pluginInfo.name;\n          map.put(name, pluginInfo);\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.getCleanTag(), e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","sourceOld":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) {\n          for (PluginInfo pluginInfo : result) {\n            //just create a UUID for the time being so that map key is not null\n            String name = pluginInfo.name == null ?\n                UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n                pluginInfo.name;\n            map.put(name, pluginInfo);\n          }\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          PluginInfo value = new PluginInfo(info.getCleanTag(), e.getValue());\n          value.pathInConfig = Arrays.asList(info.getCleanTag(),e.getKey());\n          map.put(e.getKey(), value);\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.emptyList() : result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75237075d8425856bf4bbf52a6be4f9162b8187d","date":1591103291,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#getPluginInfos(String).mjava","sourceNew":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) {\n          //just create a UUID for the time being so that map key is not null\n          String name = pluginInfo.name == null ?\n              UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n              pluginInfo.name;\n          map.put(name, pluginInfo);\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.getCleanTag(), e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","sourceOld":"  /**\n   * SolrConfig keeps a repository of plugins by the type. The known interfaces are the types.\n   *\n   * @param type The key is FQN of the plugin class there are a few  known types : SolrFormatter, SolrFragmenter\n   *             SolrRequestHandler,QParserPlugin, QueryResponseWriter,ValueSourceParser,\n   *             SearchComponent, QueryConverter, SolrEventListener, DirectoryFactory,\n   *             IndexDeletionPolicy, IndexReaderFactory, {@link TransformerFactory}\n   */\n  public List<PluginInfo> getPluginInfos(String type) {\n    List<PluginInfo> result = pluginStore.get(type);\n    SolrPluginInfo info = classVsSolrPluginInfo.get(type);\n    if (info != null &&\n        (info.options.contains(REQUIRE_NAME) || info.options.contains(REQUIRE_NAME_IN_OVERLAY))) {\n      Map<String, Map> infos = overlay.getNamedPlugins(info.getCleanTag());\n      if (!infos.isEmpty()) {\n        LinkedHashMap<String, PluginInfo> map = new LinkedHashMap<>();\n        if (result != null) for (PluginInfo pluginInfo : result) {\n          //just create a UUID for the time being so that map key is not null\n          String name = pluginInfo.name == null ?\n              UUID.randomUUID().toString().toLowerCase(Locale.ROOT) :\n              pluginInfo.name;\n          map.put(name, pluginInfo);\n        }\n        for (Map.Entry<String, Map> e : infos.entrySet()) {\n          map.put(e.getKey(), new PluginInfo(info.getCleanTag(), e.getValue()));\n        }\n        result = new ArrayList<>(map.values());\n      }\n    }\n    return result == null ? Collections.<PluginInfo>emptyList() : result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"75237075d8425856bf4bbf52a6be4f9162b8187d":["c44cc06c26e456fe9c215072b79fce30babe3975"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c44cc06c26e456fe9c215072b79fce30babe3975":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"ae2f5be890d26585d438eba0b9cc7d3c0a9775be":["9aea0485ecacb6734c17da2d02569816c23a69c1"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1","ae2f5be890d26585d438eba0b9cc7d3c0a9775be"],"aba371508186796cc6151d8223a5b4e16d02e26e":["c26f00b574427b55127e869b935845554afde1fa","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["ae2f5be890d26585d438eba0b9cc7d3c0a9775be"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["c26f00b574427b55127e869b935845554afde1fa","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["75237075d8425856bf4bbf52a6be4f9162b8187d"],"b0b597c65628ca9e73913a07e81691f8229bae35":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c","c44cc06c26e456fe9c215072b79fce30babe3975"]},"commit2Childs":{"75237075d8425856bf4bbf52a6be4f9162b8187d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c26f00b574427b55127e869b935845554afde1fa":["aba371508186796cc6151d8223a5b4e16d02e26e","9499b09dd7d06d975f31e59a9b00653a86f9cad2","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"c44cc06c26e456fe9c215072b79fce30babe3975":["75237075d8425856bf4bbf52a6be4f9162b8187d","b0b597c65628ca9e73913a07e81691f8229bae35"],"ae2f5be890d26585d438eba0b9cc7d3c0a9775be":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["c44cc06c26e456fe9c215072b79fce30babe3975","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9aea0485ecacb6734c17da2d02569816c23a69c1"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"9aea0485ecacb6734c17da2d02569816c23a69c1":["ae2f5be890d26585d438eba0b9cc7d3c0a9775be"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}