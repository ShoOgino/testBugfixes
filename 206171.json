{"path":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[],boolean[]).mjava","commits":[{"id":"8be807b98a5aab36b690a9bd4ef0e4b5d33b8689","date":1329492225,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[],boolean[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[]).mjava","sourceNew":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc, boolean[] childAtomic) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final IndexReader[] subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      if (subs.length != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < subs.length; subIDX++) {\n        if (subs[subIDX].maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader maxDoc\");\n        }\n        if (!(childAtomic[subIDX] ? (subs[subIDX] instanceof AtomicReader) : (subs[subIDX] instanceof CompositeReader))) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader types (atomic or composite)\");\n        }\n      }\n    }    \n  }\n\n","sourceOld":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final IndexReader[] subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      if (subs.length != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < subs.length; subIDX++) {\n        if (subs[subIDX].maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same subReader maxDoc\");\n        }\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[],boolean[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[],boolean[]).mjava","sourceNew":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc, boolean[] childAtomic) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final List<? extends IndexReader> subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      final int noSubs = subs.size();\n      if (noSubs != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < noSubs; subIDX++) {\n        final IndexReader r = subs.get(subIDX);\n        if (r.maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader maxDoc\");\n        }\n        if (!(childAtomic[subIDX] ? (r instanceof AtomicReader) : (r instanceof CompositeReader))) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader types (atomic or composite)\");\n        }\n      }\n    }    \n  }\n\n","sourceOld":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc, boolean[] childAtomic) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final IndexReader[] subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      if (subs.length != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < subs.length; subIDX++) {\n        if (subs[subIDX].maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader maxDoc\");\n        }\n        if (!(childAtomic[subIDX] ? (subs[subIDX] instanceof AtomicReader) : (subs[subIDX] instanceof CompositeReader))) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader types (atomic or composite)\");\n        }\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[],boolean[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[],boolean[]).mjava","sourceNew":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc, boolean[] childAtomic) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final List<? extends IndexReader> subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      final int noSubs = subs.size();\n      if (noSubs != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < noSubs; subIDX++) {\n        final IndexReader r = subs.get(subIDX);\n        if (r.maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader maxDoc\");\n        }\n        if (!(childAtomic[subIDX] ? (r instanceof LeafReader) : (r instanceof CompositeReader))) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader types (atomic or composite)\");\n        }\n      }\n    }    \n  }\n\n","sourceOld":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc, boolean[] childAtomic) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final List<? extends IndexReader> subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      final int noSubs = subs.size();\n      if (noSubs != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < noSubs; subIDX++) {\n        final IndexReader r = subs.get(subIDX);\n        if (r.maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader maxDoc\");\n        }\n        if (!(childAtomic[subIDX] ? (r instanceof AtomicReader) : (r instanceof CompositeReader))) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader types (atomic or composite)\");\n        }\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f6279d779b4584858af04f499e8aac0ae132c29","date":1432729989,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[],boolean[]).mjava","sourceNew":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] leafMaxDoc) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final List<? extends LeafReaderContext> subs = reader.leaves();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      final int noSubs = subs.size();\n      if (noSubs != leafMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of leaf readers\");\n      }\n      for (int subIDX = 0; subIDX < noSubs; subIDX++) {\n        final LeafReader r = subs.get(subIDX).reader();\n        if (r.maxDoc() != leafMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All leaf readers must have same corresponding subReader maxDoc\");\n        }\n      }\n    }    \n  }\n\n","sourceOld":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc, boolean[] childAtomic) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final List<? extends IndexReader> subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      final int noSubs = subs.size();\n      if (noSubs != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < noSubs; subIDX++) {\n        final IndexReader r = subs.get(subIDX);\n        if (r.maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader maxDoc\");\n        }\n        if (!(childAtomic[subIDX] ? (r instanceof LeafReader) : (r instanceof CompositeReader))) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader types (atomic or composite)\");\n        }\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["8be807b98a5aab36b690a9bd4ef0e4b5d33b8689"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f6279d779b4584858af04f499e8aac0ae132c29":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"8be807b98a5aab36b690a9bd4ef0e4b5d33b8689":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5f6279d779b4584858af04f499e8aac0ae132c29"]},"commit2Childs":{"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8be807b98a5aab36b690a9bd4ef0e4b5d33b8689"],"5f6279d779b4584858af04f499e8aac0ae132c29":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8be807b98a5aab36b690a9bd4ef0e4b5d33b8689":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["5f6279d779b4584858af04f499e8aac0ae132c29"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}