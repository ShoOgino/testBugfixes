{"path":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"/dev/null","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        status = termsEnum.seek(idx);\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        status = termsEnum.seek(idx);\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b103252dee6afa1b6d7a622c773d178788eb85a","date":1280180143,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        status = termsEnum.seek(idx);\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        status = termsEnum.seek(idx);\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56da903869515527852ee21ea7ef7bfe414cd40d","date":1294224724,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.codecId] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.codecId] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.codecId] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.this.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        // Test straight enum of the terms:\n        int upto = 0;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          assertTrue(new BytesRef(field.terms[upto++].text2).bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.this.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.this.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final char[] text = TestCodecs.this.getRandomText();\n          final String text2 = new String(text, 0, text.length-1) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        assertEquals(status, TermsEnum.SeekStatus.NOT_FOUND);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.this.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.this.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.this.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.this.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0c7a8f7304b75b1528814c5820fa23a96816c27","date":1298314239,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.codecId] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.codecId] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14ec33385f6fbb6ce172882d14605790418a5d31","date":1298910796,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.codecId] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1224a4027481acce15495b03bce9b48b93b42722","date":1300792329,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.codecId] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e92442af786151ee55bc283eb472f629e3c7b52b","date":1301070252,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.codecId] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9cc9d77712aba3662f24632df7539ab75e3667","date":1309095238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seek(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        try {\n          status = termsEnum.seek(idx);\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n          status = null;\n        }\n        if (status != null) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seek(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seek(i));\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seek(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seek(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        assertTrue(field.fieldInfo.getCodecId() != FieldInfo.UNASSIGNED_CODEC_ID);\n        if (si.getSegmentCodecs().codecs[field.fieldInfo.getCodecId()] instanceof PreFlexCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"872cff1d3a554e0cd64014cd97f88d3002b0f491","date":1323024658,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b65b350ca9588f9fc76ce7d6804160d06c45ff42","date":1323026297,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docs(null, null), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs = termsEnum.docs(null, null);\n            final DocsAndPositionsEnum postings = termsEnum.docsAndPositions(null, null);\n\n            final DocsEnum docsEnum;\n            if (postings != null) {\n              docsEnum = postings;\n            } else {\n              docsEnum = docs;\n            }\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docsEnum.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docsEnum.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docsEnum.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, docsEnum.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docsEnum.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31f025ae60076ae95274433f3fe8e6ace2857a87","date":1326669465,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["31f025ae60076ae95274433f3fe8e6ace2857a87"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e92442af786151ee55bc283eb472f629e3c7b52b":["1224a4027481acce15495b03bce9b48b93b42722"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["bde51b089eb7f86171eb3406e38a274743f9b7ac","e92442af786151ee55bc283eb472f629e3c7b52b"],"14ec33385f6fbb6ce172882d14605790418a5d31":["b0c7a8f7304b75b1528814c5820fa23a96816c27"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd9cc9d77712aba3662f24632df7539ab75e3667":["e92442af786151ee55bc283eb472f629e3c7b52b"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["868da859b43505d9d2a023bfeae6dd0c795f5295","b0c7a8f7304b75b1528814c5820fa23a96816c27"],"31f025ae60076ae95274433f3fe8e6ace2857a87":["872cff1d3a554e0cd64014cd97f88d3002b0f491"],"1224a4027481acce15495b03bce9b48b93b42722":["14ec33385f6fbb6ce172882d14605790418a5d31"],"70ad682703b8585f5d0a637efec044d57ec05efb":["4b103252dee6afa1b6d7a622c773d178788eb85a","56da903869515527852ee21ea7ef7bfe414cd40d"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","4b103252dee6afa1b6d7a622c773d178788eb85a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"3cc749c053615f5871f3b95715fe292f34e70a53":["7b91922b55d15444d554721b352861d028eb8278"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["3cc749c053615f5871f3b95715fe292f34e70a53"],"2553b00f699380c64959ccb27991289aae87be2e":["e92442af786151ee55bc283eb472f629e3c7b52b","fd9cc9d77712aba3662f24632df7539ab75e3667"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["e92442af786151ee55bc283eb472f629e3c7b52b","fd9cc9d77712aba3662f24632df7539ab75e3667"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"7b91922b55d15444d554721b352861d028eb8278":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":["3cc749c053615f5871f3b95715fe292f34e70a53","872cff1d3a554e0cd64014cd97f88d3002b0f491"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["70ad682703b8585f5d0a637efec044d57ec05efb","e92442af786151ee55bc283eb472f629e3c7b52b"],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["56da903869515527852ee21ea7ef7bfe414cd40d"],"56da903869515527852ee21ea7ef7bfe414cd40d":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["3242a09f703274d3b9283f2064a1a33064b53a1b","56da903869515527852ee21ea7ef7bfe414cd40d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["3242a09f703274d3b9283f2064a1a33064b53a1b","4b103252dee6afa1b6d7a622c773d178788eb85a","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"e92442af786151ee55bc283eb472f629e3c7b52b":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","fd9cc9d77712aba3662f24632df7539ab75e3667","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","d619839baa8ce5503e496b94a9e42ad6f079293f"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"14ec33385f6fbb6ce172882d14605790418a5d31":["1224a4027481acce15495b03bce9b48b93b42722"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","60ba444201d2570214b6fcf1d15600dc1a01f548"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"31f025ae60076ae95274433f3fe8e6ace2857a87":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"1224a4027481acce15495b03bce9b48b93b42722":["e92442af786151ee55bc283eb472f629e3c7b52b"],"70ad682703b8585f5d0a637efec044d57ec05efb":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["70ad682703b8585f5d0a637efec044d57ec05efb","3242a09f703274d3b9283f2064a1a33064b53a1b","56da903869515527852ee21ea7ef7bfe414cd40d"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"3cc749c053615f5871f3b95715fe292f34e70a53":["872cff1d3a554e0cd64014cd97f88d3002b0f491","b65b350ca9588f9fc76ce7d6804160d06c45ff42"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["31f025ae60076ae95274433f3fe8e6ace2857a87","b65b350ca9588f9fc76ce7d6804160d06c45ff42"],"2553b00f699380c64959ccb27991289aae87be2e":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"60ba444201d2570214b6fcf1d15600dc1a01f548":["7b91922b55d15444d554721b352861d028eb8278"],"7b91922b55d15444d554721b352861d028eb8278":["3cc749c053615f5871f3b95715fe292f34e70a53"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":[],"d619839baa8ce5503e496b94a9e42ad6f079293f":[],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["14ec33385f6fbb6ce172882d14605790418a5d31","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"56da903869515527852ee21ea7ef7bfe414cd40d":["70ad682703b8585f5d0a637efec044d57ec05efb","b0c7a8f7304b75b1528814c5820fa23a96816c27","868da859b43505d9d2a023bfeae6dd0c795f5295"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","b65b350ca9588f9fc76ce7d6804160d06c45ff42","d619839baa8ce5503e496b94a9e42ad6f079293f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}