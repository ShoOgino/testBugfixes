{"path":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","commits":[{"id":"d4769bdea5a853f1841c485bc1fd9d79cb7022fc","date":1292168168,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"/dev/null","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nADD: \" + input.utf8ToString());\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f7f6f6eea7367442ccb5f44b36b61ba779f8c96","date":1292267841,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nADD: \" + input.utf8ToString());\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nADD: \" + input.utf8ToString());\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"/dev/null","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nADD: \" + input.utf8ToString());\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"/dev/null","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nADD: \" + input.utf8ToString());\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56da903869515527852ee21ea7ef7bfe414cd40d","date":1294224724,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nADD: \" + input.utf8ToString());\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nADD: \" + input.utf8ToString());\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nADD: \" + input.utf8ToString());\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66a31a416e3550794ff2e245570885b7193952b6","date":1298453724,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"692804e172a5810620fac3194db7b7616a21ad3d","date":1298513499,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41a7130051d507b3a37c0b9f41f5937dfed6a88e","date":1302628279,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"962d04139994fce5193143ef35615499a9a96d78","date":1302693744,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea8136d8c9f128223389b731b2affdeccdbf1af3","date":1305220410,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) > 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    // push remaining output:\n    frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8be6e1e4fbbc94d90b78f175c03ff389b6949373","date":1306674752,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","56da903869515527852ee21ea7ef7bfe414cd40d"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["ea8136d8c9f128223389b731b2affdeccdbf1af3"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["d619839baa8ce5503e496b94a9e42ad6f079293f","41a7130051d507b3a37c0b9f41f5937dfed6a88e"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2f7f6f6eea7367442ccb5f44b36b61ba779f8c96"],"962d04139994fce5193143ef35615499a9a96d78":["692804e172a5810620fac3194db7b7616a21ad3d","41a7130051d507b3a37c0b9f41f5937dfed6a88e"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2f7f6f6eea7367442ccb5f44b36b61ba779f8c96"],"41a7130051d507b3a37c0b9f41f5937dfed6a88e":["66a31a416e3550794ff2e245570885b7193952b6"],"d4769bdea5a853f1841c485bc1fd9d79cb7022fc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2f7f6f6eea7367442ccb5f44b36b61ba779f8c96":["d4769bdea5a853f1841c485bc1fd9d79cb7022fc"],"692804e172a5810620fac3194db7b7616a21ad3d":["868da859b43505d9d2a023bfeae6dd0c795f5295","66a31a416e3550794ff2e245570885b7193952b6"],"66a31a416e3550794ff2e245570885b7193952b6":["56da903869515527852ee21ea7ef7bfe414cd40d"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["70ad682703b8585f5d0a637efec044d57ec05efb","66a31a416e3550794ff2e245570885b7193952b6"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a3776dccca01c11e7046323cfad46a3b4a471233","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"56da903869515527852ee21ea7ef7bfe414cd40d":["2f7f6f6eea7367442ccb5f44b36b61ba779f8c96"],"a3776dccca01c11e7046323cfad46a3b4a471233":["66a31a416e3550794ff2e245570885b7193952b6","ea8136d8c9f128223389b731b2affdeccdbf1af3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ea8136d8c9f128223389b731b2affdeccdbf1af3":["41a7130051d507b3a37c0b9f41f5937dfed6a88e"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["135621f3a0670a9394eb563224a3b76cc4dddc0f","ea8136d8c9f128223389b731b2affdeccdbf1af3"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","56da903869515527852ee21ea7ef7bfe414cd40d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","8be6e1e4fbbc94d90b78f175c03ff389b6949373"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["70ad682703b8585f5d0a637efec044d57ec05efb"],"962d04139994fce5193143ef35615499a9a96d78":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"41a7130051d507b3a37c0b9f41f5937dfed6a88e":["135621f3a0670a9394eb563224a3b76cc4dddc0f","962d04139994fce5193143ef35615499a9a96d78","ea8136d8c9f128223389b731b2affdeccdbf1af3"],"d4769bdea5a853f1841c485bc1fd9d79cb7022fc":["2f7f6f6eea7367442ccb5f44b36b61ba779f8c96"],"2f7f6f6eea7367442ccb5f44b36b61ba779f8c96":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","56da903869515527852ee21ea7ef7bfe414cd40d"],"692804e172a5810620fac3194db7b7616a21ad3d":["962d04139994fce5193143ef35615499a9a96d78"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"66a31a416e3550794ff2e245570885b7193952b6":["41a7130051d507b3a37c0b9f41f5937dfed6a88e","692804e172a5810620fac3194db7b7616a21ad3d","d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"56da903869515527852ee21ea7ef7bfe414cd40d":["70ad682703b8585f5d0a637efec044d57ec05efb","66a31a416e3550794ff2e245570885b7193952b6","868da859b43505d9d2a023bfeae6dd0c795f5295"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d4769bdea5a853f1841c485bc1fd9d79cb7022fc"],"ea8136d8c9f128223389b731b2affdeccdbf1af3":["8be6e1e4fbbc94d90b78f175c03ff389b6949373","a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["692804e172a5810620fac3194db7b7616a21ad3d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["962d04139994fce5193143ef35615499a9a96d78","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}