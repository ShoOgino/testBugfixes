{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"78ae724e55b07e7d158110151c0a7247cd54b460","date":1396011287,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = getCollectionStatus(stateMap, name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(stateMap, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection docCollection = clusterState.getCollection(collection);\n        DocRouter router = docCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, docCollection);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(stateMap, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = getCollectionStatus(stateMap, name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(stateMap, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection docCollection = clusterState.getCollection(collection);\n        DocRouter router = docCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, docCollection);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(stateMap, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.hasExternalCollection(name)) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.hasExternalCollection(collection)) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String, Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = getCollectionStatus(stateMap, name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(stateMap, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection docCollection = clusterState.getCollection(collection);\n        DocRouter router = docCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, docCollection);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(stateMap, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n\n      docCollection = (Map<String, Object>) stateMap.get(collection);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.hasExternalCollection(name)) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.hasExternalCollection(collection)) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String, Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2434ed0b85e169536d867d4445ae92599339bdad","date":1403868554,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if(zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n\n      docCollection = (Map<String, Object>) stateMap.get(collection);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n\n      docCollection = (Map<String, Object>) stateMap.get(collection);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef23f5445cdca47281cc83511d279c4a5c3e2e0c","date":1403871297,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n\n      docCollection = (Map<String, Object>) stateMap.get(collection);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if(zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n\n      docCollection = (Map<String, Object>) stateMap.get(collection);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":["ada1eee209add16fbb0b271444355004e182c8ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat()>1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat()>1 ) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String, Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n\n      docCollection = (Map<String, Object>) stateMap.get(collection);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n\n      docCollection = (Map<String, Object>) stateMap.get(collection);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat()>1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat()>1 ) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String, Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat() > 1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String,Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String,Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, shard);\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n\n      docCollection = (Map<String, Object>) stateMap.get(collection);\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat() > 1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String,Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String,Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat() > 1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String,Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String,Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ada1eee209add16fbb0b271444355004e182c8ad","date":1411402636,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat() > 1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String,Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String,Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat() > 1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String,Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String,Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":["ef23f5445cdca47281cc83511d279c4a5c3e2e0c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f900ef89aa1e7b79fbc0a8a4a81937ca271b962a","date":1428989112,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat() > 1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String,Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String,Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        String configName = zkStateReader.readConfigName(collection);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        String configName = zkStateReader.readConfigName(collection);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat() > 1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String,Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String,Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec381030975b88c20fde64532548a9e9a4bc4f51","date":1432653875,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n    if (collection == null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String name : collections) {\n        Map<String, Object> collectionStatus = null;\n        if (clusterState.getCollection(name).getStateFormat() > 1) {\n          bytes = ZkStateReader.toJSON(clusterState.getCollection(name));\n          Map<String, Object> docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n          collectionStatus = getCollectionStatus(docCollection, name, shard);\n        } else  {\n          collectionStatus = getCollectionStatus((Map<String,Object>) stateMap.get(name), name, shard);\n        }\n        if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n        }\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      }\n    } else {\n      String routeKey = message.getStr(ShardParams._ROUTE_);\n      Map<String, Object> docCollection = null;\n      if (clusterState.getCollection(collection).getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterState.getCollection(collection));\n        docCollection = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n      } else  {\n        docCollection = (Map<String,Object>) stateMap.get(collection);\n      }\n      if (routeKey == null) {\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, shard);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        String configName = zkStateReader.readConfigName(collection);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(collection, collectionStatus);\n      } else {\n        DocCollection coll = clusterState.getCollection(collection);\n        DocRouter router = coll.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, coll);\n        String s = \"\";\n        for (Slice slice : slices) {\n          s += slice.getName() + \",\";\n        }\n        if (shard != null)  {\n          s += shard;\n        }\n        Map<String, Object> collectionStatus = getCollectionStatus(docCollection, collection, s);\n        if (collectionVsAliases.containsKey(collection) && !collectionVsAliases.get(collection).isEmpty())  {\n          collectionStatus.put(\"aliases\", collectionVsAliases.get(collection));\n        }\n        String configName = zkStateReader.readConfigName(collection);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(collection, collectionStatus);\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","78ae724e55b07e7d158110151c0a7247cd54b460"],"ec381030975b88c20fde64532548a9e9a4bc4f51":["f900ef89aa1e7b79fbc0a8a4a81937ca271b962a"],"ada1eee209add16fbb0b271444355004e182c8ad":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["ec381030975b88c20fde64532548a9e9a4bc4f51"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["9279b175e5e66258442d2123a50f052219a9cc1b"],"78ae724e55b07e7d158110151c0a7247cd54b460":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f900ef89aa1e7b79fbc0a8a4a81937ca271b962a":["ada1eee209add16fbb0b271444355004e182c8ad"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["ef23f5445cdca47281cc83511d279c4a5c3e2e0c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ef23f5445cdca47281cc83511d279c4a5c3e2e0c":["2434ed0b85e169536d867d4445ae92599339bdad"],"2434ed0b85e169536d867d4445ae92599339bdad":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["78ae724e55b07e7d158110151c0a7247cd54b460"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"ec381030975b88c20fde64532548a9e9a4bc4f51":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"ada1eee209add16fbb0b271444355004e182c8ad":["f900ef89aa1e7b79fbc0a8a4a81937ca271b962a"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["2434ed0b85e169536d867d4445ae92599339bdad"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"78ae724e55b07e7d158110151c0a7247cd54b460":["5eb2511ababf862ea11e10761c70ee560cd84510","0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["ada1eee209add16fbb0b271444355004e182c8ad"],"f900ef89aa1e7b79fbc0a8a4a81937ca271b962a":["ec381030975b88c20fde64532548a9e9a4bc4f51"],"9279b175e5e66258442d2123a50f052219a9cc1b":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5eb2511ababf862ea11e10761c70ee560cd84510","78ae724e55b07e7d158110151c0a7247cd54b460"],"ef23f5445cdca47281cc83511d279c4a5c3e2e0c":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"2434ed0b85e169536d867d4445ae92599339bdad":["ef23f5445cdca47281cc83511d279c4a5c3e2e0c"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}