{"path":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","commits":[{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, null);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6","718607d99d02778db3280e64975663762c94170d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, null);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"718607d99d02778db3280e64975663762c94170d","date":1354986964,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","sourceNew":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","sourceOld":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, null);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","sourceNew":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","sourceOld":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, null);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674","date":1358098706,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","sourceNew":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, DirContext.DEFAULT, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","sourceOld":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","sourceNew":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, DirContext.DEFAULT, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","sourceOld":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6","date":1361552322,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","sourceNew":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, DirContext.DEFAULT, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME) + \" because it already exists\");\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","sourceOld":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, DirContext.DEFAULT, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME));\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"190779ba7de3fda15afd1bbafbc383720a4b0966","date":1384747256,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","sourceNew":null,"sourceOld":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, DirContext.DEFAULT, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME) + \" because it already exists\");\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#downloadIndexFiles(boolean,Directory,long).mjava","sourceNew":null,"sourceOld":"  /**\n   * Download the index files. If a new index is needed, download all the files.\n   *\n   * @param downloadCompleteIndex is it a fresh index copy\n   * @param tmpIndexDir               the directory to which files need to be downloadeed to\n   * @param latestGeneration         the version number\n   */\n  private void downloadIndexFiles(boolean downloadCompleteIndex,\n      Directory tmpIndexDir, long latestGeneration) throws Exception {\n    String indexDir = solrCore.getIndexDir();\n    \n    // it's okay to use null for lock factory since we know this dir will exist\n    Directory dir = solrCore.getDirectoryFactory().get(indexDir, DirContext.DEFAULT, solrCore.getSolrConfig().indexConfig.lockType);\n    try {\n      for (Map<String,Object> file : filesToDownload) {\n        if (!dir.fileExists((String) file.get(NAME)) || downloadCompleteIndex) {\n          dirFileFetcher = new DirectoryFileFetcher(tmpIndexDir, file,\n              (String) file.get(NAME), false, latestGeneration);\n          currentFile = file;\n          dirFileFetcher.fetchFile();\n          filesDownloaded.add(new HashMap<String,Object>(file));\n        } else {\n          LOG.info(\"Skipping download for \" + file.get(NAME) + \" because it already exists\");\n        }\n      }\n    } finally {\n      solrCore.getDirectoryFactory().release(dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8917bfede3b4ca30f4305c1e391e9218959cd723":["407687e67faf6e1f02a211ca078d8e3eed631027","1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674"],"1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674":["718607d99d02778db3280e64975663762c94170d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["d9405f486872f1e416304dfe389741f4ee2f8a4d","718607d99d02778db3280e64975663762c94170d"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6","190779ba7de3fda15afd1bbafbc383720a4b0966"],"43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6":["1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674"],"190779ba7de3fda15afd1bbafbc383720a4b0966":["43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f2126b84bd093fa3d921582a109a0ee578c28126":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"718607d99d02778db3280e64975663762c94170d":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["190779ba7de3fda15afd1bbafbc383720a4b0966"]},"commit2Childs":{"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674":["8917bfede3b4ca30f4305c1e391e9218959cd723","43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9405f486872f1e416304dfe389741f4ee2f8a4d","f2126b84bd093fa3d921582a109a0ee578c28126"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"43e5779eeb016d5b6980fbf3437f3e8ff4dbf1d6":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","190779ba7de3fda15afd1bbafbc383720a4b0966"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["407687e67faf6e1f02a211ca078d8e3eed631027","f2126b84bd093fa3d921582a109a0ee578c28126","718607d99d02778db3280e64975663762c94170d"],"190779ba7de3fda15afd1bbafbc383720a4b0966":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"718607d99d02778db3280e64975663762c94170d":["1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674","407687e67faf6e1f02a211ca078d8e3eed631027"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","74f45af4339b0daf7a95c820ab88c1aea74fbce0","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}