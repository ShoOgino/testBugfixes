{"path":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,int,Set).mjava","commits":[{"id":"13eaef7d286f35b5c850a1c2eb7b337679aa6453","date":1249118545,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,int,Set).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,IndexWriter,int,Set).mjava","sourceNew":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos,\n      int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    MergeSpecification spec;\n\n    assert maxNumSegments > 0;\n\n    if (!isOptimized(infos, maxNumSegments, segmentsToOptimize)) {\n\n      // Find the newest (rightmost) segment that needs to\n      // be optimized (other segments may have been flushed\n      // since optimize started):\n      int last = infos.size();\n      while(last > 0) {\n        final SegmentInfo info = infos.info(--last);\n        if (segmentsToOptimize.contains(info)) {\n          last++;\n          break;\n        }\n      }\n\n      if (last > 0) {\n\n        spec = new MergeSpecification();\n\n        // First, enroll all \"full\" merges (size\n        // mergeFactor) to potentially be run concurrently:\n        while (last - maxNumSegments + 1 >= mergeFactor) {\n          spec.add(new OneMerge(infos.range(last-mergeFactor, last), useCompoundFile));\n          last -= mergeFactor;\n        }\n\n        // Only if there are no full merges pending do we\n        // add a final partial (< mergeFactor segments) merge:\n        if (0 == spec.merges.size()) {\n          if (maxNumSegments == 1) {\n\n            // Since we must optimize down to 1 segment, the\n            // choice is simple:\n            if (last > 1 || !isOptimized(infos.info(0)))\n              spec.add(new OneMerge(infos.range(0, last), useCompoundFile));\n          } else if (last > maxNumSegments) {\n\n            // Take care to pick a partial merge that is\n            // least cost, but does not make the index too\n            // lopsided.  If we always just picked the\n            // partial tail then we could produce a highly\n            // lopsided index over time:\n\n            // We must merge this many segments to leave\n            // maxNumSegments in the index (from when\n            // optimize was first kicked off):\n            final int finalMergeSize = last - maxNumSegments + 1;\n\n            // Consider all possible starting points:\n            long bestSize = 0;\n            int bestStart = 0;\n\n            for(int i=0;i<last-finalMergeSize+1;i++) {\n              long sumSize = 0;\n              for(int j=0;j<finalMergeSize;j++)\n                sumSize += size(infos.info(j+i));\n              if (i == 0 || (sumSize < 2*size(infos.info(i-1)) && sumSize < bestSize)) {\n                bestStart = i;\n                bestSize = sumSize;\n              }\n            }\n\n            spec.add(new OneMerge(infos.range(bestStart, bestStart+finalMergeSize), useCompoundFile));\n          }\n        }\n        \n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","sourceOld":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    MergeSpecification spec;\n\n    assert maxNumSegments > 0;\n\n    if (!isOptimized(infos, writer, maxNumSegments, segmentsToOptimize)) {\n\n      // Find the newest (rightmost) segment that needs to\n      // be optimized (other segments may have been flushed\n      // since optimize started):\n      int last = infos.size();\n      while(last > 0) {\n        final SegmentInfo info = infos.info(--last);\n        if (segmentsToOptimize.contains(info)) {\n          last++;\n          break;\n        }\n      }\n\n      if (last > 0) {\n\n        spec = new MergeSpecification();\n\n        // First, enroll all \"full\" merges (size\n        // mergeFactor) to potentially be run concurrently:\n        while (last - maxNumSegments + 1 >= mergeFactor) {\n          spec.add(new OneMerge(infos.range(last-mergeFactor, last), useCompoundFile));\n          last -= mergeFactor;\n        }\n\n        // Only if there are no full merges pending do we\n        // add a final partial (< mergeFactor segments) merge:\n        if (0 == spec.merges.size()) {\n          if (maxNumSegments == 1) {\n\n            // Since we must optimize down to 1 segment, the\n            // choice is simple:\n            if (last > 1 || !isOptimized(writer, infos.info(0)))\n              spec.add(new OneMerge(infos.range(0, last), useCompoundFile));\n          } else if (last > maxNumSegments) {\n\n            // Take care to pick a partial merge that is\n            // least cost, but does not make the index too\n            // lopsided.  If we always just picked the\n            // partial tail then we could produce a highly\n            // lopsided index over time:\n\n            // We must merge this many segments to leave\n            // maxNumSegments in the index (from when\n            // optimize was first kicked off):\n            final int finalMergeSize = last - maxNumSegments + 1;\n\n            // Consider all possible starting points:\n            long bestSize = 0;\n            int bestStart = 0;\n\n            for(int i=0;i<last-finalMergeSize+1;i++) {\n              long sumSize = 0;\n              for(int j=0;j<finalMergeSize;j++)\n                sumSize += size(infos.info(j+i));\n              if (i == 0 || (sumSize < 2*size(infos.info(i-1)) && sumSize < bestSize)) {\n                bestStart = i;\n                bestSize = sumSize;\n              }\n            }\n\n            spec.add(new OneMerge(infos.range(bestStart, bestStart+finalMergeSize), useCompoundFile));\n          }\n        }\n        \n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d","date":1255859449,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,int,Set[SegmentInfo]).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,int,Set).mjava","sourceNew":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos,\n      int maxNumSegments, Set<SegmentInfo> segmentsToOptimize) throws IOException {\n    MergeSpecification spec;\n\n    assert maxNumSegments > 0;\n\n    if (!isOptimized(infos, maxNumSegments, segmentsToOptimize)) {\n\n      // Find the newest (rightmost) segment that needs to\n      // be optimized (other segments may have been flushed\n      // since optimize started):\n      int last = infos.size();\n      while(last > 0) {\n        final SegmentInfo info = infos.info(--last);\n        if (segmentsToOptimize.contains(info)) {\n          last++;\n          break;\n        }\n      }\n\n      if (last > 0) {\n\n        spec = new MergeSpecification();\n\n        // First, enroll all \"full\" merges (size\n        // mergeFactor) to potentially be run concurrently:\n        while (last - maxNumSegments + 1 >= mergeFactor) {\n          spec.add(new OneMerge(infos.range(last-mergeFactor, last), useCompoundFile));\n          last -= mergeFactor;\n        }\n\n        // Only if there are no full merges pending do we\n        // add a final partial (< mergeFactor segments) merge:\n        if (0 == spec.merges.size()) {\n          if (maxNumSegments == 1) {\n\n            // Since we must optimize down to 1 segment, the\n            // choice is simple:\n            if (last > 1 || !isOptimized(infos.info(0)))\n              spec.add(new OneMerge(infos.range(0, last), useCompoundFile));\n          } else if (last > maxNumSegments) {\n\n            // Take care to pick a partial merge that is\n            // least cost, but does not make the index too\n            // lopsided.  If we always just picked the\n            // partial tail then we could produce a highly\n            // lopsided index over time:\n\n            // We must merge this many segments to leave\n            // maxNumSegments in the index (from when\n            // optimize was first kicked off):\n            final int finalMergeSize = last - maxNumSegments + 1;\n\n            // Consider all possible starting points:\n            long bestSize = 0;\n            int bestStart = 0;\n\n            for(int i=0;i<last-finalMergeSize+1;i++) {\n              long sumSize = 0;\n              for(int j=0;j<finalMergeSize;j++)\n                sumSize += size(infos.info(j+i));\n              if (i == 0 || (sumSize < 2*size(infos.info(i-1)) && sumSize < bestSize)) {\n                bestStart = i;\n                bestSize = sumSize;\n              }\n            }\n\n            spec.add(new OneMerge(infos.range(bestStart, bestStart+finalMergeSize), useCompoundFile));\n          }\n        }\n        \n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","sourceOld":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos,\n      int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    MergeSpecification spec;\n\n    assert maxNumSegments > 0;\n\n    if (!isOptimized(infos, maxNumSegments, segmentsToOptimize)) {\n\n      // Find the newest (rightmost) segment that needs to\n      // be optimized (other segments may have been flushed\n      // since optimize started):\n      int last = infos.size();\n      while(last > 0) {\n        final SegmentInfo info = infos.info(--last);\n        if (segmentsToOptimize.contains(info)) {\n          last++;\n          break;\n        }\n      }\n\n      if (last > 0) {\n\n        spec = new MergeSpecification();\n\n        // First, enroll all \"full\" merges (size\n        // mergeFactor) to potentially be run concurrently:\n        while (last - maxNumSegments + 1 >= mergeFactor) {\n          spec.add(new OneMerge(infos.range(last-mergeFactor, last), useCompoundFile));\n          last -= mergeFactor;\n        }\n\n        // Only if there are no full merges pending do we\n        // add a final partial (< mergeFactor segments) merge:\n        if (0 == spec.merges.size()) {\n          if (maxNumSegments == 1) {\n\n            // Since we must optimize down to 1 segment, the\n            // choice is simple:\n            if (last > 1 || !isOptimized(infos.info(0)))\n              spec.add(new OneMerge(infos.range(0, last), useCompoundFile));\n          } else if (last > maxNumSegments) {\n\n            // Take care to pick a partial merge that is\n            // least cost, but does not make the index too\n            // lopsided.  If we always just picked the\n            // partial tail then we could produce a highly\n            // lopsided index over time:\n\n            // We must merge this many segments to leave\n            // maxNumSegments in the index (from when\n            // optimize was first kicked off):\n            final int finalMergeSize = last - maxNumSegments + 1;\n\n            // Consider all possible starting points:\n            long bestSize = 0;\n            int bestStart = 0;\n\n            for(int i=0;i<last-finalMergeSize+1;i++) {\n              long sumSize = 0;\n              for(int j=0;j<finalMergeSize;j++)\n                sumSize += size(infos.info(j+i));\n              if (i == 0 || (sumSize < 2*size(infos.info(i-1)) && sumSize < bestSize)) {\n                bestStart = i;\n                bestSize = sumSize;\n              }\n            }\n\n            spec.add(new OneMerge(infos.range(bestStart, bestStart+finalMergeSize), useCompoundFile));\n          }\n        }\n        \n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d":["13eaef7d286f35b5c850a1c2eb7b337679aa6453"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"13eaef7d286f35b5c850a1c2eb7b337679aa6453":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fa27b750ee9a51ec4bed93ef328aef9ca1e2153d"]},"commit2Childs":{"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["13eaef7d286f35b5c850a1c2eb7b337679aa6453"],"13eaef7d286f35b5c850a1c2eb7b337679aa6453":["fa27b750ee9a51ec4bed93ef328aef9ca1e2153d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}