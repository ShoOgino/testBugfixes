{"path":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","commits":[{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.info.docCount;\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.info.docCount;\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203d7d3cb7712e10ef33009a63247ae40c302d7a","date":1337798111,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.info.docCount;\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.info.docCount;\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"119ae5b0966bbb5d6948c7f86207613595764d2e","date":1357249026,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","c19f985e36a65cc969e8e564fe337a0d41512075"],"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e072d0b1fc19e0533d8ce432eed245196bca6fde","date":1379265112,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null, false);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null, false);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n    boolean anyNewUpdates = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(false, IOContext.READ); // don't apply deletes, as we're about to add more!\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            anyNewUpdates |= applyNumericDocValueUpdates(coalescedDeletes.numericDVUpdates, rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          anyNewUpdates |= applyNumericDocValueUpdates(Arrays.asList(packet.updates), rld, reader); \n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(false, IOContext.READ); // don't apply deletes, as we're about to add more!\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            anyNewUpdates |= applyNumericDocValueUpdates(coalescedDeletes.numericDVUpdates, rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted, anyNewUpdates);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe","date":1381909398,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          Map<String,NumericFieldUpdates> fieldUpdates = null;\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, fieldUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          fieldUpdates = applyNumericDocValuesUpdates(Arrays.asList(packet.updates), rld, reader, fieldUpdates);\n          if (!fieldUpdates.isEmpty()) {\n            rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            Map<String,NumericFieldUpdates> fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, null);\n            if (!fieldUpdates.isEmpty()) {\n              rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null, false);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null, false);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n    boolean anyNewUpdates = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(false, IOContext.READ); // don't apply deletes, as we're about to add more!\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            anyNewUpdates |= applyNumericDocValueUpdates(coalescedDeletes.numericDVUpdates, rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          anyNewUpdates |= applyNumericDocValueUpdates(Arrays.asList(packet.updates), rld, reader); \n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(false, IOContext.READ); // don't apply deletes, as we're about to add more!\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            anyNewUpdates |= applyNumericDocValueUpdates(coalescedDeletes.numericDVUpdates, rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted, anyNewUpdates);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyDeletesAndUpdates(IndexWriter.ReaderPool,List[SegmentCommitInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool readerPool, List<SegmentCommitInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + updates.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentCommitInfo> infos2 = new ArrayList<SegmentCommitInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedUpdates coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = updates.size()-1;\n\n    List<SegmentCommitInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;\n      final SegmentCommitInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndUpdates rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          Map<String,NumericFieldUpdates> fieldUpdates = null;\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, fieldUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          fieldUpdates = applyNumericDocValuesUpdates(Arrays.asList(packet.updates), rld, reader, fieldUpdates);\n          if (!fieldUpdates.isEmpty()) {\n            rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentCommitInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedUpdates();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndUpdates rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            Map<String,NumericFieldUpdates> fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, null);\n            if (!fieldUpdates.isEmpty()) {\n              rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentCommitInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    final long gen = nextGen++;\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n//        System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          Map<String,NumericFieldUpdates> fieldUpdates = null;\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, fieldUpdates);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          fieldUpdates = applyNumericDocValuesUpdates(Arrays.asList(packet.updates), rld, reader, fieldUpdates);\n          if (!fieldUpdates.isEmpty()) {\n            rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n          }\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(gen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            Map<String,NumericFieldUpdates> fieldUpdates = applyNumericDocValuesUpdates(coalescedDeletes.numericDVUpdates, rld, reader, null);\n            if (!fieldUpdates.isEmpty()) {\n              rld.writeFieldUpdates(info.info.dir, fieldUpdates);\n            }\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {\n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + coalescedDeletes + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(gen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["119ae5b0966bbb5d6948c7f86207613595764d2e"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","119ae5b0966bbb5d6948c7f86207613595764d2e"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","203d7d3cb7712e10ef33009a63247ae40c302d7a"],"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d153abcf92dc5329d98571a8c3035df9bd80648":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"119ae5b0966bbb5d6948c7f86207613595764d2e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"]},"commit2Childs":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","119ae5b0966bbb5d6948c7f86207613595764d2e"],"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","9d153abcf92dc5329d98571a8c3035df9bd80648"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"119ae5b0966bbb5d6948c7f86207613595764d2e":["e072d0b1fc19e0533d8ce432eed245196bca6fde","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}