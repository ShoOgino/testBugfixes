{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","commits":[{"id":"937923083e4d137932336fc80f3d78758ff698a6","date":1454691519,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    noVirusChecker(dir);\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2331aada47d7da50e6835b59445dadc1bd456c39","date":1456778709,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + (distanceKM * 1000)\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"278394e71c5c3727ff5225bafdde73d7454d0012","date":1458392644,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d102f8823b515dca7758d04ef1039875f73324e","date":1458843204,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"/dev/null","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(75);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n      }\n      Query query;\n      VerifyHits verifyHits;\n\n      if (random().nextBoolean()) {\n        // Rect: don't allow dateline crossing when testing small:\n        final GeoRect rect = randomRect(small, small == false);\n\n        query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return rectContainsPoint(rect, pointLat, pointLon);\n          }\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n\n      } else if (random().nextBoolean()) {\n        // Distance\n        final boolean rangeQuery = random().nextBoolean();\n        final double centerLat = randomLat(small);\n        final double centerLon = randomLon(small);\n\n        double radiusMeters;\n        double minRadiusMeters;\n\n        if (small) {\n          // Approx 3 degrees lon at the equator:\n          radiusMeters = random().nextDouble() * 333000 + 1.0;\n        } else {\n          // So the query can cover at most 50% of the earth's surface:\n          radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n        }\n\n        // generate a random minimum radius between 1% and 95% the max radius\n        minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n        if (VERBOSE) {\n          final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n          System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n          + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n        }\n\n        try {\n          if (rangeQuery == true) {\n            query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n          } else {\n            query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n          }\n        } catch (IllegalArgumentException e) {\n          if (e.getMessage().contains(\"exceeds maxRadius\")) {\n            continue;\n          }\n          throw e;\n        }\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            if (rangeQuery == false) {\n              return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n            } else {\n              return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n            }\n          }\n\n          @Override\n          protected void describe(int docID, double pointLat, double pointLon) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n            System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n          }\n        };\n\n        // TODO: get poly query working with dateline crossing too (how?)!\n      } else {\n\n        // TODO: poly query can't handle dateline crossing yet:\n        final GeoRect bbox = randomRect(small, false);\n\n        // Polygon\n        double[] polyLats = new double[5];\n        double[] polyLons = new double[5];\n        polyLats[0] = bbox.minLat;\n        polyLons[0] = bbox.minLon;\n        polyLats[1] = bbox.maxLat;\n        polyLons[1] = bbox.minLon;\n        polyLats[2] = bbox.maxLat;\n        polyLons[2] = bbox.maxLon;\n        polyLats[3] = bbox.minLat;\n        polyLons[3] = bbox.maxLon;\n        polyLats[4] = bbox.minLat;\n        polyLons[4] = bbox.minLon;\n        query = newPolygonQuery(FIELD_NAME, polyLats, polyLons);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return polyRectContainsPoint(bbox, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n      }\n\n      if (query != null) {\n\n        if (VERBOSE) {\n          System.out.println(\"  query=\" + query);\n        }\n\n        verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f9686ea8f446704d6bb22f2cb00a63aa9ca52400"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"53ae4376ac9dc30118cb178489db6519070ba5bb","date":1459106837,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(75);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n      }\n      Query query;\n      VerifyHits verifyHits;\n\n      if (random().nextBoolean()) {\n        // Rect: don't allow dateline crossing when testing small:\n        final GeoRect rect = randomRect(small, small == false);\n\n        query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return rectContainsPoint(rect, pointLat, pointLon);\n          }\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n\n      } else if (random().nextBoolean()) {\n        // Distance\n        final boolean rangeQuery = random().nextBoolean();\n        final double centerLat = randomLat(small);\n        final double centerLon = randomLon(small);\n\n        double radiusMeters;\n        double minRadiusMeters;\n\n        if (small) {\n          // Approx 3 degrees lon at the equator:\n          radiusMeters = random().nextDouble() * 333000 + 1.0;\n        } else {\n          // So the query can cover at most 50% of the earth's surface:\n          radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n        }\n\n        // generate a random minimum radius between 1% and 95% the max radius\n        minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n        if (VERBOSE) {\n          final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n          System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n          + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n        }\n\n        try {\n          if (rangeQuery == true) {\n            query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n          } else {\n            query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n          }\n        } catch (IllegalArgumentException e) {\n          if (e.getMessage().contains(\"exceeds maxRadius\")) {\n            continue;\n          }\n          throw e;\n        }\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            if (rangeQuery == false) {\n              return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n            } else {\n              return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n            }\n          }\n\n          @Override\n          protected void describe(int docID, double pointLat, double pointLon) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n            System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n          }\n        };\n\n        // TODO: get poly query working with dateline crossing too (how?)!\n      } else {\n\n        // TODO: poly query can't handle dateline crossing yet:\n        final GeoRect bbox = randomRect(small, false);\n\n        // Polygon\n        final double[] polyLats;\n        final double[] polyLons;\n        // TODO: factor this out, maybe if we add Polygon class?\n        if (random().nextBoolean()) {\n          // box\n          polyLats = new double[5];\n          polyLons = new double[5];\n          polyLats[0] = bbox.minLat;\n          polyLons[0] = bbox.minLon;\n          polyLats[1] = bbox.maxLat;\n          polyLons[1] = bbox.minLon;\n          polyLats[2] = bbox.maxLat;\n          polyLons[2] = bbox.maxLon;\n          polyLats[3] = bbox.minLat;\n          polyLons[3] = bbox.maxLon;\n          polyLats[4] = bbox.minLat;\n          polyLons[4] = bbox.minLon;\n        } else {\n          // right triangle\n          polyLats = new double[4];\n          polyLons = new double[4];\n          polyLats[0] = bbox.minLat;\n          polyLons[0] = bbox.minLon;\n          polyLats[1] = bbox.maxLat;\n          polyLons[1] = bbox.minLon;\n          polyLats[2] = bbox.maxLat;\n          polyLons[2] = bbox.maxLon;\n          polyLats[3] = bbox.minLat;\n          polyLons[3] = bbox.minLon;\n        }\n        query = newPolygonQuery(FIELD_NAME, polyLats, polyLons);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return polygonContainsPoint(polyLats, polyLons, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n      }\n\n      if (query != null) {\n\n        if (VERBOSE) {\n          System.out.println(\"  query=\" + query);\n        }\n\n        verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(75);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n      }\n      Query query;\n      VerifyHits verifyHits;\n\n      if (random().nextBoolean()) {\n        // Rect: don't allow dateline crossing when testing small:\n        final GeoRect rect = randomRect(small, small == false);\n\n        query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return rectContainsPoint(rect, pointLat, pointLon);\n          }\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n\n      } else if (random().nextBoolean()) {\n        // Distance\n        final boolean rangeQuery = random().nextBoolean();\n        final double centerLat = randomLat(small);\n        final double centerLon = randomLon(small);\n\n        double radiusMeters;\n        double minRadiusMeters;\n\n        if (small) {\n          // Approx 3 degrees lon at the equator:\n          radiusMeters = random().nextDouble() * 333000 + 1.0;\n        } else {\n          // So the query can cover at most 50% of the earth's surface:\n          radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n        }\n\n        // generate a random minimum radius between 1% and 95% the max radius\n        minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n        if (VERBOSE) {\n          final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n          System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n          + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n        }\n\n        try {\n          if (rangeQuery == true) {\n            query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n          } else {\n            query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n          }\n        } catch (IllegalArgumentException e) {\n          if (e.getMessage().contains(\"exceeds maxRadius\")) {\n            continue;\n          }\n          throw e;\n        }\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            if (rangeQuery == false) {\n              return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n            } else {\n              return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n            }\n          }\n\n          @Override\n          protected void describe(int docID, double pointLat, double pointLon) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n            System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n          }\n        };\n\n        // TODO: get poly query working with dateline crossing too (how?)!\n      } else {\n\n        // TODO: poly query can't handle dateline crossing yet:\n        final GeoRect bbox = randomRect(small, false);\n\n        // Polygon\n        double[] polyLats = new double[5];\n        double[] polyLons = new double[5];\n        polyLats[0] = bbox.minLat;\n        polyLons[0] = bbox.minLon;\n        polyLats[1] = bbox.maxLat;\n        polyLons[1] = bbox.minLon;\n        polyLats[2] = bbox.maxLat;\n        polyLons[2] = bbox.maxLon;\n        polyLats[3] = bbox.minLat;\n        polyLons[3] = bbox.maxLon;\n        polyLats[4] = bbox.minLat;\n        polyLons[4] = bbox.minLon;\n        query = newPolygonQuery(FIELD_NAME, polyLats, polyLons);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return polyRectContainsPoint(bbox, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n      }\n\n      if (query != null) {\n\n        if (VERBOSE) {\n          System.out.println(\"  query=\" + query);\n        }\n\n        verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac94c1c73e01278464e2c6be2b6f7ea0df26a571","date":1459112294,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(75);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n      }\n      Query query;\n      VerifyHits verifyHits;\n\n      if (random().nextBoolean()) {\n        // Rect: don't allow dateline crossing when testing small:\n        final GeoRect rect = randomRect(small, small == false);\n\n        query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return rectContainsPoint(rect, pointLat, pointLon);\n          }\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n\n      } else if (random().nextBoolean()) {\n        // Distance\n        final boolean rangeQuery = random().nextBoolean();\n        final double centerLat = randomLat(small);\n        final double centerLon = randomLon(small);\n\n        double radiusMeters;\n        double minRadiusMeters;\n\n        if (small) {\n          // Approx 3 degrees lon at the equator:\n          radiusMeters = random().nextDouble() * 333000 + 1.0;\n        } else {\n          // So the query can cover at most 50% of the earth's surface:\n          radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n        }\n\n        // generate a random minimum radius between 1% and 95% the max radius\n        minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n        if (VERBOSE) {\n          final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n          System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n          + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n        }\n\n        try {\n          if (rangeQuery == true) {\n            query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n          } else {\n            query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n          }\n        } catch (IllegalArgumentException e) {\n          if (e.getMessage().contains(\"exceeds maxRadius\")) {\n            continue;\n          }\n          throw e;\n        }\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            if (rangeQuery == false) {\n              return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n            } else {\n              return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n            }\n          }\n\n          @Override\n          protected void describe(int docID, double pointLat, double pointLon) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n            System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n          }\n        };\n\n        // TODO: get poly query working with dateline crossing too (how?)!\n      } else {\n\n        // TODO: poly query can't handle dateline crossing yet:\n        final GeoRect bbox = randomRect(small, false);\n\n        // Polygon\n        final double[] polyLats;\n        final double[] polyLons;\n        // TODO: factor this out, maybe if we add Polygon class?\n        switch (random().nextInt(3)) {\n          case 0:\n            // box\n            polyLats = new double[5];\n            polyLons = new double[5];\n            polyLats[0] = bbox.minLat;\n            polyLons[0] = bbox.minLon;\n            polyLats[1] = bbox.maxLat;\n            polyLons[1] = bbox.minLon;\n            polyLats[2] = bbox.maxLat;\n            polyLons[2] = bbox.maxLon;\n            polyLats[3] = bbox.minLat;\n            polyLons[3] = bbox.maxLon;\n            polyLats[4] = bbox.minLat;\n            polyLons[4] = bbox.minLon;\n            break;\n          case 1:\n            // right triangle\n            polyLats = new double[4];\n            polyLons = new double[4];\n            polyLats[0] = bbox.minLat;\n            polyLons[0] = bbox.minLon;\n            polyLats[1] = bbox.maxLat;\n            polyLons[1] = bbox.minLon;\n            polyLats[2] = bbox.maxLat;\n            polyLons[2] = bbox.maxLon;\n            polyLats[3] = bbox.minLat;\n            polyLons[3] = bbox.minLon;\n            break;\n          default:\n            // surprise me!\n            double[][] res = surpriseMePolygon();\n            polyLats = res[0];\n            polyLons = res[1];\n            break;\n        }\n        query = newPolygonQuery(FIELD_NAME, polyLats, polyLons);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return polygonContainsPoint(polyLats, polyLons, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n      }\n\n      if (query != null) {\n\n        if (VERBOSE) {\n          System.out.println(\"  query=\" + query);\n        }\n\n        verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(75);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n      }\n      Query query;\n      VerifyHits verifyHits;\n\n      if (random().nextBoolean()) {\n        // Rect: don't allow dateline crossing when testing small:\n        final GeoRect rect = randomRect(small, small == false);\n\n        query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return rectContainsPoint(rect, pointLat, pointLon);\n          }\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n\n      } else if (random().nextBoolean()) {\n        // Distance\n        final boolean rangeQuery = random().nextBoolean();\n        final double centerLat = randomLat(small);\n        final double centerLon = randomLon(small);\n\n        double radiusMeters;\n        double minRadiusMeters;\n\n        if (small) {\n          // Approx 3 degrees lon at the equator:\n          radiusMeters = random().nextDouble() * 333000 + 1.0;\n        } else {\n          // So the query can cover at most 50% of the earth's surface:\n          radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n        }\n\n        // generate a random minimum radius between 1% and 95% the max radius\n        minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n        if (VERBOSE) {\n          final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n          System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n          + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n        }\n\n        try {\n          if (rangeQuery == true) {\n            query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n          } else {\n            query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n          }\n        } catch (IllegalArgumentException e) {\n          if (e.getMessage().contains(\"exceeds maxRadius\")) {\n            continue;\n          }\n          throw e;\n        }\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            if (rangeQuery == false) {\n              return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n            } else {\n              return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n            }\n          }\n\n          @Override\n          protected void describe(int docID, double pointLat, double pointLon) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n            System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n          }\n        };\n\n        // TODO: get poly query working with dateline crossing too (how?)!\n      } else {\n\n        // TODO: poly query can't handle dateline crossing yet:\n        final GeoRect bbox = randomRect(small, false);\n\n        // Polygon\n        final double[] polyLats;\n        final double[] polyLons;\n        // TODO: factor this out, maybe if we add Polygon class?\n        if (random().nextBoolean()) {\n          // box\n          polyLats = new double[5];\n          polyLons = new double[5];\n          polyLats[0] = bbox.minLat;\n          polyLons[0] = bbox.minLon;\n          polyLats[1] = bbox.maxLat;\n          polyLons[1] = bbox.minLon;\n          polyLats[2] = bbox.maxLat;\n          polyLons[2] = bbox.maxLon;\n          polyLats[3] = bbox.minLat;\n          polyLons[3] = bbox.maxLon;\n          polyLats[4] = bbox.minLat;\n          polyLons[4] = bbox.minLon;\n        } else {\n          // right triangle\n          polyLats = new double[4];\n          polyLons = new double[4];\n          polyLats[0] = bbox.minLat;\n          polyLons[0] = bbox.minLon;\n          polyLats[1] = bbox.maxLat;\n          polyLons[1] = bbox.minLon;\n          polyLats[2] = bbox.maxLat;\n          polyLons[2] = bbox.maxLon;\n          polyLats[3] = bbox.minLat;\n          polyLons[3] = bbox.minLon;\n        }\n        query = newPolygonQuery(FIELD_NAME, polyLats, polyLons);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return polygonContainsPoint(polyLats, polyLons, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n      }\n\n      if (query != null) {\n\n        if (VERBOSE) {\n          System.out.println(\"  query=\" + query);\n        }\n\n        verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f9686ea8f446704d6bb22f2cb00a63aa9ca52400","date":1459165568,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(75);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n      }\n      Query query;\n      VerifyHits verifyHits;\n\n      if (random().nextBoolean()) {\n        // Rect: don't allow dateline crossing when testing small:\n        final GeoRect rect = randomRect(small, small == false);\n\n        query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return rectContainsPoint(rect, pointLat, pointLon);\n          }\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n\n      } else if (random().nextBoolean()) {\n        // Distance\n        final double centerLat = randomLat(small);\n        final double centerLon = randomLon(small);\n\n        final double radiusMeters;\n        if (small) {\n          // Approx 3 degrees lon at the equator:\n          radiusMeters = random().nextDouble() * 333000 + 1.0;\n        } else {\n          // So the query can cover at most 50% of the earth's surface:\n          radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n        }\n\n        if (VERBOSE) {\n          final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n          System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n        }\n\n        query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double pointLat, double pointLon) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n            System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                + \" vs radiusMeters=\" + radiusMeters);\n          }\n        };\n\n        // TODO: get poly query working with dateline crossing too (how?)!\n      } else {\n\n        // TODO: poly query can't handle dateline crossing yet:\n        final GeoRect bbox = randomRect(small, false);\n\n        // Polygon\n        final double[] polyLats;\n        final double[] polyLons;\n        // TODO: factor this out, maybe if we add Polygon class?\n        switch (random().nextInt(3)) {\n          case 0:\n            // box\n            polyLats = new double[5];\n            polyLons = new double[5];\n            polyLats[0] = bbox.minLat;\n            polyLons[0] = bbox.minLon;\n            polyLats[1] = bbox.maxLat;\n            polyLons[1] = bbox.minLon;\n            polyLats[2] = bbox.maxLat;\n            polyLons[2] = bbox.maxLon;\n            polyLats[3] = bbox.minLat;\n            polyLons[3] = bbox.maxLon;\n            polyLats[4] = bbox.minLat;\n            polyLons[4] = bbox.minLon;\n            break;\n          case 1:\n            // right triangle\n            polyLats = new double[4];\n            polyLons = new double[4];\n            polyLats[0] = bbox.minLat;\n            polyLons[0] = bbox.minLon;\n            polyLats[1] = bbox.maxLat;\n            polyLons[1] = bbox.minLon;\n            polyLats[2] = bbox.maxLat;\n            polyLons[2] = bbox.maxLon;\n            polyLats[3] = bbox.minLat;\n            polyLons[3] = bbox.minLon;\n            break;\n          default:\n            // surprise me!\n            double[][] res = surpriseMePolygon();\n            polyLats = res[0];\n            polyLons = res[1];\n            break;\n        }\n        query = newPolygonQuery(FIELD_NAME, polyLats, polyLons);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return polygonContainsPoint(polyLats, polyLons, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n      }\n\n      if (query != null) {\n\n        if (VERBOSE) {\n          System.out.println(\"  query=\" + query);\n        }\n\n        verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(75);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n      }\n      Query query;\n      VerifyHits verifyHits;\n\n      if (random().nextBoolean()) {\n        // Rect: don't allow dateline crossing when testing small:\n        final GeoRect rect = randomRect(small, small == false);\n\n        query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return rectContainsPoint(rect, pointLat, pointLon);\n          }\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n\n      } else if (random().nextBoolean()) {\n        // Distance\n        final boolean rangeQuery = random().nextBoolean();\n        final double centerLat = randomLat(small);\n        final double centerLon = randomLon(small);\n\n        double radiusMeters;\n        double minRadiusMeters;\n\n        if (small) {\n          // Approx 3 degrees lon at the equator:\n          radiusMeters = random().nextDouble() * 333000 + 1.0;\n        } else {\n          // So the query can cover at most 50% of the earth's surface:\n          radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n        }\n\n        // generate a random minimum radius between 1% and 95% the max radius\n        minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n        if (VERBOSE) {\n          final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n          System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n          + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n        }\n\n        try {\n          if (rangeQuery == true) {\n            query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n          } else {\n            query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n          }\n        } catch (IllegalArgumentException e) {\n          if (e.getMessage().contains(\"exceeds maxRadius\")) {\n            continue;\n          }\n          throw e;\n        }\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            if (rangeQuery == false) {\n              return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n            } else {\n              return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n            }\n          }\n\n          @Override\n          protected void describe(int docID, double pointLat, double pointLon) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n            System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n          }\n        };\n\n        // TODO: get poly query working with dateline crossing too (how?)!\n      } else {\n\n        // TODO: poly query can't handle dateline crossing yet:\n        final GeoRect bbox = randomRect(small, false);\n\n        // Polygon\n        final double[] polyLats;\n        final double[] polyLons;\n        // TODO: factor this out, maybe if we add Polygon class?\n        switch (random().nextInt(3)) {\n          case 0:\n            // box\n            polyLats = new double[5];\n            polyLons = new double[5];\n            polyLats[0] = bbox.minLat;\n            polyLons[0] = bbox.minLon;\n            polyLats[1] = bbox.maxLat;\n            polyLons[1] = bbox.minLon;\n            polyLats[2] = bbox.maxLat;\n            polyLons[2] = bbox.maxLon;\n            polyLats[3] = bbox.minLat;\n            polyLons[3] = bbox.maxLon;\n            polyLats[4] = bbox.minLat;\n            polyLons[4] = bbox.minLon;\n            break;\n          case 1:\n            // right triangle\n            polyLats = new double[4];\n            polyLons = new double[4];\n            polyLats[0] = bbox.minLat;\n            polyLons[0] = bbox.minLon;\n            polyLats[1] = bbox.maxLat;\n            polyLons[1] = bbox.minLon;\n            polyLats[2] = bbox.maxLat;\n            polyLons[2] = bbox.maxLon;\n            polyLats[3] = bbox.minLat;\n            polyLons[3] = bbox.minLon;\n            break;\n          default:\n            // surprise me!\n            double[][] res = surpriseMePolygon();\n            polyLats = res[0];\n            polyLons = res[1];\n            break;\n        }\n        query = newPolygonQuery(FIELD_NAME, polyLats, polyLons);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return polygonContainsPoint(polyLats, polyLons, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n      }\n\n      if (query != null) {\n\n        if (VERBOSE) {\n          System.out.println(\"  query=\" + query);\n        }\n\n        verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":["1d102f8823b515dca7758d04ef1039875f73324e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84d7daf8313ff5c20a3ab51ffd646f5e862e1bac","date":1459177733,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  private void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    verifyRandomRectangles(small, lats, lons);\n    verifyRandomDistances(small, lats, lons);\n    verifyRandomPolygons(small, lats, lons);\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    final int iters = atLeast(75);\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n    for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n      if (VERBOSE) {\n        System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n      }\n      Query query;\n      VerifyHits verifyHits;\n\n      if (random().nextBoolean()) {\n        // Rect: don't allow dateline crossing when testing small:\n        final GeoRect rect = randomRect(small, small == false);\n\n        query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return rectContainsPoint(rect, pointLat, pointLon);\n          }\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n\n      } else if (random().nextBoolean()) {\n        // Distance\n        final double centerLat = randomLat(small);\n        final double centerLon = randomLon(small);\n\n        final double radiusMeters;\n        if (small) {\n          // Approx 3 degrees lon at the equator:\n          radiusMeters = random().nextDouble() * 333000 + 1.0;\n        } else {\n          // So the query can cover at most 50% of the earth's surface:\n          radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n        }\n\n        if (VERBOSE) {\n          final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n          System.out.println(\"  radiusMeters = \" + df.format(radiusMeters));\n        }\n\n        query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double pointLat, double pointLon) {\n            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n            System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                + \" vs radiusMeters=\" + radiusMeters);\n          }\n        };\n\n        // TODO: get poly query working with dateline crossing too (how?)!\n      } else {\n\n        // TODO: poly query can't handle dateline crossing yet:\n        final GeoRect bbox = randomRect(small, false);\n\n        // Polygon\n        final double[] polyLats;\n        final double[] polyLons;\n        // TODO: factor this out, maybe if we add Polygon class?\n        switch (random().nextInt(3)) {\n          case 0:\n            // box\n            polyLats = new double[5];\n            polyLons = new double[5];\n            polyLats[0] = bbox.minLat;\n            polyLons[0] = bbox.minLon;\n            polyLats[1] = bbox.maxLat;\n            polyLons[1] = bbox.minLon;\n            polyLats[2] = bbox.maxLat;\n            polyLons[2] = bbox.maxLon;\n            polyLats[3] = bbox.minLat;\n            polyLons[3] = bbox.maxLon;\n            polyLats[4] = bbox.minLat;\n            polyLons[4] = bbox.minLon;\n            break;\n          case 1:\n            // right triangle\n            polyLats = new double[4];\n            polyLons = new double[4];\n            polyLats[0] = bbox.minLat;\n            polyLons[0] = bbox.minLon;\n            polyLats[1] = bbox.maxLat;\n            polyLons[1] = bbox.minLon;\n            polyLats[2] = bbox.maxLat;\n            polyLons[2] = bbox.maxLon;\n            polyLats[3] = bbox.minLat;\n            polyLons[3] = bbox.minLon;\n            break;\n          default:\n            // surprise me!\n            double[][] res = surpriseMePolygon();\n            polyLats = res[0];\n            polyLons = res[1];\n            break;\n        }\n        query = newPolygonQuery(FIELD_NAME, polyLats, polyLons);\n\n        verifyHits = new VerifyHits() {\n          @Override\n          protected boolean shouldMatch(double pointLat, double pointLon) {\n            return polygonContainsPoint(polyLats, polyLons, pointLat, pointLon);\n          }\n\n          @Override\n          protected void describe(int docID, double lat, double lon) {\n          }\n        };\n      }\n\n      if (query != null) {\n\n        if (VERBOSE) {\n          System.out.println(\"  query=\" + query);\n        }\n\n        verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n      }\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"253f983bd74e240286a3e1a1e40294d589c5bef4","date":1459190341,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  private void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    // quantize each value the same way the index does\n    for (int i = 0; i < lats.length; i++) {\n      lats[i] = quantizeLat(lats[i]);\n    }\n    for (int i = 0; i < lons.length; i++) {\n      lons[i] = quantizeLon(lons[i]);\n    }\n    verifyRandomRectangles(small, lats, lons);\n    verifyRandomDistances(small, lats, lons);\n    verifyRandomPolygons(small, lats, lons);\n  }\n\n","sourceOld":"  private void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    verifyRandomRectangles(small, lats, lons);\n    verifyRandomDistances(small, lats, lons);\n    verifyRandomPolygons(small, lats, lons);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68733ee78b8968fcc7a4fff0d89b17f1c5284c1a","date":1459195322,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  private void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    // quantize each value the same way the index does\n    // NaN means missing for the doc!!!!!\n    for (int i = 0; i < lats.length; i++) {\n      if (!Double.isNaN(lats[i])) {\n        lats[i] = quantizeLat(lats[i]);\n      }\n    }\n    for (int i = 0; i < lons.length; i++) {\n      if (!Double.isNaN(lons[i])) {\n        lons[i] = quantizeLon(lons[i]);\n      }\n    }\n    verifyRandomRectangles(small, lats, lons);\n    verifyRandomDistances(small, lats, lons);\n    verifyRandomPolygons(small, lats, lons);\n  }\n\n","sourceOld":"  private void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    // quantize each value the same way the index does\n    for (int i = 0; i < lats.length; i++) {\n      lats[i] = quantizeLat(lats[i]);\n    }\n    for (int i = 0; i < lons.length; i++) {\n      lons[i] = quantizeLon(lons[i]);\n    }\n    verifyRandomRectangles(small, lats, lons);\n    verifyRandomDistances(small, lats, lons);\n    verifyRandomPolygons(small, lats, lons);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e21d7642ee7e0c00429964e5b47504602fe218c","date":1460897579,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  private void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    // quantize each value the same way the index does\n    // NaN means missing for the doc!!!!!\n    for (int i = 0; i < lats.length; i++) {\n      if (!Double.isNaN(lats[i])) {\n        lats[i] = quantizeLat(lats[i]);\n      }\n    }\n    for (int i = 0; i < lons.length; i++) {\n      if (!Double.isNaN(lons[i])) {\n        lons[i] = quantizeLon(lons[i]);\n      }\n    }\n    verifyRandomRectangles(small, lats, lons);\n    verifyRandomDistances(small, lats, lons);\n    verifyRandomPolygons(small, lats, lons);\n  }\n\n","sourceOld":"  private void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    // quantize each value the same way the index does\n    // NaN means missing for the doc!!!!!\n    for (int i = 0; i < lats.length; i++) {\n      if (!Double.isNaN(lats[i])) {\n        lats[i] = quantizeLat(lats[i]);\n      }\n    }\n    for (int i = 0; i < lons.length; i++) {\n      if (!Double.isNaN(lons[i])) {\n        lons[i] = quantizeLon(lons[i]);\n      }\n    }\n    verifyRandomRectangles(small, lats, lons);\n    verifyRandomDistances(small, lats, lons);\n    verifyRandomPolygons(small, lats, lons);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8cb57c50beb99a1245256e866350af8e5ea1f36","date":1460921840,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  private void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    // quantize each value the same way the index does\n    // NaN means missing for the doc!!!!!\n    for (int i = 0; i < lats.length; i++) {\n      if (!Double.isNaN(lats[i])) {\n        lats[i] = quantizeLat(lats[i]);\n      }\n    }\n    for (int i = 0; i < lons.length; i++) {\n      if (!Double.isNaN(lons[i])) {\n        lons[i] = quantizeLon(lons[i]);\n      }\n    }\n    verifyRandomRectangles(small, lats, lons);\n    verifyRandomDistances(small, lats, lons);\n    verifyRandomPolygons(small, lats, lons);\n  }\n\n","sourceOld":"  private void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    // quantize each value the same way the index does\n    // NaN means missing for the doc!!!!!\n    for (int i = 0; i < lats.length; i++) {\n      if (!Double.isNaN(lats[i])) {\n        lats[i] = quantizeLat(lats[i]);\n      }\n    }\n    for (int i = 0; i < lons.length; i++) {\n      if (!Double.isNaN(lons[i])) {\n        lons[i] = quantizeLon(lons[i]);\n      }\n    }\n    verifyRandomRectangles(small, lats, lons);\n    verifyRandomDistances(small, lats, lons);\n    verifyRandomPolygons(small, lats, lons);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["68496c2200e559fb7802f7575427b7a482659afb","2331aada47d7da50e6835b59445dadc1bd456c39"],"68733ee78b8968fcc7a4fff0d89b17f1c5284c1a":["253f983bd74e240286a3e1a1e40294d589c5bef4"],"253f983bd74e240286a3e1a1e40294d589c5bef4":["84d7daf8313ff5c20a3ab51ffd646f5e862e1bac"],"5a207d19eac354d649c3f0e2cce070017c78125e":["937923083e4d137932336fc80f3d78758ff698a6","b470f36a9372c97283360b1304eacbde22df6c0d"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b470f36a9372c97283360b1304eacbde22df6c0d"],"53ae4376ac9dc30118cb178489db6519070ba5bb":["1d102f8823b515dca7758d04ef1039875f73324e"],"2331aada47d7da50e6835b59445dadc1bd456c39":["68496c2200e559fb7802f7575427b7a482659afb"],"278394e71c5c3727ff5225bafdde73d7454d0012":["af2638813028b254a88b418ebeafb541afb49653"],"f8cb57c50beb99a1245256e866350af8e5ea1f36":["68733ee78b8968fcc7a4fff0d89b17f1c5284c1a","3e21d7642ee7e0c00429964e5b47504602fe218c"],"1d102f8823b515dca7758d04ef1039875f73324e":["278394e71c5c3727ff5225bafdde73d7454d0012"],"84d7daf8313ff5c20a3ab51ffd646f5e862e1bac":["f9686ea8f446704d6bb22f2cb00a63aa9ca52400"],"b470f36a9372c97283360b1304eacbde22df6c0d":["937923083e4d137932336fc80f3d78758ff698a6","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"ac94c1c73e01278464e2c6be2b6f7ea0df26a571":["53ae4376ac9dc30118cb178489db6519070ba5bb"],"937923083e4d137932336fc80f3d78758ff698a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3e21d7642ee7e0c00429964e5b47504602fe218c":["68733ee78b8968fcc7a4fff0d89b17f1c5284c1a"],"f9686ea8f446704d6bb22f2cb00a63aa9ca52400":["ac94c1c73e01278464e2c6be2b6f7ea0df26a571"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f8cb57c50beb99a1245256e866350af8e5ea1f36"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["278394e71c5c3727ff5225bafdde73d7454d0012"],"68733ee78b8968fcc7a4fff0d89b17f1c5284c1a":["f8cb57c50beb99a1245256e866350af8e5ea1f36","3e21d7642ee7e0c00429964e5b47504602fe218c"],"253f983bd74e240286a3e1a1e40294d589c5bef4":["68733ee78b8968fcc7a4fff0d89b17f1c5284c1a"],"5a207d19eac354d649c3f0e2cce070017c78125e":["68496c2200e559fb7802f7575427b7a482659afb"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["68496c2200e559fb7802f7575427b7a482659afb"],"2331aada47d7da50e6835b59445dadc1bd456c39":["af2638813028b254a88b418ebeafb541afb49653"],"53ae4376ac9dc30118cb178489db6519070ba5bb":["ac94c1c73e01278464e2c6be2b6f7ea0df26a571"],"278394e71c5c3727ff5225bafdde73d7454d0012":["1d102f8823b515dca7758d04ef1039875f73324e"],"f8cb57c50beb99a1245256e866350af8e5ea1f36":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d102f8823b515dca7758d04ef1039875f73324e":["53ae4376ac9dc30118cb178489db6519070ba5bb"],"84d7daf8313ff5c20a3ab51ffd646f5e862e1bac":["253f983bd74e240286a3e1a1e40294d589c5bef4"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","b470f36a9372c97283360b1304eacbde22df6c0d","937923083e4d137932336fc80f3d78758ff698a6"],"68496c2200e559fb7802f7575427b7a482659afb":["af2638813028b254a88b418ebeafb541afb49653","2331aada47d7da50e6835b59445dadc1bd456c39"],"ac94c1c73e01278464e2c6be2b6f7ea0df26a571":["f9686ea8f446704d6bb22f2cb00a63aa9ca52400"],"937923083e4d137932336fc80f3d78758ff698a6":["5a207d19eac354d649c3f0e2cce070017c78125e","b470f36a9372c97283360b1304eacbde22df6c0d"],"3e21d7642ee7e0c00429964e5b47504602fe218c":["f8cb57c50beb99a1245256e866350af8e5ea1f36"],"f9686ea8f446704d6bb22f2cb00a63aa9ca52400":["84d7daf8313ff5c20a3ab51ffd646f5e862e1bac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}