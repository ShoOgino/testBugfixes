{"path":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","commits":[{"id":"f0852ebe96f807ea1c84a88f9aaa4985a2088594","date":1304368766,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"/dev/null","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new Field(\"field\", \"\", Field.Store.NO, Field.Index.ANALYZED));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assert hits.totalHits == 2;\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"/dev/null","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new Field(\"field\", \"\", Field.Store.NO, Field.Index.ANALYZED));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assert hits.totalHits == 2;\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0226c4da52b4b59afa6d616cdf5bacb3733ca47e","date":1305730778,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new Field(\"field\", \"\", Field.Store.NO, Field.Index.ANALYZED));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new Field(\"field\", \"\", Field.Store.NO, Field.Index.ANALYZED));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assert hits.totalHits == 2;\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new Field(\"field\", \"\", Field.Store.NO, Field.Index.ANALYZED));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new Field(\"field\", \"\", Field.Store.NO, Field.Index.ANALYZED));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assert hits.totalHits == 2;\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"/dev/null","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new Field(\"field\", \"\", Field.Store.NO, Field.Index.ANALYZED));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", \"\"));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new Field(\"field\", \"\", Field.Store.NO, Field.Index.ANALYZED));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31f025ae60076ae95274433f3fe8e6ace2857a87","date":1326669465,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", \"\"));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final TokenAndPos[] tokens = new TokenAndPos[3];\n    tokens[0] = new TokenAndPos(\"a\", 0);\n    tokens[1] = new TokenAndPos(\"b\", 0);\n    tokens[2] = new TokenAndPos(\"c\", 0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", \"\"));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestMultiPhraseQuery#testZeroPosIncr().mjava","sourceNew":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", \"\"));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testZeroPosIncr() throws IOException {\n    Directory dir = new RAMDirectory();\n    final Token[] tokens = new Token[3];\n    tokens[0] = new Token();\n    tokens[0].append(\"a\");\n    tokens[0].setPositionIncrement(1);\n    tokens[1] = new Token();\n    tokens[1].append(\"b\");\n    tokens[1].setPositionIncrement(0);\n    tokens[2] = new Token();\n    tokens[2].append(\"c\");\n    tokens[2].setPositionIncrement(0);\n\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, new CannedAnalyzer(tokens));\n    Document doc = new Document();\n    doc.add(new TextField(\"field\", \"\"));\n    writer.addDocument(doc);\n    writer.addDocument(doc);\n    IndexReader r = writer.getReader();\n    writer.close();\n    IndexSearcher s = new IndexSearcher(r);\n    MultiPhraseQuery mpq = new MultiPhraseQuery();\n    //mpq.setSlop(1);\n\n    // NOTE: not great that if we do the else clause here we\n    // get different scores!  MultiPhraseQuery counts that\n    // phrase as occurring twice per doc (it should be 1, I\n    // think?).  This is because MultipleTermPositions is able to\n    // return the same position more than once (0, in this\n    // case):\n    if (true) {\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n    } else {\n      mpq.add(new Term[] {new Term(\"field\", \"a\")}, 0);\n      mpq.add(new Term[] {new Term(\"field\", \"b\"), new Term(\"field\", \"c\")}, 0);\n    }\n    TopDocs hits = s.search(mpq, 2);\n    assertEquals(2, hits.totalHits);\n    assertEquals(hits.scoreDocs[0].score, hits.scoreDocs[1].score, 1e-5);\n    /*\n    for(int hit=0;hit<hits.totalHits;hit++) {\n      ScoreDoc sd = hits.scoreDocs[hit];\n      System.out.println(\"  hit doc=\" + sd.doc + \" score=\" + sd.score);\n    }\n    */\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f0852ebe96f807ea1c84a88f9aaa4985a2088594":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["31f025ae60076ae95274433f3fe8e6ace2857a87"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0852ebe96f807ea1c84a88f9aaa4985a2088594"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"0226c4da52b4b59afa6d616cdf5bacb3733ca47e":["f0852ebe96f807ea1c84a88f9aaa4985a2088594"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"31f025ae60076ae95274433f3fe8e6ace2857a87":["1509f151d7692d84fae414b2b799ac06ba60fcb4"]},"commit2Childs":{"f0852ebe96f807ea1c84a88f9aaa4985a2088594":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","0226c4da52b4b59afa6d616cdf5bacb3733ca47e"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f0852ebe96f807ea1c84a88f9aaa4985a2088594","a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["31f025ae60076ae95274433f3fe8e6ace2857a87"],"0226c4da52b4b59afa6d616cdf5bacb3733ca47e":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","1509f151d7692d84fae414b2b799ac06ba60fcb4"],"31f025ae60076ae95274433f3fe8e6ace2857a87":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}