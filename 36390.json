{"path":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":null,"sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5653af107efef582afd0bc6aff175972359fdd6","date":1293390698,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","date":1294014627,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, use allowDups\n    if( idField == null ) {\n      cmd.allowDups = true;\n      cmd.overwriteCommitted = false;\n      cmd.overwritePending = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwriteCommitted || cmd.overwritePending) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","date":1296400215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","date":1308670974,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a71a0b2d4be2299a163f60626729852d81a8e02","date":1309442399,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n    iwAccess.lock();\n    try {\n\n      // We can't use iwCommit to protect internal data here, since it would\n      // block other addDoc calls.  Hence, we synchronize to protect internal\n      // state.  This is safe as all other state-changing operations are\n      // protected with iwCommit (which iwAccess excludes from this block).\n      synchronized (this) {\n        // adding document -- prep writer\n        openWriter();\n        tracker.addedDocument( cmd.commitWithin );\n      } // end synchronized block\n\n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = this.idTerm.createTerm(cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n        \tupdateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      iwAccess.unlock();\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#addDoc(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","sourceOld":"  @Override\n  public int addDoc(AddUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    addCommands.incrementAndGet();\n    addCommandsCumulative.incrementAndGet();\n    int rc=-1;\n\n    // if there is no ID field, don't overwrite\n    if( idField == null ) {\n      cmd.overwrite = false;\n    }\n\n\n    try {\n      boolean triggered = commitTracker.addedDocument( cmd.commitWithin );\n    \n      if (!triggered) {\n        // if we hard commit, don't soft commit\n        softCommitTracker.addedDocument( cmd.commitWithin );\n      } else {\n        // still inc softCommit\n        softCommitTracker.docsSinceCommit++;\n      }\n      \n      // this is the only unsynchronized code in the iwAccess block, which\n      // should account for most of the time\n\t\t\tTerm updateTerm = null;\n\n      if (cmd.overwrite) {\n        if (cmd.indexedId == null) {\n          cmd.indexedId = getIndexedId(cmd.doc);\n        }\n        Term idTerm = new Term(idField.getName(), cmd.indexedId);\n        boolean del = false;\n        if (cmd.updateTerm == null) {\n          updateTerm = idTerm;\n        } else {\n          del = true;\n          updateTerm = cmd.updateTerm;\n        }\n\n        writer.updateDocument(updateTerm, cmd.getLuceneDocument(schema));\n        if(del) { // ensure id remains unique\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));\n          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));\n          writer.deleteDocuments(bq);\n        }\n      } else {\n        // allow duplicates\n        writer.addDocument(cmd.getLuceneDocument(schema));\n      }\n\n      rc = 1;\n    } finally {\n      if (rc!=1) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      } else {\n        numDocsPending.incrementAndGet();\n      }\n    }\n\n    return rc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["b5653af107efef582afd0bc6aff175972359fdd6"],"70ad682703b8585f5d0a637efec044d57ec05efb":["1da8d55113b689b06716246649de6f62430f15c0","b5653af107efef582afd0bc6aff175972359fdd6"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"c26f00b574427b55127e869b935845554afde1fa":["7a71a0b2d4be2299a163f60626729852d81a8e02","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"2553b00f699380c64959ccb27991289aae87be2e":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","7a71a0b2d4be2299a163f60626729852d81a8e02"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["2553b00f699380c64959ccb27991289aae87be2e","7a71a0b2d4be2299a163f60626729852d81a8e02"],"7a71a0b2d4be2299a163f60626729852d81a8e02":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["1da8d55113b689b06716246649de6f62430f15c0","b5653af107efef582afd0bc6aff175972359fdd6"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"b5653af107efef582afd0bc6aff175972359fdd6":["1da8d55113b689b06716246649de6f62430f15c0"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["7a71a0b2d4be2299a163f60626729852d81a8e02"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["2553b00f699380c64959ccb27991289aae87be2e","7a71a0b2d4be2299a163f60626729852d81a8e02"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"2553b00f699380c64959ccb27991289aae87be2e":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"7a71a0b2d4be2299a163f60626729852d81a8e02":["c26f00b574427b55127e869b935845554afde1fa","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","a258fbb26824fd104ed795e5d9033d2d040049ee"],"1da8d55113b689b06716246649de6f62430f15c0":["70ad682703b8585f5d0a637efec044d57ec05efb","ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","b5653af107efef582afd0bc6aff175972359fdd6"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"b5653af107efef582afd0bc6aff175972359fdd6":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","70ad682703b8585f5d0a637efec044d57ec05efb","ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","29ef99d61cda9641b6250bf9567329a6e65f901d","a258fbb26824fd104ed795e5d9033d2d040049ee","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}