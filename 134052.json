{"path":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","commits":[{"id":"e99275efa2c9c9ae3bdba986218af82f2bf3dc30","date":1354658499,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      // nocommit do we randomly turn on term vectors / doc\n      // values...?\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      _TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1cb7272a011a4619b3953f2eb43f9dce7c7d7f3","date":1355159219,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      _TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      // nocommit do we randomly turn on term vectors / doc\n      // values...?\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      _TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      _TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      _TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.shutdown();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.shutdown();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    Directory d = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(AtomicReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85ca0e073c286ebb2c89364ada6dd2740fc18880","date":1453996944,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8de18786ea000fc5fbc7214d571cc7f41d597ee3","date":1454085819,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d15e34266d75e4e8b95da046cd0afc812367b38","date":1454246129,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    d.deleteFiles(Arrays.asList(d.listAll()));\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for (String name : d.listAll()) {\n      d.deleteFile(name);\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    d.deleteFiles(Arrays.asList(d.listAll()));\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for (String name : d.listAll()) {\n      d.deleteFile(name);\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for (String name : d.listAll()) {\n      d.deleteFile(name);\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecHoldsOpenFiles#test().mjava","sourceNew":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for (String name : d.listAll()) {\n      d.deleteFile(name);\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    BaseDirectoryWrapper d = newDirectory();\n    d.setCheckIndexOnClose(false);\n    // we nuke files, but verify the reader still works\n    RandomIndexWriter w = new RandomIndexWriter(random(), d);\n    int numDocs = atLeast(100);\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"foo\", \"bar\", TextField.TYPE_NOT_STORED));\n      doc.add(new IntPoint(\"doc\", i));\n      doc.add(new IntPoint(\"doc2d\", i, i));\n      doc.add(new NumericDocValuesField(\"dv\", i));\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.commit();\n    w.close();\n\n    for(String fileName : d.listAll()) {\n      try {\n        d.deleteFile(fileName);\n        // may succeed, e.g. if the file is completely read into RAM.\n      } catch (IOException ioe) {\n        // ignore: this means codec (correctly) is holding\n        // the file open\n      }\n    }\n\n    for(LeafReaderContext cxt : r.leaves()) {\n      TestUtil.checkReader(cxt.reader());\n    }\n\n    r.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6613659748fe4411a7dcf85266e55db1f95f7315":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"5a207d19eac354d649c3f0e2cce070017c78125e":["8d15e34266d75e4e8b95da046cd0afc812367b38","b470f36a9372c97283360b1304eacbde22df6c0d"],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["c9fb5f46e264daf5ba3860defe623a89d202dd87","b470f36a9372c97283360b1304eacbde22df6c0d"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"d1cb7272a011a4619b3953f2eb43f9dce7c7d7f3":["e99275efa2c9c9ae3bdba986218af82f2bf3dc30"],"8de18786ea000fc5fbc7214d571cc7f41d597ee3":["85ca0e073c286ebb2c89364ada6dd2740fc18880"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d1cb7272a011a4619b3953f2eb43f9dce7c7d7f3"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"b470f36a9372c97283360b1304eacbde22df6c0d":["8d15e34266d75e4e8b95da046cd0afc812367b38","8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"85ca0e073c286ebb2c89364ada6dd2740fc18880":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["c9fb5f46e264daf5ba3860defe623a89d202dd87","8de18786ea000fc5fbc7214d571cc7f41d597ee3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5a207d19eac354d649c3f0e2cce070017c78125e"]},"commit2Childs":{"6613659748fe4411a7dcf85266e55db1f95f7315":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"5a207d19eac354d649c3f0e2cce070017c78125e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["d1cb7272a011a4619b3953f2eb43f9dce7c7d7f3"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","85ca0e073c286ebb2c89364ada6dd2740fc18880","8d15e34266d75e4e8b95da046cd0afc812367b38"],"d1cb7272a011a4619b3953f2eb43f9dce7c7d7f3":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"8de18786ea000fc5fbc7214d571cc7f41d597ee3":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["6613659748fe4411a7dcf85266e55db1f95f7315"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["b470f36a9372c97283360b1304eacbde22df6c0d"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e99275efa2c9c9ae3bdba986218af82f2bf3dc30","d4d69c535930b5cce125cff868d40f6373dc27d4"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"85ca0e073c286ebb2c89364ada6dd2740fc18880":["8de18786ea000fc5fbc7214d571cc7f41d597ee3"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["5a207d19eac354d649c3f0e2cce070017c78125e","b470f36a9372c97283360b1304eacbde22df6c0d","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}