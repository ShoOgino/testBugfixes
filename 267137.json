{"path":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","sourceNew":"  /**\n   * Compute category list data for caching for faster iteration.\n   */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, \n      FacetIndexingParams iparams, CategoryListParams clp) throws IOException {\n  \n    final int maxDoc = reader.maxDoc();\n    int[][][]dpf  = new int[maxDoc][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntArray docCategories = new IntArray(); \n    for (int part=0; part<numPartitions; part++) {\n      CategoryListIterator cli = clp.createCategoryListIterator(reader, part);\n      if (cli.init()) {\n        for (int doc=0; doc<maxDoc; doc++) {\n          if (cli.skipTo(doc)) {\n            docCategories.clear(false);\n            if (dpf[doc]==null) {\n              dpf[doc] = new int[numPartitions][];\n            }\n            long category;\n            while ((category = cli.nextCategory()) <= Integer.MAX_VALUE) {\n              docCategories.addToArray((int)category);\n            }\n            final int size = docCategories.size();\n            dpf[doc][part] = new int[size];\n            for (int i=0; i<size; i++) {\n              dpf[doc][part][i] = docCategories.get(i);\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","sourceOld":"  /**\n   * Compute category list data for caching for faster iteration.\n   */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, \n      FacetIndexingParams iparams, CategoryListParams clp) throws IOException {\n  \n    final int maxDoc = reader.maxDoc();\n    int[][][]dpf  = new int[maxDoc][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntArray docCategories = new IntArray(); \n    for (int part=0; part<numPartitions; part++) {\n      CategoryListIterator cli = clp.createCategoryListIterator(reader, part);\n      if (cli.init()) {\n        for (int doc=0; doc<maxDoc; doc++) {\n          if (cli.skipTo(doc)) {\n            docCategories.clear(false);\n            if (dpf[doc]==null) {\n              dpf[doc] = new int[numPartitions][];\n            }\n            long category;\n            while ((category = cli.nextCategory()) <= Integer.MAX_VALUE) {\n              docCategories.addToArray((int)category);\n            }\n            final int size = docCategories.size();\n            dpf[doc][part] = new int[size];\n            for (int i=0; i<size; i++) {\n              dpf[doc][part][i] = docCategories.get(i);\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bceb02c33032dd9bbf107cd06d0b74e5db4f110a","date":1357909746,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","sourceNew":"  /** Compute category list data for caching for faster iteration. */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, \n      FacetIndexingParams iparams, CategoryListParams clp) throws IOException {\n  \n    final int maxDoc = reader.maxDoc();\n    int[][][]dpf  = new int[maxDoc][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntsRef ordinals = new IntsRef(32);\n    for (int part = 0; part < numPartitions; part++) {\n      CategoryListIterator cli = clp.createCategoryListIterator(reader, part);\n      if (cli.init()) {\n        for (int doc = 0; doc < maxDoc; doc++) {\n          cli.getOrdinals(doc, ordinals);\n          if (ordinals.length > 0) {\n            if (dpf[doc] == null) {\n              dpf[doc] = new int[numPartitions][];\n            }\n            dpf[doc][part] = new int[ordinals.length];\n            for (int i = 0; i < ordinals.length; i++) {\n              dpf[doc][part][i] = ordinals.ints[i];\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","sourceOld":"  /**\n   * Compute category list data for caching for faster iteration.\n   */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, \n      FacetIndexingParams iparams, CategoryListParams clp) throws IOException {\n  \n    final int maxDoc = reader.maxDoc();\n    int[][][]dpf  = new int[maxDoc][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntArray docCategories = new IntArray(); \n    for (int part=0; part<numPartitions; part++) {\n      CategoryListIterator cli = clp.createCategoryListIterator(reader, part);\n      if (cli.init()) {\n        for (int doc=0; doc<maxDoc; doc++) {\n          if (cli.skipTo(doc)) {\n            docCategories.clear(false);\n            if (dpf[doc]==null) {\n              dpf[doc] = new int[numPartitions][];\n            }\n            long category;\n            while ((category = cli.nextCategory()) <= Integer.MAX_VALUE) {\n              docCategories.addToArray((int)category);\n            }\n            final int size = docCategories.size();\n            dpf[doc][part] = new int[size];\n            for (int i=0; i<size; i++) {\n              dpf[doc][part][i] = docCategories.get(i);\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","sourceNew":"  /** Compute category list data for caching for faster iteration. */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, \n      FacetIndexingParams iparams, CategoryListParams clp) throws IOException {\n  \n    final int maxDoc = reader.maxDoc();\n    int[][][]dpf  = new int[maxDoc][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntsRef ordinals = new IntsRef(32);\n    for (int part = 0; part < numPartitions; part++) {\n      CategoryListIterator cli = clp.createCategoryListIterator(reader, part);\n      if (cli.init()) {\n        for (int doc = 0; doc < maxDoc; doc++) {\n          cli.getOrdinals(doc, ordinals);\n          if (ordinals.length > 0) {\n            if (dpf[doc] == null) {\n              dpf[doc] = new int[numPartitions][];\n            }\n            dpf[doc][part] = new int[ordinals.length];\n            for (int i = 0; i < ordinals.length; i++) {\n              dpf[doc][part][i] = ordinals.ints[i];\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","sourceOld":"  /**\n   * Compute category list data for caching for faster iteration.\n   */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, \n      FacetIndexingParams iparams, CategoryListParams clp) throws IOException {\n  \n    final int maxDoc = reader.maxDoc();\n    int[][][]dpf  = new int[maxDoc][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntArray docCategories = new IntArray(); \n    for (int part=0; part<numPartitions; part++) {\n      CategoryListIterator cli = clp.createCategoryListIterator(reader, part);\n      if (cli.init()) {\n        for (int doc=0; doc<maxDoc; doc++) {\n          if (cli.skipTo(doc)) {\n            docCategories.clear(false);\n            if (dpf[doc]==null) {\n              dpf[doc] = new int[numPartitions][];\n            }\n            long category;\n            while ((category = cli.nextCategory()) <= Integer.MAX_VALUE) {\n              docCategories.addToArray((int)category);\n            }\n            final int size = docCategories.size();\n            dpf[doc][part] = new int[size];\n            for (int i=0; i<size; i++) {\n              dpf[doc][part][i] = docCategories.get(i);\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42f51b3ab4258ff4623227b0db011b8bb83db5c7","date":1358164991,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","sourceNew":"  /** Compute category list data for caching for faster iteration. */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, FacetIndexingParams iparams, CategoryListParams clp) \n      throws IOException {\n  \n    int[][][]dpf  = new int[reader.maxDoc()][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntsRef ordinals = new IntsRef(32);\n    for (int part = 0; part < numPartitions; part++) {\n      for (AtomicReaderContext context : reader.leaves()) {\n        CategoryListIterator cli = clp.createCategoryListIterator(part);\n        if (cli.setNextReader(context)) {\n          final int maxDoc = context.reader().maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            cli.getOrdinals(i, ordinals);\n            if (ordinals.length > 0) {\n              int doc = i + context.docBase;\n              if (dpf[doc] == null) {\n                dpf[doc] = new int[numPartitions][];\n              }\n              if (dpf[doc][part] == null) {\n                dpf[doc][part] = new int[ordinals.length];\n              }\n              for (int j = 0; j < ordinals.length; j++) {\n                dpf[doc][part][j] = ordinals.ints[j];\n              }\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","sourceOld":"  /** Compute category list data for caching for faster iteration. */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, \n      FacetIndexingParams iparams, CategoryListParams clp) throws IOException {\n  \n    final int maxDoc = reader.maxDoc();\n    int[][][]dpf  = new int[maxDoc][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntsRef ordinals = new IntsRef(32);\n    for (int part = 0; part < numPartitions; part++) {\n      CategoryListIterator cli = clp.createCategoryListIterator(reader, part);\n      if (cli.init()) {\n        for (int doc = 0; doc < maxDoc; doc++) {\n          cli.getOrdinals(doc, ordinals);\n          if (ordinals.length > 0) {\n            if (dpf[doc] == null) {\n              dpf[doc] = new int[numPartitions][];\n            }\n            dpf[doc][part] = new int[ordinals.length];\n            for (int i = 0; i < ordinals.length; i++) {\n              dpf[doc][part][i] = ordinals.ints[i];\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","sourceNew":"  /** Compute category list data for caching for faster iteration. */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, FacetIndexingParams iparams, CategoryListParams clp) \n      throws IOException {\n  \n    int[][][]dpf  = new int[reader.maxDoc()][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntsRef ordinals = new IntsRef(32);\n    for (int part = 0; part < numPartitions; part++) {\n      for (AtomicReaderContext context : reader.leaves()) {\n        CategoryListIterator cli = clp.createCategoryListIterator(part);\n        if (cli.setNextReader(context)) {\n          final int maxDoc = context.reader().maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            cli.getOrdinals(i, ordinals);\n            if (ordinals.length > 0) {\n              int doc = i + context.docBase;\n              if (dpf[doc] == null) {\n                dpf[doc] = new int[numPartitions][];\n              }\n              if (dpf[doc][part] == null) {\n                dpf[doc][part] = new int[ordinals.length];\n              }\n              for (int j = 0; j < ordinals.length; j++) {\n                dpf[doc][part][j] = ordinals.ints[j];\n              }\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","sourceOld":"  /** Compute category list data for caching for faster iteration. */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, \n      FacetIndexingParams iparams, CategoryListParams clp) throws IOException {\n  \n    final int maxDoc = reader.maxDoc();\n    int[][][]dpf  = new int[maxDoc][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntsRef ordinals = new IntsRef(32);\n    for (int part = 0; part < numPartitions; part++) {\n      CategoryListIterator cli = clp.createCategoryListIterator(reader, part);\n      if (cli.init()) {\n        for (int doc = 0; doc < maxDoc; doc++) {\n          cli.getOrdinals(doc, ordinals);\n          if (ordinals.length > 0) {\n            if (dpf[doc] == null) {\n              dpf[doc] = new int[numPartitions][];\n            }\n            dpf[doc][part] = new int[ordinals.length];\n            for (int i = 0; i < ordinals.length; i++) {\n              dpf[doc][part][i] = ordinals.ints[i];\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c2cd18c7da6f499a33f06fc89c07a463ec074c0","date":1358329431,"type":4,"author":"Shai Erera","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","sourceNew":null,"sourceOld":"  /** Compute category list data for caching for faster iteration. */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, FacetIndexingParams iparams, CategoryListParams clp) \n      throws IOException {\n  \n    int[][][]dpf  = new int[reader.maxDoc()][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntsRef ordinals = new IntsRef(32);\n    for (int part = 0; part < numPartitions; part++) {\n      for (AtomicReaderContext context : reader.leaves()) {\n        CategoryListIterator cli = clp.createCategoryListIterator(part);\n        if (cli.setNextReader(context)) {\n          final int maxDoc = context.reader().maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            cli.getOrdinals(i, ordinals);\n            if (ordinals.length > 0) {\n              int doc = i + context.docBase;\n              if (dpf[doc] == null) {\n                dpf[doc] = new int[numPartitions][];\n              }\n              if (dpf[doc][part] == null) {\n                dpf[doc][part] = new int[ordinals.length];\n              }\n              for (int j = 0; j < ordinals.length; j++) {\n                dpf[doc][part][j] = ordinals.ints[j];\n              }\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/cache/CategoryListData#CategoryListData(IndexReader,TaxonomyReader,FacetIndexingParams,CategoryListParams).mjava","sourceNew":null,"sourceOld":"  /** Compute category list data for caching for faster iteration. */\n  CategoryListData(IndexReader reader, TaxonomyReader taxo, FacetIndexingParams iparams, CategoryListParams clp) \n      throws IOException {\n  \n    int[][][]dpf  = new int[reader.maxDoc()][][];\n    int numPartitions = (int)Math.ceil(taxo.getSize()/(double)iparams.getPartitionSize());\n    IntsRef ordinals = new IntsRef(32);\n    for (int part = 0; part < numPartitions; part++) {\n      for (AtomicReaderContext context : reader.leaves()) {\n        CategoryListIterator cli = clp.createCategoryListIterator(part);\n        if (cli.setNextReader(context)) {\n          final int maxDoc = context.reader().maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            cli.getOrdinals(i, ordinals);\n            if (ordinals.length > 0) {\n              int doc = i + context.docBase;\n              if (dpf[doc] == null) {\n                dpf[doc] = new int[numPartitions][];\n              }\n              if (dpf[doc][part] == null) {\n                dpf[doc][part] = new int[ordinals.length];\n              }\n              for (int j = 0; j < ordinals.length; j++) {\n                dpf[doc][part][j] = ordinals.ints[j];\n              }\n            }\n          }\n        }\n      }\n    }\n    docPartitionCategories = dpf;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"42f51b3ab4258ff4623227b0db011b8bb83db5c7":["bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["8917bfede3b4ca30f4305c1e391e9218959cd723","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"bceb02c33032dd9bbf107cd06d0b74e5db4f110a":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["4e6354dd7c71fe122926fc53d7d29f715b1283db","42f51b3ab4258ff4623227b0db011b8bb83db5c7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["42f51b3ab4258ff4623227b0db011b8bb83db5c7"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["b89678825b68eccaf09e6ab71675fc0b0af1e099","bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6c2cd18c7da6f499a33f06fc89c07a463ec074c0"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["bceb02c33032dd9bbf107cd06d0b74e5db4f110a","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"42f51b3ab4258ff4623227b0db011b8bb83db5c7":["8917bfede3b4ca30f4305c1e391e9218959cd723","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"bceb02c33032dd9bbf107cd06d0b74e5db4f110a":["42f51b3ab4258ff4623227b0db011b8bb83db5c7","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["c4015cd39dff8d4dec562d909f9766debac53aa6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c4015cd39dff8d4dec562d909f9766debac53aa6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}