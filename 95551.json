{"path":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","commits":[{"id":"d4aa50b979cd392e00e5bc0f23f78cbd106cb968","date":1308150768,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: this cannot merge totalGroupCount; ie the\n   * returned TopGroups will have null totalGroupCount.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs.TopDocsAndShards mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      final int[] mergedShardIndex;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n        mergedShardIndex = mergedTopDocs.shardIndex;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n        mergedShardIndex = new int[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n        mergedShardIndex = new int[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.shardIndex,\n                         docOffset,\n                         mergedShardIndex,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocsAndShards<T>(maxScore,\n                                                            totalHits,\n                                                            mergedScoreDocs,\n                                                            groupValue,\n                                                            shardGroups[0].groups[groupIDX].groupSortValues,\n                                                            mergedShardIndex);\n    }\n\n    return new TopGroups<T>(groupSort.getSort(),\n                            docSort == null ? null : docSort.getSort(),\n                            totalHitCount,\n                            totalGroupedHitCount,\n                            mergedGroupDocs);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2eb9dcbcff763b925aeaf51efba4dabd996ec69a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5d731d304e051cf7ed37410c1431e942f41c09b","date":1308235976,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: this cannot merge totalGroupCount; ie the\n   * returned TopGroups will have null totalGroupCount.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    return new TopGroups<T>(groupSort.getSort(),\n                            docSort == null ? null : docSort.getSort(),\n                            totalHitCount,\n                            totalGroupedHitCount,\n                            mergedGroupDocs);\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: this cannot merge totalGroupCount; ie the\n   * returned TopGroups will have null totalGroupCount.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs.TopDocsAndShards mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      final int[] mergedShardIndex;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n        mergedShardIndex = mergedTopDocs.shardIndex;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n        mergedShardIndex = new int[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n        mergedShardIndex = new int[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.shardIndex,\n                         docOffset,\n                         mergedShardIndex,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocsAndShards<T>(maxScore,\n                                                            totalHits,\n                                                            mergedScoreDocs,\n                                                            groupValue,\n                                                            shardGroups[0].groups[groupIDX].groupSortValues,\n                                                            mergedShardIndex);\n    }\n\n    return new TopGroups<T>(groupSort.getSort(),\n                            docSort == null ? null : docSort.getSort(),\n                            totalHitCount,\n                            totalGroupedHitCount,\n                            mergedGroupDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: this cannot merge totalGroupCount; ie the\n   * returned TopGroups will have null totalGroupCount.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    return new TopGroups<T>(groupSort.getSort(),\n                            docSort == null ? null : docSort.getSort(),\n                            totalHitCount,\n                            totalGroupedHitCount,\n                            mergedGroupDocs);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccc08aa684aee4964baee0644a6ba047bfd70829","date":1316263707,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: this cannot merge totalGroupCount; ie the\n   * returned TopGroups will have null totalGroupCount.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    return new TopGroups<T>(groupSort.getSort(),\n                            docSort == null ? null : docSort.getSort(),\n                            totalHitCount,\n                            totalGroupedHitCount,\n                            mergedGroupDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"72c26897e0e0c4b4f3e73c8c43b1cf89f2564127","date":1331198608,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb008c8f8fc29e5deccfa43d8a054268ba1c5e48","date":1331199997,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["ccc08aa684aee4964baee0644a6ba047bfd70829","eb008c8f8fc29e5deccfa43d8a054268ba1c5e48"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e5d731d304e051cf7ed37410c1431e942f41c09b"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["eb008c8f8fc29e5deccfa43d8a054268ba1c5e48"],"72c26897e0e0c4b4f3e73c8c43b1cf89f2564127":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"eb008c8f8fc29e5deccfa43d8a054268ba1c5e48":["72c26897e0e0c4b4f3e73c8c43b1cf89f2564127"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["e5d731d304e051cf7ed37410c1431e942f41c09b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e5d731d304e051cf7ed37410c1431e942f41c09b":["d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"72c26897e0e0c4b4f3e73c8c43b1cf89f2564127":["eb008c8f8fc29e5deccfa43d8a054268ba1c5e48"],"eb008c8f8fc29e5deccfa43d8a054268ba1c5e48":["38e3b736c7ca086d61b7dbb841c905ee115490da","b89678825b68eccaf09e6ab71675fc0b0af1e099"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["38e3b736c7ca086d61b7dbb841c905ee115490da","72c26897e0e0c4b4f3e73c8c43b1cf89f2564127"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["e5d731d304e051cf7ed37410c1431e942f41c09b"],"e5d731d304e051cf7ed37410c1431e942f41c09b":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","ccc08aa684aee4964baee0644a6ba047bfd70829"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}