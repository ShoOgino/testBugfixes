{"path":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","commits":[{"id":"631e24c389c59f74b6d125a2a4cb909d6fbfa356","date":1445957240,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (shouldCache(context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aac61ee5b4492f174e60bd54939aba9539906edf","date":1461245473,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery(), context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (shouldCache(context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25f40dbcd244dc82447a23719db34376cdcc9cfe","date":1461323366,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery(), context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa","date":1461326984,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":null,"bugIntro":["1b92f673a8027e5fb106d73b5d3e321f2c4db3f6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery(), context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"706a7a3396c030cc66dda92a0492eb492131c4c0","date":1509705614,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      final IndexReader.CacheHelper cacheHelper = in.getCacheHelper(context);\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      final IndexReader.CacheHelper cacheHelper = in.getCacheHelper(context);\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da1460d7a5dea2658e7b8e4f6e632e53ade440ac","date":1510316270,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      final IndexReader.CacheHelper cacheHelper = in.getCacheHelper(context);\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b92f673a8027e5fb106d73b5d3e321f2c4db3f6","date":1523872632,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":["aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c226b0eeb8b028f572020f459851a663a2c064e","date":1542377651,"type":3,"author":"Christophe Bismuth","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4e703a107dabba92e897b4405f4a69f135565a2","date":1567669029,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f740a4cb7f5949ddb40a1647671c4a997223312","date":1569677340,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            cacheSynchronously = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, we will perform synchronous caching\n            // hence do not return the uncached value here\n            if (cacheSynchronously == false) {\n              return in.bulkScorer(context);\n            }\n          }\n\n          if (cacheSynchronously) {\n            docIdSet = cache(context);\n            putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n          }\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b9f74021389e2b32ee750fa5a24281c87951ec3","date":1569845983,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            cacheSynchronously = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, we will perform synchronous caching\n            // hence do not return the uncached value here\n            if (cacheSynchronously == false) {\n              return in.bulkScorer(context);\n            }\n          }\n\n          if (cacheSynchronously) {\n            docIdSet = cache(context);\n            putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n          }\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"906d4da7e00f8453a5a024fe1ee92d6b14c0627f","date":1570006475,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            cacheSynchronously = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, we will perform synchronous caching\n            // hence do not return the uncached value here\n            if (cacheSynchronously == false) {\n              return in.bulkScorer(context);\n            }\n          }\n\n          if (cacheSynchronously) {\n            docIdSet = cache(context);\n            putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n          }\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            cacheSynchronously = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, we will perform synchronous caching\n            // hence do not return the uncached value here\n            if (cacheSynchronously == false) {\n              return in.bulkScorer(context);\n            }\n          }\n\n          if (cacheSynchronously) {\n            docIdSet = cache(context);\n            putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n          }\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fbdd90cd58912788fecb1044df8f566a4420e59","date":1574749923,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            boolean asyncCachingSucceeded = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, we will perform synchronous caching\n            // hence do not return the uncached value here\n            if (asyncCachingSucceeded) {\n              return in.bulkScorer(context);\n            }\n          }\n\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bbc355b3e849ee4a34763155bb78e638d625419","date":1574952532,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#bulkScorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","sourceOld":"    @Override\n    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.bulkScorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.bulkScorer(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cacheHelper\n        return in.bulkScorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.bulkScorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            boolean asyncCachingSucceeded = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, we will perform synchronous caching\n            // hence do not return the uncached value here\n            if (asyncCachingSucceeded) {\n              return in.bulkScorer(context);\n            }\n          }\n\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.bulkScorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new DefaultBulkScorer(new ConstantScoreScorer(this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"906d4da7e00f8453a5a024fe1ee92d6b14c0627f":["6f740a4cb7f5949ddb40a1647671c4a997223312"],"706a7a3396c030cc66dda92a0492eb492131c4c0":["d211216c83f01894810543d1c107160a9ae3650b"],"1b92f673a8027e5fb106d73b5d3e321f2c4db3f6":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac"],"da1460d7a5dea2658e7b8e4f6e632e53ade440ac":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"aac61ee5b4492f174e60bd54939aba9539906edf":["631e24c389c59f74b6d125a2a4cb909d6fbfa356"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["d211216c83f01894810543d1c107160a9ae3650b","706a7a3396c030cc66dda92a0492eb492131c4c0"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["aac61ee5b4492f174e60bd54939aba9539906edf","aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa"],"9c226b0eeb8b028f572020f459851a663a2c064e":["1b92f673a8027e5fb106d73b5d3e321f2c4db3f6"],"1fbdd90cd58912788fecb1044df8f566a4420e59":["906d4da7e00f8453a5a024fe1ee92d6b14c0627f"],"d4e703a107dabba92e897b4405f4a69f135565a2":["9c226b0eeb8b028f572020f459851a663a2c064e"],"d211216c83f01894810543d1c107160a9ae3650b":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6f740a4cb7f5949ddb40a1647671c4a997223312":["d4e703a107dabba92e897b4405f4a69f135565a2"],"9bbc355b3e849ee4a34763155bb78e638d625419":["1fbdd90cd58912788fecb1044df8f566a4420e59"],"631e24c389c59f74b6d125a2a4cb909d6fbfa356":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"25f40dbcd244dc82447a23719db34376cdcc9cfe":["aac61ee5b4492f174e60bd54939aba9539906edf"],"4b9f74021389e2b32ee750fa5a24281c87951ec3":["d4e703a107dabba92e897b4405f4a69f135565a2","6f740a4cb7f5949ddb40a1647671c4a997223312"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9bbc355b3e849ee4a34763155bb78e638d625419"],"aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa":["25f40dbcd244dc82447a23719db34376cdcc9cfe"],"b0b597c65628ca9e73913a07e81691f8229bae35":["4b9f74021389e2b32ee750fa5a24281c87951ec3","906d4da7e00f8453a5a024fe1ee92d6b14c0627f"]},"commit2Childs":{"906d4da7e00f8453a5a024fe1ee92d6b14c0627f":["1fbdd90cd58912788fecb1044df8f566a4420e59","b0b597c65628ca9e73913a07e81691f8229bae35"],"706a7a3396c030cc66dda92a0492eb492131c4c0":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"1b92f673a8027e5fb106d73b5d3e321f2c4db3f6":["9c226b0eeb8b028f572020f459851a663a2c064e"],"da1460d7a5dea2658e7b8e4f6e632e53ade440ac":["1b92f673a8027e5fb106d73b5d3e321f2c4db3f6"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac"],"aac61ee5b4492f174e60bd54939aba9539906edf":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","25f40dbcd244dc82447a23719db34376cdcc9cfe"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["d211216c83f01894810543d1c107160a9ae3650b"],"9c226b0eeb8b028f572020f459851a663a2c064e":["d4e703a107dabba92e897b4405f4a69f135565a2"],"1fbdd90cd58912788fecb1044df8f566a4420e59":["9bbc355b3e849ee4a34763155bb78e638d625419"],"d211216c83f01894810543d1c107160a9ae3650b":["706a7a3396c030cc66dda92a0492eb492131c4c0","d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"d4e703a107dabba92e897b4405f4a69f135565a2":["6f740a4cb7f5949ddb40a1647671c4a997223312","4b9f74021389e2b32ee750fa5a24281c87951ec3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["631e24c389c59f74b6d125a2a4cb909d6fbfa356"],"6f740a4cb7f5949ddb40a1647671c4a997223312":["906d4da7e00f8453a5a024fe1ee92d6b14c0627f","4b9f74021389e2b32ee750fa5a24281c87951ec3"],"631e24c389c59f74b6d125a2a4cb909d6fbfa356":["aac61ee5b4492f174e60bd54939aba9539906edf"],"9bbc355b3e849ee4a34763155bb78e638d625419":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"25f40dbcd244dc82447a23719db34376cdcc9cfe":["aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa"],"4b9f74021389e2b32ee750fa5a24281c87951ec3":["b0b597c65628ca9e73913a07e81691f8229bae35"],"aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}