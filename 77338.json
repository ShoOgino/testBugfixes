{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","commits":[{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    out.writeVInt(leafBlockFPs.length);\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbb73ab0a8ba4f44fac803beb5bf0a0cc182f0e7","date":1447172780,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    out.writeVInt(leafBlockFPs.length);\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    out.writeVInt(leafBlockFPs.length);\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d53f98721d7cda12df9fd4b2e8e2c235be9ac494","date":1450448699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    out.writeVInt(leafBlockFPs.length);\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecf331f9d7bdd234863d2df2bb5c1f019979422f","date":1452250335,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7","date":1456959208,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"251c5b33f0a2c8988550b63c78ed22b0e84524e5","date":1456961997,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd630fded84c5695bd4e07bda0a20634517a4224","date":1476795950,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    if (numDims == 1) {\n      // write the index, skipping the byte used to store the split dim since it is always 0\n      for (int i = 1; i < splitPackedValues.length; i += 1 + bytesPerDim) {\n        out.writeBytes(splitPackedValues, i, bytesPerDim);\n      }\n    } else {\n      out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n    }\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f177ec0246f5d1788b56d8f5d5c66cb38d66bcef","date":1476800106,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    if (numDims == 1) {\n      // write the index, skipping the byte used to store the split dim since it is always 0\n      for (int i = 1; i < splitPackedValues.length; i += 1 + bytesPerDim) {\n        out.writeBytes(splitPackedValues, i, bytesPerDim);\n      }\n    } else {\n      out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n    }\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    if (numDims == 1) {\n      // write the index, skipping the byte used to store the split dim since it is always 0\n      for (int i = 1; i < splitPackedValues.length; i += 1 + bytesPerDim) {\n        out.writeBytes(splitPackedValues, i, bytesPerDim);\n      }\n    } else {\n      out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n    }\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // TODO: for 1D case, don't waste the first byte of each split value (it's always 0)\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  private void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    byte[] packedIndex = packIndex(leafBlockFPs, splitPackedValues);\n    writeIndex(out, leafBlockFPs.length, packedIndex);\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    if (numDims == 1) {\n      // write the index, skipping the byte used to store the split dim since it is always 0\n      for (int i = 1; i < splitPackedValues.length; i += 1 + bytesPerDim) {\n        out.writeBytes(splitPackedValues, i, bytesPerDim);\n      }\n    } else {\n      out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n    }\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":"  private void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    byte[] packedIndex = packIndex(leafBlockFPs, splitPackedValues);\n    writeIndex(out, leafBlockFPs.length, packedIndex);\n  }\n\n","sourceOld":"  /** Subclass can change how it writes the index. */\n  protected void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    CodecUtil.writeHeader(out, CODEC_NAME, VERSION_CURRENT);\n    out.writeVInt(numDims);\n    out.writeVInt(maxPointsInLeafNode);\n    out.writeVInt(bytesPerDim);\n\n    assert leafBlockFPs.length > 0;\n    out.writeVInt(leafBlockFPs.length);\n    out.writeBytes(minPackedValue, 0, packedBytesLength);\n    out.writeBytes(maxPackedValue, 0, packedBytesLength);\n\n    out.writeVLong(pointCount);\n    out.writeVInt(docsSeen.cardinality());\n\n    // NOTE: splitPackedValues[0] is unused, because nodeID is 1-based:\n    if (numDims == 1) {\n      // write the index, skipping the byte used to store the split dim since it is always 0\n      for (int i = 1; i < splitPackedValues.length; i += 1 + bytesPerDim) {\n        out.writeBytes(splitPackedValues, i, bytesPerDim);\n      }\n    } else {\n      out.writeBytes(splitPackedValues, 0, splitPackedValues.length);\n    }\n\n    long lastFP = 0;\n    for (int i=0;i<leafBlockFPs.length;i++) {\n      long delta = leafBlockFPs[i]-lastFP;\n      out.writeVLong(delta);\n      lastFP = leafBlockFPs[i];\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15fe6782474c00ec2ccc636052a025f8fe0bdb8b","date":1484743707,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":null,"sourceOld":"  private void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    byte[] packedIndex = packIndex(leafBlockFPs, splitPackedValues);\n    writeIndex(out, leafBlockFPs.length, packedIndex);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#writeIndex(IndexOutput,long[],byte[]).mjava","sourceNew":null,"sourceOld":"  private void writeIndex(IndexOutput out, long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    byte[] packedIndex = packIndex(leafBlockFPs, splitPackedValues);\n    writeIndex(out, leafBlockFPs.length, packedIndex);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["d53f98721d7cda12df9fd4b2e8e2c235be9ac494"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"302d34f2c66e8d489ee13078305c330cbf67b226":["9856095f7afb5a607bf5e65077615ed91273508c","15fe6782474c00ec2ccc636052a025f8fe0bdb8b"],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd630fded84c5695bd4e07bda0a20634517a4224":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"d53f98721d7cda12df9fd4b2e8e2c235be9ac494":["dbb73ab0a8ba4f44fac803beb5bf0a0cc182f0e7"],"879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"15fe6782474c00ec2ccc636052a025f8fe0bdb8b":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["ecf331f9d7bdd234863d2df2bb5c1f019979422f","251c5b33f0a2c8988550b63c78ed22b0e84524e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["15fe6782474c00ec2ccc636052a025f8fe0bdb8b"],"dbb73ab0a8ba4f44fac803beb5bf0a0cc182f0e7":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"f177ec0246f5d1788b56d8f5d5c66cb38d66bcef":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","dd630fded84c5695bd4e07bda0a20634517a4224"]},"commit2Childs":{"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"302d34f2c66e8d489ee13078305c330cbf67b226":[],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["9856095f7afb5a607bf5e65077615ed91273508c","15fe6782474c00ec2ccc636052a025f8fe0bdb8b"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["dbb73ab0a8ba4f44fac803beb5bf0a0cc182f0e7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"dd630fded84c5695bd4e07bda0a20634517a4224":["f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"d53f98721d7cda12df9fd4b2e8e2c235be9ac494":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7":["251c5b33f0a2c8988550b63c78ed22b0e84524e5"],"9856095f7afb5a607bf5e65077615ed91273508c":["302d34f2c66e8d489ee13078305c330cbf67b226"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","dd630fded84c5695bd4e07bda0a20634517a4224","f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"15fe6782474c00ec2ccc636052a025f8fe0bdb8b":["302d34f2c66e8d489ee13078305c330cbf67b226","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f177ec0246f5d1788b56d8f5d5c66cb38d66bcef":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"dbb73ab0a8ba4f44fac803beb5bf0a0cc182f0e7":["d53f98721d7cda12df9fd4b2e8e2c235be9ac494"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["302d34f2c66e8d489ee13078305c330cbf67b226","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}