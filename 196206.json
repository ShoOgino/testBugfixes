{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/src/common/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      \n      connected = false;\n      log.info(\"Attempting to reconnect to ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this, new ZkClientConnectionStrategy.ZkUpdate() {\n          @Override\n          public void update(SolrZooKeeper keeper) throws InterruptedException, TimeoutException, IOException {\n           waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n           client.updateKeeper(keeper);\n           if(onReconnect != null) {\n             onReconnect.command();\n           }\n           ConnectionManager.this.connected = true;\n          }\n        });\n      } catch (Exception e) {\n        log.error(\"\", e);\n      }\n\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      // ZooKeeper client will recover when it can\n      // TODO: this needs to be investigated more\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      \n      connected = false;\n      log.info(\"Attempting to reconnect to ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this, new ZkClientConnectionStrategy.ZkUpdate() {\n          @Override\n          public void update(SolrZooKeeper keeper) throws InterruptedException, TimeoutException, IOException {\n           waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n           client.updateKeeper(keeper);\n           if(onReconnect != null) {\n             onReconnect.command();\n           }\n           ConnectionManager.this.connected = true;\n          }\n        });\n      } catch (Exception e) {\n        log.error(\"\", e);\n      }\n\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      // ZooKeeper client will recover when it can\n      // TODO: this needs to be investigated more\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/src/common/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      \n      connected = false;\n      log.info(\"Attempting to reconnect to ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this, new ZkClientConnectionStrategy.ZkUpdate() {\n          @Override\n          public void update(SolrZooKeeper keeper) throws InterruptedException, TimeoutException, IOException {\n           waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n           client.updateKeeper(keeper);\n           if(onReconnect != null) {\n             onReconnect.command();\n           }\n           ConnectionManager.this.connected = true;\n          }\n        });\n      } catch (Exception e) {\n        log.error(\"\", e);\n      }\n\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      // ZooKeeper client will recover when it can\n      // TODO: this needs to be investigated more\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      \n      connected = false;\n      log.info(\"Attempting to reconnect to ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this, new ZkClientConnectionStrategy.ZkUpdate() {\n          @Override\n          public void update(SolrZooKeeper keeper) throws InterruptedException, TimeoutException, IOException {\n           waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n           client.updateKeeper(keeper);\n           if(onReconnect != null) {\n             onReconnect.command();\n           }\n           ConnectionManager.this.connected = true;\n          }\n        });\n      } catch (Exception e) {\n        log.error(\"\", e);\n      }\n\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      // ZooKeeper client will recover when it can\n      // TODO: this needs to be investigated more\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/src/common/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      \n      connected = false;\n      log.info(\"Attempting to reconnect to ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this, new ZkClientConnectionStrategy.ZkUpdate() {\n          @Override\n          public void update(SolrZooKeeper keeper) throws InterruptedException, TimeoutException, IOException {\n           waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n           client.updateKeeper(keeper);\n           if(onReconnect != null) {\n             onReconnect.command();\n           }\n           ConnectionManager.this.connected = true;\n          }\n        });\n      } catch (Exception e) {\n        log.error(\"\", e);\n      }\n\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      // ZooKeeper client will recover when it can\n      // TODO: this needs to be investigated more\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      \n      connected = false;\n      log.info(\"Attempting to reconnect to ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this, new ZkClientConnectionStrategy.ZkUpdate() {\n          @Override\n          public void update(SolrZooKeeper keeper) throws InterruptedException, TimeoutException, IOException {\n           waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n           client.updateKeeper(keeper);\n           if(onReconnect != null) {\n             onReconnect.command();\n           }\n           ConnectionManager.this.connected = true;\n          }\n        });\n      } catch (Exception e) {\n        log.error(\"\", e);\n      }\n\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      // ZooKeeper client will recover when it can\n      // TODO: this needs to be investigated more\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException, IOException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      \n      connected = false;\n      log.info(\"Attempting to reconnect to ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this, new ZkClientConnectionStrategy.ZkUpdate() {\n          @Override\n          public void update(SolrZooKeeper keeper) throws InterruptedException, TimeoutException, IOException {\n           waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n           client.updateKeeper(keeper);\n           if(onReconnect != null) {\n             onReconnect.command();\n           }\n           ConnectionManager.this.connected = true;\n          }\n        });\n      } catch (Exception e) {\n        log.error(\"\", e);\n      }\n\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      // ZooKeeper client will recover when it can\n      // TODO: this needs to be investigated more\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException, IOException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      \n      connected = false;\n      log.info(\"Attempting to reconnect to ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this, new ZkClientConnectionStrategy.ZkUpdate() {\n          @Override\n          public void update(SolrZooKeeper keeper) throws InterruptedException, TimeoutException, IOException {\n           waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n           client.updateKeeper(keeper);\n           if(onReconnect != null) {\n             onReconnect.command();\n           }\n           ConnectionManager.this.connected = true;\n          }\n        });\n      } catch (Exception e) {\n        log.error(\"\", e);\n      }\n\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      // ZooKeeper client will recover when it can\n      // TODO: this needs to be investigated more\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException, IOException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      \n      connected = false;\n      log.info(\"Attempting to reconnect to ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this, new ZkClientConnectionStrategy.ZkUpdate() {\n          @Override\n          public void update(SolrZooKeeper keeper) throws InterruptedException, TimeoutException, IOException {\n           waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n           client.updateKeeper(keeper);\n           if(onReconnect != null) {\n             onReconnect.command();\n           }\n           ConnectionManager.this.connected = true;\n          }\n        });\n      } catch (Exception e) {\n        log.error(\"\", e);\n      }\n\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      // ZooKeeper client will recover when it can\n      // TODO: this needs to be investigated more\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException, IOException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException, IOException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938e4fd7b1e4b34da1650edba7471764bbfaefde","date":1344033248,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    checkClosed();\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) throws TimeoutException {\n                synchronized (connectionStrategy) {\n                  checkClosed();\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                    checkClosed();\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    // we must have been asked to stop\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\");\n                  }\n                  checkClosed();\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4","26142aee40b41474610b68db7487682d938fd6de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    checkClosed();\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) throws TimeoutException {\n                synchronized (connectionStrategy) {\n                  checkClosed();\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                    checkClosed();\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    // we must have been asked to stop\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\");\n                  }\n                  checkClosed();\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    checkClosed();\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) throws TimeoutException {\n                synchronized (connectionStrategy) {\n                  checkClosed();\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                    checkClosed();\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    // we must have been asked to stop\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\");\n                  }\n                  checkClosed();\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper)\n                  throws InterruptedException, TimeoutException {\n                synchronized (connectionStrategy) {\n                  waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  client.updateKeeper(keeper);\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d","date":1344892928,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionStrategy) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    // we must have been asked to stop\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\");\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    checkClosed();\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) throws TimeoutException {\n                synchronized (connectionStrategy) {\n                  checkClosed();\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                    checkClosed();\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    // we must have been asked to stop\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\");\n                  }\n                  checkClosed();\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1764a3d38fa1de1ac5474f293b8d32da723a409e","date":1344907887,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionStrategy) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (InterruptedException e1) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\", e1);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  \n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionStrategy) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    // we must have been asked to stop\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\");\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionStrategy) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (InterruptedException e1) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\", e1);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  \n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    checkClosed();\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) throws TimeoutException {\n                synchronized (connectionStrategy) {\n                  checkClosed();\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                    checkClosed();\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    // we must have been asked to stop\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\");\n                  }\n                  checkClosed();\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionStrategy) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (InterruptedException e1) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\", e1);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  \n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    checkClosed();\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) throws TimeoutException {\n                synchronized (connectionStrategy) {\n                  checkClosed();\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                    checkClosed();\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    // we must have been asked to stop\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\");\n                  }\n                  checkClosed();\n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6013b4c7388f1627659c8f96c44abd10a294d3a6","date":1346343796,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionUpdateLock) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionStrategy) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (InterruptedException e1) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\", e1);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  \n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4","a697d0472461db648ff3f697d6b99115204c6054"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionUpdateLock) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionStrategy) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (InterruptedException e1) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(\"Giving up on connecting - we were interrupted\", e1);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  \n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      connected = false;\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionUpdateLock) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionUpdateLock) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionUpdateLock) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionUpdateLock) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"26142aee40b41474610b68db7487682d938fd6de","date":1370871717,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionUpdateLock) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionUpdateLock) {\n                  try {\n                    waitForConnected(SolrZkClient.DEFAULT_CLIENT_CONNECT_TIMEOUT);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":["938e4fd7b1e4b34da1650edba7471764bbfaefde"],"bugIntro":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d45f6da75d87f98de746bf0d49949e15f6b5b2c4","date":1378751771,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                synchronized (ConnectionManager.this) {\n                  ConnectionManager.this.connected = true;\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                // if keeper does not replace oldKeeper we must be sure to close it\n                synchronized (connectionUpdateLock) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch(Throwable t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n      \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                  synchronized (ConnectionManager.this) {\n                    ConnectionManager.this.connected = true;\n                  }\n                }\n                \n              }\n\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":["26142aee40b41474610b68db7487682d938fd6de","7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","6013b4c7388f1627659c8f96c44abd10a294d3a6","938e4fd7b1e4b34da1650edba7471764bbfaefde","1764a3d38fa1de1ac5474f293b8d32da723a409e"],"bugIntro":["5be2ff5f99976897aa35a6ce84f61b0a2b45d91f","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","fa687b84635cf8674b125b033b5f1a97f32175f0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9e6c873b95174ff04c895232927baa76a95925eb","date":1385054916,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                synchronized (ConnectionManager.this) {\n                  ConnectionManager.this.connected = true;\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                synchronized (ConnectionManager.this) {\n                  ConnectionManager.this.connected = true;\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":["f69c653e8becd53e858e17609c0aefdd764fea86"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                synchronized (ConnectionManager.this) {\n                  ConnectionManager.this.connected = true;\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                synchronized (ConnectionManager.this) {\n                  ConnectionManager.this.connected = true;\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b85d2aa862c6ff17c9930e80591ab781c0b87579","date":1388263753,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      disconnected();\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      try {\n        connectionStrategy.reconnect(zkServerAddress, client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                connected();\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected = true;\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      connected = false;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      try {\n        connectionStrategy.reconnect(zkServerAddress, zkClientTimeout, this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                synchronized (ConnectionManager.this) {\n                  ConnectionManager.this.connected = true;\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      connected = false;\n      connectionStrategy.disconnected();\n    } else {\n      connected = false;\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":["7e960b22866c3adab1ce41b4db8c659c841654bb","5be2ff5f99976897aa35a6ce84f61b0a2b45d91f","fa687b84635cf8674b125b033b5f1a97f32175f0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"200efd54b24604d7f18b2a3fca3dfaef51525348","date":1389038112,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      if (disconnectedTimer != null) {\n        disconnectedTimer.cancel();\n        disconnectedTimer = null;\n      }\n      \n      connected = false;\n      likelyExpired = true;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      try {\n        connectionStrategy.reconnect(zkServerAddress, client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                connected();\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n    notifyAll();\n  }\n\n","sourceOld":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      disconnected();\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      try {\n        connectionStrategy.reconnect(zkServerAddress, client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                connected();\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n    notifyAll();\n  }\n\n","bugFix":null,"bugIntro":["5ae839c0b155e35fa4049376c3d3a1d842a68111"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5be2ff5f99976897aa35a6ce84f61b0a2b45d91f","date":1389198917,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      if (disconnectedTimer != null) {\n        disconnectedTimer.cancel();\n        disconnectedTimer = null;\n      }\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                connected();\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    state = event.getState();\n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      if (disconnectedTimer != null) {\n        disconnectedTimer.cancel();\n        disconnectedTimer = null;\n      }\n      \n      connected = false;\n      likelyExpired = true;\n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      try {\n        connectionStrategy.reconnect(zkServerAddress, client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n                \n                connected();\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n    notifyAll();\n  }\n\n","bugFix":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","b85d2aa862c6ff17c9930e80591ab781c0b87579","d45f6da75d87f98de746bf0d49949e15f6b5b2c4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      if (disconnectedTimer != null) {\n        disconnectedTimer.cancel();\n        disconnectedTimer = null;\n      }\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                connected();\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      if (disconnectedTimer != null) {\n        disconnectedTimer.cancel();\n        disconnectedTimer = null;\n      }\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Throwable t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                connected();\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n  }\n\n","bugFix":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ec245241c2474ed40f97e19635afbe89daf55c2","date":1390256744,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected because there\n      // is no need to start the timer - if we are expired\n      // likelyExpired can just be set to true\n      cancelTimer();\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                connected();\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      if (disconnectedTimer != null) {\n        disconnectedTimer.cancel();\n        disconnectedTimer = null;\n      }\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                connected();\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ae839c0b155e35fa4049376c3d3a1d842a68111"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e960b22866c3adab1ce41b4db8c659c841654bb","date":1391189943,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected because there\n      // is no need to start the timer - if we are expired\n      // likelyExpired can just be set to true\n      cancelTimer();\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                connected();\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected because there\n      // is no need to start the timer - if we are expired\n      // likelyExpired can just be set to true\n      cancelTimer();\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                connected();\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else {\n      disconnected();\n    }\n  }\n\n","bugFix":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","b85d2aa862c6ff17c9930e80591ab781c0b87579"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa687b84635cf8674b125b033b5f1a97f32175f0","date":1392153405,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected because there\n      // is no need to start the timer - if we are expired\n      // likelyExpired can just be set to true\n      cancelTimer();\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n\n                // The new event thread will call connected\n                // we just start the reconnect thread and \n                // do nothing else\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      clientConnected.countDown();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected because there\n      // is no need to start the timer - if we are expired\n      // likelyExpired can just be set to true\n      cancelTimer();\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n                \n                connected();\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","b85d2aa862c6ff17c9930e80591ab781c0b87579","d45f6da75d87f98de746bf0d49949e15f6b5b2c4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ae839c0b155e35fa4049376c3d3a1d842a68111","date":1392392160,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n\n                // The new event thread will call connected\n                // we just start the reconnect thread and \n                // do nothing else\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected because there\n      // is no need to start the timer - if we are expired\n      // likelyExpired can just be set to true\n      cancelTimer();\n      \n      connected = false;\n      likelyExpired = true;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n\n                // The new event thread will call connected\n                // we just start the reconnect thread and \n                // do nothing else\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":["200efd54b24604d7f18b2a3fca3dfaef51525348","2ec245241c2474ed40f97e19635afbe89daf55c2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f69c653e8becd53e858e17609c0aefdd764fea86","date":1392397373,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n\n                // The new event thread will call connected\n                // we just start the reconnect thread and \n                // do nothing else\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        beforeReconnect.command();\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n\n                // The new event thread will call connected\n                // we just start the reconnect thread and \n                // do nothing else\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":["9e6c873b95174ff04c895232927baa76a95925eb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8f10f8a5700202b5f7eba33d154eace46f05bd4","date":1416408776,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n\n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n\n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n                \n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n\n                // The new event thread will call connected\n                // we just start the reconnect thread and \n                // do nothing else\n                \n                if (onReconnect != null) {\n                  Thread thread = new Thread() {\n                    @Override\n                    public void run() {\n                      try {\n                        onReconnect.command();\n                      } catch (Exception e) {\n                        log.warn(\"Exception running onReconnect command\", e);\n                      }\n                    }\n                  };\n                  thread.start();\n                }\n                \n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92b41ac3fad9e7627f8f6f6ef605ee6bbdfb4cd4","date":1456187116,"type":3,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n\n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n\n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","fb5affed8a5d31cb9e34de183eb4e27c94130d74","bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"419a8f52c6635419beb951255cacbbb281044c57","date":1456189353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      try {\n        connectionStrategy.reconnect(zkServerAddress,\n            client.getZkClientTimeout(), this,\n            new ZkClientConnectionStrategy.ZkUpdate() {\n              @Override\n              public void update(SolrZooKeeper keeper) {\n                try {\n                  waitForConnected(Long.MAX_VALUE);\n                } catch (Exception e1) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(e1);\n                }\n\n                log.info(\"Connection with ZooKeeper reestablished.\");\n                try {\n                  client.updateKeeper(keeper);\n                } catch (InterruptedException e) {\n                  closeKeeper(keeper);\n                  Thread.currentThread().interrupt();\n                  // we must have been asked to stop\n                  throw new RuntimeException(e);\n                } catch (Exception t) {\n                  closeKeeper(keeper);\n                  throw new RuntimeException(t);\n                }\n\n                if (onReconnect != null) {\n                  onReconnect.command();\n                }\n              }\n            });\n      } catch (Exception e) {\n        SolrException.log(log, \"\", e);\n      }\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a697d0472461db648ff3f697d6b99115204c6054","date":1469556699,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    } else if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    } else if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    } else if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aac63b614f11eae7300a15a1ec9d8bee1e057e3b","date":1474972984,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    } else if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (log.isInfoEnabled()) {\n      log.info(\"Watcher \" + this + \" name:\" + name + \" got event \" + event\n          + \" path:\" + event.getPath() + \" type:\" + event.getType());\n    }\n    \n    if (isClosed) {\n      log.info(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == KeeperState.Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.info(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break iff a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.info(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb6348d79165730d693bd2e2181bd06534dd0917","date":1512509690,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":["43adc163640856c8b07e4cf1b2046c9af56d3ae7"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed()) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      if (isClosed()) {\n        return;\n      }\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed());\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed);\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":["7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d","92b41ac3fad9e7627f8f6f6ef605ee6bbdfb4cd4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb5affed8a5d31cb9e34de183eb4e27c94130d74","date":1551989851,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed()) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      if (isClosed()) {\n        return;\n      }\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 1s and trying again\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed());\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed()) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      if (isClosed()) {\n        return;\n      }\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 5s and trying agian\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed());\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":["92b41ac3fad9e7627f8f6f6ef605ee6bbdfb4cd4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bbb0b5c5101d175049b4ced1462f4c266d32fc63","date":1559534216,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed()) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      if (isClosed()) {\n        return;\n      }\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n\n                    try {\n                      client.updateKeeper(keeper);\n                    } catch (InterruptedException e) {\n                      closeKeeper(keeper);\n                      Thread.currentThread().interrupt();\n                      // we must have been asked to stop\n                      throw new RuntimeException(e);\n                    }\n                    \n                    if (onReconnect != null) {\n                      onReconnect.command();\n                    }\n                    \n                  } catch (Exception e1) {\n                    // if there was a problem creating the new SolrZooKeeper\n                    // or if we cannot run our reconnect command, close the keeper\n                    // our retry loop will try to create one again\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 1s and trying again\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed());\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed()) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      if (isClosed()) {\n        return;\n      }\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n                  } catch (Exception e1) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n  \n                  log.info(\"Connection with ZooKeeper reestablished.\");\n                  try {\n                    client.updateKeeper(keeper);\n                  } catch (InterruptedException e) {\n                    closeKeeper(keeper);\n                    Thread.currentThread().interrupt();\n                    // we must have been asked to stop\n                    throw new RuntimeException(e);\n                  } catch (Exception t) {\n                    closeKeeper(keeper);\n                    throw new RuntimeException(t);\n                  }\n  \n                  if (onReconnect != null) {\n                    onReconnect.command();\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 1s and trying again\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed());\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":["92b41ac3fad9e7627f8f6f6ef605ee6bbdfb4cd4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n\n    if (isClosed()) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    KeeperState state = event.getState();\n\n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      if (isClosed()) {\n        return;\n      }\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n\n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n\n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n\n                    try {\n                      client.updateKeeper(keeper);\n                    } catch (InterruptedException e) {\n                      closeKeeper(keeper);\n                      Thread.currentThread().interrupt();\n                      // we must have been asked to stop\n                      throw new RuntimeException(e);\n                    }\n\n                    if (onReconnect != null) {\n                      onReconnect.command();\n                    }\n\n                  } catch (Exception e1) {\n                    // if there was a problem creating the new SolrZooKeeper\n                    // or if we cannot run our reconnect command, close the keeper\n                    // our retry loop will try to create one again\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                }\n              });\n\n          break;\n\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 1s and trying again\");\n          waitSleep(1000);\n        }\n\n      } while (!isClosed());\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n    \n    if (isClosed()) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n    \n    KeeperState state = event.getState();\n    \n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      if (isClosed()) {\n        return;\n      }\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n      \n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n      \n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n      \n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n\n                    try {\n                      client.updateKeeper(keeper);\n                    } catch (InterruptedException e) {\n                      closeKeeper(keeper);\n                      Thread.currentThread().interrupt();\n                      // we must have been asked to stop\n                      throw new RuntimeException(e);\n                    }\n                    \n                    if (onReconnect != null) {\n                      onReconnect.command();\n                    }\n                    \n                  } catch (Exception e1) {\n                    // if there was a problem creating the new SolrZooKeeper\n                    // or if we cannot run our reconnect command, close the keeper\n                    // our retry loop will try to create one again\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                }\n              });\n          \n          break;\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 1s and trying again\");\n          waitSleep(1000);\n        }\n        \n      } while (!isClosed());\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ConnectionManager#process(WatchedEvent).mjava","sourceNew":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n      }\n    }\n\n    if (isClosed()) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    KeeperState state = event.getState();\n\n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      if (isClosed()) {\n        return;\n      }\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n\n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n\n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n\n                    try {\n                      client.updateKeeper(keeper);\n                    } catch (InterruptedException e) {\n                      closeKeeper(keeper);\n                      Thread.currentThread().interrupt();\n                      // we must have been asked to stop\n                      throw new RuntimeException(e);\n                    }\n\n                    if (onReconnect != null) {\n                      onReconnect.command();\n                    }\n\n                  } catch (Exception e1) {\n                    // if there was a problem creating the new SolrZooKeeper\n                    // or if we cannot run our reconnect command, close the keeper\n                    // our retry loop will try to create one again\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                }\n              });\n\n          break;\n\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 1s and trying again\");\n          waitSleep(1000);\n        }\n\n      } while (!isClosed());\n      log.info(\"zkClient Connected: {}\", connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(WatchedEvent event) {\n    if (event.getState() == AuthFailed || event.getState() == Disconnected || event.getState() == Expired) {\n      log.warn(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    } else {\n      log.debug(\"Watcher {} name: {} got event {} path: {} type: {}\", this, name, event, event.getPath(), event.getType());\n    }\n\n    if (isClosed()) {\n      log.debug(\"Client->ZooKeeper status change trigger but we are already closed\");\n      return;\n    }\n\n    KeeperState state = event.getState();\n\n    if (state == KeeperState.SyncConnected) {\n      log.info(\"zkClient has connected\");\n      connected();\n      connectionStrategy.connected();\n    } else if (state == Expired) {\n      if (isClosed()) {\n        return;\n      }\n      // we don't call disconnected here, because we know we are expired\n      connected = false;\n      likelyExpiredState = LikelyExpiredState.EXPIRED;\n\n      log.warn(\"Our previous ZooKeeper session was expired. Attempting to reconnect to recover relationship with ZooKeeper...\");\n\n      if (beforeReconnect != null) {\n        try {\n          beforeReconnect.command();\n        } catch (Exception e) {\n          log.warn(\"Exception running beforeReconnect command\", e);\n        }\n      }\n\n      do {\n        // This loop will break if a valid connection is made. If a connection is not made then it will repeat and\n        // try again to create a new connection.\n        try {\n          connectionStrategy.reconnect(zkServerAddress,\n              client.getZkClientTimeout(), this,\n              new ZkClientConnectionStrategy.ZkUpdate() {\n                @Override\n                public void update(SolrZooKeeper keeper) {\n                  try {\n                    waitForConnected(Long.MAX_VALUE);\n\n                    try {\n                      client.updateKeeper(keeper);\n                    } catch (InterruptedException e) {\n                      closeKeeper(keeper);\n                      Thread.currentThread().interrupt();\n                      // we must have been asked to stop\n                      throw new RuntimeException(e);\n                    }\n\n                    if (onReconnect != null) {\n                      onReconnect.command();\n                    }\n\n                  } catch (Exception e1) {\n                    // if there was a problem creating the new SolrZooKeeper\n                    // or if we cannot run our reconnect command, close the keeper\n                    // our retry loop will try to create one again\n                    closeKeeper(keeper);\n                    throw new RuntimeException(e1);\n                  }\n                }\n              });\n\n          break;\n\n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n          log.info(\"Could not connect due to error, sleeping for 1s and trying again\");\n          waitSleep(1000);\n        }\n\n      } while (!isClosed());\n      log.info(\"zkClient Connected:\" + connected);\n    } else if (state == KeeperState.Disconnected) {\n      log.warn(\"zkClient has disconnected\");\n      disconnected();\n      connectionStrategy.disconnected();\n    } else if (state == KeeperState.AuthFailed) {\n      log.warn(\"zkClient received AuthFailed\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d45f6da75d87f98de746bf0d49949e15f6b5b2c4":["26142aee40b41474610b68db7487682d938fd6de"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["8fd5be977c105554c6a7b68afcdbc511439723ab","1764a3d38fa1de1ac5474f293b8d32da723a409e"],"419a8f52c6635419beb951255cacbbb281044c57":["a8f10f8a5700202b5f7eba33d154eace46f05bd4","92b41ac3fad9e7627f8f6f6ef605ee6bbdfb4cd4"],"7e960b22866c3adab1ce41b4db8c659c841654bb":["2ec245241c2474ed40f97e19635afbe89daf55c2"],"b85d2aa862c6ff17c9930e80591ab781c0b87579":["9e6c873b95174ff04c895232927baa76a95925eb"],"bb6348d79165730d693bd2e2181bd06534dd0917":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["5be2ff5f99976897aa35a6ce84f61b0a2b45d91f"],"a8f10f8a5700202b5f7eba33d154eace46f05bd4":["f69c653e8becd53e858e17609c0aefdd764fea86"],"938e4fd7b1e4b34da1650edba7471764bbfaefde":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"fb5affed8a5d31cb9e34de183eb4e27c94130d74":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"5be2ff5f99976897aa35a6ce84f61b0a2b45d91f":["200efd54b24604d7f18b2a3fca3dfaef51525348"],"1764a3d38fa1de1ac5474f293b8d32da723a409e":["7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","938e4fd7b1e4b34da1650edba7471764bbfaefde"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4","9e6c873b95174ff04c895232927baa76a95925eb"],"7530de27b87b961b51f01bd1299b7004d46e8823":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"5ae839c0b155e35fa4049376c3d3a1d842a68111":["fa687b84635cf8674b125b033b5f1a97f32175f0"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["6013b4c7388f1627659c8f96c44abd10a294d3a6","7530de27b87b961b51f01bd1299b7004d46e8823"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["bb6348d79165730d693bd2e2181bd06534dd0917"],"f69c653e8becd53e858e17609c0aefdd764fea86":["5ae839c0b155e35fa4049376c3d3a1d842a68111"],"2ec245241c2474ed40f97e19635afbe89daf55c2":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d6f074e73200c07d54f242d3880a8da5a35ff97b","1764a3d38fa1de1ac5474f293b8d32da723a409e"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["1764a3d38fa1de1ac5474f293b8d32da723a409e"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d":["938e4fd7b1e4b34da1650edba7471764bbfaefde"],"a697d0472461db648ff3f697d6b99115204c6054":["419a8f52c6635419beb951255cacbbb281044c57"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a697d0472461db648ff3f697d6b99115204c6054","aac63b614f11eae7300a15a1ec9d8bee1e057e3b"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["fb5affed8a5d31cb9e34de183eb4e27c94130d74"],"962cd4f5e313777f35da8f521265323e84184929":["a697d0472461db648ff3f697d6b99115204c6054"],"92b41ac3fad9e7627f8f6f6ef605ee6bbdfb4cd4":["a8f10f8a5700202b5f7eba33d154eace46f05bd4"],"26142aee40b41474610b68db7487682d938fd6de":["7530de27b87b961b51f01bd1299b7004d46e8823"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["fe33227f6805edab2036cbb80645cc4e2d1fa424","938e4fd7b1e4b34da1650edba7471764bbfaefde"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["419a8f52c6635419beb951255cacbbb281044c57","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9e6c873b95174ff04c895232927baa76a95925eb":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"200efd54b24604d7f18b2a3fca3dfaef51525348":["b85d2aa862c6ff17c9930e80591ab781c0b87579"],"aac63b614f11eae7300a15a1ec9d8bee1e057e3b":["962cd4f5e313777f35da8f521265323e84184929"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["419a8f52c6635419beb951255cacbbb281044c57","a697d0472461db648ff3f697d6b99115204c6054"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"fa687b84635cf8674b125b033b5f1a97f32175f0":["7e960b22866c3adab1ce41b4db8c659c841654bb"]},"commit2Childs":{"d45f6da75d87f98de746bf0d49949e15f6b5b2c4":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","9e6c873b95174ff04c895232927baa76a95925eb"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"419a8f52c6635419beb951255cacbbb281044c57":["a697d0472461db648ff3f697d6b99115204c6054","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"7e960b22866c3adab1ce41b4db8c659c841654bb":["fa687b84635cf8674b125b033b5f1a97f32175f0"],"b85d2aa862c6ff17c9930e80591ab781c0b87579":["200efd54b24604d7f18b2a3fca3dfaef51525348"],"bb6348d79165730d693bd2e2181bd06534dd0917":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["2ec245241c2474ed40f97e19635afbe89daf55c2"],"a8f10f8a5700202b5f7eba33d154eace46f05bd4":["419a8f52c6635419beb951255cacbbb281044c57","92b41ac3fad9e7627f8f6f6ef605ee6bbdfb4cd4"],"938e4fd7b1e4b34da1650edba7471764bbfaefde":["d6f074e73200c07d54f242d3880a8da5a35ff97b","7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d","8fd5be977c105554c6a7b68afcdbc511439723ab"],"fb5affed8a5d31cb9e34de183eb4e27c94130d74":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"5be2ff5f99976897aa35a6ce84f61b0a2b45d91f":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"1764a3d38fa1de1ac5474f293b8d32da723a409e":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","26142aee40b41474610b68db7487682d938fd6de"],"5ae839c0b155e35fa4049376c3d3a1d842a68111":["f69c653e8becd53e858e17609c0aefdd764fea86"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2ec245241c2474ed40f97e19635afbe89daf55c2":["7e960b22866c3adab1ce41b4db8c659c841654bb"],"f69c653e8becd53e858e17609c0aefdd764fea86":["a8f10f8a5700202b5f7eba33d154eace46f05bd4"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["fb5affed8a5d31cb9e34de183eb4e27c94130d74"],"c26f00b574427b55127e869b935845554afde1fa":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["05a14b2611ead08655a2b2bdc61632eb31316e57","7530de27b87b961b51f01bd1299b7004d46e8823","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"7ef2f1fb62d1e1507a618a2accff53a38b6c6e3d":["1764a3d38fa1de1ac5474f293b8d32da723a409e"],"a697d0472461db648ff3f697d6b99115204c6054":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","962cd4f5e313777f35da8f521265323e84184929","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["bb6348d79165730d693bd2e2181bd06534dd0917","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["938e4fd7b1e4b34da1650edba7471764bbfaefde","fe33227f6805edab2036cbb80645cc4e2d1fa424","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"962cd4f5e313777f35da8f521265323e84184929":["aac63b614f11eae7300a15a1ec9d8bee1e057e3b"],"92b41ac3fad9e7627f8f6f6ef605ee6bbdfb4cd4":["419a8f52c6635419beb951255cacbbb281044c57"],"26142aee40b41474610b68db7487682d938fd6de":["d45f6da75d87f98de746bf0d49949e15f6b5b2c4"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"9e6c873b95174ff04c895232927baa76a95925eb":["b85d2aa862c6ff17c9930e80591ab781c0b87579","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","fe33227f6805edab2036cbb80645cc4e2d1fa424","0d22ac6a4146774c1bc8400160fc0b6150294e92","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"200efd54b24604d7f18b2a3fca3dfaef51525348":["5be2ff5f99976897aa35a6ce84f61b0a2b45d91f"],"aac63b614f11eae7300a15a1ec9d8bee1e057e3b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"fa687b84635cf8674b125b033b5f1a97f32175f0":["5ae839c0b155e35fa4049376c3d3a1d842a68111"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","05a14b2611ead08655a2b2bdc61632eb31316e57","74f45af4339b0daf7a95c820ab88c1aea74fbce0","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","0d22ac6a4146774c1bc8400160fc0b6150294e92","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a258fbb26824fd104ed795e5d9033d2d040049ee","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}