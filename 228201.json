{"path":"lucene/core/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","sourceNew":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    final int nonSurrogateCount;\n    final boolean ovSurStart;\n    if (endCode < UnicodeUtil.UNI_SUR_HIGH_START ||\n        startCode > UnicodeUtil.UNI_SUR_LOW_END) {\n      // no overlap w/ surrogates\n      nonSurrogateCount = endCode - startCode + 1;\n      ovSurStart = false;\n    } else if (isSurrogate(startCode)) {\n      // start of range overlaps surrogates\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - startCode + 1);\n      ovSurStart = false;\n    } else if (isSurrogate(endCode)) {\n      // end of range overlaps surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (endCode - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    } else {\n      // range completely subsumes surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    }\n\n    assert nonSurrogateCount > 0;\n        \n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      int code = startCode + r.nextInt(nonSurrogateCount);\n      if (isSurrogate(code)) {\n        if (ovSurStart) {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - UnicodeUtil.UNI_SUR_HIGH_START);\n        } else {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - startCode);\n        }\n      }\n\n      assert code >= startCode && code <= endCode: \"code=\" + code + \" start=\" + startCode + \" end=\" + endCode;\n      assert !isSurrogate(code);\n\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","sourceOld":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    final int nonSurrogateCount;\n    final boolean ovSurStart;\n    if (endCode < UnicodeUtil.UNI_SUR_HIGH_START ||\n        startCode > UnicodeUtil.UNI_SUR_LOW_END) {\n      // no overlap w/ surrogates\n      nonSurrogateCount = endCode - startCode + 1;\n      ovSurStart = false;\n    } else if (isSurrogate(startCode)) {\n      // start of range overlaps surrogates\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - startCode + 1);\n      ovSurStart = false;\n    } else if (isSurrogate(endCode)) {\n      // end of range overlaps surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (endCode - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    } else {\n      // range completely subsumes surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    }\n\n    assert nonSurrogateCount > 0;\n        \n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      int code = startCode + r.nextInt(nonSurrogateCount);\n      if (isSurrogate(code)) {\n        if (ovSurStart) {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - UnicodeUtil.UNI_SUR_HIGH_START);\n        } else {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - startCode);\n        }\n      }\n\n      assert code >= startCode && code <= endCode: \"code=\" + code + \" start=\" + startCode + \" end=\" + endCode;\n      assert !isSurrogate(code);\n\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestUTF32ToUTF8#testOne(Random,ByteRunAutomaton,int,int,int).mjava","sourceNew":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    final int nonSurrogateCount;\n    final boolean ovSurStart;\n    if (endCode < UnicodeUtil.UNI_SUR_HIGH_START ||\n        startCode > UnicodeUtil.UNI_SUR_LOW_END) {\n      // no overlap w/ surrogates\n      nonSurrogateCount = endCode - startCode + 1;\n      ovSurStart = false;\n    } else if (isSurrogate(startCode)) {\n      // start of range overlaps surrogates\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - startCode + 1);\n      ovSurStart = false;\n    } else if (isSurrogate(endCode)) {\n      // end of range overlaps surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (endCode - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    } else {\n      // range completely subsumes surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    }\n\n    assert nonSurrogateCount > 0;\n        \n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      int code = startCode + r.nextInt(nonSurrogateCount);\n      if (isSurrogate(code)) {\n        if (ovSurStart) {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - UnicodeUtil.UNI_SUR_HIGH_START);\n        } else {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - startCode);\n        }\n      }\n\n      assert code >= startCode && code <= endCode: \"code=\" + code + \" start=\" + startCode + \" end=\" + endCode;\n      assert !isSurrogate(code);\n\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = TestUtil.nextInt(r, 0, invalidRange - 1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","sourceOld":"  private void testOne(Random r, ByteRunAutomaton a, int startCode, int endCode, int iters) {\n\n    // Verify correct ints are accepted\n    final int nonSurrogateCount;\n    final boolean ovSurStart;\n    if (endCode < UnicodeUtil.UNI_SUR_HIGH_START ||\n        startCode > UnicodeUtil.UNI_SUR_LOW_END) {\n      // no overlap w/ surrogates\n      nonSurrogateCount = endCode - startCode + 1;\n      ovSurStart = false;\n    } else if (isSurrogate(startCode)) {\n      // start of range overlaps surrogates\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - startCode + 1);\n      ovSurStart = false;\n    } else if (isSurrogate(endCode)) {\n      // end of range overlaps surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (endCode - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    } else {\n      // range completely subsumes surrogates\n      ovSurStart = true;\n      nonSurrogateCount = endCode - startCode + 1 - (UnicodeUtil.UNI_SUR_LOW_END - UnicodeUtil.UNI_SUR_HIGH_START + 1);\n    }\n\n    assert nonSurrogateCount > 0;\n        \n    for(int iter=0;iter<iters;iter++) {\n      // pick random code point in-range\n\n      int code = startCode + r.nextInt(nonSurrogateCount);\n      if (isSurrogate(code)) {\n        if (ovSurStart) {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - UnicodeUtil.UNI_SUR_HIGH_START);\n        } else {\n          code = UnicodeUtil.UNI_SUR_LOW_END + 1 + (code - startCode);\n        }\n      }\n\n      assert code >= startCode && code <= endCode: \"code=\" + code + \" start=\" + startCode + \" end=\" + endCode;\n      assert !isSurrogate(code);\n\n      assertTrue(\"DFA for range \" + startCode + \"-\" + endCode + \" failed to match code=\" + code, \n                 matches(a, code));\n    }\n\n    // Verify invalid ints are not accepted\n    final int invalidRange = MAX_UNICODE - (endCode - startCode + 1);\n    if (invalidRange > 0) {\n      for(int iter=0;iter<iters;iter++) {\n        int x = _TestUtil.nextInt(r, 0, invalidRange-1);\n        final int code;\n        if (x >= startCode) {\n          code = endCode + 1 + x - startCode;\n        } else {\n          code = x;\n        }\n        if ((code >= UnicodeUtil.UNI_SUR_HIGH_START && code <= UnicodeUtil.UNI_SUR_HIGH_END) |\n            (code >= UnicodeUtil.UNI_SUR_LOW_START && code <= UnicodeUtil.UNI_SUR_LOW_END)) {\n          iter--;\n          continue;\n        }\n        assertFalse(\"DFA for range \" + startCode + \"-\" + endCode + \" matched invalid code=\" + code,\n                    matches(a, code));\n                    \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6613659748fe4411a7dcf85266e55db1f95f7315":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6613659748fe4411a7dcf85266e55db1f95f7315"]},"commit2Childs":{"6613659748fe4411a7dcf85266e55db1f95f7315":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}