{"path":"solr/core/src/java/org/apache/solr/search/SimpleQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","commits":[{"id":"51fe3498927e9ed88f36c6a38187b1d46053faa8","date":1384593417,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SimpleQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a QParser that will create a query by using Lucene's SimpleQueryParser. */\n  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    // Some of the parameters may come in through localParams, so combine them with params.\n    SolrParams defaultParams = SolrParams.wrapDefaults(localParams, params);\n\n    // This will be used to specify what fields and boosts will be used by SimpleQueryParser.\n    Map<String, Float> queryFields = SolrPluginUtils.parseFieldBoosts(defaultParams.get(SimpleParams.QF));\n\n    if (queryFields.isEmpty()) {\n      // It qf is not specified setup up the queryFields map to use the defaultField.\n      String defaultField = QueryParsing.getDefaultField(req.getSchema(), defaultParams.get(CommonParams.DF));\n\n      if (defaultField == null) {\n        // A query cannot be run without having a field or set of fields to run against.\n        throw new IllegalStateException(\"Neither \" + SimpleParams.QF + \", \" + CommonParams.DF\n            + \", nor the default search field are present.\");\n      }\n\n      queryFields.put(defaultField, 1.0F);\n    }\n    else {\n      for (Map.Entry<String, Float> queryField : queryFields.entrySet()) {\n        if (queryField.getValue() == null) {\n          // Some fields may be specified without a boost, so default the boost to 1.0 since a null value\n          // will not be accepted by SimpleQueryParser.\n          queryField.setValue(1.0F);\n        }\n      }\n    }\n\n    // Setup the operations that are enabled for the query.\n    int enabledOps = 0;\n    String opParam = defaultParams.get(SimpleParams.QO);\n\n    if (opParam == null) {\n      // All operations will be enabled.\n      enabledOps = -1;\n    } else {\n      // Parse the specified enabled operations to be used by the query.\n      String[] operations = opParam.split(\",\");\n\n      for (String operation : operations) {\n        Integer enabledOp = OPERATORS.get(operation.trim().toUpperCase(Locale.getDefault()));\n\n        if (enabledOp != null) {\n          enabledOps |= enabledOp;\n        }\n      }\n    }\n\n    // Create a SimpleQueryParser using the analyzer from the schema.\n    final SimpleQueryParser parser = new SimpleQueryParser(req.getSchema().getAnalyzer(), queryFields, enabledOps);\n\n    // Set the default operator to be either 'AND' or 'OR' for the query.\n    QueryParser.Operator defaultOp = QueryParsing.getQueryParserDefaultOperator(req.getSchema(), defaultParams.get(QueryParsing.OP));\n\n    if (defaultOp == QueryParser.Operator.AND) {\n      parser.setDefaultOperator(BooleanClause.Occur.MUST);\n    }\n\n    // Return a QParser that wraps a SimpleQueryParser.\n    return new QParser(qstr, localParams, params, req) {\n      public Query parse() throws SyntaxError {\n        return parser.parse(qstr);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d39aff1aebcdb668f75b89b6dd2b85b79ad91bf","date":1385226734,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SimpleQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SimpleQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  /** Returns a QParser that will create a query by using Lucene's SimpleQueryParser. */\n  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    // Some of the parameters may come in through localParams, so combine them with params.\n    SolrParams defaultParams = SolrParams.wrapDefaults(localParams, params);\n\n    // This will be used to specify what fields and boosts will be used by SimpleQueryParser.\n    Map<String, Float> queryFields = SolrPluginUtils.parseFieldBoosts(defaultParams.get(SimpleParams.QF));\n\n    if (queryFields.isEmpty()) {\n      // It qf is not specified setup up the queryFields map to use the defaultField.\n      String defaultField = QueryParsing.getDefaultField(req.getSchema(), defaultParams.get(CommonParams.DF));\n\n      if (defaultField == null) {\n        // A query cannot be run without having a field or set of fields to run against.\n        throw new IllegalStateException(\"Neither \" + SimpleParams.QF + \", \" + CommonParams.DF\n            + \", nor the default search field are present.\");\n      }\n\n      queryFields.put(defaultField, 1.0F);\n    }\n    else {\n      for (Map.Entry<String, Float> queryField : queryFields.entrySet()) {\n        if (queryField.getValue() == null) {\n          // Some fields may be specified without a boost, so default the boost to 1.0 since a null value\n          // will not be accepted by SimpleQueryParser.\n          queryField.setValue(1.0F);\n        }\n      }\n    }\n\n    // Setup the operations that are enabled for the query.\n    int enabledOps = 0;\n    String opParam = defaultParams.get(SimpleParams.QO);\n\n    if (opParam == null) {\n      // All operations will be enabled.\n      enabledOps = -1;\n    } else {\n      // Parse the specified enabled operations to be used by the query.\n      String[] operations = opParam.split(\",\");\n\n      for (String operation : operations) {\n        Integer enabledOp = OPERATORS.get(operation.trim().toUpperCase(Locale.getDefault()));\n\n        if (enabledOp != null) {\n          enabledOps |= enabledOp;\n        }\n      }\n    }\n\n    // Create a SimpleQueryParser using the analyzer from the schema.\n    final IndexSchema schema = req.getSchema();\n    final SimpleQueryParser parser = new SimpleQueryParser(req.getSchema().getAnalyzer(), queryFields, enabledOps) {\n      // Override newPrefixQuery to provide a multi term analyzer for prefix queries run against TextFields.\n      @Override\n      protected Query newPrefixQuery(String text) {\n        BooleanQuery bq = new BooleanQuery(true);\n\n        for (Map.Entry<String, Float> entry : weights.entrySet()) {\n          String field = entry.getKey();\n          FieldType type = schema.getFieldType(field);\n          Query prefix;\n\n          if (type instanceof TextField) {\n            // If the field type is a TextField then use the multi term analyzer.\n            Analyzer analyzer = ((TextField)type).getMultiTermAnalyzer();\n            String term = TextField.analyzeMultiTerm(field, text, analyzer).utf8ToString();\n            prefix = new PrefixQuery(new Term(field, term));\n          } else {\n            // If the type is *not* a TextField don't do any analysis.\n            prefix = new PrefixQuery(new Term(entry.getKey(), text));\n          }\n\n          prefix.setBoost(entry.getValue());\n          bq.add(prefix, BooleanClause.Occur.SHOULD);\n        }\n\n        return simplify(bq);\n      }\n    };\n\n    // Set the default operator to be either 'AND' or 'OR' for the query.\n    QueryParser.Operator defaultOp = QueryParsing.getQueryParserDefaultOperator(req.getSchema(), defaultParams.get(QueryParsing.OP));\n\n    if (defaultOp == QueryParser.Operator.AND) {\n      parser.setDefaultOperator(BooleanClause.Occur.MUST);\n    }\n\n    // Return a QParser that wraps a SimpleQueryParser.\n    return new QParser(qstr, localParams, params, req) {\n      public Query parse() throws SyntaxError {\n        return parser.parse(qstr);\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a QParser that will create a query by using Lucene's SimpleQueryParser. */\n  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    // Some of the parameters may come in through localParams, so combine them with params.\n    SolrParams defaultParams = SolrParams.wrapDefaults(localParams, params);\n\n    // This will be used to specify what fields and boosts will be used by SimpleQueryParser.\n    Map<String, Float> queryFields = SolrPluginUtils.parseFieldBoosts(defaultParams.get(SimpleParams.QF));\n\n    if (queryFields.isEmpty()) {\n      // It qf is not specified setup up the queryFields map to use the defaultField.\n      String defaultField = QueryParsing.getDefaultField(req.getSchema(), defaultParams.get(CommonParams.DF));\n\n      if (defaultField == null) {\n        // A query cannot be run without having a field or set of fields to run against.\n        throw new IllegalStateException(\"Neither \" + SimpleParams.QF + \", \" + CommonParams.DF\n            + \", nor the default search field are present.\");\n      }\n\n      queryFields.put(defaultField, 1.0F);\n    }\n    else {\n      for (Map.Entry<String, Float> queryField : queryFields.entrySet()) {\n        if (queryField.getValue() == null) {\n          // Some fields may be specified without a boost, so default the boost to 1.0 since a null value\n          // will not be accepted by SimpleQueryParser.\n          queryField.setValue(1.0F);\n        }\n      }\n    }\n\n    // Setup the operations that are enabled for the query.\n    int enabledOps = 0;\n    String opParam = defaultParams.get(SimpleParams.QO);\n\n    if (opParam == null) {\n      // All operations will be enabled.\n      enabledOps = -1;\n    } else {\n      // Parse the specified enabled operations to be used by the query.\n      String[] operations = opParam.split(\",\");\n\n      for (String operation : operations) {\n        Integer enabledOp = OPERATORS.get(operation.trim().toUpperCase(Locale.getDefault()));\n\n        if (enabledOp != null) {\n          enabledOps |= enabledOp;\n        }\n      }\n    }\n\n    // Create a SimpleQueryParser using the analyzer from the schema.\n    final SimpleQueryParser parser = new SimpleQueryParser(req.getSchema().getAnalyzer(), queryFields, enabledOps);\n\n    // Set the default operator to be either 'AND' or 'OR' for the query.\n    QueryParser.Operator defaultOp = QueryParsing.getQueryParserDefaultOperator(req.getSchema(), defaultParams.get(QueryParsing.OP));\n\n    if (defaultOp == QueryParser.Operator.AND) {\n      parser.setDefaultOperator(BooleanClause.Occur.MUST);\n    }\n\n    // Return a QParser that wraps a SimpleQueryParser.\n    return new QParser(qstr, localParams, params, req) {\n      public Query parse() throws SyntaxError {\n        return parser.parse(qstr);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44df044997f1941d47ed12fd9dc261ee8ef16935","date":1387470022,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SimpleQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SimpleQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  /** Returns a QParser that will create a query by using Lucene's SimpleQueryParser. */\n  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    // Some of the parameters may come in through localParams, so combine them with params.\n    SolrParams defaultParams = SolrParams.wrapDefaults(localParams, params);\n\n    // This will be used to specify what fields and boosts will be used by SimpleQueryParser.\n    Map<String, Float> queryFields = SolrPluginUtils.parseFieldBoosts(defaultParams.get(SimpleParams.QF));\n\n    if (queryFields.isEmpty()) {\n      // It qf is not specified setup up the queryFields map to use the defaultField.\n      String defaultField = QueryParsing.getDefaultField(req.getSchema(), defaultParams.get(CommonParams.DF));\n\n      if (defaultField == null) {\n        // A query cannot be run without having a field or set of fields to run against.\n        throw new IllegalStateException(\"Neither \" + SimpleParams.QF + \", \" + CommonParams.DF\n            + \", nor the default search field are present.\");\n      }\n\n      queryFields.put(defaultField, 1.0F);\n    }\n    else {\n      for (Map.Entry<String, Float> queryField : queryFields.entrySet()) {\n        if (queryField.getValue() == null) {\n          // Some fields may be specified without a boost, so default the boost to 1.0 since a null value\n          // will not be accepted by SimpleQueryParser.\n          queryField.setValue(1.0F);\n        }\n      }\n    }\n\n    // Setup the operations that are enabled for the query.\n    int enabledOps = 0;\n    String opParam = defaultParams.get(SimpleParams.QO);\n\n    if (opParam == null) {\n      // All operations will be enabled.\n      enabledOps = -1;\n    } else {\n      // Parse the specified enabled operations to be used by the query.\n      String[] operations = opParam.split(\",\");\n\n      for (String operation : operations) {\n        Integer enabledOp = OPERATORS.get(operation.trim().toUpperCase(Locale.ROOT));\n\n        if (enabledOp != null) {\n          enabledOps |= enabledOp;\n        }\n      }\n    }\n\n    // Create a SimpleQueryParser using the analyzer from the schema.\n    final IndexSchema schema = req.getSchema();\n    final SimpleQueryParser parser = new SimpleQueryParser(req.getSchema().getAnalyzer(), queryFields, enabledOps) {\n      // Override newPrefixQuery to provide a multi term analyzer for prefix queries run against TextFields.\n      @Override\n      protected Query newPrefixQuery(String text) {\n        BooleanQuery bq = new BooleanQuery(true);\n\n        for (Map.Entry<String, Float> entry : weights.entrySet()) {\n          String field = entry.getKey();\n          FieldType type = schema.getFieldType(field);\n          Query prefix;\n\n          if (type instanceof TextField) {\n            // If the field type is a TextField then use the multi term analyzer.\n            Analyzer analyzer = ((TextField)type).getMultiTermAnalyzer();\n            String term = TextField.analyzeMultiTerm(field, text, analyzer).utf8ToString();\n            prefix = new PrefixQuery(new Term(field, term));\n          } else {\n            // If the type is *not* a TextField don't do any analysis.\n            prefix = new PrefixQuery(new Term(entry.getKey(), text));\n          }\n\n          prefix.setBoost(entry.getValue());\n          bq.add(prefix, BooleanClause.Occur.SHOULD);\n        }\n\n        return simplify(bq);\n      }\n    };\n\n    // Set the default operator to be either 'AND' or 'OR' for the query.\n    QueryParser.Operator defaultOp = QueryParsing.getQueryParserDefaultOperator(req.getSchema(), defaultParams.get(QueryParsing.OP));\n\n    if (defaultOp == QueryParser.Operator.AND) {\n      parser.setDefaultOperator(BooleanClause.Occur.MUST);\n    }\n\n    // Return a QParser that wraps a SimpleQueryParser.\n    return new QParser(qstr, localParams, params, req) {\n      public Query parse() throws SyntaxError {\n        return parser.parse(qstr);\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a QParser that will create a query by using Lucene's SimpleQueryParser. */\n  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    // Some of the parameters may come in through localParams, so combine them with params.\n    SolrParams defaultParams = SolrParams.wrapDefaults(localParams, params);\n\n    // This will be used to specify what fields and boosts will be used by SimpleQueryParser.\n    Map<String, Float> queryFields = SolrPluginUtils.parseFieldBoosts(defaultParams.get(SimpleParams.QF));\n\n    if (queryFields.isEmpty()) {\n      // It qf is not specified setup up the queryFields map to use the defaultField.\n      String defaultField = QueryParsing.getDefaultField(req.getSchema(), defaultParams.get(CommonParams.DF));\n\n      if (defaultField == null) {\n        // A query cannot be run without having a field or set of fields to run against.\n        throw new IllegalStateException(\"Neither \" + SimpleParams.QF + \", \" + CommonParams.DF\n            + \", nor the default search field are present.\");\n      }\n\n      queryFields.put(defaultField, 1.0F);\n    }\n    else {\n      for (Map.Entry<String, Float> queryField : queryFields.entrySet()) {\n        if (queryField.getValue() == null) {\n          // Some fields may be specified without a boost, so default the boost to 1.0 since a null value\n          // will not be accepted by SimpleQueryParser.\n          queryField.setValue(1.0F);\n        }\n      }\n    }\n\n    // Setup the operations that are enabled for the query.\n    int enabledOps = 0;\n    String opParam = defaultParams.get(SimpleParams.QO);\n\n    if (opParam == null) {\n      // All operations will be enabled.\n      enabledOps = -1;\n    } else {\n      // Parse the specified enabled operations to be used by the query.\n      String[] operations = opParam.split(\",\");\n\n      for (String operation : operations) {\n        Integer enabledOp = OPERATORS.get(operation.trim().toUpperCase(Locale.getDefault()));\n\n        if (enabledOp != null) {\n          enabledOps |= enabledOp;\n        }\n      }\n    }\n\n    // Create a SimpleQueryParser using the analyzer from the schema.\n    final IndexSchema schema = req.getSchema();\n    final SimpleQueryParser parser = new SimpleQueryParser(req.getSchema().getAnalyzer(), queryFields, enabledOps) {\n      // Override newPrefixQuery to provide a multi term analyzer for prefix queries run against TextFields.\n      @Override\n      protected Query newPrefixQuery(String text) {\n        BooleanQuery bq = new BooleanQuery(true);\n\n        for (Map.Entry<String, Float> entry : weights.entrySet()) {\n          String field = entry.getKey();\n          FieldType type = schema.getFieldType(field);\n          Query prefix;\n\n          if (type instanceof TextField) {\n            // If the field type is a TextField then use the multi term analyzer.\n            Analyzer analyzer = ((TextField)type).getMultiTermAnalyzer();\n            String term = TextField.analyzeMultiTerm(field, text, analyzer).utf8ToString();\n            prefix = new PrefixQuery(new Term(field, term));\n          } else {\n            // If the type is *not* a TextField don't do any analysis.\n            prefix = new PrefixQuery(new Term(entry.getKey(), text));\n          }\n\n          prefix.setBoost(entry.getValue());\n          bq.add(prefix, BooleanClause.Occur.SHOULD);\n        }\n\n        return simplify(bq);\n      }\n    };\n\n    // Set the default operator to be either 'AND' or 'OR' for the query.\n    QueryParser.Operator defaultOp = QueryParsing.getQueryParserDefaultOperator(req.getSchema(), defaultParams.get(QueryParsing.OP));\n\n    if (defaultOp == QueryParser.Operator.AND) {\n      parser.setDefaultOperator(BooleanClause.Occur.MUST);\n    }\n\n    // Return a QParser that wraps a SimpleQueryParser.\n    return new QParser(qstr, localParams, params, req) {\n      public Query parse() throws SyntaxError {\n        return parser.parse(qstr);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SimpleQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a QParser that will create a query by using Lucene's SimpleQueryParser. */\n  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    // Some of the parameters may come in through localParams, so combine them with params.\n    SolrParams defaultParams = SolrParams.wrapDefaults(localParams, params);\n\n    // This will be used to specify what fields and boosts will be used by SimpleQueryParser.\n    Map<String, Float> queryFields = SolrPluginUtils.parseFieldBoosts(defaultParams.get(SimpleParams.QF));\n\n    if (queryFields.isEmpty()) {\n      // It qf is not specified setup up the queryFields map to use the defaultField.\n      String defaultField = QueryParsing.getDefaultField(req.getSchema(), defaultParams.get(CommonParams.DF));\n\n      if (defaultField == null) {\n        // A query cannot be run without having a field or set of fields to run against.\n        throw new IllegalStateException(\"Neither \" + SimpleParams.QF + \", \" + CommonParams.DF\n            + \", nor the default search field are present.\");\n      }\n\n      queryFields.put(defaultField, 1.0F);\n    }\n    else {\n      for (Map.Entry<String, Float> queryField : queryFields.entrySet()) {\n        if (queryField.getValue() == null) {\n          // Some fields may be specified without a boost, so default the boost to 1.0 since a null value\n          // will not be accepted by SimpleQueryParser.\n          queryField.setValue(1.0F);\n        }\n      }\n    }\n\n    // Setup the operations that are enabled for the query.\n    int enabledOps = 0;\n    String opParam = defaultParams.get(SimpleParams.QO);\n\n    if (opParam == null) {\n      // All operations will be enabled.\n      enabledOps = -1;\n    } else {\n      // Parse the specified enabled operations to be used by the query.\n      String[] operations = opParam.split(\",\");\n\n      for (String operation : operations) {\n        Integer enabledOp = OPERATORS.get(operation.trim().toUpperCase(Locale.getDefault()));\n\n        if (enabledOp != null) {\n          enabledOps |= enabledOp;\n        }\n      }\n    }\n\n    // Create a SimpleQueryParser using the analyzer from the schema.\n    final IndexSchema schema = req.getSchema();\n    final SimpleQueryParser parser = new SimpleQueryParser(req.getSchema().getAnalyzer(), queryFields, enabledOps) {\n      // Override newPrefixQuery to provide a multi term analyzer for prefix queries run against TextFields.\n      @Override\n      protected Query newPrefixQuery(String text) {\n        BooleanQuery bq = new BooleanQuery(true);\n\n        for (Map.Entry<String, Float> entry : weights.entrySet()) {\n          String field = entry.getKey();\n          FieldType type = schema.getFieldType(field);\n          Query prefix;\n\n          if (type instanceof TextField) {\n            // If the field type is a TextField then use the multi term analyzer.\n            Analyzer analyzer = ((TextField)type).getMultiTermAnalyzer();\n            String term = TextField.analyzeMultiTerm(field, text, analyzer).utf8ToString();\n            prefix = new PrefixQuery(new Term(field, term));\n          } else {\n            // If the type is *not* a TextField don't do any analysis.\n            prefix = new PrefixQuery(new Term(entry.getKey(), text));\n          }\n\n          prefix.setBoost(entry.getValue());\n          bq.add(prefix, BooleanClause.Occur.SHOULD);\n        }\n\n        return simplify(bq);\n      }\n    };\n\n    // Set the default operator to be either 'AND' or 'OR' for the query.\n    QueryParser.Operator defaultOp = QueryParsing.getQueryParserDefaultOperator(req.getSchema(), defaultParams.get(QueryParsing.OP));\n\n    if (defaultOp == QueryParser.Operator.AND) {\n      parser.setDefaultOperator(BooleanClause.Occur.MUST);\n    }\n\n    // Return a QParser that wraps a SimpleQueryParser.\n    return new QParser(qstr, localParams, params, req) {\n      public Query parse() throws SyntaxError {\n        return parser.parse(qstr);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee9efffeff762194ca606ff91a43e2f6f56a430f","date":1390409407,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SimpleQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SimpleQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  /** Returns a QParser that will create a query by using Lucene's SimpleQueryParser. */\n  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new SimpleQParser(qstr, localParams, params, req);\n  }\n\n","sourceOld":"  /** Returns a QParser that will create a query by using Lucene's SimpleQueryParser. */\n  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    // Some of the parameters may come in through localParams, so combine them with params.\n    SolrParams defaultParams = SolrParams.wrapDefaults(localParams, params);\n\n    // This will be used to specify what fields and boosts will be used by SimpleQueryParser.\n    Map<String, Float> queryFields = SolrPluginUtils.parseFieldBoosts(defaultParams.get(SimpleParams.QF));\n\n    if (queryFields.isEmpty()) {\n      // It qf is not specified setup up the queryFields map to use the defaultField.\n      String defaultField = QueryParsing.getDefaultField(req.getSchema(), defaultParams.get(CommonParams.DF));\n\n      if (defaultField == null) {\n        // A query cannot be run without having a field or set of fields to run against.\n        throw new IllegalStateException(\"Neither \" + SimpleParams.QF + \", \" + CommonParams.DF\n            + \", nor the default search field are present.\");\n      }\n\n      queryFields.put(defaultField, 1.0F);\n    }\n    else {\n      for (Map.Entry<String, Float> queryField : queryFields.entrySet()) {\n        if (queryField.getValue() == null) {\n          // Some fields may be specified without a boost, so default the boost to 1.0 since a null value\n          // will not be accepted by SimpleQueryParser.\n          queryField.setValue(1.0F);\n        }\n      }\n    }\n\n    // Setup the operations that are enabled for the query.\n    int enabledOps = 0;\n    String opParam = defaultParams.get(SimpleParams.QO);\n\n    if (opParam == null) {\n      // All operations will be enabled.\n      enabledOps = -1;\n    } else {\n      // Parse the specified enabled operations to be used by the query.\n      String[] operations = opParam.split(\",\");\n\n      for (String operation : operations) {\n        Integer enabledOp = OPERATORS.get(operation.trim().toUpperCase(Locale.ROOT));\n\n        if (enabledOp != null) {\n          enabledOps |= enabledOp;\n        }\n      }\n    }\n\n    // Create a SimpleQueryParser using the analyzer from the schema.\n    final IndexSchema schema = req.getSchema();\n    final SimpleQueryParser parser = new SimpleQueryParser(req.getSchema().getAnalyzer(), queryFields, enabledOps) {\n      // Override newPrefixQuery to provide a multi term analyzer for prefix queries run against TextFields.\n      @Override\n      protected Query newPrefixQuery(String text) {\n        BooleanQuery bq = new BooleanQuery(true);\n\n        for (Map.Entry<String, Float> entry : weights.entrySet()) {\n          String field = entry.getKey();\n          FieldType type = schema.getFieldType(field);\n          Query prefix;\n\n          if (type instanceof TextField) {\n            // If the field type is a TextField then use the multi term analyzer.\n            Analyzer analyzer = ((TextField)type).getMultiTermAnalyzer();\n            String term = TextField.analyzeMultiTerm(field, text, analyzer).utf8ToString();\n            prefix = new PrefixQuery(new Term(field, term));\n          } else {\n            // If the type is *not* a TextField don't do any analysis.\n            prefix = new PrefixQuery(new Term(entry.getKey(), text));\n          }\n\n          prefix.setBoost(entry.getValue());\n          bq.add(prefix, BooleanClause.Occur.SHOULD);\n        }\n\n        return simplify(bq);\n      }\n    };\n\n    // Set the default operator to be either 'AND' or 'OR' for the query.\n    QueryParser.Operator defaultOp = QueryParsing.getQueryParserDefaultOperator(req.getSchema(), defaultParams.get(QueryParsing.OP));\n\n    if (defaultOp == QueryParser.Operator.AND) {\n      parser.setDefaultOperator(BooleanClause.Occur.MUST);\n    }\n\n    // Return a QParser that wraps a SimpleQueryParser.\n    return new QParser(qstr, localParams, params, req) {\n      public Query parse() throws SyntaxError {\n        return parser.parse(qstr);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6d39aff1aebcdb668f75b89b6dd2b85b79ad91bf":["51fe3498927e9ed88f36c6a38187b1d46053faa8"],"ee9efffeff762194ca606ff91a43e2f6f56a430f":["44df044997f1941d47ed12fd9dc261ee8ef16935"],"44df044997f1941d47ed12fd9dc261ee8ef16935":["6d39aff1aebcdb668f75b89b6dd2b85b79ad91bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d39aff1aebcdb668f75b89b6dd2b85b79ad91bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ee9efffeff762194ca606ff91a43e2f6f56a430f"],"51fe3498927e9ed88f36c6a38187b1d46053faa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"6d39aff1aebcdb668f75b89b6dd2b85b79ad91bf":["44df044997f1941d47ed12fd9dc261ee8ef16935","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"ee9efffeff762194ca606ff91a43e2f6f56a430f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"44df044997f1941d47ed12fd9dc261ee8ef16935":["ee9efffeff762194ca606ff91a43e2f6f56a430f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","51fe3498927e9ed88f36c6a38187b1d46053faa8"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"51fe3498927e9ed88f36c6a38187b1d46053faa8":["6d39aff1aebcdb668f75b89b6dd2b85b79ad91bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}