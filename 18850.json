{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#findCommonPrefixAndHistogram(OfflinePointWriter,long,long,int,int).mjava","commits":[{"id":"c2344a1c769566d8c85cffcacc5e55153fa54b86","date":1550661298,"type":0,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#findCommonPrefixAndHistogram(OfflinePointWriter,long,long,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private int findCommonPrefixAndHistogram(OfflinePointWriter points, long from, long to, int dim, int dimCommonPrefix) throws IOException{\n    //find common prefix\n    int commonPrefixPosition = bytesSorted;\n    final int offset = dim * bytesPerDim;\n    try (OfflinePointReader reader = points.getReader(from, to - from, offlineBuffer)) {\n      assert commonPrefixPosition > dimCommonPrefix;\n      reader.next();\n      PointValue pointValue = reader.pointValue();\n      // copy dimension\n      BytesRef packedValue = pointValue.packedValue();\n      System.arraycopy(packedValue.bytes, packedValue.offset + offset, scratch, 0, bytesPerDim);\n      // copy docID\n      BytesRef docIDBytes = pointValue.docIDBytes();\n      System.arraycopy(docIDBytes.bytes, docIDBytes.offset, scratch, bytesPerDim, Integer.BYTES);\n      for (long i = from + 1; i < to; i++) {\n        reader.next();\n        pointValue = reader.pointValue();\n        if (commonPrefixPosition == dimCommonPrefix) {\n          histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          // we do not need to check for common prefix anymore,\n          // just finish the histogram and break\n          for (long j = i + 1; j < to; j++) {\n            reader.next();\n            pointValue = reader.pointValue();\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n          break;\n        } else {\n          //check common prefix and adjust histogram\n          final int startIndex = (dimCommonPrefix > bytesPerDim) ? bytesPerDim : dimCommonPrefix;\n          final int endIndex = (commonPrefixPosition > bytesPerDim) ? bytesPerDim : commonPrefixPosition;\n          packedValue = pointValue.packedValue();\n          int j = FutureArrays.mismatch(scratch, startIndex, endIndex, packedValue.bytes, packedValue.offset + offset + startIndex, packedValue.offset + offset + endIndex);\n          if (j == -1) {\n            if (commonPrefixPosition > bytesPerDim) {\n              //tie-break on docID\n              docIDBytes = pointValue.docIDBytes();\n              int k = FutureArrays.mismatch(scratch, bytesPerDim, commonPrefixPosition, docIDBytes.bytes, docIDBytes.offset, docIDBytes.offset + commonPrefixPosition - bytesPerDim);\n              if (k != -1) {\n                commonPrefixPosition = bytesPerDim + k;\n                Arrays.fill(histogram, 0);\n                histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n              }\n            }\n          } else {\n            commonPrefixPosition = dimCommonPrefix + j;\n            Arrays.fill(histogram, 0);\n            histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n          }\n          if (commonPrefixPosition != bytesSorted) {\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n        }\n      }\n    }\n\n    //build partition buckets up to commonPrefix\n    for (int i = 0; i < commonPrefixPosition; i++) {\n      partitionBucket[i] = scratch[i] & 0xff;\n    }\n    return commonPrefixPosition;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#findCommonPrefixAndHistogram(OfflinePointWriter,long,long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#findCommonPrefixAndHistogram(OfflinePointWriter,long,long,int,int).mjava","sourceNew":"  private int findCommonPrefixAndHistogram(OfflinePointWriter points, long from, long to, int dim, int dimCommonPrefix) throws IOException{\n    //find common prefix\n    int commonPrefixPosition = bytesSorted;\n    final int offset = dim * bytesPerDim;\n    try (OfflinePointReader reader = points.getReader(from, to - from, offlineBuffer)) {\n      assert commonPrefixPosition > dimCommonPrefix;\n      reader.next();\n      PointValue pointValue = reader.pointValue();\n      // copy dimension\n      BytesRef packedValue = pointValue.packedValue();\n      System.arraycopy(packedValue.bytes, packedValue.offset + offset, scratch, 0, bytesPerDim);\n      // copy docID\n      BytesRef docIDBytes = pointValue.docIDBytes();\n      System.arraycopy(docIDBytes.bytes, docIDBytes.offset, scratch, bytesPerDim, Integer.BYTES);\n      for (long i = from + 1; i < to; i++) {\n        reader.next();\n        pointValue = reader.pointValue();\n        if (commonPrefixPosition == dimCommonPrefix) {\n          histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          // we do not need to check for common prefix anymore,\n          // just finish the histogram and break\n          for (long j = i + 1; j < to; j++) {\n            reader.next();\n            pointValue = reader.pointValue();\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n          break;\n        } else {\n          //check common prefix and adjust histogram\n          final int startIndex = (dimCommonPrefix > bytesPerDim) ? bytesPerDim : dimCommonPrefix;\n          final int endIndex = (commonPrefixPosition > bytesPerDim) ? bytesPerDim : commonPrefixPosition;\n          packedValue = pointValue.packedValue();\n          int j = Arrays.mismatch(scratch, startIndex, endIndex, packedValue.bytes, packedValue.offset + offset + startIndex, packedValue.offset + offset + endIndex);\n          if (j == -1) {\n            if (commonPrefixPosition > bytesPerDim) {\n              //tie-break on docID\n              docIDBytes = pointValue.docIDBytes();\n              int k = Arrays.mismatch(scratch, bytesPerDim, commonPrefixPosition, docIDBytes.bytes, docIDBytes.offset, docIDBytes.offset + commonPrefixPosition - bytesPerDim);\n              if (k != -1) {\n                commonPrefixPosition = bytesPerDim + k;\n                Arrays.fill(histogram, 0);\n                histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n              }\n            }\n          } else {\n            commonPrefixPosition = dimCommonPrefix + j;\n            Arrays.fill(histogram, 0);\n            histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n          }\n          if (commonPrefixPosition != bytesSorted) {\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n        }\n      }\n    }\n\n    //build partition buckets up to commonPrefix\n    for (int i = 0; i < commonPrefixPosition; i++) {\n      partitionBucket[i] = scratch[i] & 0xff;\n    }\n    return commonPrefixPosition;\n  }\n\n","sourceOld":"  private int findCommonPrefixAndHistogram(OfflinePointWriter points, long from, long to, int dim, int dimCommonPrefix) throws IOException{\n    //find common prefix\n    int commonPrefixPosition = bytesSorted;\n    final int offset = dim * bytesPerDim;\n    try (OfflinePointReader reader = points.getReader(from, to - from, offlineBuffer)) {\n      assert commonPrefixPosition > dimCommonPrefix;\n      reader.next();\n      PointValue pointValue = reader.pointValue();\n      // copy dimension\n      BytesRef packedValue = pointValue.packedValue();\n      System.arraycopy(packedValue.bytes, packedValue.offset + offset, scratch, 0, bytesPerDim);\n      // copy docID\n      BytesRef docIDBytes = pointValue.docIDBytes();\n      System.arraycopy(docIDBytes.bytes, docIDBytes.offset, scratch, bytesPerDim, Integer.BYTES);\n      for (long i = from + 1; i < to; i++) {\n        reader.next();\n        pointValue = reader.pointValue();\n        if (commonPrefixPosition == dimCommonPrefix) {\n          histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          // we do not need to check for common prefix anymore,\n          // just finish the histogram and break\n          for (long j = i + 1; j < to; j++) {\n            reader.next();\n            pointValue = reader.pointValue();\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n          break;\n        } else {\n          //check common prefix and adjust histogram\n          final int startIndex = (dimCommonPrefix > bytesPerDim) ? bytesPerDim : dimCommonPrefix;\n          final int endIndex = (commonPrefixPosition > bytesPerDim) ? bytesPerDim : commonPrefixPosition;\n          packedValue = pointValue.packedValue();\n          int j = FutureArrays.mismatch(scratch, startIndex, endIndex, packedValue.bytes, packedValue.offset + offset + startIndex, packedValue.offset + offset + endIndex);\n          if (j == -1) {\n            if (commonPrefixPosition > bytesPerDim) {\n              //tie-break on docID\n              docIDBytes = pointValue.docIDBytes();\n              int k = FutureArrays.mismatch(scratch, bytesPerDim, commonPrefixPosition, docIDBytes.bytes, docIDBytes.offset, docIDBytes.offset + commonPrefixPosition - bytesPerDim);\n              if (k != -1) {\n                commonPrefixPosition = bytesPerDim + k;\n                Arrays.fill(histogram, 0);\n                histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n              }\n            }\n          } else {\n            commonPrefixPosition = dimCommonPrefix + j;\n            Arrays.fill(histogram, 0);\n            histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n          }\n          if (commonPrefixPosition != bytesSorted) {\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n        }\n      }\n    }\n\n    //build partition buckets up to commonPrefix\n    for (int i = 0; i < commonPrefixPosition; i++) {\n      partitionBucket[i] = scratch[i] & 0xff;\n    }\n    return commonPrefixPosition;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7f06758793500ca773d0df1037290e6e404fb33","date":1562230223,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#findCommonPrefixAndHistogram(OfflinePointWriter,long,long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#findCommonPrefixAndHistogram(OfflinePointWriter,long,long,int,int).mjava","sourceNew":"  private int findCommonPrefixAndHistogram(OfflinePointWriter points, long from, long to, int dim, int dimCommonPrefix) throws IOException{\n    //find common prefix\n    int commonPrefixPosition = bytesSorted;\n    final int offset = dim * bytesPerDim;\n    try (OfflinePointReader reader = points.getReader(from, to - from, offlineBuffer)) {\n      assert commonPrefixPosition > dimCommonPrefix;\n      reader.next();\n      PointValue pointValue = reader.pointValue();\n      BytesRef packedValueDocID = pointValue.packedValueDocIDBytes();\n      // copy dimension\n      System.arraycopy(packedValueDocID.bytes, packedValueDocID.offset + offset, scratch, 0, bytesPerDim);\n      // copy data dimensions and docID\n      System.arraycopy(packedValueDocID.bytes, packedValueDocID.offset + numIndexDims * bytesPerDim, scratch, bytesPerDim, (numDataDims - numIndexDims) * bytesPerDim + Integer.BYTES);\n\n      for (long i = from + 1; i < to; i++) {\n        reader.next();\n        pointValue = reader.pointValue();\n        if (commonPrefixPosition == dimCommonPrefix) {\n          histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          // we do not need to check for common prefix anymore,\n          // just finish the histogram and break\n          for (long j = i + 1; j < to; j++) {\n            reader.next();\n            pointValue = reader.pointValue();\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n          break;\n        } else {\n          //check common prefix and adjust histogram\n          final int startIndex = (dimCommonPrefix > bytesPerDim) ? bytesPerDim : dimCommonPrefix;\n          final int endIndex = (commonPrefixPosition > bytesPerDim) ? bytesPerDim : commonPrefixPosition;\n          packedValueDocID = pointValue.packedValueDocIDBytes();\n          int j = Arrays.mismatch(scratch, startIndex, endIndex, packedValueDocID.bytes, packedValueDocID.offset + offset + startIndex, packedValueDocID.offset + offset + endIndex);\n          if (j == -1) {\n            if (commonPrefixPosition > bytesPerDim) {\n              //tie-break on data dimensions + docID\n              final int startTieBreak = numIndexDims * bytesPerDim;\n              final int endTieBreak = startTieBreak + commonPrefixPosition - bytesPerDim;\n              int k = Arrays.mismatch(scratch, bytesPerDim, commonPrefixPosition,\n                  packedValueDocID.bytes, packedValueDocID.offset + startTieBreak, packedValueDocID.offset + endTieBreak);\n              if (k != -1) {\n                commonPrefixPosition = bytesPerDim + k;\n                Arrays.fill(histogram, 0);\n                histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n              }\n            }\n          } else {\n            commonPrefixPosition = dimCommonPrefix + j;\n            Arrays.fill(histogram, 0);\n            histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n          }\n          if (commonPrefixPosition != bytesSorted) {\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n        }\n      }\n    }\n\n    //build partition buckets up to commonPrefix\n    for (int i = 0; i < commonPrefixPosition; i++) {\n      partitionBucket[i] = scratch[i] & 0xff;\n    }\n    return commonPrefixPosition;\n  }\n\n","sourceOld":"  private int findCommonPrefixAndHistogram(OfflinePointWriter points, long from, long to, int dim, int dimCommonPrefix) throws IOException{\n    //find common prefix\n    int commonPrefixPosition = bytesSorted;\n    final int offset = dim * bytesPerDim;\n    try (OfflinePointReader reader = points.getReader(from, to - from, offlineBuffer)) {\n      assert commonPrefixPosition > dimCommonPrefix;\n      reader.next();\n      PointValue pointValue = reader.pointValue();\n      // copy dimension\n      BytesRef packedValue = pointValue.packedValue();\n      System.arraycopy(packedValue.bytes, packedValue.offset + offset, scratch, 0, bytesPerDim);\n      // copy docID\n      BytesRef docIDBytes = pointValue.docIDBytes();\n      System.arraycopy(docIDBytes.bytes, docIDBytes.offset, scratch, bytesPerDim, Integer.BYTES);\n      for (long i = from + 1; i < to; i++) {\n        reader.next();\n        pointValue = reader.pointValue();\n        if (commonPrefixPosition == dimCommonPrefix) {\n          histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          // we do not need to check for common prefix anymore,\n          // just finish the histogram and break\n          for (long j = i + 1; j < to; j++) {\n            reader.next();\n            pointValue = reader.pointValue();\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n          break;\n        } else {\n          //check common prefix and adjust histogram\n          final int startIndex = (dimCommonPrefix > bytesPerDim) ? bytesPerDim : dimCommonPrefix;\n          final int endIndex = (commonPrefixPosition > bytesPerDim) ? bytesPerDim : commonPrefixPosition;\n          packedValue = pointValue.packedValue();\n          int j = Arrays.mismatch(scratch, startIndex, endIndex, packedValue.bytes, packedValue.offset + offset + startIndex, packedValue.offset + offset + endIndex);\n          if (j == -1) {\n            if (commonPrefixPosition > bytesPerDim) {\n              //tie-break on docID\n              docIDBytes = pointValue.docIDBytes();\n              int k = Arrays.mismatch(scratch, bytesPerDim, commonPrefixPosition, docIDBytes.bytes, docIDBytes.offset, docIDBytes.offset + commonPrefixPosition - bytesPerDim);\n              if (k != -1) {\n                commonPrefixPosition = bytesPerDim + k;\n                Arrays.fill(histogram, 0);\n                histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n              }\n            }\n          } else {\n            commonPrefixPosition = dimCommonPrefix + j;\n            Arrays.fill(histogram, 0);\n            histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n          }\n          if (commonPrefixPosition != bytesSorted) {\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n        }\n      }\n    }\n\n    //build partition buckets up to commonPrefix\n    for (int i = 0; i < commonPrefixPosition; i++) {\n      partitionBucket[i] = scratch[i] & 0xff;\n    }\n    return commonPrefixPosition;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#findCommonPrefixAndHistogram(OfflinePointWriter,long,long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDRadixSelector#findCommonPrefixAndHistogram(OfflinePointWriter,long,long,int,int).mjava","sourceNew":"  private int findCommonPrefixAndHistogram(OfflinePointWriter points, long from, long to, int dim, int dimCommonPrefix) throws IOException{\n    // find common prefix\n    int commonPrefixPosition = bytesSorted;\n    final int offset = dim * config.bytesPerDim;\n    try (OfflinePointReader reader = points.getReader(from, to - from, offlineBuffer)) {\n      assert commonPrefixPosition > dimCommonPrefix;\n      reader.next();\n      PointValue pointValue = reader.pointValue();\n      BytesRef packedValueDocID = pointValue.packedValueDocIDBytes();\n      // copy dimension\n      System.arraycopy(packedValueDocID.bytes, packedValueDocID.offset + offset, scratch, 0, config.bytesPerDim);\n      // copy data dimensions and docID\n      System.arraycopy(packedValueDocID.bytes, packedValueDocID.offset + config.packedIndexBytesLength, scratch, config.bytesPerDim, (config.numDims - config.numIndexDims) * config.bytesPerDim + Integer.BYTES);\n\n      for (long i = from + 1; i < to; i++) {\n        reader.next();\n        pointValue = reader.pointValue();\n        if (commonPrefixPosition == dimCommonPrefix) {\n          histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          // we do not need to check for common prefix anymore,\n          // just finish the histogram and break\n          for (long j = i + 1; j < to; j++) {\n            reader.next();\n            pointValue = reader.pointValue();\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n          break;\n        } else {\n          // Check common prefix and adjust histogram\n          final int startIndex = (dimCommonPrefix > config.bytesPerDim) ? config.bytesPerDim : dimCommonPrefix;\n          final int endIndex = (commonPrefixPosition > config.bytesPerDim) ? config.bytesPerDim : commonPrefixPosition;\n          packedValueDocID = pointValue.packedValueDocIDBytes();\n          int j = Arrays.mismatch(scratch, startIndex, endIndex, packedValueDocID.bytes, packedValueDocID.offset + offset + startIndex, packedValueDocID.offset + offset + endIndex);\n          if (j == -1) {\n            if (commonPrefixPosition > config.bytesPerDim) {\n              // Tie-break on data dimensions + docID\n              final int startTieBreak = config.packedIndexBytesLength;\n              final int endTieBreak = startTieBreak + commonPrefixPosition - config.bytesPerDim;\n              int k = Arrays.mismatch(scratch, config.bytesPerDim, commonPrefixPosition,\n                  packedValueDocID.bytes, packedValueDocID.offset + startTieBreak, packedValueDocID.offset + endTieBreak);\n              if (k != -1) {\n                commonPrefixPosition = config.bytesPerDim + k;\n                Arrays.fill(histogram, 0);\n                histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n              }\n            }\n          } else {\n            commonPrefixPosition = dimCommonPrefix + j;\n            Arrays.fill(histogram, 0);\n            histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n          }\n          if (commonPrefixPosition != bytesSorted) {\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n        }\n      }\n    }\n\n    // Build partition buckets up to commonPrefix\n    for (int i = 0; i < commonPrefixPosition; i++) {\n      partitionBucket[i] = scratch[i] & 0xff;\n    }\n    return commonPrefixPosition;\n  }\n\n","sourceOld":"  private int findCommonPrefixAndHistogram(OfflinePointWriter points, long from, long to, int dim, int dimCommonPrefix) throws IOException{\n    //find common prefix\n    int commonPrefixPosition = bytesSorted;\n    final int offset = dim * bytesPerDim;\n    try (OfflinePointReader reader = points.getReader(from, to - from, offlineBuffer)) {\n      assert commonPrefixPosition > dimCommonPrefix;\n      reader.next();\n      PointValue pointValue = reader.pointValue();\n      BytesRef packedValueDocID = pointValue.packedValueDocIDBytes();\n      // copy dimension\n      System.arraycopy(packedValueDocID.bytes, packedValueDocID.offset + offset, scratch, 0, bytesPerDim);\n      // copy data dimensions and docID\n      System.arraycopy(packedValueDocID.bytes, packedValueDocID.offset + numIndexDims * bytesPerDim, scratch, bytesPerDim, (numDataDims - numIndexDims) * bytesPerDim + Integer.BYTES);\n\n      for (long i = from + 1; i < to; i++) {\n        reader.next();\n        pointValue = reader.pointValue();\n        if (commonPrefixPosition == dimCommonPrefix) {\n          histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          // we do not need to check for common prefix anymore,\n          // just finish the histogram and break\n          for (long j = i + 1; j < to; j++) {\n            reader.next();\n            pointValue = reader.pointValue();\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n          break;\n        } else {\n          //check common prefix and adjust histogram\n          final int startIndex = (dimCommonPrefix > bytesPerDim) ? bytesPerDim : dimCommonPrefix;\n          final int endIndex = (commonPrefixPosition > bytesPerDim) ? bytesPerDim : commonPrefixPosition;\n          packedValueDocID = pointValue.packedValueDocIDBytes();\n          int j = Arrays.mismatch(scratch, startIndex, endIndex, packedValueDocID.bytes, packedValueDocID.offset + offset + startIndex, packedValueDocID.offset + offset + endIndex);\n          if (j == -1) {\n            if (commonPrefixPosition > bytesPerDim) {\n              //tie-break on data dimensions + docID\n              final int startTieBreak = numIndexDims * bytesPerDim;\n              final int endTieBreak = startTieBreak + commonPrefixPosition - bytesPerDim;\n              int k = Arrays.mismatch(scratch, bytesPerDim, commonPrefixPosition,\n                  packedValueDocID.bytes, packedValueDocID.offset + startTieBreak, packedValueDocID.offset + endTieBreak);\n              if (k != -1) {\n                commonPrefixPosition = bytesPerDim + k;\n                Arrays.fill(histogram, 0);\n                histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n              }\n            }\n          } else {\n            commonPrefixPosition = dimCommonPrefix + j;\n            Arrays.fill(histogram, 0);\n            histogram[scratch[commonPrefixPosition] & 0xff] = i - from;\n          }\n          if (commonPrefixPosition != bytesSorted) {\n            histogram[getBucket(offset, commonPrefixPosition, pointValue)]++;\n          }\n        }\n      }\n    }\n\n    //build partition buckets up to commonPrefix\n    for (int i = 0; i < commonPrefixPosition; i++) {\n      partitionBucket[i] = scratch[i] & 0xff;\n    }\n    return commonPrefixPosition;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7f06758793500ca773d0df1037290e6e404fb33":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["c7f06758793500ca773d0df1037290e6e404fb33"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"c7f06758793500ca773d0df1037290e6e404fb33":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["c7f06758793500ca773d0df1037290e6e404fb33"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}