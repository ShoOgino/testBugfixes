{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,PolygonDescription,double).mjava","commits":[{"id":"961aa3f803841184bcbd8a9d0533743be1323d63","date":1521994841,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,PolygonDescription,double).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param description describes the polygon and its associated holes.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final PolygonDescription description,\n    final double leniencyValue) {\n      \n    // First, convert the holes to polygons in their own right.\n    final List<GeoPolygon> holes;\n    if (description.holes != null && description.holes.size() > 0) {\n      holes = new ArrayList<>(description.holes.size());\n      for (final PolygonDescription holeDescription : description.holes) {\n        final GeoPolygon gp = makeGeoPolygon(planetModel, holeDescription, leniencyValue);\n        if (gp == null) {\n          return null;\n        }\n        holes.add(gp);\n      }\n    } else {\n      holes = null;\n    }\n\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(description.points);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n\n    if (filteredPointList.size() <= SMALL_POLYGON_CUTOFF_EDGES) {\n      try {\n        //First approximation to find a point\n        final GeoPoint centerOfMass = getCenterOfMass(planetModel, filteredPointList);\n        final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, filteredPointList);\n        if (isCenterOfMassInside != null) {\n          return generateGeoPolygon(planetModel, filteredPointList, holes, centerOfMass, isCenterOfMassInside);\n        }\n        \n        //System.err.println(\"points=\"+pointList);\n        // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n        // of points to use for poles.\n        final Random generator = new Random(1234);\n        for (int counter = 0; counter < 1000000; counter++) {\n          //counter++;\n          // Pick the next random pole\n          final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n          // Is it inside or outside?\n          final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n          if (isPoleInside != null) {\n            // Legal pole\n            //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n            //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n            return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n          }\n          // If pole choice was illegal, try another one\n        }\n        throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n      } catch (TileException e) {\n        // Couldn't tile the polygon; use GeoComplexPolygon instead, if we can.\n      }\n    }\n    // Fallback: create large geo polygon, using complex polygon logic.\n    final List<PolygonDescription> pd = new ArrayList<>(1);\n    pd.add(description);\n    return makeLargeGeoPolygon(planetModel, pd);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0384fe767a50d9d16907ca6924a3227c24a5c98c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0384fe767a50d9d16907ca6924a3227c24a5c98c","date":1522059634,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,PolygonDescription,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,PolygonDescription,double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param description describes the polygon and its associated holes.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final PolygonDescription description,\n    final double leniencyValue) {\n      \n    // First, convert the holes to polygons in their own right.\n    final List<GeoPolygon> holes;\n    if (description.holes != null && description.holes.size() > 0) {\n      holes = new ArrayList<>(description.holes.size());\n      for (final PolygonDescription holeDescription : description.holes) {\n        final GeoPolygon gp = makeGeoPolygon(planetModel, holeDescription, leniencyValue);\n        if (gp == null) {\n          return null;\n        }\n        holes.add(gp);\n      }\n    } else {\n      holes = null;\n    }\n\n    if (description.points.size() <= SMALL_POLYGON_CUTOFF_EDGES) {\n      // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n      //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n      //final long startTime = System.currentTimeMillis();\n      final List<GeoPoint> firstFilteredPointList = filterPoints(description.points);\n      if (firstFilteredPointList == null) {\n        return null;\n      }\n      final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n      //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n      if (filteredPointList == null) {\n        return null;\n      }\n\n      try {\n        //First approximation to find a point\n        final GeoPoint centerOfMass = getCenterOfMass(planetModel, filteredPointList);\n        final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, filteredPointList);\n        if (isCenterOfMassInside != null) {\n          return generateGeoPolygon(planetModel, filteredPointList, holes, centerOfMass, isCenterOfMassInside);\n        }\n        \n        //System.err.println(\"points=\"+pointList);\n        // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n        // of points to use for poles.\n        final Random generator = new Random(1234);\n        for (int counter = 0; counter < 1000000; counter++) {\n          //counter++;\n          // Pick the next random pole\n          final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n          // Is it inside or outside?\n          final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n          if (isPoleInside != null) {\n            // Legal pole\n            //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n            //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n            return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n          }\n          // If pole choice was illegal, try another one\n        }\n        throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n      } catch (TileException e) {\n        // Couldn't tile the polygon; use GeoComplexPolygon instead, if we can.\n      }\n    }\n    // Fallback: create large geo polygon, using complex polygon logic.\n    final List<PolygonDescription> pd = new ArrayList<>(1);\n    pd.add(description);\n    return makeLargeGeoPolygon(planetModel, pd);\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param description describes the polygon and its associated holes.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final PolygonDescription description,\n    final double leniencyValue) {\n      \n    // First, convert the holes to polygons in their own right.\n    final List<GeoPolygon> holes;\n    if (description.holes != null && description.holes.size() > 0) {\n      holes = new ArrayList<>(description.holes.size());\n      for (final PolygonDescription holeDescription : description.holes) {\n        final GeoPolygon gp = makeGeoPolygon(planetModel, holeDescription, leniencyValue);\n        if (gp == null) {\n          return null;\n        }\n        holes.add(gp);\n      }\n    } else {\n      holes = null;\n    }\n\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(description.points);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n\n    if (filteredPointList.size() <= SMALL_POLYGON_CUTOFF_EDGES) {\n      try {\n        //First approximation to find a point\n        final GeoPoint centerOfMass = getCenterOfMass(planetModel, filteredPointList);\n        final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, filteredPointList);\n        if (isCenterOfMassInside != null) {\n          return generateGeoPolygon(planetModel, filteredPointList, holes, centerOfMass, isCenterOfMassInside);\n        }\n        \n        //System.err.println(\"points=\"+pointList);\n        // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n        // of points to use for poles.\n        final Random generator = new Random(1234);\n        for (int counter = 0; counter < 1000000; counter++) {\n          //counter++;\n          // Pick the next random pole\n          final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n          // Is it inside or outside?\n          final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n          if (isPoleInside != null) {\n            // Legal pole\n            //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n            //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n            return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n          }\n          // If pole choice was illegal, try another one\n        }\n        throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n      } catch (TileException e) {\n        // Couldn't tile the polygon; use GeoComplexPolygon instead, if we can.\n      }\n    }\n    // Fallback: create large geo polygon, using complex polygon logic.\n    final List<PolygonDescription> pd = new ArrayList<>(1);\n    pd.add(description);\n    return makeLargeGeoPolygon(planetModel, pd);\n  }\n\n","bugFix":["961aa3f803841184bcbd8a9d0533743be1323d63"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"961aa3f803841184bcbd8a9d0533743be1323d63":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0384fe767a50d9d16907ca6924a3227c24a5c98c":["961aa3f803841184bcbd8a9d0533743be1323d63"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0384fe767a50d9d16907ca6924a3227c24a5c98c"]},"commit2Childs":{"961aa3f803841184bcbd8a9d0533743be1323d63":["0384fe767a50d9d16907ca6924a3227c24a5c98c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["961aa3f803841184bcbd8a9d0533743be1323d63"],"0384fe767a50d9d16907ca6924a3227c24a5c98c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}