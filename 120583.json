{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\",false);\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\n        // to the collection for this core.\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\n                continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = nodeProps.get(\"url\");\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b03a8a4023c6f2ef8538d5a2b5c4b0d58ab73447","date":1329193136,"type":4,"author":"Yonik Seeley","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#checkDistributed(ResponseBuilder).mjava","sourceNew":null,"sourceOld":"  // TODO: this could go in a different component, or in SearchHandler\n  // check if this is a distributed request and set info on the response builder\n  void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n\n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // This can be more efficient... we only record the name, even though we have the\n        // shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b03a8a4023c6f2ef8538d5a2b5c4b0d58ab73447":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b03a8a4023c6f2ef8538d5a2b5c4b0d58ab73447"]},"commit2Childs":{"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"b03a8a4023c6f2ef8538d5a2b5c4b0d58ab73447":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","b03a8a4023c6f2ef8538d5a2b5c4b0d58ab73447","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}