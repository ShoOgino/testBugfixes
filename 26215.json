{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","commits":[{"id":"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e","date":1406603075,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"/dev/null","sourceNew":"  private Watcher wrapWatcher (final Watcher watcher) {\n    if (watcher == null) return watcher;\n\n    // wrap the watcher so that it doesn't fire off ZK's event queue\n    return new Watcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        zkCallbackExecutor.submit(new Runnable () {\n          @Override\n          public void run () {\n            watcher.process(event);\n          }\n        });\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["14ad5f6d86e47603e934be859694ffbba27cd436"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        zkCallbackExecutor.submit(new Runnable () {\n          @Override\n          public void run () {\n            watcher.process(event);\n          }\n        });\n      }\n    };\n  }\n\n","sourceOld":"  private Watcher wrapWatcher (final Watcher watcher) {\n    if (watcher == null) return watcher;\n\n    // wrap the watcher so that it doesn't fire off ZK's event queue\n    return new Watcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        zkCallbackExecutor.submit(new Runnable () {\n          @Override\n          public void run () {\n            watcher.process(event);\n          }\n        });\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        zkCallbackExecutor.submit(() -> watcher.process(event));\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        zkCallbackExecutor.submit(new Runnable () {\n          @Override\n          public void run () {\n            watcher.process(event);\n          }\n        });\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4169a39455be564348e51f60d4dc9f77a80c2f9","date":1473707172,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        try {\n          zkCallbackExecutor.submit(() -> watcher.process(event));\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        zkCallbackExecutor.submit(() -> watcher.process(event));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["bb6348d79165730d693bd2e2181bd06534dd0917"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        try {\n          zkCallbackExecutor.submit(() -> watcher.process(event));\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        zkCallbackExecutor.submit(() -> watcher.process(event));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        try {\n          zkCallbackExecutor.submit(() -> watcher.process(event));\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        zkCallbackExecutor.submit(() -> watcher.process(event));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        try {\n          zkCallbackExecutor.submit(() -> watcher.process(event));\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        zkCallbackExecutor.submit(() -> watcher.process(event));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb6348d79165730d693bd2e2181bd06534dd0917","date":1512509690,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        try {\n          if (watcher instanceof ConnectionManager) {\n            zkConnManagerCallbackExecutor.submit(() -> watcher.process(event));\n          } else {\n            zkCallbackExecutor.submit(() -> watcher.process(event));\n          }\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        try {\n          zkCallbackExecutor.submit(() -> watcher.process(event));\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":["d4169a39455be564348e51f60d4dc9f77a80c2f9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14ad5f6d86e47603e934be859694ffbba27cd436","date":1522709785,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event {}\", event);\n        try {\n          if (watcher instanceof ConnectionManager) {\n            zkConnManagerCallbackExecutor.submit(() -> watcher.process(event));\n          } else {\n            zkCallbackExecutor.submit(() -> watcher.process(event));\n          }\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event \" + event);\n        try {\n          if (watcher instanceof ConnectionManager) {\n            zkConnManagerCallbackExecutor.submit(() -> watcher.process(event));\n          } else {\n            zkCallbackExecutor.submit(() -> watcher.process(event));\n          }\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51a2db0abe886e592b27151529b09efc818dac80","date":1559220196,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof ProcessWatchWithExecutor) return watcher;\n    return new ProcessWatchWithExecutor(watcher);\n  }\n\n","sourceOld":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event {}\", event);\n        try {\n          if (watcher instanceof ConnectionManager) {\n            zkConnManagerCallbackExecutor.submit(() -> watcher.process(event));\n          } else {\n            zkCallbackExecutor.submit(() -> watcher.process(event));\n          }\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58af973abe9f7c0faa777c1a6285fc7f72c171c5","date":1559329541,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#wrapWatcher(Watcher).mjava","sourceNew":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof ProcessWatchWithExecutor) return watcher;\n    return new ProcessWatchWithExecutor(watcher);\n  }\n\n","sourceOld":"  /**\n   * Wraps the watcher so that it doesn't fire off ZK's event queue. In order to guarantee that a watch object will\n   * only be triggered once for a given notification, users need to wrap their watcher using this method before\n   * calling {@link #exists(String, org.apache.zookeeper.Watcher, boolean)} or\n   * {@link #getData(String, org.apache.zookeeper.Watcher, org.apache.zookeeper.data.Stat, boolean)}.\n   */\n  public Watcher wrapWatcher(final Watcher watcher) {\n    if (watcher == null || watcher instanceof SolrZkWatcher) return watcher;\n\n    return new SolrZkWatcher() {\n      @Override\n      public void process(final WatchedEvent event) {\n        log.debug(\"Submitting job to respond to event {}\", event);\n        try {\n          if (watcher instanceof ConnectionManager) {\n            zkConnManagerCallbackExecutor.submit(() -> watcher.process(event));\n          } else {\n            zkCallbackExecutor.submit(() -> watcher.process(event));\n          }\n        } catch (RejectedExecutionException e) {\n          // If not a graceful shutdown\n          if (!isClosed()) {\n            throw e;\n          }\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"14ad5f6d86e47603e934be859694ffbba27cd436":["bb6348d79165730d693bd2e2181bd06534dd0917"],"3a0c04b71951333291abc7f317109a6a5957bd28":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3a0c04b71951333291abc7f317109a6a5957bd28","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"89424def13674ea17829b41c5883c54ecc31a132":["3a0c04b71951333291abc7f317109a6a5957bd28","d4169a39455be564348e51f60d4dc9f77a80c2f9"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e"],"51a2db0abe886e592b27151529b09efc818dac80":["14ad5f6d86e47603e934be859694ffbba27cd436"],"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["3a0c04b71951333291abc7f317109a6a5957bd28","89424def13674ea17829b41c5883c54ecc31a132"],"58af973abe9f7c0faa777c1a6285fc7f72c171c5":["14ad5f6d86e47603e934be859694ffbba27cd436","51a2db0abe886e592b27151529b09efc818dac80"],"bb6348d79165730d693bd2e2181bd06534dd0917":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"d4169a39455be564348e51f60d4dc9f77a80c2f9":["3a0c04b71951333291abc7f317109a6a5957bd28"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["51a2db0abe886e592b27151529b09efc818dac80"]},"commit2Childs":{"14ad5f6d86e47603e934be859694ffbba27cd436":["51a2db0abe886e592b27151529b09efc818dac80","58af973abe9f7c0faa777c1a6285fc7f72c171c5"],"3a0c04b71951333291abc7f317109a6a5957bd28":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","89424def13674ea17829b41c5883c54ecc31a132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","d4169a39455be564348e51f60d4dc9f77a80c2f9"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["3a0c04b71951333291abc7f317109a6a5957bd28"],"51a2db0abe886e592b27151529b09efc818dac80":["58af973abe9f7c0faa777c1a6285fc7f72c171c5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","bb6348d79165730d693bd2e2181bd06534dd0917"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e"],"58af973abe9f7c0faa777c1a6285fc7f72c171c5":[],"bb6348d79165730d693bd2e2181bd06534dd0917":["14ad5f6d86e47603e934be859694ffbba27cd436"],"d4169a39455be564348e51f60d4dc9f77a80c2f9":["89424def13674ea17829b41c5883c54ecc31a132"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","58af973abe9f7c0faa777c1a6285fc7f72c171c5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}