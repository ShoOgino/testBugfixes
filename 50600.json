{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand).mjava","commits":[{"id":"1bea3922196318026c4274f2013416acb60c691e","date":1336496433,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // not found... allow this in the future (depending on the details of the update, or if the user explicitly sets it).\n      // could also just not change anything here and let the optimistic locking throw the error\n      throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n    }\n\n    oldDoc.remove(VERSION_FIELD);\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["817fc4762cd649397b27305970dad27295735f3a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02f65b52d33e2ddff7660dd6c22e86d8d296760e","date":1337022150,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // not found... allow this in the future (depending on the details of the update, or if the user explicitly sets it).\n      // could also just not change anything here and let the optimistic locking throw the error\n      throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n    }\n\n    oldDoc.remove(VERSION_FIELD);\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // not found... allow this in the future (depending on the details of the update, or if the user explicitly sets it).\n      // could also just not change anything here and let the optimistic locking throw the error\n      throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n    }\n\n    oldDoc.remove(VERSION_FIELD);\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e5dbf4268db532969cc84ef336b9988afce9843","date":1342199436,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // not found... allow this in the future (depending on the details of the update, or if the user explicitly sets it).\n      // could also just not change anything here and let the optimistic locking throw the error\n      throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n    }\n\n    oldDoc.remove(VERSION_FIELD);\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["817fc4762cd649397b27305970dad27295735f3a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand).mjava","sourceNew":null,"sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // not found... allow this in the future (depending on the details of the update, or if the user explicitly sets it).\n      // could also just not change anything here and let the optimistic locking throw the error\n      throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n    }\n\n    oldDoc.remove(VERSION_FIELD);\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand).mjava","sourceNew":null,"sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // not found... allow this in the future (depending on the details of the update, or if the user explicitly sets it).\n      // could also just not change anything here and let the optimistic locking throw the error\n      throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n    }\n\n    oldDoc.remove(VERSION_FIELD);\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aba371508186796cc6151d8223a5b4e16d02e26e":["02f65b52d33e2ddff7660dd6c22e86d8d296760e","5e5dbf4268db532969cc84ef336b9988afce9843"],"5e5dbf4268db532969cc84ef336b9988afce9843":["02f65b52d33e2ddff7660dd6c22e86d8d296760e"],"02f65b52d33e2ddff7660dd6c22e86d8d296760e":["1bea3922196318026c4274f2013416acb60c691e"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["02f65b52d33e2ddff7660dd6c22e86d8d296760e","5e5dbf4268db532969cc84ef336b9988afce9843"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1bea3922196318026c4274f2013416acb60c691e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5e5dbf4268db532969cc84ef336b9988afce9843"]},"commit2Childs":{"aba371508186796cc6151d8223a5b4e16d02e26e":[],"5e5dbf4268db532969cc84ef336b9988afce9843":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"02f65b52d33e2ddff7660dd6c22e86d8d296760e":["aba371508186796cc6151d8223a5b4e16d02e26e","5e5dbf4268db532969cc84ef336b9988afce9843","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1bea3922196318026c4274f2013416acb60c691e"],"1bea3922196318026c4274f2013416acb60c691e":["02f65b52d33e2ddff7660dd6c22e86d8d296760e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}