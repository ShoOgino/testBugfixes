{"path":"solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.TopLevelDocValuesTermsQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","commits":[{"id":"a32b832a37c116a61a7e58893eb45eb8c940cc0f","date":1578915801,"type":0,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.TopLevelDocValuesTermsQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"/dev/null","sourceNew":"    public Weight createWeight(IndexSearcher searcher, final ScoreMode scoreMode, float boost) throws IOException {\n      if (! (searcher instanceof SolrIndexSearcher)) {\n        log.debug(\"Falling back to DocValuesTermsQuery because searcher [{}] is not the required SolrIndexSearcher\", searcher);\n        return super.createWeight(searcher, scoreMode, boost);\n      }\n\n      topLevelDocValues = DocValues.getSortedSet(((SolrIndexSearcher)searcher).getSlowAtomicReader(), fieldName);\n      topLevelTermOrdinals = new LongBitSet(topLevelDocValues.getValueCount());\n      PrefixCodedTerms.TermIterator iterator = getTerms().iterator();\n\n      long lastTermOrdFound = 0;\n      for(BytesRef term = iterator.next(); term != null; term = iterator.next()) {\n        long currentTermOrd = lookupTerm(topLevelDocValues, term, lastTermOrdFound);\n        if (currentTermOrd >= 0L) {\n          matchesAtLeastOneTerm = true;\n          topLevelTermOrdinals.set(currentTermOrd);\n          lastTermOrdFound = currentTermOrd;\n        }\n      }\n\n      return new ConstantScoreWeight(this, boost) {\n        public Scorer scorer(LeafReaderContext context) throws IOException {\n          if (! matchesAtLeastOneTerm) {\n            return null;\n          }\n          \n          SortedSetDocValues segmentDocValues = context.reader().getSortedSetDocValues(fieldName);\n          if (segmentDocValues == null) {\n            return null;\n          }\n\n          final int docBase = context.docBase;\n          return new ConstantScoreScorer(this, this.score(), scoreMode, new TwoPhaseIterator(segmentDocValues) {\n            public boolean matches() throws IOException {\n              topLevelDocValues.advanceExact(docBase + approximation.docID());\n              for(long ord = topLevelDocValues.nextOrd(); ord != -1L; ord = topLevelDocValues.nextOrd()) {\n                if (topLevelTermOrdinals.get(ord)) {\n                  return true;\n                }\n              }\n\n              return false;\n            }\n\n            public float matchCost() {\n              return 10.0F;\n            }\n          });\n\n        }\n\n        public boolean isCacheable(LeafReaderContext ctx) {\n          return DocValues.isCacheable(ctx, new String[]{fieldName});\n        }\n      };\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["496b994c291d3ea81d7c8e99988e0f36a46b970b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2509bad1fbf30792438821cc94f7a5e1a13d5473","date":1578934553,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.TopLevelDocValuesTermsQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"/dev/null","sourceNew":"    public Weight createWeight(IndexSearcher searcher, final ScoreMode scoreMode, float boost) throws IOException {\n      if (! (searcher instanceof SolrIndexSearcher)) {\n        log.debug(\"Falling back to DocValuesTermsQuery because searcher [{}] is not the required SolrIndexSearcher\", searcher);\n        return super.createWeight(searcher, scoreMode, boost);\n      }\n\n      topLevelDocValues = DocValues.getSortedSet(((SolrIndexSearcher)searcher).getSlowAtomicReader(), fieldName);\n      topLevelTermOrdinals = new LongBitSet(topLevelDocValues.getValueCount());\n      PrefixCodedTerms.TermIterator iterator = getTerms().iterator();\n\n      long lastTermOrdFound = 0;\n      for(BytesRef term = iterator.next(); term != null; term = iterator.next()) {\n        long currentTermOrd = lookupTerm(topLevelDocValues, term, lastTermOrdFound);\n        if (currentTermOrd >= 0L) {\n          matchesAtLeastOneTerm = true;\n          topLevelTermOrdinals.set(currentTermOrd);\n          lastTermOrdFound = currentTermOrd;\n        }\n      }\n\n      return new ConstantScoreWeight(this, boost) {\n        public Scorer scorer(LeafReaderContext context) throws IOException {\n          if (! matchesAtLeastOneTerm) {\n            return null;\n          }\n          \n          SortedSetDocValues segmentDocValues = context.reader().getSortedSetDocValues(fieldName);\n          if (segmentDocValues == null) {\n            return null;\n          }\n\n          final int docBase = context.docBase;\n          return new ConstantScoreScorer(this, this.score(), scoreMode, new TwoPhaseIterator(segmentDocValues) {\n            public boolean matches() throws IOException {\n              topLevelDocValues.advanceExact(docBase + approximation.docID());\n              for(long ord = topLevelDocValues.nextOrd(); ord != -1L; ord = topLevelDocValues.nextOrd()) {\n                if (topLevelTermOrdinals.get(ord)) {\n                  return true;\n                }\n              }\n\n              return false;\n            }\n\n            public float matchCost() {\n              return 10.0F;\n            }\n          });\n\n        }\n\n        public boolean isCacheable(LeafReaderContext ctx) {\n          return DocValues.isCacheable(ctx, new String[]{fieldName});\n        }\n      };\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"496b994c291d3ea81d7c8e99988e0f36a46b970b","date":1599328467,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.TopLevelDocValuesTermsQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/TermsQParserPlugin.TopLevelDocValuesTermsQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","sourceNew":"    public Weight createWeight(IndexSearcher searcher, final ScoreMode scoreMode, float boost) throws IOException {\n      if (! (searcher instanceof SolrIndexSearcher)) {\n        log.debug(\"Falling back to DocValuesTermsQuery because searcher [{}] is not the required SolrIndexSearcher\", searcher);\n        return super.createWeight(searcher, scoreMode, boost);\n      }\n\n      topLevelDocValues = DocValues.getSortedSet(((SolrIndexSearcher)searcher).getSlowAtomicReader(), fieldName);\n      topLevelTermOrdinals = new LongBitSet(topLevelDocValues.getValueCount());\n      PrefixCodedTerms.TermIterator iterator = getTerms().iterator();\n\n      long lastTermOrdFound = 0;\n      for(BytesRef term = iterator.next(); term != null; term = iterator.next()) {\n        long currentTermOrd = lookupTerm(topLevelDocValues, term, lastTermOrdFound);\n        if (currentTermOrd >= 0L) {\n          matchesAtLeastOneTerm = true;\n          topLevelTermOrdinals.set(currentTermOrd);\n          lastTermOrdFound = currentTermOrd;\n        }\n      }\n\n      return new ConstantScoreWeight(this, boost) {\n        public Scorer scorer(LeafReaderContext context) throws IOException {\n          if (! matchesAtLeastOneTerm) {\n            return null;\n          }\n\n          SortedSetDocValues segmentDocValues = DocValues.getSortedSet(context.reader(), fieldName);\n          if (segmentDocValues == null) {\n            return null;\n          }\n\n          final int docBase = context.docBase;\n          return new ConstantScoreScorer(this, this.score(), scoreMode, new TwoPhaseIterator(segmentDocValues) {\n            public boolean matches() throws IOException {\n              topLevelDocValues.advanceExact(docBase + approximation.docID());\n              for(long ord = topLevelDocValues.nextOrd(); ord != -1L; ord = topLevelDocValues.nextOrd()) {\n                if (topLevelTermOrdinals.get(ord)) {\n                  return true;\n                }\n              }\n\n              return false;\n            }\n\n            public float matchCost() {\n              return 10.0F;\n            }\n          });\n\n        }\n\n        public boolean isCacheable(LeafReaderContext ctx) {\n          return DocValues.isCacheable(ctx, new String[]{fieldName});\n        }\n      };\n    }\n\n","sourceOld":"    public Weight createWeight(IndexSearcher searcher, final ScoreMode scoreMode, float boost) throws IOException {\n      if (! (searcher instanceof SolrIndexSearcher)) {\n        log.debug(\"Falling back to DocValuesTermsQuery because searcher [{}] is not the required SolrIndexSearcher\", searcher);\n        return super.createWeight(searcher, scoreMode, boost);\n      }\n\n      topLevelDocValues = DocValues.getSortedSet(((SolrIndexSearcher)searcher).getSlowAtomicReader(), fieldName);\n      topLevelTermOrdinals = new LongBitSet(topLevelDocValues.getValueCount());\n      PrefixCodedTerms.TermIterator iterator = getTerms().iterator();\n\n      long lastTermOrdFound = 0;\n      for(BytesRef term = iterator.next(); term != null; term = iterator.next()) {\n        long currentTermOrd = lookupTerm(topLevelDocValues, term, lastTermOrdFound);\n        if (currentTermOrd >= 0L) {\n          matchesAtLeastOneTerm = true;\n          topLevelTermOrdinals.set(currentTermOrd);\n          lastTermOrdFound = currentTermOrd;\n        }\n      }\n\n      return new ConstantScoreWeight(this, boost) {\n        public Scorer scorer(LeafReaderContext context) throws IOException {\n          if (! matchesAtLeastOneTerm) {\n            return null;\n          }\n          \n          SortedSetDocValues segmentDocValues = context.reader().getSortedSetDocValues(fieldName);\n          if (segmentDocValues == null) {\n            return null;\n          }\n\n          final int docBase = context.docBase;\n          return new ConstantScoreScorer(this, this.score(), scoreMode, new TwoPhaseIterator(segmentDocValues) {\n            public boolean matches() throws IOException {\n              topLevelDocValues.advanceExact(docBase + approximation.docID());\n              for(long ord = topLevelDocValues.nextOrd(); ord != -1L; ord = topLevelDocValues.nextOrd()) {\n                if (topLevelTermOrdinals.get(ord)) {\n                  return true;\n                }\n              }\n\n              return false;\n            }\n\n            public float matchCost() {\n              return 10.0F;\n            }\n          });\n\n        }\n\n        public boolean isCacheable(LeafReaderContext ctx) {\n          return DocValues.isCacheable(ctx, new String[]{fieldName});\n        }\n      };\n    }\n\n","bugFix":["a32b832a37c116a61a7e58893eb45eb8c940cc0f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"496b994c291d3ea81d7c8e99988e0f36a46b970b":["a32b832a37c116a61a7e58893eb45eb8c940cc0f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a32b832a37c116a61a7e58893eb45eb8c940cc0f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["496b994c291d3ea81d7c8e99988e0f36a46b970b"],"2509bad1fbf30792438821cc94f7a5e1a13d5473":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a32b832a37c116a61a7e58893eb45eb8c940cc0f"]},"commit2Childs":{"496b994c291d3ea81d7c8e99988e0f36a46b970b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a32b832a37c116a61a7e58893eb45eb8c940cc0f","2509bad1fbf30792438821cc94f7a5e1a13d5473"],"a32b832a37c116a61a7e58893eb45eb8c940cc0f":["496b994c291d3ea81d7c8e99988e0f36a46b970b","2509bad1fbf30792438821cc94f7a5e1a13d5473"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2509bad1fbf30792438821cc94f7a5e1a13d5473":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","2509bad1fbf30792438821cc94f7a5e1a13d5473"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}