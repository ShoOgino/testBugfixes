{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toLightAutomaton(Map[String,LightAutomaton],LightAutomatonProvider).mjava","commits":[{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toLightAutomaton(Map[String,LightAutomaton],LightAutomatonProvider).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","sourceNew":"  private LightAutomaton toLightAutomaton(Map<String,LightAutomaton> automata,\n      LightAutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<LightAutomaton> list;\n    LightAutomaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.unionLight(list);\n        MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenateLight(list);\n        MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = BasicOperations.intersectionLight(\n            exp1.toLightAutomaton(automata, automaton_provider),\n            exp2.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = BasicOperations.optionalLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = BasicOperations.complementLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeCharLight(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRangeLight(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyCharLight();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmptyLight();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeStringLight(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyStringLight();\n        break;\n      case REGEXP_AUTOMATON:\n        LightAutomaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeIntervalLight(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","date":1402946522,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toLightAutomaton(Map[String,LightAutomaton],LightAutomatonProvider).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toLightAutomaton(Map[String,LightAutomaton],LightAutomatonProvider).mjava","sourceNew":"  private LightAutomaton toLightAutomaton(Map<String,LightAutomaton> automata,\n      LightAutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<LightAutomaton> list;\n    LightAutomaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.unionLight(list);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenateLight(list);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = BasicOperations.intersectionLight(\n            exp1.toLightAutomaton(automata, automaton_provider),\n            exp2.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = BasicOperations.optionalLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = BasicOperations.complementLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeCharLight(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRangeLight(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyCharLight();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmptyLight();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeStringLight(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyStringLight();\n        break;\n      case REGEXP_AUTOMATON:\n        LightAutomaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeIntervalLight(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private LightAutomaton toLightAutomaton(Map<String,LightAutomaton> automata,\n      LightAutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<LightAutomaton> list;\n    LightAutomaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.unionLight(list);\n        MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenateLight(list);\n        MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = BasicOperations.intersectionLight(\n            exp1.toLightAutomaton(automata, automaton_provider),\n            exp2.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = BasicOperations.optionalLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = BasicOperations.complementLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeCharLight(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRangeLight(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyCharLight();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmptyLight();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeStringLight(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyStringLight();\n        break;\n      case REGEXP_AUTOMATON:\n        LightAutomaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeIntervalLight(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toLightAutomaton(Map[String,LightAutomaton],LightAutomatonProvider).mjava","sourceNew":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = Operations.union(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = Operations.concatenate(list);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = Operations.intersection(\n            exp1.toAutomaton(automata, automaton_provider),\n            exp2.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = Operations.optional(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = Operations.repeat(exp1.toAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = Operations.complement(exp1.toAutomaton(automata, automaton_provider));\n        a = MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = Automata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = Automata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = Automata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = Automata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = Automata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = Automata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = Automata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private LightAutomaton toLightAutomaton(Map<String,LightAutomaton> automata,\n      LightAutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<LightAutomaton> list;\n    LightAutomaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.unionLight(list);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenateLight(list);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = BasicOperations.intersectionLight(\n            exp1.toLightAutomaton(automata, automaton_provider),\n            exp2.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = BasicOperations.optionalLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = BasicOperations.repeatLight(exp1.toLightAutomaton(automata, automaton_provider), min, max);\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = BasicOperations.complementLight(exp1.toLightAutomaton(automata, automaton_provider));\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeCharLight(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRangeLight(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyCharLight();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmptyLight();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeStringLight(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyStringLight();\n        break;\n      case REGEXP_AUTOMATON:\n        LightAutomaton aa = null;\n        if (automata != null) {\n          aa = automata.get(s);\n        }\n        if (aa == null && automaton_provider != null) {\n          try {\n            aa = automaton_provider.getAutomaton(s);\n          } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n          }\n        }\n        if (aa == null) {\n          throw new IllegalArgumentException(\"'\" + s + \"' not found\");\n        }\n        a = aa;\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeIntervalLight(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ac34f0c5bb9274821fb0cb18075234e02002e9bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":[],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}