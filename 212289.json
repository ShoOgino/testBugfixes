{"path":"solr/core/src/test/org/apache/solr/util/hll/BigEndianAscendingWordSerializerTest#smokeTestSparseParams().mjava","commits":[{"id":"6faa211c4af605e3cf078a76d200c1dc348973f5","date":1437043657,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/hll/BigEndianAscendingWordSerializerTest#smokeTestSparseParams().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Smoke test for typical parameters used in practice.\n     */\n    @Test\n    public void smokeTestSparseParams() {\n        // XXX: revisit\n        final int shortWordLength = 17;\n        {// Should work on an empty sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     0/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            assert(Arrays.equals(serializer.getBytes(), new byte[0]));\n        }\n        {// Should work on a non-byte-divisible sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     3/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            serializer.writeWord(9);\n            serializer.writeWord(42);\n            serializer.writeWord(75);\n\n            // The values:\n            // -----------\n            // 9                    |42                   |75                   |padding\n\n            // Corresponding bits:\n            // ------------------\n            // 0000 0000 0000 0100 1|000 0000 0000 1010 10|00 0000 0000 1001 011|0 0000\n\n            // And the hex/decimal (remember Java bytes are signed):\n            // -----------------------------------------------------\n            // 0000 0000 -> 0x00 -> 0\n            // 0000 0100 -> 0x04 -> 4\n            // 1000 0000 -> 0x80 -> -128\n            // 0000 1010 -> 0x0A -> 10\n            // 1000 0000 -> 0x80 -> -128\n            // 0000 1001 -> 0x09 -> 9\n            // 0110 0000 -> 0x60 -> 96\n\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 0, 4, -128, 10, -128, 9, 96 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n        {// Should work on a byte-divisible sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     8/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            for(int i=1; i<9; i++) {\n                serializer.writeWord(i);\n            }\n\n            // Values: 1-8\n            // Corresponding bits:\n            // ------------------\n            // 0000 0000 0000 0000 1\n            // 000 0000 0000 0000 10\n            // 00 0000 0000 0000 011\n            // 0 0000 0000 0000 0100\n\n            // 0000 0000 0000 0010 1\n            // 000 0000 0000 0001 10\n            // 00 0000 0000 0000 111\n            // 0 0000 0000 0000 1000\n\n            // And the hex:\n            // ------------\n            // 0000 0000 -> 0x00 -> 0\n            // 0000 0000 -> 0x00 -> 0\n            // 1000 0000 -> 0x80 -> -128\n            // 0000 0000 -> 0x00 -> 0\n            // 1000 0000 -> 0x80 -> -128\n            // 0000 0000 -> 0x00 -> 0\n            // 0110 0000 -> 0x60 -> 96\n            // 0000 0000 -> 0x00 -> 0\n            // 0100 0000 -> 0x40 -> 64\n            // 0000 0000 -> 0x00 -> 0\n            // 0010 1000 -> 0x28 -> 40\n            // 0000 0000 -> 0x00 -> 0\n            // 0001 1000 -> 0x18 -> 24\n            // 0000 0000 -> 0x00 -> 0\n            // 0000 1110 -> 0x0D -> 14\n            // 0000 0000 -> 0x00 -> 0\n            // 0000 1000 -> 0x08 -> 8\n\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 0, 0, -128, 0, -128, 0, 96, 0, 64, 0, 40, 0, 24, 0, 14, 0, 8 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n        {// Should pad the array correctly.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     1/*wordCount*/,\n                                                     1/*bytePadding*/);\n\n            serializer.writeWord(1);\n            // 1 byte leading padding | value 1 | trailing padding\n            // 0000 0000 | 0000 0000 0000 0000 1|000 0000\n            // 0x00 0x00 0x00 0x80\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 0, 0, 0, -128 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/util/hll/BigEndianAscendingWordSerializerTest#smokeTestSparseParams().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Smoke test for typical parameters used in practice.\n     */\n    @Test\n    public void smokeTestSparseParams() {\n        // XXX: revisit\n        final int shortWordLength = 17;\n        {// Should work on an empty sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     0/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            assert(Arrays.equals(serializer.getBytes(), new byte[0]));\n        }\n        {// Should work on a non-byte-divisible sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     3/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            serializer.writeWord(9);\n            serializer.writeWord(42);\n            serializer.writeWord(75);\n\n            // The values:\n            // -----------\n            // 9                    |42                   |75                   |padding\n\n            // Corresponding bits:\n            // ------------------\n            // 0000 0000 0000 0100 1|000 0000 0000 1010 10|00 0000 0000 1001 011|0 0000\n\n            // And the hex/decimal (remember Java bytes are signed):\n            // -----------------------------------------------------\n            // 0000 0000 -> 0x00 -> 0\n            // 0000 0100 -> 0x04 -> 4\n            // 1000 0000 -> 0x80 -> -128\n            // 0000 1010 -> 0x0A -> 10\n            // 1000 0000 -> 0x80 -> -128\n            // 0000 1001 -> 0x09 -> 9\n            // 0110 0000 -> 0x60 -> 96\n\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 0, 4, -128, 10, -128, 9, 96 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n        {// Should work on a byte-divisible sequence, with no padding.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     8/*wordCount*/,\n                                                     0/*bytePadding, none*/);\n\n            for(int i=1; i<9; i++) {\n                serializer.writeWord(i);\n            }\n\n            // Values: 1-8\n            // Corresponding bits:\n            // ------------------\n            // 0000 0000 0000 0000 1\n            // 000 0000 0000 0000 10\n            // 00 0000 0000 0000 011\n            // 0 0000 0000 0000 0100\n\n            // 0000 0000 0000 0010 1\n            // 000 0000 0000 0001 10\n            // 00 0000 0000 0000 111\n            // 0 0000 0000 0000 1000\n\n            // And the hex:\n            // ------------\n            // 0000 0000 -> 0x00 -> 0\n            // 0000 0000 -> 0x00 -> 0\n            // 1000 0000 -> 0x80 -> -128\n            // 0000 0000 -> 0x00 -> 0\n            // 1000 0000 -> 0x80 -> -128\n            // 0000 0000 -> 0x00 -> 0\n            // 0110 0000 -> 0x60 -> 96\n            // 0000 0000 -> 0x00 -> 0\n            // 0100 0000 -> 0x40 -> 64\n            // 0000 0000 -> 0x00 -> 0\n            // 0010 1000 -> 0x28 -> 40\n            // 0000 0000 -> 0x00 -> 0\n            // 0001 1000 -> 0x18 -> 24\n            // 0000 0000 -> 0x00 -> 0\n            // 0000 1110 -> 0x0D -> 14\n            // 0000 0000 -> 0x00 -> 0\n            // 0000 1000 -> 0x08 -> 8\n\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 0, 0, -128, 0, -128, 0, 96, 0, 64, 0, 40, 0, 24, 0, 14, 0, 8 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n        {// Should pad the array correctly.\n            final BigEndianAscendingWordSerializer serializer =\n                new BigEndianAscendingWordSerializer(shortWordLength,\n                                                     1/*wordCount*/,\n                                                     1/*bytePadding*/);\n\n            serializer.writeWord(1);\n            // 1 byte leading padding | value 1 | trailing padding\n            // 0000 0000 | 0000 0000 0000 0000 1|000 0000\n            // 0x00 0x00 0x00 0x80\n            final byte[] bytes = serializer.getBytes();\n            final byte[] expectedBytes = new byte[] { 0, 0, 0, -128 };\n            assertTrue(Arrays.equals(bytes, expectedBytes));\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6faa211c4af605e3cf078a76d200c1dc348973f5"],"6faa211c4af605e3cf078a76d200c1dc348973f5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6faa211c4af605e3cf078a76d200c1dc348973f5"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6faa211c4af605e3cf078a76d200c1dc348973f5":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}