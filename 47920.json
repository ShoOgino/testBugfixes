{"path":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","commits":[{"id":"dd6ddd3da533988676f6ec21e7e4651a2b2e8345","date":1330043299,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"/dev/null","sourceNew":"    boolean printZnode(JSONWriter json, String path) throws IOException {\r\n      try {\r\n        Stat stat = new Stat();\r\n        byte[] data = zkClient.getData(path, null, stat, true);\r\n\r\n        json.writeString(\"znode\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n\r\n        writeKeyValue(json, \"path\", path, true);\r\n\r\n        json.writeValueSeparator();\r\n        json.writeString(\"prop\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\r\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\r\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\r\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\r\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\r\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\r\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\r\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\r\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\r\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\r\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\r\n        json.endObject();\r\n\r\n        if (stat.getDataLength() != 0) {\r\n          String str;\r\n          try {\r\n            str = new String(data, \"UTF-8\");\r\n          } catch (UnsupportedEncodingException e) {\r\n            // The results are unspecified\r\n            // when the bytes are not properly encoded.\r\n\r\n            // not UTF8\r\n            StringBuilder sb = new StringBuilder(data.length * 2);\r\n            for (int i = 0; i < data.length; i++) {\r\n              byte b = data[i];\r\n              sb.append(StrUtils.HEX_DIGITS[(b >> 4) & 0xf]);\r\n              sb.append(StrUtils.HEX_DIGITS[b & 0xf]);\r\n              if ((i & 0x3f) == 0x3f) {\r\n                sb.append(\"\\n\");\r\n              }\r\n            }\r\n            str = sb.toString();\r\n          }\r\n          str = str.replaceAll(\"\\\\\\\"\", \"\\\\\\\\\\\"\");\r\n          writeKeyValue(json, \"data\", str, false);\r\n        }\r\n        json.endObject();\r\n      } catch (KeeperException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      } catch (InterruptedException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"/dev/null","sourceNew":"    boolean printZnode(JSONWriter json, String path) throws IOException {\r\n      try {\r\n        Stat stat = new Stat();\r\n        byte[] data = zkClient.getData(path, null, stat, true);\r\n\r\n        json.writeString(\"znode\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n\r\n        writeKeyValue(json, \"path\", path, true);\r\n\r\n        json.writeValueSeparator();\r\n        json.writeString(\"prop\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\r\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\r\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\r\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\r\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\r\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\r\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\r\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\r\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\r\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\r\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\r\n        json.endObject();\r\n\r\n        if (stat.getDataLength() != 0) {\r\n          String str;\r\n          try {\r\n            str = new String(data, \"UTF-8\");\r\n          } catch (UnsupportedEncodingException e) {\r\n            // The results are unspecified\r\n            // when the bytes are not properly encoded.\r\n\r\n            // not UTF8\r\n            StringBuilder sb = new StringBuilder(data.length * 2);\r\n            for (int i = 0; i < data.length; i++) {\r\n              byte b = data[i];\r\n              sb.append(StrUtils.HEX_DIGITS[(b >> 4) & 0xf]);\r\n              sb.append(StrUtils.HEX_DIGITS[b & 0xf]);\r\n              if ((i & 0x3f) == 0x3f) {\r\n                sb.append(\"\\n\");\r\n              }\r\n            }\r\n            str = sb.toString();\r\n          }\r\n          str = str.replaceAll(\"\\\\\\\"\", \"\\\\\\\\\\\"\");\r\n          writeKeyValue(json, \"data\", str, false);\r\n        }\r\n        json.endObject();\r\n      } catch (KeeperException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      } catch (InterruptedException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dccd36091d3547bf3a42b32aa932bb6082269048","date":1331137820,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    boolean printZnode(JSONWriter json, String path) throws IOException {\r\n      try {\r\n        Stat stat = new Stat();\r\n        // Trickily, the call to zkClient.getData fills in the stat variable\r\n        byte[] data = zkClient.getData(path, null, stat, true);\r\n\r\n        json.writeString(\"znode\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n\r\n        writeKeyValue(json, \"path\", path, true);\r\n\r\n        json.writeValueSeparator();\r\n        json.writeString(\"prop\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\r\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\r\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\r\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\r\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\r\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\r\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\r\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\r\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\r\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\r\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\r\n        json.endObject();\r\n\r\n        if (data != null) {\r\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\r\n        }\r\n        json.endObject();\r\n      } catch (KeeperException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      } catch (InterruptedException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) throws IOException {\r\n      try {\r\n        Stat stat = new Stat();\r\n        byte[] data = zkClient.getData(path, null, stat, true);\r\n\r\n        json.writeString(\"znode\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n\r\n        writeKeyValue(json, \"path\", path, true);\r\n\r\n        json.writeValueSeparator();\r\n        json.writeString(\"prop\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\r\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\r\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\r\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\r\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\r\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\r\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\r\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\r\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\r\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\r\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\r\n        json.endObject();\r\n\r\n        if (stat.getDataLength() != 0) {\r\n          String str;\r\n          try {\r\n            str = new String(data, \"UTF-8\");\r\n          } catch (UnsupportedEncodingException e) {\r\n            // The results are unspecified\r\n            // when the bytes are not properly encoded.\r\n\r\n            // not UTF8\r\n            StringBuilder sb = new StringBuilder(data.length * 2);\r\n            for (int i = 0; i < data.length; i++) {\r\n              byte b = data[i];\r\n              sb.append(StrUtils.HEX_DIGITS[(b >> 4) & 0xf]);\r\n              sb.append(StrUtils.HEX_DIGITS[b & 0xf]);\r\n              if ((i & 0x3f) == 0x3f) {\r\n                sb.append(\"\\n\");\r\n              }\r\n            }\r\n            str = sb.toString();\r\n          }\r\n          str = str.replaceAll(\"\\\\\\\"\", \"\\\\\\\\\\\"\");\r\n          writeKeyValue(json, \"data\", str, false);\r\n        }\r\n        json.endObject();\r\n      } catch (KeeperException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      } catch (InterruptedException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    boolean printZnode(JSONWriter json, String path) throws IOException {\r\n      try {\r\n        Stat stat = new Stat();\r\n        // Trickily, the call to zkClient.getData fills in the stat variable\r\n        byte[] data = zkClient.getData(path, null, stat, true);\r\n\r\n        json.writeString(\"znode\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n\r\n        writeKeyValue(json, \"path\", path, true);\r\n\r\n        json.writeValueSeparator();\r\n        json.writeString(\"prop\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\r\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\r\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\r\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\r\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\r\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\r\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\r\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\r\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\r\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\r\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\r\n        json.endObject();\r\n\r\n        if (data != null) {\r\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\r\n        }\r\n        json.endObject();\r\n      } catch (KeeperException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      } catch (InterruptedException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) throws IOException {\r\n      try {\r\n        Stat stat = new Stat();\r\n        byte[] data = zkClient.getData(path, null, stat, true);\r\n\r\n        json.writeString(\"znode\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n\r\n        writeKeyValue(json, \"path\", path, true);\r\n\r\n        json.writeValueSeparator();\r\n        json.writeString(\"prop\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\r\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\r\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\r\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\r\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\r\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\r\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\r\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\r\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\r\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\r\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\r\n        json.endObject();\r\n\r\n        if (stat.getDataLength() != 0) {\r\n          String str;\r\n          try {\r\n            str = new String(data, \"UTF-8\");\r\n          } catch (UnsupportedEncodingException e) {\r\n            // The results are unspecified\r\n            // when the bytes are not properly encoded.\r\n\r\n            // not UTF8\r\n            StringBuilder sb = new StringBuilder(data.length * 2);\r\n            for (int i = 0; i < data.length; i++) {\r\n              byte b = data[i];\r\n              sb.append(StrUtils.HEX_DIGITS[(b >> 4) & 0xf]);\r\n              sb.append(StrUtils.HEX_DIGITS[b & 0xf]);\r\n              if ((i & 0x3f) == 0x3f) {\r\n                sb.append(\"\\n\");\r\n              }\r\n            }\r\n            str = sb.toString();\r\n          }\r\n          str = str.replaceAll(\"\\\\\\\"\", \"\\\\\\\\\\\"\");\r\n          writeKeyValue(json, \"data\", str, false);\r\n        }\r\n        json.endObject();\r\n      } catch (KeeperException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      } catch (InterruptedException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23","date":1332766738,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) throws IOException {\r\n      try {\r\n        Stat stat = new Stat();\r\n        // Trickily, the call to zkClient.getData fills in the stat variable\r\n        byte[] data = zkClient.getData(path, null, stat, true);\r\n\r\n        json.writeString(\"znode\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n\r\n        writeKeyValue(json, \"path\", path, true);\r\n\r\n        json.writeValueSeparator();\r\n        json.writeString(\"prop\");\r\n        json.writeNameSeparator();\r\n        json.startObject();\r\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\r\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\r\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\r\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\r\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\r\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\r\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\r\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\r\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\r\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\r\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\r\n        json.endObject();\r\n\r\n        if (data != null) {\r\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\r\n        }\r\n        json.endObject();\r\n      } catch (KeeperException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      } catch (InterruptedException e) {\r\n        writeError(500, e.toString());\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","49603a0e95f2e91a45eaedf0db2d6b734b41611d","49603a0e95f2e91a45eaedf0db2d6b734b41611d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    boolean printZnode(JSONWriter json, String path) {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":["5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    boolean printZnode(JSONWriter json, String path) {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7d0565444d6381434fbff66cecf07da249f2bb4","date":1357484111,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49603a0e95f2e91a45eaedf0db2d6b734b41611d","date":1378229389,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        json.endObject();\n\n        if (data != null) {\n          writeKeyValue(json, \"data\", new BytesRef(data).utf8ToString(), false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":["5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path, boolean all) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        // pull in external collections too\n        if (\"/clusterstate.json\".equals(path) && all) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(\"/collections\", null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = String.format(\"/collections/%s/state\", collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<String,Object>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String,boolean).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path, boolean all) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        // pull in external collections too\n        if (\"/clusterstate.json\".equals(path) && all) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(\"/collections\", null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state\", collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<String,Object>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // pull in external collections too\n        if (ZkStateReader.CLUSTER_STATE.equals(path) && !isTreeView) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(ZkStateReader.COLLECTIONS_ZKNODE, null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = ZkStateReader.getCollectionPath(collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (KeeperException.NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // pull in external collections too\n        if (ZkStateReader.CLUSTER_STATE.equals(path) && !isTreeView) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(ZkStateReader.COLLECTIONS_ZKNODE, null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = ZkStateReader.getCollectionPath(collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (KeeperException.NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // pull in external collections too\n        if (ZkStateReader.CLUSTER_STATE.equals(path) && !isTreeView) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(ZkStateReader.COLLECTIONS_ZKNODE, null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = ZkStateReader.getCollectionPath(collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (KeeperException.NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d69bac0909e90a1213b0850137b00ac371f866e1","date":1419979130,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {     \n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);          \n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String,Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = ZkNodeProps.makeMap();\n          }\n          \n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter = \n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;           \n          Set<String> liveNodes = applyStatusFilter ? \n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n          \n          SortedMap<String,Object> collectionStates = new TreeMap<String,Object>(pagingSupport);          \n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {              \n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);                \n              }              \n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {              \n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \"+collection+\n                    \" not found in /clusterstate.json or /collections/\"+collection+\"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n              }\n              \n              if (childDataStr != null) {\n                Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n                \n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);                \n                }              \n              }              \n            }            \n          }\n          \n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n            \n            // rebuild the Map of state data\n            SortedMap<String,Object> map = new TreeMap<String,Object>(pagingSupport);                      \n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }          \n          \n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n\n        String dataStr = null;\n        String dataStrErr = null;\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // pull in external collections too\n        if (ZkStateReader.CLUSTER_STATE.equals(path) && !isTreeView) {\n          SortedMap<String,Object> collectionStates = null;\n          List<String> children = zkClient.getChildren(ZkStateReader.COLLECTIONS_ZKNODE, null, true);\n          java.util.Collections.sort(children);\n          for (String collection : children) {\n            String collStatePath = ZkStateReader.getCollectionPath(collection);\n            String childDataStr = null;\n            try {\n              byte[] childData = zkClient.getData(collStatePath, null, null, true);\n              if (childData != null) {\n                childDataStr = (new BytesRef(childData)).utf8ToString();\n              }\n            } catch (KeeperException.NoNodeException nne) {\n              // safe to ignore\n            } catch (Exception childErr) {\n              log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n            }\n\n            if (childDataStr != null) {\n              if (collectionStates == null) {\n                // initialize lazily as there may not be any external collections\n                collectionStates = new TreeMap<>();\n\n                // add the internal collections\n                if (dataStr != null)\n                  collectionStates.putAll((Map<String,Object>)ObjectBuilder.fromJSON(dataStr));\n              }\n\n              // now add in the external collections\n              Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n              collectionStates.put(collection, extColl.get(collection));\n            }\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {     \n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);          \n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String,Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = ZkNodeProps.makeMap();\n          }\n          \n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter = \n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;           \n          Set<String> liveNodes = applyStatusFilter ? \n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n          \n          SortedMap<String,Object> collectionStates = new TreeMap<String,Object>(pagingSupport);          \n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {              \n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);                \n              }              \n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {              \n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \"+collection+\n                    \" not found in /clusterstate.json or /collections/\"+collection+\"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n              }\n              \n              if (childDataStr != null) {\n                Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n                \n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);                \n                }              \n              }              \n            }            \n          }\n          \n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n            \n            // rebuild the Map of state data\n            SortedMap<String,Object> map = new TreeMap<String,Object>(pagingSupport);                      \n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }          \n          \n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {     \n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);          \n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String,Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = ZkNodeProps.makeMap();\n          }\n          \n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter = \n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;           \n          Set<String> liveNodes = applyStatusFilter ? \n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n          \n          SortedMap<String,Object> collectionStates = new TreeMap<String,Object>(pagingSupport);          \n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {              \n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);                \n              }              \n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {              \n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \"+collection+\n                    \" not found in /clusterstate.json or /collections/\"+collection+\"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n              }\n              \n              if (childDataStr != null) {\n                Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n                \n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);                \n                }              \n              }              \n            }            \n          }\n          \n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n            \n            // rebuild the Map of state data\n            SortedMap<String,Object> map = new TreeMap<String,Object>(pagingSupport);                      \n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }          \n          \n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {     \n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);          \n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String,Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = ZkNodeProps.makeMap();\n          }\n          \n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter = \n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;           \n          Set<String> liveNodes = applyStatusFilter ? \n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n          \n          SortedMap<String,Object> collectionStates = new TreeMap<String,Object>(pagingSupport);          \n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {              \n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);                \n              }              \n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {              \n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \"+collection+\n                    \" not found in /clusterstate.json or /collections/\"+collection+\"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n              }\n              \n              if (childDataStr != null) {\n                Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n                \n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);                \n                }              \n              }              \n            }            \n          }\n          \n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n            \n            // rebuild the Map of state data\n            SortedMap<String,Object> map = new TreeMap<String,Object>(pagingSupport);                      \n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }          \n          \n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {     \n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);          \n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String,Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = ZkNodeProps.makeMap();\n          }\n          \n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter = \n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;           \n          Set<String> liveNodes = applyStatusFilter ? \n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n          \n          SortedMap<String,Object> collectionStates = new TreeMap<String,Object>(pagingSupport);          \n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {              \n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);                \n              }              \n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {              \n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \"+collection+\n                    \" not found in /clusterstate.json or /collections/\"+collection+\"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n              }\n              \n              if (childDataStr != null) {\n                Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n                \n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);                \n                }              \n              }              \n            }            \n          }\n          \n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n            \n            // rebuild the Map of state data\n            SortedMap<String,Object> map = new TreeMap<String,Object>(pagingSupport);                      \n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }          \n          \n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, \"path\", path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {     \n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);          \n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String,Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n          \n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter = \n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;           \n          Set<String> liveNodes = applyStatusFilter ? \n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n          \n          SortedMap<String,Object> collectionStates = new TreeMap<String,Object>(pagingSupport);          \n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {              \n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);                \n              }              \n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {              \n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \"+collection+\n                    \" not found in /clusterstate.json or /collections/\"+collection+\"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n              }\n              \n              if (childDataStr != null) {\n                Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n                \n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);                \n                }              \n              }              \n            }            \n          }\n          \n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n            \n            // rebuild the Map of state data\n            SortedMap<String,Object> map = new TreeMap<String,Object>(pagingSupport);                      \n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }          \n          \n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {     \n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);          \n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String,Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = ZkNodeProps.makeMap();\n          }\n          \n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter = \n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;           \n          Set<String> liveNodes = applyStatusFilter ? \n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n          \n          SortedMap<String,Object> collectionStates = new TreeMap<String,Object>(pagingSupport);          \n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {              \n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);                \n              }              \n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {              \n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \"+collection+\n                    \" not found in /clusterstate.json or /collections/\"+collection+\"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n              }\n              \n              if (childDataStr != null) {\n                Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n                \n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);                \n                }              \n              }              \n            }            \n          }\n          \n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n            \n            // rebuild the Map of state data\n            SortedMap<String,Object> map = new TreeMap<String,Object>(pagingSupport);                      \n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }          \n          \n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80ebe5b1d946f7c2ed9c46206b0c7254dc21206a","date":1443442239,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String, Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n\n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter =\n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;\n          Set<String> liveNodes = applyStatusFilter ?\n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n\n          SortedMap<String, Object> collectionStates = new TreeMap<String, Object>(pagingSupport);\n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {\n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);\n              }\n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {\n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \" + collection +\n                    \" not found in /clusterstate.json or /collections/\" + collection + \"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \" + collStatePath + \" due to: \" + childErr);\n              }\n\n              if (childDataStr != null) {\n                Map<String, Object> extColl = (Map<String, Object>) ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n\n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);\n                }\n              }\n            }\n          }\n\n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n\n            // rebuild the Map of state data\n            SortedMap<String, Object> map = new TreeMap<String, Object>(pagingSupport);\n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {     \n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);          \n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String,Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n          \n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter = \n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;           \n          Set<String> liveNodes = applyStatusFilter ? \n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n          \n          SortedMap<String,Object> collectionStates = new TreeMap<String,Object>(pagingSupport);          \n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {              \n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);                \n              }              \n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {              \n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \"+collection+\n                    \" not found in /clusterstate.json or /collections/\"+collection+\"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n              }\n              \n              if (childDataStr != null) {\n                Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n                \n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);                \n                }              \n              }              \n            }            \n          }\n          \n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n            \n            // rebuild the Map of state data\n            SortedMap<String,Object> map = new TreeMap<String,Object>(pagingSupport);                      \n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }          \n          \n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","c7d0565444d6381434fbff66cecf07da249f2bb4"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","dccd36091d3547bf3a42b32aa932bb6082269048"],"c7d0565444d6381434fbff66cecf07da249f2bb4":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23":["dccd36091d3547bf3a42b32aa932bb6082269048"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","dd6ddd3da533988676f6ec21e7e4651a2b2e8345"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"dccd36091d3547bf3a42b32aa932bb6082269048":["dd6ddd3da533988676f6ec21e7e4651a2b2e8345"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"80ebe5b1d946f7c2ed9c46206b0c7254dc21206a":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"d69bac0909e90a1213b0850137b00ac371f866e1":["9279b175e5e66258442d2123a50f052219a9cc1b"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["d69bac0909e90a1213b0850137b00ac371f866e1"],"dd6ddd3da533988676f6ec21e7e4651a2b2e8345":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["d69bac0909e90a1213b0850137b00ac371f866e1","1390137e395d2f07f9ba5b8c43d293befe84d563"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["49603a0e95f2e91a45eaedf0db2d6b734b41611d"],"49603a0e95f2e91a45eaedf0db2d6b734b41611d":["c7d0565444d6381434fbff66cecf07da249f2bb4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["80ebe5b1d946f7c2ed9c46206b0c7254dc21206a"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"c7d0565444d6381434fbff66cecf07da249f2bb4":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","49603a0e95f2e91a45eaedf0db2d6b734b41611d"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"dccd36091d3547bf3a42b32aa932bb6082269048":["38e3b736c7ca086d61b7dbb841c905ee115490da","5a002afd8b1e0d1bbf0debb2ff740b5e77ed8b23"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["80ebe5b1d946f7c2ed9c46206b0c7254dc21206a"],"9279b175e5e66258442d2123a50f052219a9cc1b":["d69bac0909e90a1213b0850137b00ac371f866e1"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"80ebe5b1d946f7c2ed9c46206b0c7254dc21206a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d69bac0909e90a1213b0850137b00ac371f866e1":["1390137e395d2f07f9ba5b8c43d293befe84d563","d2638f781be724518ff6c2263d14a48cf6e68017"],"dd6ddd3da533988676f6ec21e7e4651a2b2e8345":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","dccd36091d3547bf3a42b32aa932bb6082269048"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["b693a83132c9e45afcd564fd65a25b60ed80388b","d2638f781be724518ff6c2263d14a48cf6e68017"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","dd6ddd3da533988676f6ec21e7e4651a2b2e8345"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c7d0565444d6381434fbff66cecf07da249f2bb4","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"49603a0e95f2e91a45eaedf0db2d6b734b41611d":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","38e3b736c7ca086d61b7dbb841c905ee115490da","fe33227f6805edab2036cbb80645cc4e2d1fa424","d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}