{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(OverseerCollectionMessageHandler.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getZkController().getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(OverseerCollectionMessageHandler.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de3459a54b4c8751d9ef19b035577e2418064be7","date":1520297996,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(OverseerCollectionMessageHandler.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(OverseerCollectionMessageHandler.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82b686ab2904b3e81184ecea0d238b4ab0885376","date":1529576124,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(OverseerCollectionMessageHandler.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(OverseerCollectionMessageHandler.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(OverseerCollectionMessageHandler.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59bad1cc1e7f90125a140496e79b06afcedb68ec","date":1554915399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c","date":1562161956,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    String collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json\n    //Since we don't want to distinguish we extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":["c5c99ad021f3da085fcb66220598a8f91dc5e453"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58dba38d0c9777f300cca9dd3c150fe2d244742","date":1599661188,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(repo);\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"c526352db87264a72a7a9ad68c1b769b81e54305":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["82b686ab2904b3e81184ecea0d238b4ab0885376"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"82b686ab2904b3e81184ecea0d238b4ab0885376":["de3459a54b4c8751d9ef19b035577e2418064be7"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["de3459a54b4c8751d9ef19b035577e2418064be7","82b686ab2904b3e81184ecea0d238b4ab0885376"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"de3459a54b4c8751d9ef19b035577e2418064be7":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d58dba38d0c9777f300cca9dd3c150fe2d244742":["e7b17e79a71117668ecbf8d3417c876e41396565"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d58dba38d0c9777f300cca9dd3c150fe2d244742"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["de3459a54b4c8751d9ef19b035577e2418064be7","82b686ab2904b3e81184ecea0d238b4ab0885376"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["d58dba38d0c9777f300cca9dd3c150fe2d244742"],"b94236357aaa22b76c10629851fe4e376e0cea82":["de3459a54b4c8751d9ef19b035577e2418064be7"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"82b686ab2904b3e81184ecea0d238b4ab0885376":["59bad1cc1e7f90125a140496e79b06afcedb68ec","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"de3459a54b4c8751d9ef19b035577e2418064be7":["82b686ab2904b3e81184ecea0d238b4ab0885376","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"d58dba38d0c9777f300cca9dd3c150fe2d244742":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}