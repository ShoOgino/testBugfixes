{"path":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","commits":[{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","pathOld":"/dev/null","sourceNew":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(ThreadState state) throws IOException {\n\n    // Now write the indexed document to the real files.\n\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      state.isIdle = true;\n      nextWriteDocID++;\n      state.writeDocument();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        while(true) {\n          int upto = 0;\n          for(int i=0;i<numWaiting;i++) {\n            ThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.isIdle = true;\n              nextWriteDocID++;\n              s.writeDocument();\n            } else\n              // Compact as we go\n              waitingThreadStates[upto++] = waitingThreadStates[i];\n          }\n          if (upto == numWaiting) \n            break;\n          numWaiting = upto;\n        }\n      }\n\n      // Now notify any incoming calls to addDocument\n      // (above) that are waiting on our line to\n      // shrink\n      notifyAll();\n\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      if (numWaiting == waitingThreadStates.length) {\n        ThreadState[] newWaiting = new ThreadState[2*waitingThreadStates.length];\n        System.arraycopy(waitingThreadStates, 0, newWaiting, 0, numWaiting);\n        waitingThreadStates = newWaiting;\n      }\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83bbb041887bbef07b8a98d08a0e1713ce137039","date":1200330381,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","sourceNew":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(ThreadState state) throws IOException, AbortException {\n    if (aborting) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final ThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","sourceOld":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(ThreadState state) throws IOException {\n\n    // Now write the indexed document to the real files.\n\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      state.isIdle = true;\n      nextWriteDocID++;\n      state.writeDocument();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        while(true) {\n          int upto = 0;\n          for(int i=0;i<numWaiting;i++) {\n            ThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.isIdle = true;\n              nextWriteDocID++;\n              s.writeDocument();\n            } else\n              // Compact as we go\n              waitingThreadStates[upto++] = waitingThreadStates[i];\n          }\n          if (upto == numWaiting) \n            break;\n          numWaiting = upto;\n        }\n      }\n\n      // Now notify any incoming calls to addDocument\n      // (above) that are waiting on our line to\n      // shrink\n      notifyAll();\n\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      if (numWaiting == waitingThreadStates.length) {\n        ThreadState[] newWaiting = new ThreadState[2*waitingThreadStates.length];\n        System.arraycopy(waitingThreadStates, 0, newWaiting, 0, numWaiting);\n        waitingThreadStates = newWaiting;\n      }\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","bugFix":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"bugIntro":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d","date":1202734547,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","sourceNew":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(ThreadState state) throws IOException, AbortException {\n    if (abortCount > 0) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final ThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","sourceOld":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(ThreadState state) throws IOException, AbortException {\n    if (aborting) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final ThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","bugFix":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2684bcb2a921b6b5b76f64ba986564ab1ef0649d","date":1202988124,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","sourceNew":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(ThreadState state) throws IOException, AbortException {\n    if (abortCount > 0) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    if (ramBufferSize != IndexWriter.DISABLE_AUTO_FLUSH\n        && numBytesUsed >= ramBufferSize)\n      balanceRAM();\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final ThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","sourceOld":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(ThreadState state) throws IOException, AbortException {\n    if (abortCount > 0) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final ThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a0af3a442be522899177e5e11384a45a6784a3f","date":1205348952,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(DocumentsWriterThreadState).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","sourceNew":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(DocumentsWriterThreadState state) throws IOException, AbortException {\n    if (abortCount > 0) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    if (ramBufferSize != IndexWriter.DISABLE_AUTO_FLUSH\n        && numBytesUsed >= ramBufferSize)\n      balanceRAM();\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final DocumentsWriterThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","sourceOld":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(ThreadState state) throws IOException, AbortException {\n    if (abortCount > 0) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    if (ramBufferSize != IndexWriter.DISABLE_AUTO_FLUSH\n        && numBytesUsed >= ramBufferSize)\n      balanceRAM();\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final ThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"83bbb041887bbef07b8a98d08a0e1713ce137039":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"2684bcb2a921b6b5b76f64ba986564ab1ef0649d":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5a0af3a442be522899177e5e11384a45a6784a3f":["2684bcb2a921b6b5b76f64ba986564ab1ef0649d"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5a0af3a442be522899177e5e11384a45a6784a3f"]},"commit2Childs":{"83bbb041887bbef07b8a98d08a0e1713ce137039":["176324efd1eab6bd44a6d81c27c9b3a1a175ba3d"],"2684bcb2a921b6b5b76f64ba986564ab1ef0649d":["5a0af3a442be522899177e5e11384a45a6784a3f"],"176324efd1eab6bd44a6d81c27c9b3a1a175ba3d":["2684bcb2a921b6b5b76f64ba986564ab1ef0649d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"5a0af3a442be522899177e5e11384a45a6784a3f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}