{"path":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6fff8f4b218bd0626afcdce82027bafeb84a50a4","date":1327229950,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94","date":1327846543,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicIndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicIndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicIndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da6d5ac19a80d65b1e864251f155d30960353b7e","date":1327881054,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicIndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicIndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicIndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["7b91922b55d15444d554721b352861d028eb8278"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["7b91922b55d15444d554721b352861d028eb8278","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94":["6fff8f4b218bd0626afcdce82027bafeb84a50a4"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["0e7c2454a6a8237bfd0e953f5b940838408c9055","da6d5ac19a80d65b1e864251f155d30960353b7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["0e7c2454a6a8237bfd0e953f5b940838408c9055","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","6fff8f4b218bd0626afcdce82027bafeb84a50a4","5cab9a86bd67202d20b6adc463008c8e982b070a"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94"],"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94":["da6d5ac19a80d65b1e864251f155d30960353b7e"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}