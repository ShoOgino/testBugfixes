{"path":"solr/core/src/java/org/apache/solr/handler/admin/IndexSizeEstimator#estimate().mjava","commits":[{"id":"e4583dbd381e291c87e23144564c59ba3391b188","date":1560187306,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/IndexSizeEstimator#estimate().mjava","pathOld":"/dev/null","sourceNew":"  public Estimate estimate() throws Exception {\n    Map<String, Object> details = new LinkedHashMap<>();\n    Map<String, Object> summary = new LinkedHashMap<>();\n    estimateStoredFields(details);\n    estimateTerms(details);\n    estimateNorms(details);\n    estimatePoints(details);\n    estimateTermVectors(details);\n    estimateDocValues(details);\n    estimateSummary(details, summary);\n    if (samplingStep > 1) {\n      details.put(\"samplingPercent\", samplingPercent);\n      details.put(\"samplingStep\", samplingStep);\n    }\n    ItemPriorityQueue fieldSizeQueue = new ItemPriorityQueue(summary.size());\n    summary.forEach((field, perField) -> {\n      long size = ((AtomicLong)((Map<String, Object>)perField).get(\"totalSize\")).get();\n      if (size > 0) {\n        fieldSizeQueue.insertWithOverflow(new Item(field, size));\n      }\n    });\n    Map<String, Long> fieldsBySize = new LinkedHashMap<>();\n    fieldSizeQueue._forEachEntry((k, v) -> fieldsBySize.put((String)k, (Long)v));\n    Map<String, AtomicLong> typeSizes = new HashMap<>();\n    summary.forEach((field, perField) -> {\n      Map<String, Object> perType = (Map<String, Object>)((Map<String, Object>)perField).get(\"perType\");\n      perType.forEach((type, size) -> {\n        if (type.contains(\"_lengths\")) {\n          AtomicLong totalSize = typeSizes.computeIfAbsent(type.replace(\"_lengths\", \"\"), t -> new AtomicLong());\n          totalSize.addAndGet(((AtomicLong)size).get());\n        }\n      });\n    });\n    ItemPriorityQueue typesSizeQueue = new ItemPriorityQueue(typeSizes.size());\n    typeSizes.forEach((type, size) -> {\n      if (size.get() > 0) {\n        typesSizeQueue.insertWithOverflow(new Item(type, size.get()));\n      }\n    });\n    Map<String, Long> typesBySize = new LinkedHashMap<>();\n    typesSizeQueue._forEachEntry((k, v) -> typesBySize.put((String)k, (Long)v));\n    // sort summary by field size\n    Map<String, Object> newSummary = new LinkedHashMap<>();\n    fieldsBySize.keySet().forEach(k -> newSummary.put(String.valueOf(k), summary.get(k)));\n    // convert everything to maps and primitives\n    convert(newSummary);\n    convert(details);\n    return new Estimate(fieldsBySize, typesBySize, withSummary ? newSummary : null, withDetails ? details : null);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba055e19afc289adcb5bedaf68513793a7254012","date":1591268575,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/IndexSizeEstimator#estimate().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/IndexSizeEstimator#estimate().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public Estimate estimate() throws Exception {\n    Map<String, Object> details = new LinkedHashMap<>();\n    Map<String, Object> summary = new LinkedHashMap<>();\n    estimateStoredFields(details);\n    estimateTerms(details);\n    estimateNorms(details);\n    estimatePoints(details);\n    estimateTermVectors(details);\n    estimateDocValues(details);\n    estimateSummary(details, summary);\n    if (samplingStep > 1) {\n      details.put(\"samplingPercent\", samplingPercent);\n      details.put(\"samplingStep\", samplingStep);\n    }\n    ItemPriorityQueue fieldSizeQueue = new ItemPriorityQueue(summary.size());\n    summary.forEach((field, perField) -> {\n      long size = ((AtomicLong)((Map<String, Object>)perField).get(\"totalSize\")).get();\n      if (size > 0) {\n        fieldSizeQueue.insertWithOverflow(new Item(field, size));\n      }\n    });\n    Map<String, Long> fieldsBySize = new LinkedHashMap<>();\n    fieldSizeQueue._forEachEntry((k, v) -> fieldsBySize.put((String)k, (Long)v));\n    Map<String, AtomicLong> typeSizes = new HashMap<>();\n    summary.forEach((field, perField) -> {\n      Map<String, Object> perType = (Map<String, Object>)((Map<String, Object>)perField).get(\"perType\");\n      perType.forEach((type, size) -> {\n        if (type.contains(\"_lengths\")) {\n          AtomicLong totalSize = typeSizes.computeIfAbsent(type.replace(\"_lengths\", \"\"), t -> new AtomicLong());\n          totalSize.addAndGet(((AtomicLong)size).get());\n        }\n      });\n    });\n    ItemPriorityQueue typesSizeQueue = new ItemPriorityQueue(typeSizes.size());\n    typeSizes.forEach((type, size) -> {\n      if (size.get() > 0) {\n        typesSizeQueue.insertWithOverflow(new Item(type, size.get()));\n      }\n    });\n    Map<String, Long> typesBySize = new LinkedHashMap<>();\n    typesSizeQueue._forEachEntry((k, v) -> typesBySize.put((String)k, (Long)v));\n    // sort summary by field size\n    Map<String, Object> newSummary = new LinkedHashMap<>();\n    fieldsBySize.keySet().forEach(k -> newSummary.put(String.valueOf(k), summary.get(k)));\n    // convert everything to maps and primitives\n    convert(newSummary);\n    convert(details);\n    return new Estimate(fieldsBySize, typesBySize, withSummary ? newSummary : null, withDetails ? details : null);\n  }\n\n","sourceOld":"  public Estimate estimate() throws Exception {\n    Map<String, Object> details = new LinkedHashMap<>();\n    Map<String, Object> summary = new LinkedHashMap<>();\n    estimateStoredFields(details);\n    estimateTerms(details);\n    estimateNorms(details);\n    estimatePoints(details);\n    estimateTermVectors(details);\n    estimateDocValues(details);\n    estimateSummary(details, summary);\n    if (samplingStep > 1) {\n      details.put(\"samplingPercent\", samplingPercent);\n      details.put(\"samplingStep\", samplingStep);\n    }\n    ItemPriorityQueue fieldSizeQueue = new ItemPriorityQueue(summary.size());\n    summary.forEach((field, perField) -> {\n      long size = ((AtomicLong)((Map<String, Object>)perField).get(\"totalSize\")).get();\n      if (size > 0) {\n        fieldSizeQueue.insertWithOverflow(new Item(field, size));\n      }\n    });\n    Map<String, Long> fieldsBySize = new LinkedHashMap<>();\n    fieldSizeQueue._forEachEntry((k, v) -> fieldsBySize.put((String)k, (Long)v));\n    Map<String, AtomicLong> typeSizes = new HashMap<>();\n    summary.forEach((field, perField) -> {\n      Map<String, Object> perType = (Map<String, Object>)((Map<String, Object>)perField).get(\"perType\");\n      perType.forEach((type, size) -> {\n        if (type.contains(\"_lengths\")) {\n          AtomicLong totalSize = typeSizes.computeIfAbsent(type.replace(\"_lengths\", \"\"), t -> new AtomicLong());\n          totalSize.addAndGet(((AtomicLong)size).get());\n        }\n      });\n    });\n    ItemPriorityQueue typesSizeQueue = new ItemPriorityQueue(typeSizes.size());\n    typeSizes.forEach((type, size) -> {\n      if (size.get() > 0) {\n        typesSizeQueue.insertWithOverflow(new Item(type, size.get()));\n      }\n    });\n    Map<String, Long> typesBySize = new LinkedHashMap<>();\n    typesSizeQueue._forEachEntry((k, v) -> typesBySize.put((String)k, (Long)v));\n    // sort summary by field size\n    Map<String, Object> newSummary = new LinkedHashMap<>();\n    fieldsBySize.keySet().forEach(k -> newSummary.put(String.valueOf(k), summary.get(k)));\n    // convert everything to maps and primitives\n    convert(newSummary);\n    convert(details);\n    return new Estimate(fieldsBySize, typesBySize, withSummary ? newSummary : null, withDetails ? details : null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba055e19afc289adcb5bedaf68513793a7254012":["e4583dbd381e291c87e23144564c59ba3391b188"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e4583dbd381e291c87e23144564c59ba3391b188":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba055e19afc289adcb5bedaf68513793a7254012"]},"commit2Childs":{"ba055e19afc289adcb5bedaf68513793a7254012":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e4583dbd381e291c87e23144564c59ba3391b188"],"e4583dbd381e291c87e23144564c59ba3391b188":["ba055e19afc289adcb5bedaf68513793a7254012"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}