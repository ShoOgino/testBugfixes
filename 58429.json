{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfo info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null && rld.writeLiveDocs(directory)) {\n          assert infoIsLive(info);\n          // Must checkpoint w/ deleter, because we just\n          // created created new _X_N.del file.\n          deleter.checkpoint(segmentInfos, false);\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfo info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null && rld.writeLiveDocs(directory)) {\n          assert infoIsLive(info);\n          // Must checkpoint w/ deleter, because we just\n          // created created new _X_N.del file.\n          deleter.checkpoint(segmentInfos, false);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfo info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfo info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null && rld.writeLiveDocs(directory)) {\n          assert infoIsLive(info);\n          // Must checkpoint w/ deleter, because we just\n          // created created new _X_N.del file.\n          deleter.checkpoint(segmentInfos, false);\n        }\n      }\n    }\n\n","bugFix":["1085ea837da8f1e96697e17cf73e1d08e7329261","9ce667c6d3400b22523701c549c0d35e26da8b46","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfo info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfo info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null && rld.writeLiveDocs(directory)) {\n          assert infoIsLive(info);\n          // Must checkpoint w/ deleter, because we just\n          // created created new _X_N.del file.\n          deleter.checkpoint(segmentInfos, false);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfo info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfo info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e072d0b1fc19e0533d8ce432eed245196bca6fde","date":1379265112,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs and updates for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint w/ deleter, because we just\n            // created new _X_N.del and field updates files.\n            deleter.checkpoint(segmentInfos, false);\n            \n            // we wrote liveDocs and field updates, reopen the reader\n            rld.reopenReader(IOContext.READ);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n            // Must checkpoint w/ deleter, because we just\n            // created created new _X_N.del file.\n            deleter.checkpoint(segmentInfos, false);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8435160e9702b19398118ddf76b61c846612b6a4","date":1380349140,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean hasFieldUpdates = rld.hasFieldUpdates(); // only reopen reader if there were field udpates\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs and updates for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint w/ deleter, because we just\n            // created new _X_N.del and field updates files.\n            deleter.checkpoint(segmentInfos, false);\n            \n            // we wrote field updates, reopen the reader\n            if (hasFieldUpdates) {\n              rld.reopenReader(IOContext.READ);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs and updates for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint w/ deleter, because we just\n            // created new _X_N.del and field updates files.\n            deleter.checkpoint(segmentInfos, false);\n            \n            // we wrote liveDocs and field updates, reopen the reader\n            rld.reopenReader(IOContext.READ);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666","date":1381263930,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean hasFieldUpdates = rld.hasFieldUpdates(); // only reopen reader if there were field udpates\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs and updates for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            deleter.checkpoint(segmentInfos, false);\n            checkpointNoSIS();\n\n            // we wrote field updates, reopen the reader\n            if (hasFieldUpdates) {\n              rld.reopenReader(IOContext.READ);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean hasFieldUpdates = rld.hasFieldUpdates(); // only reopen reader if there were field udpates\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs and updates for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint w/ deleter, because we just\n            // created new _X_N.del and field updates files.\n            deleter.checkpoint(segmentInfos, false);\n            \n            // we wrote field updates, reopen the reader\n            if (hasFieldUpdates) {\n              rld.reopenReader(IOContext.READ);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"459db714567feae6ad85fa89d8d9dce4d36d7803","date":1381342285,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean hasFieldUpdates = rld.hasFieldUpdates(); // only reopen reader if there were field udpates\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs and updates for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n\n            // we wrote field updates, reopen the reader\n            if (hasFieldUpdates) {\n              rld.reopenReader(IOContext.READ);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean hasFieldUpdates = rld.hasFieldUpdates(); // only reopen reader if there were field udpates\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs and updates for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            deleter.checkpoint(segmentInfos, false);\n            checkpointNoSIS();\n\n            // we wrote field updates, reopen the reader\n            if (hasFieldUpdates) {\n              rld.reopenReader(IOContext.READ);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe","date":1381909398,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean hasFieldUpdates = rld.hasFieldUpdates(); // only reopen reader if there were field udpates\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs and updates for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n\n            // we wrote field updates, reopen the reader\n            if (hasFieldUpdates) {\n              rld.reopenReader(IOContext.READ);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentInfoPerCommit info : infos) {\n        final ReadersAndLiveDocs rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean changed = rld.writeLiveDocs(directory);\n          \n          changed |= rld.writeFieldUpdates(directory, bufferedUpdatesStream.getCompletedDelGen(), infoStream);\n\n          if (changed) {\n            // Make sure we only write del docs for a live segment:\n            assert assertInfoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean changed = rld.writeLiveDocs(directory);\n          \n          changed |= rld.writeFieldUpdates(directory, bufferedUpdatesStream.getCompletedDelGen(), infoStream);\n\n          if (changed) {\n            // Make sure we only write del docs for a live segment:\n            assert assertInfoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean changed = rld.writeLiveDocs(directory);\n          \n          changed |= rld.writeFieldUpdates(directory, bufferedUpdatesStream.getCompletedDelGen(), infoStream);\n\n          if (changed) {\n            // Make sure we only write del docs for a live segment:\n            assert assertInfoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          if (rld.writeLiveDocs(directory)) {\n            // Make sure we only write del docs for a live segment:\n            assert infoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d60c1bb96a28a26d197c36299f7b6c9c5da617a1","date":1522484702,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean changed = rld.writeLiveDocs(directory);\n          changed |= rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream);\n\n          if (changed) {\n            // Make sure we only write del docs for a live segment:\n            assert assertInfoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean changed = rld.writeLiveDocs(directory);\n          \n          changed |= rld.writeFieldUpdates(directory, bufferedUpdatesStream.getCompletedDelGen(), infoStream);\n\n          if (changed) {\n            // Make sure we only write del docs for a live segment:\n            assert assertInfoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa5e39259dfd4a68287c824d3b7e1bc9097dc895","date":1522505041,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean changed = rld.writeLiveDocs(directory);\n          changed |= rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream);\n\n          if (changed) {\n            // Make sure we only write del docs for a live segment:\n            assert assertInfoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean changed = rld.writeLiveDocs(directory);\n          \n          changed |= rld.writeFieldUpdates(directory, bufferedUpdatesStream.getCompletedDelGen(), infoStream);\n\n          if (changed) {\n            // Make sure we only write del docs for a live segment:\n            assert assertInfoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":4,"author":"Simon Willnauer","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#commit(SegmentInfos).mjava","sourceNew":null,"sourceOld":"    /**\n     * Commit live docs changes for the segment readers for\n     * the provided infos.\n     *\n     * @throws IOException If there is a low-level I/O error\n     */\n    public synchronized void commit(SegmentInfos infos) throws IOException {\n      for (SegmentCommitInfo info : infos) {\n        final ReadersAndUpdates rld = readerMap.get(info);\n        if (rld != null) {\n          assert rld.info == info;\n          boolean changed = rld.writeLiveDocs(directory);\n          changed |= rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream);\n\n          if (changed) {\n            // Make sure we only write del docs for a live segment:\n            assert assertInfoIsLive(info);\n\n            // Must checkpoint because we just\n            // created new _X_N.del and field updates files;\n            // don't call IW.checkpoint because that also\n            // increments SIS.version, which we do not want to\n            // do here: it was done previously (after we\n            // invoked BDS.applyDeletes), whereas here all we\n            // did was move the state to disk:\n            checkpointNoSIS();\n          }\n\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["8435160e9702b19398118ddf76b61c846612b6a4"],"e072d0b1fc19e0533d8ce432eed245196bca6fde":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"8435160e9702b19398118ddf76b61c846612b6a4":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["28288370235ed02234a64753cdbf0c6ec096304a","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"459db714567feae6ad85fa89d8d9dce4d36d7803":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","9d153abcf92dc5329d98571a8c3035df9bd80648"],"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe":["459db714567feae6ad85fa89d8d9dce4d36d7803"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1926100d9b67becc9701c54266fee3ba7878a5f0"]},"commit2Childs":{"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["459db714567feae6ad85fa89d8d9dce4d36d7803"],"e072d0b1fc19e0533d8ce432eed245196bca6fde":["8435160e9702b19398118ddf76b61c846612b6a4"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"8435160e9702b19398118ddf76b61c846612b6a4":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["38e3b736c7ca086d61b7dbb841c905ee115490da","9d153abcf92dc5329d98571a8c3035df9bd80648","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"459db714567feae6ad85fa89d8d9dce4d36d7803":["1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"1bae040fd1d5e03e0d8d695a9c25cf4f402e7ffe":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}