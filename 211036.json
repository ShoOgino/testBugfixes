{"path":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#initUnmapHack().mjava","commits":[{"id":"cb6c879a87683d96d7dee96cdded91f47f462412","date":1455562659,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#initUnmapHack().mjava","pathOld":"/dev/null","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object initUnmapHack() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      final MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      final Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        cleanMethod = explicitCastArguments(lookup.findVirtual(Runnable.class, \"run\", methodType(void.class)),\n            methodType(void.class, cleanerClass));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = explicitCastArguments(lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class)),\n          methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(explicitCastArguments(constant(Void.class, null), methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = explicitCastArguments(filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop)),\n          methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file. \" +\n          \"Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")\";\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c50c96b16492ed517eb3e89c3ec9d50a419535d","date":1455926745,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#initUnmapHack().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#initUnmapHack().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object initUnmapHack() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file. \" +\n          \"Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")\";\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object initUnmapHack() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      final MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      final Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        cleanMethod = explicitCastArguments(lookup.findVirtual(Runnable.class, \"run\", methodType(void.class)),\n            methodType(void.class, cleanerClass));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = explicitCastArguments(lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class)),\n          methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(explicitCastArguments(constant(Void.class, null), methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = explicitCastArguments(filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop)),\n          methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file. \" +\n          \"Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e","date":1456736503,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#initUnmapHack().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object initUnmapHack() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file. \" +\n          \"Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#unmapHackImpl().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/MMapDirectory#initUnmapHack().mjava","sourceNew":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object unmapHackImpl() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file: \" + e +\n          \" [Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")]\";\n    }\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Needs access to private APIs in DirectBuffer and sun.misc.Cleaner to enable hack\")\n  private static Object initUnmapHack() {\n    final Lookup lookup = lookup();\n    try {\n      final Class<?> directBufferClass = Class.forName(\"java.nio.DirectByteBuffer\");\n      \n      final Method m = directBufferClass.getMethod(\"cleaner\");\n      m.setAccessible(true);\n      MethodHandle directBufferCleanerMethod = lookup.unreflect(m);\n      Class<?> cleanerClass = directBufferCleanerMethod.type().returnType();\n      \n      final MethodHandle cleanMethod;\n      if (Runnable.class.isAssignableFrom(cleanerClass)) {\n        // early Java 9 impl using Runnable (we do the security check early that the Runnable does at runtime):\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n          sm.checkPackageAccess(\"jdk.internal.ref\");\n        }\n        // cast return value of cleaner() to Runnable:\n        directBufferCleanerMethod = directBufferCleanerMethod.asType(directBufferCleanerMethod.type().changeReturnType(Runnable.class));\n        cleanerClass = Runnable.class;\n        // lookup run() method on the interface instead of Cleaner:\n        cleanMethod = lookup.findVirtual(cleanerClass, \"run\", methodType(void.class));\n      } else {\n        // can be either the old internal \"sun.misc.Cleaner\" or\n        // the new Java 9 \"java.lang.ref.Cleaner$Cleanable\":\n        cleanMethod = lookup.findVirtual(cleanerClass, \"clean\", methodType(void.class));\n      }\n      \n      final MethodHandle nonNullTest = lookup.findStatic(Objects.class, \"nonNull\", methodType(boolean.class, Object.class))\n          .asType(methodType(boolean.class, cleanerClass));\n      final MethodHandle noop = dropArguments(constant(Void.class, null).asType(methodType(void.class)), 0, cleanerClass);\n      final MethodHandle unmapper = filterReturnValue(directBufferCleanerMethod, guardWithTest(nonNullTest, cleanMethod, noop))\n          .asType(methodType(void.class, ByteBuffer.class));\n      \n      return (BufferCleaner) (ByteBufferIndexInput parent, ByteBuffer buffer) -> {\n        if (directBufferClass.isInstance(buffer)) {\n          final Throwable error = AccessController.doPrivileged((PrivilegedAction<Throwable>) () -> {\n            try {\n              unmapper.invokeExact(buffer);\n              return null;\n            } catch (Throwable t) {\n              return t;\n            }\n          });\n          if (error != null) {\n            throw new IOException(\"Unable to unmap the mapped buffer: \" + parent.toString(), error);\n          }\n        }\n      };\n    } catch (ReflectiveOperationException e) {\n      return \"Unmapping is not supported on this platform, because internal Java APIs are not compatible to this Lucene version: \" + e; \n    } catch (SecurityException e) {\n      return \"Unmapping is not supported, because not all required permissions are given to the Lucene JAR file. \" +\n          \"Please grant at least the following permissions: RuntimePermission(\\\"accessClassInPackage.sun.misc\\\"), \" +\n          \"RuntimePermission(\\\"accessClassInPackage.jdk.internal.ref\\\"), and \" +\n          \"ReflectPermission(\\\"suppressAccessChecks\\\")\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["6c50c96b16492ed517eb3e89c3ec9d50a419535d","dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e"],"dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e":["6c50c96b16492ed517eb3e89c3ec9d50a419535d"],"cb6c879a87683d96d7dee96cdded91f47f462412":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c50c96b16492ed517eb3e89c3ec9d50a419535d":["cb6c879a87683d96d7dee96cdded91f47f462412"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e":["af2638813028b254a88b418ebeafb541afb49653"],"cb6c879a87683d96d7dee96cdded91f47f462412":["6c50c96b16492ed517eb3e89c3ec9d50a419535d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cb6c879a87683d96d7dee96cdded91f47f462412"],"6c50c96b16492ed517eb3e89c3ec9d50a419535d":["af2638813028b254a88b418ebeafb541afb49653","dccb70cf2f8990dec6f0e64e1f34fa89ae9ecd4e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}