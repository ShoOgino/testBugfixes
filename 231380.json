{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","commits":[{"id":"c7ca1cace44c816965501b934686a2354382f000","date":1487792658,"type":0,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","pathOld":"/dev/null","sourceNew":"  private void waitForEmptyQueue() {\n\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","sourceNew":"  private void waitForEmptyQueue() {\n    boolean threadInterrupted = Thread.currentThread().isInterrupted();\n\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n      if (scheduler.isTerminated()) {\n        log.warn(\"The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. \"\n            + \"Queue size: {}, Runners: {}. Current thread Interrupted? {}\", scheduler, queue.size(), runners.size(), threadInterrupted);\n        break;\n      }\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          // If we set the thread as interrupted again, the next time the wait it's called i t's going to return immediately\n          threadInterrupted = true;\n          log.warn(\"Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.\", \n              queue.size());\n        }\n      }\n    }\n    if (threadInterrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void waitForEmptyQueue() {\n\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","sourceNew":"  private void waitForEmptyQueue() {\n    boolean threadInterrupted = Thread.currentThread().isInterrupted();\n\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n      if (scheduler.isTerminated()) {\n        log.warn(\"The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. \"\n            + \"Queue size: {}, Runners: {}. Current thread Interrupted? {}\", scheduler, queue.size(), runners.size(), threadInterrupted);\n        break;\n      }\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          // If we set the thread as interrupted again, the next time the wait it's called i t's going to return immediately\n          threadInterrupted = true;\n          log.warn(\"Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.\", \n              queue.size());\n        }\n      }\n    }\n    if (threadInterrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void waitForEmptyQueue() {\n\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"482ca6c86d7073e3c19096bdc74fe0e73da4554a","date":1576010743,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","sourceNew":"  private void waitForEmptyQueue() throws IOException {\n    boolean threadInterrupted = Thread.currentThread().isInterrupted();\n\n    long lastStallTime = -1;\n    int lastQueueSize = -1;\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n      if (scheduler.isTerminated()) {\n        log.warn(\"The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. \"\n            + \"Queue size: {}, Runners: {}. Current thread Interrupted? {}\", scheduler, queue.size(), runners.size(), threadInterrupted);\n        break;\n      }\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          // If we set the thread as interrupted again, the next time the wait it's called it's going to return immediately\n          threadInterrupted = true;\n          log.warn(\"Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.\", \n              queue.size());\n        }\n      }\n      int currentQueueSize = queue.size();\n      // stall prevention\n      if (currentQueueSize != lastQueueSize) {\n        lastQueueSize = currentQueueSize;\n        lastStallTime = -1;\n      } else {\n        lastQueueSize = currentQueueSize;\n        if (lastStallTime == -1) {\n          lastStallTime = System.nanoTime();\n        } else {\n          long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n          if (currentStallTime > stallTime) {\n            throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + currentQueueSize + \" remaining elements to process.\");\n//            threadInterrupted = true;\n//            break;\n          }\n        }\n      }\n    }\n    if (threadInterrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void waitForEmptyQueue() {\n    boolean threadInterrupted = Thread.currentThread().isInterrupted();\n\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n      if (scheduler.isTerminated()) {\n        log.warn(\"The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. \"\n            + \"Queue size: {}, Runners: {}. Current thread Interrupted? {}\", scheduler, queue.size(), runners.size(), threadInterrupted);\n        break;\n      }\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          // If we set the thread as interrupted again, the next time the wait it's called i t's going to return immediately\n          threadInterrupted = true;\n          log.warn(\"Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.\", \n              queue.size());\n        }\n      }\n    }\n    if (threadInterrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":["c7ca1cace44c816965501b934686a2354382f000","61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","sourceNew":"  private void waitForEmptyQueue() throws IOException {\n    boolean threadInterrupted = Thread.currentThread().isInterrupted();\n\n    long lastStallTime = -1;\n    int lastQueueSize = -1;\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n      if (scheduler.isTerminated()) {\n        log.warn(\"The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. \"\n            + \"Queue size: {}, Runners: {}. Current thread Interrupted? {}\", scheduler, queue.size(), runners.size(), threadInterrupted);\n        break;\n      }\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          // If we set the thread as interrupted again, the next time the wait it's called it's going to return immediately\n          threadInterrupted = true;\n          log.warn(\"Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.\", \n              queue.size());\n        }\n      }\n      int currentQueueSize = queue.size();\n      // stall prevention\n      if (currentQueueSize != lastQueueSize) {\n        lastQueueSize = currentQueueSize;\n        lastStallTime = -1;\n      } else {\n        lastQueueSize = currentQueueSize;\n        if (lastStallTime == -1) {\n          lastStallTime = System.nanoTime();\n        } else {\n          long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n          if (currentStallTime > stallTime) {\n            throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + currentQueueSize + \" remaining elements to process.\");\n//            threadInterrupted = true;\n//            break;\n          }\n        }\n      }\n    }\n    if (threadInterrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void waitForEmptyQueue() {\n    boolean threadInterrupted = Thread.currentThread().isInterrupted();\n\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n      if (scheduler.isTerminated()) {\n        log.warn(\"The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. \"\n            + \"Queue size: {}, Runners: {}. Current thread Interrupted? {}\", scheduler, queue.size(), runners.size(), threadInterrupted);\n        break;\n      }\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          // If we set the thread as interrupted again, the next time the wait it's called i t's going to return immediately\n          threadInterrupted = true;\n          log.warn(\"Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.\", \n              queue.size());\n        }\n      }\n    }\n    if (threadInterrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient#waitForEmptyQueue().mjava","sourceNew":"  private void waitForEmptyQueue() throws IOException {\n    boolean threadInterrupted = Thread.currentThread().isInterrupted();\n\n    long lastStallTime = -1;\n    int lastQueueSize = -1;\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n      if (scheduler.isTerminated()) {\n        log.warn(\"The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. Queue size: {}, Runners: {}. Current thread Interrupted? {}\"\n            , scheduler, queue.size(), runners.size(), threadInterrupted);\n        break;\n      }\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has {} adding more runners to process remaining requests on queue\"\n              , queueSize);\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          // If we set the thread as interrupted again, the next time the wait it's called it's going to return immediately\n          threadInterrupted = true;\n          log.warn(\"Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.\", \n              queue.size());\n        }\n      }\n      int currentQueueSize = queue.size();\n      // stall prevention\n      if (currentQueueSize != lastQueueSize) {\n        lastQueueSize = currentQueueSize;\n        lastStallTime = -1;\n      } else {\n        lastQueueSize = currentQueueSize;\n        if (lastStallTime == -1) {\n          lastStallTime = System.nanoTime();\n        } else {\n          long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n          if (currentStallTime > stallTime) {\n            throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + currentQueueSize + \" remaining elements to process.\");\n//            threadInterrupted = true;\n//            break;\n          }\n        }\n      }\n    }\n    if (threadInterrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n","sourceOld":"  private void waitForEmptyQueue() throws IOException {\n    boolean threadInterrupted = Thread.currentThread().isInterrupted();\n\n    long lastStallTime = -1;\n    int lastQueueSize = -1;\n    while (!queue.isEmpty()) {\n      if (log.isDebugEnabled()) emptyQueueLoops.incrementAndGet();\n      if (scheduler.isTerminated()) {\n        log.warn(\"The task queue still has elements but the update scheduler {} is terminated. Can't process any more tasks. \"\n            + \"Queue size: {}, Runners: {}. Current thread Interrupted? {}\", scheduler, queue.size(), runners.size(), threadInterrupted);\n        break;\n      }\n\n      synchronized (runners) {\n        int queueSize = queue.size();\n        if (queueSize > 0 && runners.isEmpty()) {\n          log.warn(\"No more runners, but queue still has \" +\n              queueSize + \" adding more runners to process remaining requests on queue\");\n          addRunner();\n        }\n      }\n      synchronized (queue) {\n        try {\n          queue.wait(250);\n        } catch (InterruptedException e) {\n          // If we set the thread as interrupted again, the next time the wait it's called it's going to return immediately\n          threadInterrupted = true;\n          log.warn(\"Thread interrupted while waiting for update queue to be empty. There are still {} elements in the queue.\", \n              queue.size());\n        }\n      }\n      int currentQueueSize = queue.size();\n      // stall prevention\n      if (currentQueueSize != lastQueueSize) {\n        lastQueueSize = currentQueueSize;\n        lastStallTime = -1;\n      } else {\n        lastQueueSize = currentQueueSize;\n        if (lastStallTime == -1) {\n          lastStallTime = System.nanoTime();\n        } else {\n          long currentStallTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - lastStallTime);\n          if (currentStallTime > stallTime) {\n            throw new IOException(\"Task queue processing has stalled for \" + currentStallTime + \" ms with \" + currentQueueSize + \" remaining elements to process.\");\n//            threadInterrupted = true;\n//            break;\n          }\n        }\n      }\n    }\n    if (threadInterrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["c7ca1cace44c816965501b934686a2354382f000","61c45e99cf6676da48f19d7511c73712ad39402b"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["61c45e99cf6676da48f19d7511c73712ad39402b"],"61c45e99cf6676da48f19d7511c73712ad39402b":["c7ca1cace44c816965501b934686a2354382f000"],"a229cb50768e988c50a2106bdae3a92154f428bf":["61c45e99cf6676da48f19d7511c73712ad39402b","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c7ca1cace44c816965501b934686a2354382f000":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dc613ed6f75d1988140301ee8de8fdb056fa337"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["6dc613ed6f75d1988140301ee8de8fdb056fa337","a229cb50768e988c50a2106bdae3a92154f428bf"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","482ca6c86d7073e3c19096bdc74fe0e73da4554a","a229cb50768e988c50a2106bdae3a92154f428bf"],"a229cb50768e988c50a2106bdae3a92154f428bf":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7ca1cace44c816965501b934686a2354382f000"],"c7ca1cace44c816965501b934686a2354382f000":["e9017cf144952056066919f1ebc7897ff9bd71b1","61c45e99cf6676da48f19d7511c73712ad39402b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","a229cb50768e988c50a2106bdae3a92154f428bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}