{"path":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","commits":[{"id":"52c7e49be259508735752fba88085255014a6ecf","date":1398706273,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexed();\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3394716f52b34ab259ad5247e7595d9f9db6e935","date":1398791921,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexed();\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexed();\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3184874f7f3aca850248483485b4995343066875","date":1413876758,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != null;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexed();\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != null;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexed();\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bb2842e561df4e8e9ad89010605fc86ac265465","date":1414768208,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != IndexOptions.NO;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != null;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95ce1375367b92d411a06175eab3915fe93c6bc","date":1414788502,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != IndexOptions.NO;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e72e3ade782716457071fee4033f18689acc4c4f","date":1496770651,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    super.start(field, first);\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f344bb33ca91f48e99c061980115b46fa84fc8f5","date":1496903283,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    super.start(field, first);\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    super.start(field, first);\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    super.start(field, first);\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3cc3fa1ecad75b99ec55169e44628808f9866ad","date":1592311545,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField#start(IndexableField,boolean).mjava","sourceNew":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    super.start(field, first);\n    termFreqAtt = fieldState.termFreqAttribute;\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (getNumTerms() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      reinitHash();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","sourceOld":"  @Override\n  boolean start(IndexableField field, boolean first) {\n    super.start(field, first);\n    assert field.fieldType().indexOptions() != IndexOptions.NONE;\n\n    if (first) {\n\n      if (bytesHash.size() != 0) {\n        // Only necessary if previous doc hit a\n        // non-aborting exception while writing vectors in\n        // this field:\n        reset();\n      }\n\n      bytesHash.reinit();\n\n      hasPayloads = false;\n\n      doVectors = field.fieldType().storeTermVectors();\n\n      if (doVectors) {\n\n        termsWriter.hasVectors = true;\n\n        doVectorPositions = field.fieldType().storeTermVectorPositions();\n\n        // Somewhat confusingly, unlike postings, you are\n        // allowed to index TV offsets without TV positions:\n        doVectorOffsets = field.fieldType().storeTermVectorOffsets();\n\n        if (doVectorPositions) {\n          doVectorPayloads = field.fieldType().storeTermVectorPayloads();\n        } else {\n          doVectorPayloads = false;\n          if (field.fieldType().storeTermVectorPayloads()) {\n            // TODO: move this check somewhere else, and impl the other missing ones\n            throw new IllegalArgumentException(\"cannot index term vector payloads without term vector positions (field=\\\"\" + field.name() + \"\\\")\");\n          }\n        }\n        \n      } else {\n        if (field.fieldType().storeTermVectorOffsets()) {\n          throw new IllegalArgumentException(\"cannot index term vector offsets when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPositions()) {\n          throw new IllegalArgumentException(\"cannot index term vector positions when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n        if (field.fieldType().storeTermVectorPayloads()) {\n          throw new IllegalArgumentException(\"cannot index term vector payloads when term vectors are not indexed (field=\\\"\" + field.name() + \"\\\")\");\n        }\n      }\n    } else {\n      if (doVectors != field.fieldType().storeTermVectors()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectors changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPositions != field.fieldType().storeTermVectorPositions()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPositions changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorOffsets != field.fieldType().storeTermVectorOffsets()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorOffsets changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n      if (doVectorPayloads != field.fieldType().storeTermVectorPayloads()) {\n        throw new IllegalArgumentException(\"all instances of a given field name must have the same term vectors settings (storeTermVectorPayloads changed for field=\\\"\" + field.name() + \"\\\")\");\n      }\n    }\n\n    if (doVectors) {\n      if (doVectorOffsets) {\n        offsetAttribute = fieldState.offsetAttribute;\n        assert offsetAttribute != null;\n      }\n\n      if (doVectorPayloads) {\n        // Can be null:\n        payloadAttribute = fieldState.payloadAttribute;\n      } else {\n        payloadAttribute = null;\n      }\n    }\n\n    return doVectors;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3394716f52b34ab259ad5247e7595d9f9db6e935"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["3184874f7f3aca850248483485b4995343066875"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["f95ce1375367b92d411a06175eab3915fe93c6bc","e72e3ade782716457071fee4033f18689acc4c4f"],"f95ce1375367b92d411a06175eab3915fe93c6bc":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"3184874f7f3aca850248483485b4995343066875":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"28288370235ed02234a64753cdbf0c6ec096304a":["f95ce1375367b92d411a06175eab3915fe93c6bc","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"3394716f52b34ab259ad5247e7595d9f9db6e935":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","52c7e49be259508735752fba88085255014a6ecf"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["3394716f52b34ab259ad5247e7595d9f9db6e935","3184874f7f3aca850248483485b4995343066875"],"e72e3ade782716457071fee4033f18689acc4c4f":["f95ce1375367b92d411a06175eab3915fe93c6bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"52c7e49be259508735752fba88085255014a6ecf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d3cc3fa1ecad75b99ec55169e44628808f9866ad":["28288370235ed02234a64753cdbf0c6ec096304a"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["f95ce1375367b92d411a06175eab3915fe93c6bc","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d3cc3fa1ecad75b99ec55169e44628808f9866ad"]},"commit2Childs":{"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"2bb2842e561df4e8e9ad89010605fc86ac265465":["f95ce1375367b92d411a06175eab3915fe93c6bc"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"3184874f7f3aca850248483485b4995343066875":["2bb2842e561df4e8e9ad89010605fc86ac265465","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"f95ce1375367b92d411a06175eab3915fe93c6bc":["f344bb33ca91f48e99c061980115b46fa84fc8f5","28288370235ed02234a64753cdbf0c6ec096304a","e72e3ade782716457071fee4033f18689acc4c4f","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"28288370235ed02234a64753cdbf0c6ec096304a":["d3cc3fa1ecad75b99ec55169e44628808f9866ad"],"3394716f52b34ab259ad5247e7595d9f9db6e935":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","3184874f7f3aca850248483485b4995343066875","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"e72e3ade782716457071fee4033f18689acc4c4f":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","3394716f52b34ab259ad5247e7595d9f9db6e935","52c7e49be259508735752fba88085255014a6ecf"],"52c7e49be259508735752fba88085255014a6ecf":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"d3cc3fa1ecad75b99ec55169e44628808f9866ad":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","0a22eafe3f72a4c2945eaad9547e6c78816978f4","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}