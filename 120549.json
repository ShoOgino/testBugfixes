{"path":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","commits":[{"id":"3cdd24a5b48ffd59f921ccc4f5199fc029f65797","date":1485039431,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  private Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : type == TrieTypes.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : type == TrieTypes.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : type == TrieTypes.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : type == TrieTypes.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = type == TrieTypes.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = type == TrieTypes.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = type == TrieTypes.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = type == TrieTypes.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieField#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  private Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : type == TrieTypes.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : type == TrieTypes.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : type == TrieTypes.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : type == TrieTypes.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = type == TrieTypes.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = type == TrieTypes.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = type == TrieTypes.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = type == TrieTypes.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = DocValuesRangeQuery.newLongRange\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = DocValuesRangeQuery.newLongRange\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":["92f8ab19a30ff70981e43b8cc78069cb0941476e","dfa8ee8a03218e801f864cf0ef8171a2fdd06f35"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"744b111b17d15d490a648eb021bfa240e7f11556","date":1487008069,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"022a4de90e0479b604264ca9c2e134c996454ab3","date":1487118265,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96","date":1487122334,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4958642f967bfbd6f083ddf50f141bcde89b9ec1","date":1489572234,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":["dfa8ee8a03218e801f864cf0ef8171a2fdd06f35"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bca83a747f8e297ee4412c0d18bdd3a98c09df3b","date":1489651910,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? negativeInfinityBits : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? positiveInfinityBits : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92f8ab19a30ff70981e43b8cc78069cb0941476e","date":1497374252,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), min): parseDoubleFromUser(sf.getName(), min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), max): parseDoubleFromUser(sf.getName(), max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","bugFix":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"bugIntro":["dfa8ee8a03218e801f864cf0ef8171a2fdd06f35"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), min): parseDoubleFromUser(sf.getName(), min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), max): parseDoubleFromUser(sf.getName(), max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), min): parseDoubleFromUser(sf.getName(), min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), max): parseDoubleFromUser(sf.getName(), max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(min): Double.parseDouble(min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? Float.parseFloat(max): Double.parseDouble(max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dfa8ee8a03218e801f864cf0ef8171a2fdd06f35","date":1501089160,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n    long minBits, maxBits;\n    boolean minNegative, maxNegative;\n    Number minVal, maxVal;\n    if (getNumberType() == NumberType.FLOAT) {\n      if (min == null) {\n        minVal = Float.NEGATIVE_INFINITY;\n      } else {\n        minVal = parseFloatFromUser(sf.getName(), min);\n        if (!minInclusive) {\n          if (minVal.floatValue() == Float.POSITIVE_INFINITY) return new MatchNoDocsQuery();\n          minVal = FloatPoint.nextUp(minVal.floatValue());\n        }\n      }\n      if (max == null) {\n        maxVal = Float.POSITIVE_INFINITY;\n      } else {\n        maxVal = parseFloatFromUser(sf.getName(), max);\n        if (!maxInclusive) {\n          if (maxVal.floatValue() == Float.NEGATIVE_INFINITY) return new MatchNoDocsQuery();\n          maxVal = FloatPoint.nextDown(maxVal.floatValue());\n        }\n      }\n      minBits = Float.floatToIntBits(minVal.floatValue());\n      maxBits = Float.floatToIntBits(maxVal.floatValue());\n      minNegative = minVal.floatValue() < 0f || minBits == FLOAT_MINUS_ZERO_BITS;\n      maxNegative = maxVal.floatValue() < 0f || maxBits == FLOAT_MINUS_ZERO_BITS;\n    } else {\n      assert getNumberType() == NumberType.DOUBLE;\n      if (min == null) {\n        minVal = Double.NEGATIVE_INFINITY;\n      } else {\n        minVal = parseDoubleFromUser(sf.getName(), min);\n        if (!minInclusive) {\n          if (minVal.doubleValue() == Double.POSITIVE_INFINITY) return new MatchNoDocsQuery();\n          minVal = DoublePoint.nextUp(minVal.doubleValue());\n        }\n      }\n      if (max == null) {\n        maxVal = Double.POSITIVE_INFINITY;\n      } else {\n        maxVal = parseDoubleFromUser(sf.getName(), max);\n        if (!maxInclusive) {\n          if (maxVal.doubleValue() == Double.NEGATIVE_INFINITY) return new MatchNoDocsQuery();\n          maxVal = DoublePoint.nextDown(maxVal.doubleValue());\n        }\n      }\n      minBits = Double.doubleToLongBits(minVal.doubleValue());\n      maxBits = Double.doubleToLongBits(maxVal.doubleValue());\n      minNegative = minVal.doubleValue() < 0d || minBits == DOUBLE_MINUS_ZERO_BITS;\n      maxNegative = maxVal.doubleValue() < 0d || maxBits == DOUBLE_MINUS_ZERO_BITS;\n    }\n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if (minNegative && !maxNegative) {\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, minVal.toString(), maxVal.toString(), true, true));\n    } else if (minNegative && maxNegative) {// If both max and min are negative (or -0d), then issue range query with max and min reversed\n      query = numericDocValuesRangeQuery\n          (fieldName, maxBits, minBits, true, true, false);\n    } else { // If both max and min are positive, then issue range query\n      query = numericDocValuesRangeQuery\n          (fieldName, minBits, maxBits, true, true, false);\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), min): parseDoubleFromUser(sf.getName(), min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), max): parseDoubleFromUser(sf.getName(), max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","bugFix":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797","92f8ab19a30ff70981e43b8cc78069cb0941476e","3d81baa64023bbb9b43f6d929ee168b105940d30","4958642f967bfbd6f083ddf50f141bcde89b9ec1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/NumericFieldType#getRangeQueryForFloatDoubleDocValues(SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n    long minBits, maxBits;\n    boolean minNegative, maxNegative;\n    Number minVal, maxVal;\n    if (getNumberType() == NumberType.FLOAT) {\n      if (min == null) {\n        minVal = Float.NEGATIVE_INFINITY;\n      } else {\n        minVal = parseFloatFromUser(sf.getName(), min);\n        if (!minInclusive) {\n          if (minVal.floatValue() == Float.POSITIVE_INFINITY) return new MatchNoDocsQuery();\n          minVal = FloatPoint.nextUp(minVal.floatValue());\n        }\n      }\n      if (max == null) {\n        maxVal = Float.POSITIVE_INFINITY;\n      } else {\n        maxVal = parseFloatFromUser(sf.getName(), max);\n        if (!maxInclusive) {\n          if (maxVal.floatValue() == Float.NEGATIVE_INFINITY) return new MatchNoDocsQuery();\n          maxVal = FloatPoint.nextDown(maxVal.floatValue());\n        }\n      }\n      minBits = Float.floatToIntBits(minVal.floatValue());\n      maxBits = Float.floatToIntBits(maxVal.floatValue());\n      minNegative = minVal.floatValue() < 0f || minBits == FLOAT_MINUS_ZERO_BITS;\n      maxNegative = maxVal.floatValue() < 0f || maxBits == FLOAT_MINUS_ZERO_BITS;\n    } else {\n      assert getNumberType() == NumberType.DOUBLE;\n      if (min == null) {\n        minVal = Double.NEGATIVE_INFINITY;\n      } else {\n        minVal = parseDoubleFromUser(sf.getName(), min);\n        if (!minInclusive) {\n          if (minVal.doubleValue() == Double.POSITIVE_INFINITY) return new MatchNoDocsQuery();\n          minVal = DoublePoint.nextUp(minVal.doubleValue());\n        }\n      }\n      if (max == null) {\n        maxVal = Double.POSITIVE_INFINITY;\n      } else {\n        maxVal = parseDoubleFromUser(sf.getName(), max);\n        if (!maxInclusive) {\n          if (maxVal.doubleValue() == Double.NEGATIVE_INFINITY) return new MatchNoDocsQuery();\n          maxVal = DoublePoint.nextDown(maxVal.doubleValue());\n        }\n      }\n      minBits = Double.doubleToLongBits(minVal.doubleValue());\n      maxBits = Double.doubleToLongBits(maxVal.doubleValue());\n      minNegative = minVal.doubleValue() < 0d || minBits == DOUBLE_MINUS_ZERO_BITS;\n      maxNegative = maxVal.doubleValue() < 0d || maxBits == DOUBLE_MINUS_ZERO_BITS;\n    }\n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if (minNegative && !maxNegative) {\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, minVal.toString(), maxVal.toString(), true, true));\n    } else if (minNegative && maxNegative) {// If both max and min are negative (or -0d), then issue range query with max and min reversed\n      query = numericDocValuesRangeQuery\n          (fieldName, maxBits, minBits, true, true, false);\n    } else { // If both max and min are positive, then issue range query\n      query = numericDocValuesRangeQuery\n          (fieldName, minBits, maxBits, true, true, false);\n    }\n    return query;\n  }\n\n","sourceOld":"  protected Query getRangeQueryForFloatDoubleDocValues(SchemaField sf, String min, String max, boolean minInclusive, boolean maxInclusive) {\n    Query query;\n    String fieldName = sf.getName();\n\n    Number minVal = min == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), min): parseDoubleFromUser(sf.getName(), min);\n    Number maxVal = max == null ? null : getNumberType() == NumberType.FLOAT ? parseFloatFromUser(sf.getName(), max): parseDoubleFromUser(sf.getName(), max);\n    \n    Long minBits = \n        min == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(minVal.floatValue()): Double.doubleToLongBits(minVal.doubleValue());\n    Long maxBits = \n        max == null ? null : getNumberType() == NumberType.FLOAT ? (long) Float.floatToIntBits(maxVal.floatValue()): Double.doubleToLongBits(maxVal.doubleValue());\n    \n    long negativeInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_NEGATIVE_INFINITY_BITS : DOUBLE_NEGATIVE_INFINITY_BITS;\n    long positiveInfinityBits = getNumberType() == NumberType.FLOAT ? FLOAT_POSITIVE_INFINITY_BITS : DOUBLE_POSITIVE_INFINITY_BITS;\n    long minusZeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_MINUS_ZERO_BITS : DOUBLE_MINUS_ZERO_BITS;\n    long zeroBits = getNumberType() == NumberType.FLOAT ? FLOAT_ZERO_BITS : DOUBLE_ZERO_BITS;\n    \n    // If min is negative (or -0d) and max is positive (or +0d), then issue a FunctionRangeQuery\n    if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) && \n        (maxVal == null || (maxVal.doubleValue() > 0d || maxBits == zeroBits))) {\n\n      ValueSource vs = getValueSource(sf, null);\n      query = new FunctionRangeQuery(new ValueSourceRangeFilter(vs, min, max, minInclusive, maxInclusive));\n\n    } else { // If both max and min are negative (or -0d), then issue range query with max and min reversed\n      if ((minVal == null || minVal.doubleValue() < 0d || minBits == minusZeroBits) &&\n          (maxVal != null && (maxVal.doubleValue() < 0d || maxBits == minusZeroBits))) {\n        query = numericDocValuesRangeQuery\n            (fieldName, maxBits, (min == null ? Long.valueOf(negativeInfinityBits) : minBits), maxInclusive, minInclusive, false);\n      } else { // If both max and min are positive, then issue range query\n        query = numericDocValuesRangeQuery\n            (fieldName, minBits, (max == null ? Long.valueOf(positiveInfinityBits) : maxBits), minInclusive, maxInclusive, false);\n      }\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3cdd24a5b48ffd59f921ccc4f5199fc029f65797":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["4958642f967bfbd6f083ddf50f141bcde89b9ec1"],"28288370235ed02234a64753cdbf0c6ec096304a":["4958642f967bfbd6f083ddf50f141bcde89b9ec1","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdd24a5b48ffd59f921ccc4f5199fc029f65797"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["022a4de90e0479b604264ca9c2e134c996454ab3"],"022a4de90e0479b604264ca9c2e134c996454ab3":["3d81baa64023bbb9b43f6d929ee168b105940d30","744b111b17d15d490a648eb021bfa240e7f11556"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","dfa8ee8a03218e801f864cf0ef8171a2fdd06f35"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"dfa8ee8a03218e801f864cf0ef8171a2fdd06f35":["28288370235ed02234a64753cdbf0c6ec096304a"],"744b111b17d15d490a648eb021bfa240e7f11556":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"ab68488225b6a6c357dda72ed11dedca9914a192":["897b06b1364bd1f658a8be7591e43f0851458e7f","bca83a747f8e297ee4412c0d18bdd3a98c09df3b"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["ab68488225b6a6c357dda72ed11dedca9914a192","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dfa8ee8a03218e801f864cf0ef8171a2fdd06f35"]},"commit2Childs":{"3cdd24a5b48ffd59f921ccc4f5199fc029f65797":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","3d81baa64023bbb9b43f6d929ee168b105940d30"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["92f8ab19a30ff70981e43b8cc78069cb0941476e","28288370235ed02234a64753cdbf0c6ec096304a"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["4958642f967bfbd6f083ddf50f141bcde89b9ec1","bca83a747f8e297ee4412c0d18bdd3a98c09df3b","ab68488225b6a6c357dda72ed11dedca9914a192"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"28288370235ed02234a64753cdbf0c6ec096304a":["dfa8ee8a03218e801f864cf0ef8171a2fdd06f35"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"022a4de90e0479b604264ca9c2e134c996454ab3":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"3d81baa64023bbb9b43f6d929ee168b105940d30":["022a4de90e0479b604264ca9c2e134c996454ab3","744b111b17d15d490a648eb021bfa240e7f11556"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["ab68488225b6a6c357dda72ed11dedca9914a192"],"744b111b17d15d490a648eb021bfa240e7f11556":["022a4de90e0479b604264ca9c2e134c996454ab3"],"dfa8ee8a03218e801f864cf0ef8171a2fdd06f35":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ab68488225b6a6c357dda72ed11dedca9914a192":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}