{"path":"lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.ToChildBlockJoinScorer#iterator().mjava","commits":[{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.ToChildBlockJoinScorer#iterator().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public DocIdSetIterator iterator() {\n      return new DocIdSetIterator() {\n\n        @Override\n        public int docID() {\n          return childDoc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          //System.out.println(\"Q.nextDoc() parentDoc=\" + parentDoc + \" childDoc=\" + childDoc);\n\n          while (true) {\n            if (childDoc+1 == parentDoc) {\n              // OK, we are done iterating through all children\n              // matching this one parent doc, so we now nextDoc()\n              // the parent.  Use a while loop because we may have\n              // to skip over some number of parents w/ no\n              // children:\n              while (true) {\n                parentDoc = parentIt.nextDoc();\n                validateParentDoc();\n\n                if (parentDoc == 0) {\n                  // Degenerate but allowed: first parent doc has no children\n                  // TODO: would be nice to pull initial parent\n                  // into ctor so we can skip this if... but it's\n                  // tricky because scorer must return -1 for\n                  // .doc() on init...\n                  parentDoc = parentIt.nextDoc();\n                  validateParentDoc();\n                }\n\n                if (parentDoc == NO_MORE_DOCS) {\n                  childDoc = NO_MORE_DOCS;\n                  //System.out.println(\"  END\");\n                  return childDoc;\n                }\n\n                // Go to first child for this next parentDoc:\n                childDoc = 1 + parentBits.prevSetBit(parentDoc-1);\n\n                if (childDoc == parentDoc) {\n                  // This parent has no children; continue\n                  // parent loop so we move to next parent\n                  continue;\n                }\n\n                if (childDoc < parentDoc) {\n                  if (doScores) {\n                    parentScore = parentScorer.score();\n                    parentFreq = parentScorer.freq();\n                  }\n                  //System.out.println(\"  \" + childDoc);\n                  return childDoc;\n                } else {\n                  // Degenerate but allowed: parent has no children\n                }\n              }\n            } else {\n              assert childDoc < parentDoc: \"childDoc=\" + childDoc + \" parentDoc=\" + parentDoc;\n              childDoc++;\n              //System.out.println(\"  \" + childDoc);\n              return childDoc;\n            }\n          }\n        }\n\n        @Override\n        public int advance(int childTarget) throws IOException {\n          if (childTarget >= parentDoc) {\n            if (childTarget == NO_MORE_DOCS) {\n              return childDoc = parentDoc = NO_MORE_DOCS;\n            }\n            parentDoc = parentIt.advance(childTarget + 1);\n            validateParentDoc();\n\n            if (parentDoc == NO_MORE_DOCS) {\n              return childDoc = NO_MORE_DOCS;\n            }\n\n            // scan to the first parent that has children\n            while (true) {\n              final int firstChild = parentBits.prevSetBit(parentDoc-1) + 1;\n              if (firstChild != parentDoc) {\n                // this parent has children\n                childTarget = Math.max(childTarget, firstChild);\n                break;\n              }\n              // parent with no children, move to the next one\n              parentDoc = parentIt.nextDoc();\n              validateParentDoc();\n              if (parentDoc == NO_MORE_DOCS) {\n                return childDoc = NO_MORE_DOCS;\n              }\n            }\n\n            if (doScores) {\n              parentScore = parentScorer.score();\n              parentFreq = parentScorer.freq();\n            }\n          }\n\n          assert childTarget < parentDoc;\n          assert !parentBits.get(childTarget);\n          childDoc = childTarget;\n          //System.out.println(\"  \" + childDoc);\n          return childDoc;\n        }\n\n        @Override\n        public long cost() {\n          return parentIt.cost();\n        }\n      };\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc14da055888b63b4f8c922d0e1579f3cb315ad7","date":1510744456,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.ToChildBlockJoinScorer#iterator().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.ToChildBlockJoinScorer#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() {\n      return new DocIdSetIterator() {\n\n        @Override\n        public int docID() {\n          return childDoc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          //System.out.println(\"Q.nextDoc() parentDoc=\" + parentDoc + \" childDoc=\" + childDoc);\n\n          while (true) {\n            if (childDoc+1 == parentDoc) {\n              // OK, we are done iterating through all children\n              // matching this one parent doc, so we now nextDoc()\n              // the parent.  Use a while loop because we may have\n              // to skip over some number of parents w/ no\n              // children:\n              while (true) {\n                parentDoc = parentIt.nextDoc();\n                validateParentDoc();\n\n                if (parentDoc == 0) {\n                  // Degenerate but allowed: first parent doc has no children\n                  // TODO: would be nice to pull initial parent\n                  // into ctor so we can skip this if... but it's\n                  // tricky because scorer must return -1 for\n                  // .doc() on init...\n                  parentDoc = parentIt.nextDoc();\n                  validateParentDoc();\n                }\n\n                if (parentDoc == NO_MORE_DOCS) {\n                  childDoc = NO_MORE_DOCS;\n                  //System.out.println(\"  END\");\n                  return childDoc;\n                }\n\n                // Go to first child for this next parentDoc:\n                childDoc = 1 + parentBits.prevSetBit(parentDoc-1);\n\n                if (childDoc == parentDoc) {\n                  // This parent has no children; continue\n                  // parent loop so we move to next parent\n                  continue;\n                }\n\n                if (childDoc < parentDoc) {\n                  if (doScores) {\n                    parentScore = parentScorer.score();\n                  }\n                  //System.out.println(\"  \" + childDoc);\n                  return childDoc;\n                } else {\n                  // Degenerate but allowed: parent has no children\n                }\n              }\n            } else {\n              assert childDoc < parentDoc: \"childDoc=\" + childDoc + \" parentDoc=\" + parentDoc;\n              childDoc++;\n              //System.out.println(\"  \" + childDoc);\n              return childDoc;\n            }\n          }\n        }\n\n        @Override\n        public int advance(int childTarget) throws IOException {\n          if (childTarget >= parentDoc) {\n            if (childTarget == NO_MORE_DOCS) {\n              return childDoc = parentDoc = NO_MORE_DOCS;\n            }\n            parentDoc = parentIt.advance(childTarget + 1);\n            validateParentDoc();\n\n            if (parentDoc == NO_MORE_DOCS) {\n              return childDoc = NO_MORE_DOCS;\n            }\n\n            // scan to the first parent that has children\n            while (true) {\n              final int firstChild = parentBits.prevSetBit(parentDoc-1) + 1;\n              if (firstChild != parentDoc) {\n                // this parent has children\n                childTarget = Math.max(childTarget, firstChild);\n                break;\n              }\n              // parent with no children, move to the next one\n              parentDoc = parentIt.nextDoc();\n              validateParentDoc();\n              if (parentDoc == NO_MORE_DOCS) {\n                return childDoc = NO_MORE_DOCS;\n              }\n            }\n\n            if (doScores) {\n              parentScore = parentScorer.score();\n            }\n          }\n\n          assert childTarget < parentDoc;\n          assert !parentBits.get(childTarget);\n          childDoc = childTarget;\n          //System.out.println(\"  \" + childDoc);\n          return childDoc;\n        }\n\n        @Override\n        public long cost() {\n          return parentIt.cost();\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() {\n      return new DocIdSetIterator() {\n\n        @Override\n        public int docID() {\n          return childDoc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          //System.out.println(\"Q.nextDoc() parentDoc=\" + parentDoc + \" childDoc=\" + childDoc);\n\n          while (true) {\n            if (childDoc+1 == parentDoc) {\n              // OK, we are done iterating through all children\n              // matching this one parent doc, so we now nextDoc()\n              // the parent.  Use a while loop because we may have\n              // to skip over some number of parents w/ no\n              // children:\n              while (true) {\n                parentDoc = parentIt.nextDoc();\n                validateParentDoc();\n\n                if (parentDoc == 0) {\n                  // Degenerate but allowed: first parent doc has no children\n                  // TODO: would be nice to pull initial parent\n                  // into ctor so we can skip this if... but it's\n                  // tricky because scorer must return -1 for\n                  // .doc() on init...\n                  parentDoc = parentIt.nextDoc();\n                  validateParentDoc();\n                }\n\n                if (parentDoc == NO_MORE_DOCS) {\n                  childDoc = NO_MORE_DOCS;\n                  //System.out.println(\"  END\");\n                  return childDoc;\n                }\n\n                // Go to first child for this next parentDoc:\n                childDoc = 1 + parentBits.prevSetBit(parentDoc-1);\n\n                if (childDoc == parentDoc) {\n                  // This parent has no children; continue\n                  // parent loop so we move to next parent\n                  continue;\n                }\n\n                if (childDoc < parentDoc) {\n                  if (doScores) {\n                    parentScore = parentScorer.score();\n                    parentFreq = parentScorer.freq();\n                  }\n                  //System.out.println(\"  \" + childDoc);\n                  return childDoc;\n                } else {\n                  // Degenerate but allowed: parent has no children\n                }\n              }\n            } else {\n              assert childDoc < parentDoc: \"childDoc=\" + childDoc + \" parentDoc=\" + parentDoc;\n              childDoc++;\n              //System.out.println(\"  \" + childDoc);\n              return childDoc;\n            }\n          }\n        }\n\n        @Override\n        public int advance(int childTarget) throws IOException {\n          if (childTarget >= parentDoc) {\n            if (childTarget == NO_MORE_DOCS) {\n              return childDoc = parentDoc = NO_MORE_DOCS;\n            }\n            parentDoc = parentIt.advance(childTarget + 1);\n            validateParentDoc();\n\n            if (parentDoc == NO_MORE_DOCS) {\n              return childDoc = NO_MORE_DOCS;\n            }\n\n            // scan to the first parent that has children\n            while (true) {\n              final int firstChild = parentBits.prevSetBit(parentDoc-1) + 1;\n              if (firstChild != parentDoc) {\n                // this parent has children\n                childTarget = Math.max(childTarget, firstChild);\n                break;\n              }\n              // parent with no children, move to the next one\n              parentDoc = parentIt.nextDoc();\n              validateParentDoc();\n              if (parentDoc == NO_MORE_DOCS) {\n                return childDoc = NO_MORE_DOCS;\n              }\n            }\n\n            if (doScores) {\n              parentScore = parentScorer.score();\n              parentFreq = parentScorer.freq();\n            }\n          }\n\n          assert childTarget < parentDoc;\n          assert !parentBits.get(childTarget);\n          childDoc = childTarget;\n          //System.out.println(\"  \" + childDoc);\n          return childDoc;\n        }\n\n        @Override\n        public long cost() {\n          return parentIt.cost();\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dc14da055888b63b4f8c922d0e1579f3cb315ad7":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dd748bb245633a8195281556bb0e68a6ea97d18":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dc14da055888b63b4f8c922d0e1579f3cb315ad7"]},"commit2Childs":{"dc14da055888b63b4f8c922d0e1579f3cb315ad7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["dc14da055888b63b4f8c922d0e1579f3cb315ad7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}