{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      if (!params.getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","2c6fae58725738008effbd9d848abc49122913fe","2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      if (!params.getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      if (!params.getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2806236d9dfa336ac413d3724a4123e7cf4d1e93","date":1348631501,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n      if (!params.getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d7c0c8a97beb56d2e168604f9928de17981eabe","date":1357257676,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","date":1361851792,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), coreNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String nodeName = req.getCore().getCoreDescriptor().getCoreContainer()\n            .getZkController().getNodeName();\n        String shardZkNodeName = nodeName + \"_\" + req.getCore().getName();\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), shardZkNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9","date":1371479482,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), coreNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n    }\n    \n    if (vinfo != null) {\n      vinfo.lockForUpdate();\n    }\n    try {\n\n      if (ulog == null || ulog.getState() == UpdateLog.State.ACTIVE || (cmd.getFlags() & UpdateCommand.REPLAY) != 0) {\n        super.processCommit(cmd);\n      } else {\n        log.info(\"Ignoring commit while not ACTIVE - state: \" + ulog.getState() + \" replay:\" + (cmd.getFlags() & UpdateCommand.REPLAY));\n      }\n\n    } finally {\n      if (vinfo != null) {\n        vinfo.unlockForUpdate();\n      }\n    }\n    // TODO: we should consider this? commit everyone in the current collection\n\n    if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        List<Node> nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n            .getCloudDescriptor().getCollectionName(), coreNodeName);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a51acc2e27bfb18091f9395494aebe82266f7ce7","date":1385611742,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0932eb10135843758b2ca508d5aa2b4798aa07f9","date":1426947197,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else if (zkEnabled) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","date":1452195469,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c6fae58725738008effbd9d848abc49122913fe","date":1455911986,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          finish();\n        }\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (onlyLeaderIndexes) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(\n              req.getCore().getCoreDescriptor().getCloudDescriptor()\n                  .getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId());\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else {\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (onlyLeaderIndexes) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(\n              req.getCore().getCoreDescriptor().getCloudDescriptor()\n                  .getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId());\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else {\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (onlyLeaderIndexes) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(\n              req.getCore().getCoreDescriptor().getCloudDescriptor()\n                  .getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId());\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else {\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      doLocalCommit(cmd);\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName(), EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT));\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n      if (isLeader && nodes.size() == 1 && replicaType != Replica.Type.PULL) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (replicaType == Replica.Type.TLOG) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(\n              req.getCore().getCoreDescriptor().getCloudDescriptor()\n                  .getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId()): \"Core \" + req.getCore() + \" not in sync with leader\";\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (onlyLeaderIndexes) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(\n              req.getCore().getCoreDescriptor().getCloudDescriptor()\n                  .getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId());\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else {\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName(), EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT));\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n      if (isLeader && nodes.size() == 1 && replicaType != Replica.Type.PULL) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (replicaType == Replica.Type.TLOG) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(\n              req.getCore().getCoreDescriptor().getCloudDescriptor()\n                  .getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId()): \"Core \" + req.getCore() + \" not in sync with leader\";\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName());\n      if (isLeader && nodes.size() == 1) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (onlyLeaderIndexes) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(\n              req.getCore().getCoreDescriptor().getCloudDescriptor()\n                  .getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId());\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else {\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"601f914e4448cab7640fecfb5d15f8f2e2af0bf6","date":1508947828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, cloudDesc.getCollectionName(), EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT));\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n      if (isLeader && nodes.size() == 1 && replicaType != Replica.Type.PULL) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (replicaType == Replica.Type.TLOG) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId()): \"Core \" + req.getCore() + \" not in sync with leader\";\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, req.getCore().getCoreDescriptor()\n          .getCloudDescriptor().getCollectionName(), EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT));\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n      if (isLeader && nodes.size() == 1 && replicaType != Replica.Type.PULL) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (replicaType == Replica.Type.TLOG) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(\n              req.getCore().getCoreDescriptor().getCloudDescriptor()\n                  .getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId()): \"Core \" + req.getCore() + \" not in sync with leader\";\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65","date":1509551229,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT));\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n      if (isLeader && nodes.size() == 1 && replicaType != Replica.Type.PULL) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (replicaType == Replica.Type.TLOG) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId()): \"Core \" + req.getCore() + \" not in sync with leader\";\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(req, cloudDesc.getCollectionName(), EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT));\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n      if (isLeader && nodes.size() == 1 && replicaType != Replica.Type.PULL) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (replicaType == Replica.Type.TLOG) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId()): \"Core \" + req.getCore() + \" not in sync with leader\";\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    Replica leaderReplica = null;\n    if (zkEnabled) {\n      zkCheck();\n      try {\n        leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        Thread.interrupted();\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n      }\n      isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT), true);\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n\n      nodes.removeIf((node) -> node.getNodeProps().getNodeName().equals(zkController.getNodeName())\n          && node.getNodeProps().getCoreName().equals(req.getCore().getName()));\n    }\n    \n    CompletionService<Exception> completionService = new ExecutorCompletionService<>(req.getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n    Set<Future<Exception>> pending = new HashSet<>();\n    if (!zkEnabled || (!isLeader && req.getParams().get(COMMIT_END_POINT, \"\").equals(\"replicas\"))) {\n      if (replicaType == Replica.Type.TLOG) {\n\n        if (isLeader) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n          doLocalCommit(cmd);\n        } else {\n          assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n              zkController, collection, cloudDesc.getShardId()) : \"Core \" + req.getCore() + \" not in sync with leader\";\n        }\n\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n  \n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n\n      List<Node> useNodes = null;\n      if (req.getParams().get(COMMIT_END_POINT) == null) {\n        useNodes = nodes;\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.TOLEADER.toString());\n        params.set(COMMIT_END_POINT, \"leaders\");\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n\n      if (isLeader) {\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n\n        params.set(COMMIT_END_POINT, \"replicas\");\n\n        useNodes = getReplicaNodesForLeader(cloudDesc.getShardId(), leaderReplica);\n\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n        }\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n\n        doLocalCommit(cmd);\n        if (useNodes != null) {\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    boolean singleLeader = false;\n    if (zkEnabled) {\n      zkCheck();\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT));\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n      if (isLeader && nodes.size() == 1 && replicaType != Replica.Type.PULL) {\n        singleLeader = true;\n      }\n    }\n    \n    if (!zkEnabled || req.getParams().getBool(COMMIT_END_POINT, false) || singleLeader) {\n      if (replicaType == Replica.Type.TLOG) {\n        try {\n          Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n              collection, cloudDesc.getShardId());\n          isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n          if (isLeader) {\n            long commitVersion = vinfo.getNewClock();\n            cmd.setVersion(commitVersion);\n            doLocalCommit(cmd);\n          } else {\n            assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n                zkController, collection, cloudDesc.getShardId()): \"Core \" + req.getCore() + \" not in sync with leader\";\n          }\n        } catch (InterruptedException e) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n        }\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      if (!req.getParams().getBool(COMMIT_END_POINT, false)) {\n        params.set(COMMIT_END_POINT, true);\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        if (nodes != null) {\n          cmdDistrib.distribCommit(cmd, nodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n  }\n\n","bugFix":["2806236d9dfa336ac413d3724a4123e7cf4d1e93","be320990bdc77e643388fa801e75017f19289c42","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","ad55ff45b3a5483090d87a63019d0e6a8d4b5a65","61c45e99cf6676da48f19d7511c73712ad39402b","2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9","601f914e4448cab7640fecfb5d15f8f2e2af0bf6","a51acc2e27bfb18091f9395494aebe82266f7ce7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b25c66490468a167b569a0466630020b7ffbb76","date":1549481515,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    Replica leaderReplica = null;\n    if (zkEnabled) {\n      zkCheck();\n      try {\n        leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        Thread.interrupted();\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n      }\n      isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT), true);\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n\n      nodes.removeIf((node) -> node.getNodeProps().getNodeName().equals(zkController.getNodeName())\n          && node.getNodeProps().getCoreName().equals(req.getCore().getName()));\n    }\n    \n    if (!zkEnabled || (!isLeader && req.getParams().get(COMMIT_END_POINT, \"\").equals(\"replicas\"))) {\n      if (replicaType == Replica.Type.TLOG) {\n\n        if (isLeader) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n          doLocalCommit(cmd);\n        } else {\n          assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n              zkController, collection, cloudDesc.getShardId()) : \"Core \" + req.getCore() + \" not in sync with leader\";\n        }\n\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n  \n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n\n      List<Node> useNodes = null;\n      if (req.getParams().get(COMMIT_END_POINT) == null) {\n        useNodes = nodes;\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.TOLEADER.toString());\n        params.set(COMMIT_END_POINT, \"leaders\");\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n\n      if (isLeader) {\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n\n        params.set(COMMIT_END_POINT, \"replicas\");\n\n        useNodes = getReplicaNodesForLeader(cloudDesc.getShardId(), leaderReplica);\n\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n        }\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n\n        doLocalCommit(cmd);\n        if (useNodes != null) {\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    Replica leaderReplica = null;\n    if (zkEnabled) {\n      zkCheck();\n      try {\n        leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        Thread.interrupted();\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n      }\n      isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT), true);\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n\n      nodes.removeIf((node) -> node.getNodeProps().getNodeName().equals(zkController.getNodeName())\n          && node.getNodeProps().getCoreName().equals(req.getCore().getName()));\n    }\n    \n    CompletionService<Exception> completionService = new ExecutorCompletionService<>(req.getCore().getCoreContainer().getUpdateShardHandler().getUpdateExecutor());\n    Set<Future<Exception>> pending = new HashSet<>();\n    if (!zkEnabled || (!isLeader && req.getParams().get(COMMIT_END_POINT, \"\").equals(\"replicas\"))) {\n      if (replicaType == Replica.Type.TLOG) {\n\n        if (isLeader) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n          doLocalCommit(cmd);\n        } else {\n          assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n              zkController, collection, cloudDesc.getShardId()) : \"Core \" + req.getCore() + \" not in sync with leader\";\n        }\n\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n  \n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n\n      List<Node> useNodes = null;\n      if (req.getParams().get(COMMIT_END_POINT) == null) {\n        useNodes = nodes;\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.TOLEADER.toString());\n        params.set(COMMIT_END_POINT, \"leaders\");\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n\n      if (isLeader) {\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n\n        params.set(COMMIT_END_POINT, \"replicas\");\n\n        useNodes = getReplicaNodesForLeader(cloudDesc.getShardId(), leaderReplica);\n\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n        }\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n\n        doLocalCommit(cmd);\n        if (useNodes != null) {\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e","date":1551802585,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n\n    if (isReadOnly()) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"Collection \" + collection + \" is read-only.\");\n    }\n\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    Replica leaderReplica = null;\n    if (zkEnabled) {\n      zkCheck();\n      try {\n        leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        Thread.interrupted();\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n      }\n      isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT), true);\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n\n      nodes.removeIf((node) -> node.getNodeProps().getNodeName().equals(zkController.getNodeName())\n          && node.getNodeProps().getCoreName().equals(req.getCore().getName()));\n    }\n    \n    if (!zkEnabled || (!isLeader && req.getParams().get(COMMIT_END_POINT, \"\").equals(\"replicas\"))) {\n      if (replicaType == Replica.Type.TLOG) {\n\n        if (isLeader) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n          doLocalCommit(cmd);\n        } else {\n          assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n              zkController, collection, cloudDesc.getShardId()) : \"Core \" + req.getCore() + \" not in sync with leader\";\n        }\n\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n  \n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n\n      List<Node> useNodes = null;\n      if (req.getParams().get(COMMIT_END_POINT) == null) {\n        useNodes = nodes;\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.TOLEADER.toString());\n        params.set(COMMIT_END_POINT, \"leaders\");\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n\n      if (isLeader) {\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n\n        params.set(COMMIT_END_POINT, \"replicas\");\n\n        useNodes = getReplicaNodesForLeader(cloudDesc.getShardId(), leaderReplica);\n\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n        }\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n\n        doLocalCommit(cmd);\n        if (useNodes != null) {\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n    List<Node> nodes = null;\n    Replica leaderReplica = null;\n    if (zkEnabled) {\n      zkCheck();\n      try {\n        leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        Thread.interrupted();\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n      }\n      isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT), true);\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n\n      nodes.removeIf((node) -> node.getNodeProps().getNodeName().equals(zkController.getNodeName())\n          && node.getNodeProps().getCoreName().equals(req.getCore().getName()));\n    }\n    \n    if (!zkEnabled || (!isLeader && req.getParams().get(COMMIT_END_POINT, \"\").equals(\"replicas\"))) {\n      if (replicaType == Replica.Type.TLOG) {\n\n        if (isLeader) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n          doLocalCommit(cmd);\n        } else {\n          assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n              zkController, collection, cloudDesc.getShardId()) : \"Core \" + req.getCore() + \" not in sync with leader\";\n        }\n\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n  \n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n\n      List<Node> useNodes = null;\n      if (req.getParams().get(COMMIT_END_POINT) == null) {\n        useNodes = nodes;\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.TOLEADER.toString());\n        params.set(COMMIT_END_POINT, \"leaders\");\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n\n      if (isLeader) {\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n\n        params.set(COMMIT_END_POINT, \"replicas\");\n\n        useNodes = getReplicaNodesForLeader(cloudDesc.getShardId(), leaderReplica);\n\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n        }\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n\n        doLocalCommit(cmd);\n        if (useNodes != null) {\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea30eccc5df86149453ac5ce8ff85443cfe1b9f7","date":1551957932,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n\n    if (isReadOnly()) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"Collection \" + collection + \" is read-only.\");\n    }\n\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    Replica leaderReplica = null;\n    if (zkEnabled) {\n      zkCheck();\n      try {\n        leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        Thread.interrupted();\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n      }\n      isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT), true);\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n\n      nodes.removeIf((node) -> node.getNodeProps().getNodeName().equals(zkController.getNodeName())\n          && node.getNodeProps().getCoreName().equals(req.getCore().getName()));\n    }\n    \n    if (!zkEnabled || (!isLeader && req.getParams().get(COMMIT_END_POINT, \"\").equals(\"replicas\"))) {\n      if (replicaType == Replica.Type.TLOG) {\n\n        if (isLeader) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n          doLocalCommit(cmd);\n        }\n\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n  \n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n\n      List<Node> useNodes = null;\n      if (req.getParams().get(COMMIT_END_POINT) == null) {\n        useNodes = nodes;\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.TOLEADER.toString());\n        params.set(COMMIT_END_POINT, \"leaders\");\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n\n      if (isLeader) {\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n\n        params.set(COMMIT_END_POINT, \"replicas\");\n\n        useNodes = getReplicaNodesForLeader(cloudDesc.getShardId(), leaderReplica);\n\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n        }\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n\n        doLocalCommit(cmd);\n        if (useNodes != null) {\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n\n    if (isReadOnly()) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"Collection \" + collection + \" is read-only.\");\n    }\n\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    Replica leaderReplica = null;\n    if (zkEnabled) {\n      zkCheck();\n      try {\n        leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        Thread.interrupted();\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n      }\n      isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT), true);\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n\n      nodes.removeIf((node) -> node.getNodeProps().getNodeName().equals(zkController.getNodeName())\n          && node.getNodeProps().getCoreName().equals(req.getCore().getName()));\n    }\n    \n    if (!zkEnabled || (!isLeader && req.getParams().get(COMMIT_END_POINT, \"\").equals(\"replicas\"))) {\n      if (replicaType == Replica.Type.TLOG) {\n\n        if (isLeader) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n          doLocalCommit(cmd);\n        } else {\n          assert TestInjection.waitForInSyncWithLeader(req.getCore(),\n              zkController, collection, cloudDesc.getShardId()) : \"Core \" + req.getCore() + \" not in sync with leader\";\n        }\n\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n  \n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n\n      List<Node> useNodes = null;\n      if (req.getParams().get(COMMIT_END_POINT) == null) {\n        useNodes = nodes;\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.TOLEADER.toString());\n        params.set(COMMIT_END_POINT, \"leaders\");\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n\n      if (isLeader) {\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n\n        params.set(COMMIT_END_POINT, \"replicas\");\n\n        useNodes = getReplicaNodesForLeader(cloudDesc.getShardId(), leaderReplica);\n\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n        }\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n\n        doLocalCommit(cmd);\n        if (useNodes != null) {\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":3,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    // replica type can only be NRT in standalone mode\n    // NRT replicas will always commit\n    doLocalCommit(cmd);\n\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n\n    if (isReadOnly()) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"Collection \" + collection + \" is read-only.\");\n    }\n\n    updateCommand = cmd;\n    List<Node> nodes = null;\n    Replica leaderReplica = null;\n    if (zkEnabled) {\n      zkCheck();\n      try {\n        leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        Thread.interrupted();\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Exception finding leader for shard \" + cloudDesc.getShardId(), e);\n      }\n      isLeader = leaderReplica.getName().equals(cloudDesc.getCoreNodeName());\n      \n      nodes = getCollectionUrls(collection, EnumSet.of(Replica.Type.TLOG,Replica.Type.NRT), true);\n      if (nodes == null) {\n        // This could happen if there are only pull replicas\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n            \"Unable to distribute commit operation. No replicas available of types \" + Replica.Type.TLOG + \" or \" + Replica.Type.NRT);\n      }\n\n      nodes.removeIf((node) -> node.getNodeProps().getNodeName().equals(zkController.getNodeName())\n          && node.getNodeProps().getCoreName().equals(req.getCore().getName()));\n    }\n    \n    if (!zkEnabled || (!isLeader && req.getParams().get(COMMIT_END_POINT, \"\").equals(\"replicas\"))) {\n      if (replicaType == Replica.Type.TLOG) {\n\n        if (isLeader) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n          doLocalCommit(cmd);\n        }\n\n      } else if (replicaType == Replica.Type.PULL) {\n        log.warn(\"Commit not supported on replicas of type \" + Replica.Type.PULL);\n      } else {\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n  \n        doLocalCommit(cmd);\n      }\n    } else {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n\n      List<Node> useNodes = null;\n      if (req.getParams().get(COMMIT_END_POINT) == null) {\n        useNodes = nodes;\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.TOLEADER.toString());\n        params.set(COMMIT_END_POINT, \"leaders\");\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n\n      if (isLeader) {\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n\n        params.set(COMMIT_END_POINT, \"replicas\");\n\n        useNodes = getReplicaNodesForLeader(cloudDesc.getShardId(), leaderReplica);\n\n        if (useNodes != null) {\n          params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName()));\n\n          cmdDistrib.distribCommit(cmd, useNodes, params);\n        }\n        // NRT replicas will always commit\n        if (vinfo != null) {\n          long commitVersion = vinfo.getNewClock();\n          cmd.setVersion(commitVersion);\n        }\n\n        doLocalCommit(cmd);\n        if (useNodes != null) {\n          cmdDistrib.blockAndDoRetries();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processCommit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n\n    updateCommand = cmd;\n\n    // replica type can only be NRT in standalone mode\n    // NRT replicas will always commit\n    doLocalCommit(cmd);\n\n  }\n\n","sourceOld":"  @Override\n  public void processCommit(CommitUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    // replica type can only be NRT in standalone mode\n    // NRT replicas will always commit\n    doLocalCommit(cmd);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["2806236d9dfa336ac413d3724a4123e7cf4d1e93","3d7c0c8a97beb56d2e168604f9928de17981eabe"],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["0932eb10135843758b2ca508d5aa2b4798aa07f9"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"07749612bed4eb54dd05255c1434c301133310c1":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","61c45e99cf6676da48f19d7511c73712ad39402b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a51acc2e27bfb18091f9395494aebe82266f7ce7","0932eb10135843758b2ca508d5aa2b4798aa07f9"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["61c45e99cf6676da48f19d7511c73712ad39402b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0932eb10135843758b2ca508d5aa2b4798aa07f9":["a51acc2e27bfb18091f9395494aebe82266f7ce7"],"be320990bdc77e643388fa801e75017f19289c42":["2c6fae58725738008effbd9d848abc49122913fe"],"ab68488225b6a6c357dda72ed11dedca9914a192":["2c6fae58725738008effbd9d848abc49122913fe","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"ea30eccc5df86149453ac5ce8ff85443cfe1b9f7":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"61c45e99cf6676da48f19d7511c73712ad39402b":["be320990bdc77e643388fa801e75017f19289c42"],"2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2806236d9dfa336ac413d3724a4123e7cf4d1e93":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["6b25c66490468a167b569a0466630020b7ffbb76"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["2c6fae58725738008effbd9d848abc49122913fe"],"a51acc2e27bfb18091f9395494aebe82266f7ce7":["2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9"],"6b25c66490468a167b569a0466630020b7ffbb76":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9","a51acc2e27bfb18091f9395494aebe82266f7ce7"],"2c6fae58725738008effbd9d848abc49122913fe":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["3d7c0c8a97beb56d2e168604f9928de17981eabe"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["ea30eccc5df86149453ac5ce8ff85443cfe1b9f7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["07749612bed4eb54dd05255c1434c301133310c1"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["2c6fae58725738008effbd9d848abc49122913fe"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["6b25c66490468a167b569a0466630020b7ffbb76"],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"07749612bed4eb54dd05255c1434c301133310c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"0932eb10135843758b2ca508d5aa2b4798aa07f9":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"be320990bdc77e643388fa801e75017f19289c42":["61c45e99cf6676da48f19d7511c73712ad39402b"],"ea30eccc5df86149453ac5ce8ff85443cfe1b9f7":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9":["37a0f60745e53927c4c876cfe5b5a58170f0646c","a51acc2e27bfb18091f9395494aebe82266f7ce7","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"2806236d9dfa336ac413d3724a4123e7cf4d1e93":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","3d7c0c8a97beb56d2e168604f9928de17981eabe"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["ea30eccc5df86149453ac5ce8ff85443cfe1b9f7"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"a51acc2e27bfb18091f9395494aebe82266f7ce7":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0932eb10135843758b2ca508d5aa2b4798aa07f9","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"6b25c66490468a167b569a0466630020b7ffbb76":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"2c6fae58725738008effbd9d848abc49122913fe":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["37a0f60745e53927c4c876cfe5b5a58170f0646c","2a4f729cab8ab6d4bf8365940c6ee4e17a0cfdd9"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["07749612bed4eb54dd05255c1434c301133310c1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","e9017cf144952056066919f1ebc7897ff9bd71b1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}