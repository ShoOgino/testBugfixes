{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"/dev/null","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      // nocommit make test where index has all docs deleted (all segments dropped, so 0 segments) and is then replicated\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n        if (deleter.isPending(segmentsFileName)) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else we can cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      message(\"exc on start:\");\n      t.printStackTrace(System.out);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7047018dca394809a6c77a991eece1f1994b704e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n        if (deleter.isPending(segmentsFileName)) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else we can cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(System.out);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      // nocommit make test where index has all docs deleted (all segments dropped, so 0 segments) and is then replicated\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n        if (deleter.isPending(segmentsFileName)) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else we can cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      message(\"exc on start:\");\n      t.printStackTrace(System.out);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b72a3c8c250ce67d9dd59e06316f982cd77bdb3c","date":1454874368,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(System.out);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n        if (deleter.isPending(segmentsFileName)) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else we can cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(System.out);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b844e2ae5435a8d4d925003c10027c25e26e02d","date":1455044345,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(System.out);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"/dev/null","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5c2b099338fb9b77f99c5127f70418a85a7689f","date":1468243391,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2dcbdc4d70424f69441091cee35f497a60c60bdb","date":1468245582,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          Collection<String> fileNamesToCopy = job.getFileNamesToCopy();\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d97ba94eef1fc33c5451259a7aa2ac682646c1af","date":1488285427,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos();\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","date":1493374641,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      IOUtils.reThrow(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c99ce0aa95120025213296d8d1ebf6164566dd49","date":1504272254,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      IndexSearcher searcher = mgr.acquire();\n      try {\n        // TODO: this is test specific:\n        int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n        message(\"top: marker count=\" + hitCount + \" version=\" + ((DirectoryReader) searcher.getIndexReader()).getVersion());\n      } finally {\n        mgr.release(searcher);\n      }\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3306bdef6cff9218671c5972462d4ff115785dd0","date":1524667585,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir.checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir instanceof FSDirectory && ((FSDirectory) dir).checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5e84aa7f651de6493590da495bcbe46d32cf038","date":1526462263,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir.getPendingDeletions().isEmpty() == false) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir.checkPendingDeletions()) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7047018dca394809a6c77a991eece1f1994b704e","date":1541865268,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#start(long).mjava","sourceNew":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir.getPendingDeletions().isEmpty() == false) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         toIndexInput(job.getCopyState().infosBytes),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","sourceOld":"  /** Start up this replica, which possibly requires heavy copying of files from the primary node, if we were down for a long time */\n  protected synchronized void start(long curPrimaryGen) throws IOException {\n\n    if (state.equals(\"init\") == false) {\n      throw new IllegalStateException(\"already started\");\n    }\n\n    message(\"top: now start\");\n    try {\n\n      // Figure out what state our local index is in now:\n      String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(dir);\n\n      // Also look for any pending_segments_N, in case we crashed mid-commit.  We must \"inflate\" our infos gen to at least this, since\n      // otherwise we may wind up re-using the pending_segments_N file name on commit, and then our deleter can get angry because it still\n      // wants to delete this file:\n      long maxPendingGen = -1;\n      for(String fileName : dir.listAll()) {\n        if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n          long gen = Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length()+1), Character.MAX_RADIX);\n          if (gen > maxPendingGen) {\n            maxPendingGen = gen;\n          }\n        }\n      }\n\n      SegmentInfos infos;\n      if (segmentsFileName == null) {\n        // No index here yet:\n        infos = new SegmentInfos(Version.LATEST.major);\n        message(\"top: init: no segments in index\");\n      } else {\n        message(\"top: init: read existing segments commit \" + segmentsFileName);\n        infos = SegmentInfos.readCommit(dir, segmentsFileName);\n        message(\"top: init: segments: \" + infos.toString() + \" version=\" + infos.getVersion());\n        Collection<String> indexFiles = infos.files(false);\n\n        lastCommitFiles.add(segmentsFileName);\n        lastCommitFiles.addAll(indexFiles);\n\n        // Always protect the last commit:\n        deleter.incRef(lastCommitFiles);\n\n        lastNRTFiles.addAll(indexFiles);\n        deleter.incRef(lastNRTFiles);\n        message(\"top: commitFiles=\" + lastCommitFiles);\n        message(\"top: nrtFiles=\" + lastNRTFiles);\n      }\n\n      message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n      deleter.deleteUnknownFiles(segmentsFileName);\n      message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n\n      String s = infos.getUserData().get(PRIMARY_GEN_KEY);\n      long myPrimaryGen;\n      if (s == null) {\n        assert infos.size() == 0;\n        myPrimaryGen = -1;\n      } else {\n        myPrimaryGen = Long.parseLong(s);\n      }\n      message(\"top: myPrimaryGen=\" + myPrimaryGen);\n\n      boolean doCommit;\n\n      if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n\n        assert myPrimaryGen < curPrimaryGen;\n\n        // Primary changed while we were down.  In this case, we must sync from primary before opening a reader, because it's possible current\n        // files we have will need to be overwritten with different ones (if index rolled back and \"forked\"), and we can't overwrite open\n        // files on Windows:\n\n        final long initSyncStartNS = System.nanoTime();\n\n        message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen +\n                \" vs curPrimaryGen=\" + curPrimaryGen +\n                \"; sync now before mgr init\");\n\n        // Try until we succeed in copying over the latest NRT point:\n        CopyJob job = null;\n\n        // We may need to overwrite files referenced by our latest commit, either right now on initial sync, or on a later sync.  To make\n        // sure the index is never even in an \"apparently\" corrupt state (where an old segments_N references invalid files) we forcefully\n        // remove the commit now, and refuse to start the replica if this delete fails:\n        message(\"top: now delete starting commit point \" + segmentsFileName);\n\n        // If this throws exc (e.g. due to virus checker), we cannot start this replica:\n        assert deleter.getRefCount(segmentsFileName) == 1;\n        deleter.decRef(Collections.singleton(segmentsFileName));\n\n        if (dir.getPendingDeletions().isEmpty() == false) {\n          // If e.g. virus checker blocks us from deleting, we absolutely cannot start this node else there is a definite window during\n          // which if we carsh, we cause corruption:\n          throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n        }\n\n        // So we don't later try to decRef it (illegally) again:\n        boolean didRemove = lastCommitFiles.remove(segmentsFileName);\n        assert didRemove;\n\n        while (true) {\n          job = newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\" + infos.getVersion(),\n                           null,\n                           null,\n                           true,\n                           null);\n          job.start();\n\n          message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n\n          // Force this copy job to finish while we wait, now.  Note that this can be very time consuming!\n          // NOTE: newNRTPoint detects we are still in init (mgr is null) and does not cancel our copy if a flush happens\n          try {\n            job.runBlocking();\n            job.finish();\n\n            // Success!\n            break;\n          } catch (IOException ioe) {\n            job.cancel(\"startup failed\", ioe);\n            if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n              // OK-ish\n              message(\"top: failed to copy: \" + ioe + \"; retrying\");\n            } else {\n              throw ioe;\n            }\n          }\n        }\n\n        lastPrimaryGen = job.getCopyState().primaryGen;\n        byte[] infosBytes = job.getCopyState().infosBytes;\n\n        SegmentInfos syncInfos = SegmentInfos.readCommit(dir,\n                                                         new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\", job.getCopyState().infosBytes)),\n                                                         job.getCopyState().gen);\n\n        // Must always commit to a larger generation than what's currently in the index:\n        syncInfos.updateGeneration(infos);\n        infos = syncInfos;\n\n        assert infos.getVersion() == job.getCopyState().version;\n        message(\"  version=\" + infos.getVersion() + \" segments=\" + infos.toString());\n        message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n        deleter.incRef(job.getFileNames());\n        message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n        deleter.decRef(lastNRTFiles);\n\n        lastNRTFiles.clear();\n        lastNRTFiles.addAll(job.getFileNames());\n\n        message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n        lastFileMetaData = job.getCopyState().files;\n        message(String.format(Locale.ROOT, \"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",\n                              id,\n                              (System.nanoTime()-initSyncStartNS)/1000000000.0,\n                              bytesToString(job.getTotalBytesCopied()),\n                              job.getCopyState().version));\n\n        doCommit = true;\n      } else {\n        doCommit = false;\n        lastPrimaryGen = curPrimaryGen;\n        message(\"top: same primary as before\");\n      }\n\n      if (infos.getGeneration() < maxPendingGen) {\n        message(\"top: move infos generation from \" + infos.getGeneration() + \" to \" + maxPendingGen);\n        infos.setNextWriteGeneration(maxPendingGen);\n      }\n\n      // Notify primary we started, to give it a chance to send any warming merges our way to reduce NRT latency of first sync:\n      sendNewReplica();\n\n      // Finally, we are open for business, since our index now \"agrees\" with the primary:\n      mgr = new SegmentInfosSearcherManager(dir, this, infos, searcherFactory);\n\n      // Must commit after init mgr:\n      if (doCommit) {\n        // Very important to commit what we just sync'd over, because we removed the pre-existing commit point above if we had to\n        // overwrite any files it referenced:\n        commit();\n      }\n\n      message(\"top: done start\");\n      state = \"idle\";\n    } catch (Throwable t) {\n      if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n        message(\"exc on start:\");\n        t.printStackTrace(printStream);\n      } else {\n        dir.close();\n      }\n      throw IOUtils.rethrowAlways(t);\n    }\n  }\n\n","bugFix":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","c99ce0aa95120025213296d8d1ebf6164566dd49"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"b72a3c8c250ce67d9dd59e06316f982cd77bdb3c":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"3306bdef6cff9218671c5972462d4ff115785dd0":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"2dcbdc4d70424f69441091cee35f497a60c60bdb":["68496c2200e559fb7802f7575427b7a482659afb","e5c2b099338fb9b77f99c5127f70418a85a7689f"],"7047018dca394809a6c77a991eece1f1994b704e":["c5e84aa7f651de6493590da495bcbe46d32cf038"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["68496c2200e559fb7802f7575427b7a482659afb","2dcbdc4d70424f69441091cee35f497a60c60bdb"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"e5c2b099338fb9b77f99c5127f70418a85a7689f":["68496c2200e559fb7802f7575427b7a482659afb"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["b72a3c8c250ce67d9dd59e06316f982cd77bdb3c"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"c99ce0aa95120025213296d8d1ebf6164566dd49":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["e9017cf144952056066919f1ebc7897ff9bd71b1","c99ce0aa95120025213296d8d1ebf6164566dd49"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2b844e2ae5435a8d4d925003c10027c25e26e02d"],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["2dcbdc4d70424f69441091cee35f497a60c60bdb"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7047018dca394809a6c77a991eece1f1994b704e"],"c5e84aa7f651de6493590da495bcbe46d32cf038":["3306bdef6cff9218671c5972462d4ff115785dd0"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["b21283ed01203901a7257aa4b7f0a0899c86e56e","e9017cf144952056066919f1ebc7897ff9bd71b1","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","c99ce0aa95120025213296d8d1ebf6164566dd49"],"b72a3c8c250ce67d9dd59e06316f982cd77bdb3c":["2b844e2ae5435a8d4d925003c10027c25e26e02d"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["b72a3c8c250ce67d9dd59e06316f982cd77bdb3c"],"3306bdef6cff9218671c5972462d4ff115785dd0":["c5e84aa7f651de6493590da495bcbe46d32cf038"],"2dcbdc4d70424f69441091cee35f497a60c60bdb":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"7047018dca394809a6c77a991eece1f1994b704e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"31741cf1390044e38a2ec3127cf302ba841bfd75":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"e5c2b099338fb9b77f99c5127f70418a85a7689f":["2dcbdc4d70424f69441091cee35f497a60c60bdb"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["68496c2200e559fb7802f7575427b7a482659afb"],"c99ce0aa95120025213296d8d1ebf6164566dd49":["b21283ed01203901a7257aa4b7f0a0899c86e56e","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["3306bdef6cff9218671c5972462d4ff115785dd0"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["2dcbdc4d70424f69441091cee35f497a60c60bdb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e5c2b099338fb9b77f99c5127f70418a85a7689f"],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"c5e84aa7f651de6493590da495bcbe46d32cf038":["7047018dca394809a6c77a991eece1f1994b704e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}