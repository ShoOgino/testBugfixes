{"path":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","commits":[{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4556b0efd847b88322058ba45656d418e7dce68a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e401f4940308a68c615c8893021c88c57010df5","date":1462635977,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4556b0efd847b88322058ba45656d418e7dce68a","date":1479993019,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(new MergeReaderWrapper(reader)) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(new MergeReaderWrapper(reader), r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","bugFix":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"927b161eb8a968101cf45f48d11ebe24beed054d","date":1480015309,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(new MergeReaderWrapper(reader)) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(new MergeReaderWrapper(reader), r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(new MergeReaderWrapper(reader)) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(new MergeReaderWrapper(reader), r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(reader) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(reader, r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.MockRandomOneMerge#wrapForMerge(CodecReader).mjava","sourceNew":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(new MergeReaderWrapper(reader)) {\n\n          @Override\n          public CacheHelper getCoreCacheHelper() {\n            return in.getCoreCacheHelper();\n          }\n\n          @Override\n          public CacheHelper getReaderCacheHelper() {\n            return in.getReaderCacheHelper();\n          }\n        });\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(new MergeReaderWrapper(reader), r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","sourceOld":"    @Override\n    public CodecReader wrapForMerge(CodecReader reader) throws IOException {\n\n      // wrap it (e.g. prevent bulk merge etc)\n      // TODO: cut this over to FilterCodecReader api, we can explicitly\n      // enable/disable bulk merge for portions of the index we want.\n      int thingToDo = r.nextInt(7);\n      if (thingToDo == 0) {\n        // simple no-op FilterReader\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a SlowCodecReaderWrapper for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new FilterLeafReader(new MergeReaderWrapper(reader)) {});\n      } else if (thingToDo == 1) {\n        // renumber fields\n        // NOTE: currently this only \"blocks\" bulk merges just by\n        // being a FilterReader. But it might find bugs elsewhere, \n        // and maybe the situation can be improved in the future.\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"NOTE: MockRandomMergePolicy now swaps in a MismatchedLeafReader for merging reader=\" + reader);\n        }\n        return SlowCodecReaderWrapper.wrap(new MismatchedLeafReader(new MergeReaderWrapper(reader), r));\n      } else {\n        // otherwise, reader is unchanged\n        return reader;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"727bb765ff2542275f6d31f67be18d7104bae148":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","927b161eb8a968101cf45f48d11ebe24beed054d"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"927b161eb8a968101cf45f48d11ebe24beed054d":["d470c8182e92b264680e34081b75e70a9f2b3c89","4556b0efd847b88322058ba45656d418e7dce68a"],"4556b0efd847b88322058ba45656d418e7dce68a":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d211216c83f01894810543d1c107160a9ae3650b":["927b161eb8a968101cf45f48d11ebe24beed054d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5e401f4940308a68c615c8893021c88c57010df5":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"0ad30c6a479e764150a3316e57263319775f1df2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3d33e731a93d4b57e662ff094f64f94a745422d4"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5e401f4940308a68c615c8893021c88c57010df5"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d211216c83f01894810543d1c107160a9ae3650b"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ad30c6a479e764150a3316e57263319775f1df2"]},"commit2Childs":{"727bb765ff2542275f6d31f67be18d7104bae148":[],"927b161eb8a968101cf45f48d11ebe24beed054d":["727bb765ff2542275f6d31f67be18d7104bae148","d211216c83f01894810543d1c107160a9ae3650b"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["5e401f4940308a68c615c8893021c88c57010df5"],"4556b0efd847b88322058ba45656d418e7dce68a":["927b161eb8a968101cf45f48d11ebe24beed054d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70","0ad30c6a479e764150a3316e57263319775f1df2","3d33e731a93d4b57e662ff094f64f94a745422d4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d211216c83f01894810543d1c107160a9ae3650b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5e401f4940308a68c615c8893021c88c57010df5":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["727bb765ff2542275f6d31f67be18d7104bae148"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["927b161eb8a968101cf45f48d11ebe24beed054d","4556b0efd847b88322058ba45656d418e7dce68a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}