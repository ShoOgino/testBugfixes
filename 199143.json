{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,Codec).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,Codec).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,Codec).mjava","sourceNew":"  private void write(Directory directory, Codec codec) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    \n\n    boolean success = false;\n\n    try {\n      SegmentInfosWriter infosWriter = codec.segmentInfosFormat().getSegmentInfosWriter();\n      segnOutput = infosWriter.writeInfos(directory, segmentFileName, codec.getName(), this, IOContext.DEFAULT);\n      infosWriter.prepareCommit(segnOutput);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory, Codec codec) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    \n\n    boolean success = false;\n\n    try {\n      SegmentInfosWriter infosWriter = codec.segmentInfosFormat().getSegmentInfosWriter();\n      segnOutput = infosWriter.writeInfos(directory, segmentFileName, codec.getName(), this, IOContext.DEFAULT);\n      infosWriter.prepareCommit(segnOutput);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,Codec).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    try {\n      // nocommit what IOCtx to use...\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, new IOContext(new FlushInfo(totalDocCount(), 0))));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // nocommit hacky!\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            //System.out.println(\"write 3x info seg=\" + si.name + \" version=\" + si.getVersion() + \" codec=\" + si.getCodec().getName());\n            write3xInfo(si);\n            // nocommit do this after, on success...\n            //si.setVersion(\"4.0\");\n            si.clearFilesCache();\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.prepareCommit();\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        // nocommit must also remove any written .si files...\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory, Codec codec) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    \n\n    boolean success = false;\n\n    try {\n      SegmentInfosWriter infosWriter = codec.segmentInfosFormat().getSegmentInfosWriter();\n      segnOutput = infosWriter.writeInfos(directory, segmentFileName, codec.getName(), this, IOContext.DEFAULT);\n      infosWriter.prepareCommit(segnOutput);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["71e1a70f18d64b93db3ef618e606d6df5062f747","71e1a70f18d64b93db3ef618e606d6df5062f747","f4ac68b353fb5616cfc6067741970000e8ee39a5","f4ac68b353fb5616cfc6067741970000e8ee39a5","8f3189d15ef66702bbb45771403a68793d5cd137","8f3189d15ef66702bbb45771403a68793d5cd137"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,Codec).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || StringHelper.getVersionComparator().compare(version, \"4.0\") < 0) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.UPGRADED_SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory, Codec codec) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    \n\n    boolean success = false;\n\n    try {\n      SegmentInfosWriter infosWriter = codec.segmentInfosFormat().getSegmentInfosWriter();\n      segnOutput = infosWriter.writeInfos(directory, segmentFileName, codec.getName(), this, IOContext.DEFAULT);\n      infosWriter.prepareCommit(segnOutput);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4356000e349e38c9fb48034695b7c309abd54557"],"4356000e349e38c9fb48034695b7c309abd54557":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"]},"commit2Childs":{"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4356000e349e38c9fb48034695b7c309abd54557":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4356000e349e38c9fb48034695b7c309abd54557"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}