{"path":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","commits":[{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a document with randomized field values, some of which be missing values, \n   * and some of which will be skewed so that small subsets of the ranges will be \n   * more common (resulting in an increased likelihood of duplicate values)\n   * \n   * @see #buildRandomQuery\n   */\n  public static SolrInputDocument buildRandomDocument(int id) {\n    SolrInputDocument doc = sdoc(\"id\", id);\n    // most fields are in most docs\n    // if field is in a doc, then \"skewed\" chance val is from a dense range\n    // (hopefully with lots of duplication)\n    if (useField()) {\n      doc.addField(\"int\", skewed(random().nextInt(), \n                                 _TestUtil.nextInt(random(), 20, 50)));\n    }\n    if (useField()) {\n      doc.addField(\"long\", skewed(random().nextLong(), \n                                  _TestUtil.nextInt(random(), 5000, 5100)));\n    }\n    if (useField()) {\n      doc.addField(\"float\", skewed(random().nextFloat() * random().nextInt(), \n                                   1.0F / random().nextInt(23)));\n    }\n    if (useField()) {\n      doc.addField(\"double\", skewed(random().nextDouble() * random().nextInt(), \n                                    1.0D / random().nextInt(37)));\n    }\n    if (useField()) {\n      doc.addField(\"str\", skewed(randomUsableUnicodeString(),\n                                 _TestUtil.randomSimpleString(random(),1,1)));\n\n    }\n    if (useField()) {\n      int numBytes = (int) skewed(_TestUtil.nextInt(random(), 20, 50), 2);\n      byte[] randBytes = new byte[numBytes];\n      random().nextBytes(randBytes);\n      doc.addField(\"bin\", ByteBuffer.wrap(randBytes));\n    }\n    return doc;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","sourceNew":"  /**\n   * Creates a document with randomized field values, some of which be missing values, \n   * and some of which will be skewed so that small subsets of the ranges will be \n   * more common (resulting in an increased likelihood of duplicate values)\n   * \n   * @see #buildRandomQuery\n   */\n  public static SolrInputDocument buildRandomDocument(int id) {\n    SolrInputDocument doc = sdoc(\"id\", id);\n    // most fields are in most docs\n    // if field is in a doc, then \"skewed\" chance val is from a dense range\n    // (hopefully with lots of duplication)\n    if (useField()) {\n      doc.addField(\"int\", skewed(random().nextInt(), \n                                 TestUtil.nextInt(random(), 20, 50)));\n    }\n    if (useField()) {\n      doc.addField(\"long\", skewed(random().nextLong(), \n                                  TestUtil.nextInt(random(), 5000, 5100)));\n    }\n    if (useField()) {\n      doc.addField(\"float\", skewed(random().nextFloat() * random().nextInt(), \n                                   1.0F / random().nextInt(23)));\n    }\n    if (useField()) {\n      doc.addField(\"double\", skewed(random().nextDouble() * random().nextInt(), \n                                    1.0D / random().nextInt(37)));\n    }\n    if (useField()) {\n      doc.addField(\"str\", skewed(randomUsableUnicodeString(),\n                                 TestUtil.randomSimpleString(random(), 1, 1)));\n\n    }\n    if (useField()) {\n      int numBytes = (int) skewed(TestUtil.nextInt(random(), 20, 50), 2);\n      byte[] randBytes = new byte[numBytes];\n      random().nextBytes(randBytes);\n      doc.addField(\"bin\", ByteBuffer.wrap(randBytes));\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Creates a document with randomized field values, some of which be missing values, \n   * and some of which will be skewed so that small subsets of the ranges will be \n   * more common (resulting in an increased likelihood of duplicate values)\n   * \n   * @see #buildRandomQuery\n   */\n  public static SolrInputDocument buildRandomDocument(int id) {\n    SolrInputDocument doc = sdoc(\"id\", id);\n    // most fields are in most docs\n    // if field is in a doc, then \"skewed\" chance val is from a dense range\n    // (hopefully with lots of duplication)\n    if (useField()) {\n      doc.addField(\"int\", skewed(random().nextInt(), \n                                 _TestUtil.nextInt(random(), 20, 50)));\n    }\n    if (useField()) {\n      doc.addField(\"long\", skewed(random().nextLong(), \n                                  _TestUtil.nextInt(random(), 5000, 5100)));\n    }\n    if (useField()) {\n      doc.addField(\"float\", skewed(random().nextFloat() * random().nextInt(), \n                                   1.0F / random().nextInt(23)));\n    }\n    if (useField()) {\n      doc.addField(\"double\", skewed(random().nextDouble() * random().nextInt(), \n                                    1.0D / random().nextInt(37)));\n    }\n    if (useField()) {\n      doc.addField(\"str\", skewed(randomUsableUnicodeString(),\n                                 _TestUtil.randomSimpleString(random(),1,1)));\n\n    }\n    if (useField()) {\n      int numBytes = (int) skewed(_TestUtil.nextInt(random(), 20, 50), 2);\n      byte[] randBytes = new byte[numBytes];\n      random().nextBytes(randBytes);\n      doc.addField(\"bin\", ByteBuffer.wrap(randBytes));\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd3693b696a64d987bf4b3a14399d2105f16b05e","date":1396054865,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","sourceNew":"  /**\n   * Creates a document with randomized field values, some of which be missing values, \n   * and some of which will be skewed so that small subsets of the ranges will be \n   * more common (resulting in an increased likelihood of duplicate values)\n   * \n   * @see #buildRandomQuery\n   */\n  public static SolrInputDocument buildRandomDocument(int id) {\n    SolrInputDocument doc = sdoc(\"id\", id);\n    // most fields are in most docs\n    // if field is in a doc, then \"skewed\" chance val is from a dense range\n    // (hopefully with lots of duplication)\n    if (useField()) {\n      doc.addField(\"int\", skewed(random().nextInt(), \n                                 TestUtil.nextInt(random(), 20, 50)));\n    }\n    if (useField()) {\n      doc.addField(\"long\", skewed(random().nextLong(), \n                                  TestUtil.nextInt(random(), 5000, 5100)));\n    }\n    if (useField()) {\n      doc.addField(\"float\", skewed(random().nextFloat() * random().nextInt(), \n                                   1.0F / random().nextInt(23)));\n    }\n    if (useField()) {\n      doc.addField(\"double\", skewed(random().nextDouble() * random().nextInt(), \n                                    1.0D / random().nextInt(37)));\n    }\n    if (useField()) {\n      doc.addField(\"str\", skewed(randomUsableUnicodeString(),\n                                 TestUtil.randomSimpleString(random(), 1, 1)));\n    }\n    if (useField()) {\n      int numBytes = (int) skewed(TestUtil.nextInt(random(), 20, 50), 2);\n      byte[] randBytes = new byte[numBytes];\n      random().nextBytes(randBytes);\n      doc.addField(\"bin\", ByteBuffer.wrap(randBytes));\n    }\n    if (useField()) {\n      doc.addField(\"date\", skewed(randomDate(),\n                                  dateWithRandomSecondOn2010_10_31_at_10_31()));\n    }\n    if (useField()) {\n      doc.addField(\"uuid\", UUID.randomUUID().toString());\n    }\n    if (useField()) {\n      doc.addField(\"currency\", skewed(\"\" + (random().nextInt() / 100.) + \",\" + randomCurrency(),\n                                      \"\" + TestUtil.nextInt(random(), 250, 320) + \",USD\"));\n    }\n    if (useField()) {\n      doc.addField(\"bool\", random().nextBoolean() ? \"t\" : \"f\");\n    }\n    if (useField()) {\n      doc.addField(\"enum\", randomEnumValue());\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Creates a document with randomized field values, some of which be missing values, \n   * and some of which will be skewed so that small subsets of the ranges will be \n   * more common (resulting in an increased likelihood of duplicate values)\n   * \n   * @see #buildRandomQuery\n   */\n  public static SolrInputDocument buildRandomDocument(int id) {\n    SolrInputDocument doc = sdoc(\"id\", id);\n    // most fields are in most docs\n    // if field is in a doc, then \"skewed\" chance val is from a dense range\n    // (hopefully with lots of duplication)\n    if (useField()) {\n      doc.addField(\"int\", skewed(random().nextInt(), \n                                 TestUtil.nextInt(random(), 20, 50)));\n    }\n    if (useField()) {\n      doc.addField(\"long\", skewed(random().nextLong(), \n                                  TestUtil.nextInt(random(), 5000, 5100)));\n    }\n    if (useField()) {\n      doc.addField(\"float\", skewed(random().nextFloat() * random().nextInt(), \n                                   1.0F / random().nextInt(23)));\n    }\n    if (useField()) {\n      doc.addField(\"double\", skewed(random().nextDouble() * random().nextInt(), \n                                    1.0D / random().nextInt(37)));\n    }\n    if (useField()) {\n      doc.addField(\"str\", skewed(randomUsableUnicodeString(),\n                                 TestUtil.randomSimpleString(random(), 1, 1)));\n\n    }\n    if (useField()) {\n      int numBytes = (int) skewed(TestUtil.nextInt(random(), 20, 50), 2);\n      byte[] randBytes = new byte[numBytes];\n      random().nextBytes(randBytes);\n      doc.addField(\"bin\", ByteBuffer.wrap(randBytes));\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","sourceNew":"  /**\n   * Creates a document with randomized field values, some of which be missing values, \n   * and some of which will be skewed so that small subsets of the ranges will be \n   * more common (resulting in an increased likelihood of duplicate values)\n   * \n   * @see #buildRandomQuery\n   */\n  public static SolrInputDocument buildRandomDocument(int id) {\n    SolrInputDocument doc = sdoc(\"id\", id);\n    // most fields are in most docs\n    // if field is in a doc, then \"skewed\" chance val is from a dense range\n    // (hopefully with lots of duplication)\n    if (useField()) {\n      doc.addField(\"int\", skewed(random().nextInt(), \n                                 TestUtil.nextInt(random(), 20, 50)));\n    }\n    if (useField()) {\n      doc.addField(\"long\", skewed(random().nextLong(), \n                                  TestUtil.nextInt(random(), 5000, 5100)));\n    }\n    if (useField()) {\n      doc.addField(\"float\", skewed(random().nextFloat() * random().nextInt(), \n                                   1.0F / random().nextInt(23)));\n    }\n    if (useField()) {\n      doc.addField(\"double\", skewed(random().nextDouble() * random().nextInt(), \n                                    1.0D / random().nextInt(37)));\n    }\n    if (useField()) {\n      doc.addField(\"str\", skewed(randomUsableUnicodeString(),\n                                 TestUtil.randomSimpleString(random(), 1, 1)));\n    }\n    if (useField()) {\n      int numBytes = (int) skewed(TestUtil.nextInt(random(), 20, 50), 2);\n      byte[] randBytes = new byte[numBytes];\n      random().nextBytes(randBytes);\n      doc.addField(\"bin\", ByteBuffer.wrap(randBytes));\n    }\n    if (useField()) {\n      doc.addField(\"date\", skewed(randomDate(),\n                                  dateWithRandomSecondOn2010_10_31_at_10_31()));\n    }\n    if (useField()) {\n      doc.addField(\"uuid\", UUID.randomUUID().toString());\n    }\n    if (useField()) {\n      doc.addField(\"currency\", skewed(\"\" + (random().nextInt() / 100.) + \",\" + randomCurrency(),\n                                      \"\" + TestUtil.nextInt(random(), 250, 320) + \",USD\"));\n    }\n    if (useField()) {\n      doc.addField(\"bool\", random().nextBoolean() ? \"t\" : \"f\");\n    }\n    if (useField()) {\n      doc.addField(\"enum\", randomEnumValue());\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Creates a document with randomized field values, some of which be missing values, \n   * and some of which will be skewed so that small subsets of the ranges will be \n   * more common (resulting in an increased likelihood of duplicate values)\n   * \n   * @see #buildRandomQuery\n   */\n  public static SolrInputDocument buildRandomDocument(int id) {\n    SolrInputDocument doc = sdoc(\"id\", id);\n    // most fields are in most docs\n    // if field is in a doc, then \"skewed\" chance val is from a dense range\n    // (hopefully with lots of duplication)\n    if (useField()) {\n      doc.addField(\"int\", skewed(random().nextInt(), \n                                 TestUtil.nextInt(random(), 20, 50)));\n    }\n    if (useField()) {\n      doc.addField(\"long\", skewed(random().nextLong(), \n                                  TestUtil.nextInt(random(), 5000, 5100)));\n    }\n    if (useField()) {\n      doc.addField(\"float\", skewed(random().nextFloat() * random().nextInt(), \n                                   1.0F / random().nextInt(23)));\n    }\n    if (useField()) {\n      doc.addField(\"double\", skewed(random().nextDouble() * random().nextInt(), \n                                    1.0D / random().nextInt(37)));\n    }\n    if (useField()) {\n      doc.addField(\"str\", skewed(randomUsableUnicodeString(),\n                                 TestUtil.randomSimpleString(random(), 1, 1)));\n\n    }\n    if (useField()) {\n      int numBytes = (int) skewed(TestUtil.nextInt(random(), 20, 50), 2);\n      byte[] randBytes = new byte[numBytes];\n      random().nextBytes(randBytes);\n      doc.addField(\"bin\", ByteBuffer.wrap(randBytes));\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","pathOld":"solr/core/src/test/org/apache/solr/CursorPagingTest#buildRandomDocument(int).mjava","sourceNew":"  /**\n   * Creates a document with randomized field values, some of which be missing values, \n   * and some of which will be skewed so that small subsets of the ranges will be \n   * more common (resulting in an increased likelihood of duplicate values)\n   * \n   * @see #buildRandomQuery\n   */\n  public static SolrInputDocument buildRandomDocument(int id) {\n    SolrInputDocument doc = sdoc(\"id\", id);\n    // most fields are in most docs\n    // if field is in a doc, then \"skewed\" chance val is from a dense range\n    // (hopefully with lots of duplication)\n    if (useField()) {\n      doc.addField(\"int\", skewed(random().nextInt(), \n                                 TestUtil.nextInt(random(), 20, 50)));\n    }\n    if (useField()) {\n      doc.addField(\"long\", skewed(random().nextLong(), \n                                  TestUtil.nextInt(random(), 5000, 5100)));\n    }\n    if (useField()) {\n      doc.addField(\"float\", skewed(random().nextFloat() * random().nextInt(), \n                                   1.0F / random().nextInt(23)));\n    }\n    if (useField()) {\n      doc.addField(\"double\", skewed(random().nextDouble() * random().nextInt(), \n                                    1.0D / random().nextInt(37)));\n    }\n    if (useField()) {\n      doc.addField(\"str\", skewed(randomXmlUsableUnicodeString(),\n                                 TestUtil.randomSimpleString(random(), 1, 1)));\n    }\n    if (useField()) {\n      int numBytes = (int) skewed(TestUtil.nextInt(random(), 20, 50), 2);\n      byte[] randBytes = new byte[numBytes];\n      random().nextBytes(randBytes);\n      doc.addField(\"bin\", ByteBuffer.wrap(randBytes));\n    }\n    if (useField()) {\n      doc.addField(\"date\", skewed(randomDate(), randomSkewedDate()));\n    }\n    if (useField()) {\n      doc.addField(\"uuid\", UUID.randomUUID().toString());\n    }\n    if (useField()) {\n      doc.addField(\"currency\", skewed(\"\" + (random().nextInt() / 100.) + \",\" + randomCurrency(),\n                                      \"\" + TestUtil.nextInt(random(), 250, 320) + \",USD\"));\n    }\n    if (useField()) {\n      doc.addField(\"bool\", random().nextBoolean() ? \"t\" : \"f\");\n    }\n    if (useField()) {\n      doc.addField(\"enum\", randomEnumValue());\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Creates a document with randomized field values, some of which be missing values, \n   * and some of which will be skewed so that small subsets of the ranges will be \n   * more common (resulting in an increased likelihood of duplicate values)\n   * \n   * @see #buildRandomQuery\n   */\n  public static SolrInputDocument buildRandomDocument(int id) {\n    SolrInputDocument doc = sdoc(\"id\", id);\n    // most fields are in most docs\n    // if field is in a doc, then \"skewed\" chance val is from a dense range\n    // (hopefully with lots of duplication)\n    if (useField()) {\n      doc.addField(\"int\", skewed(random().nextInt(), \n                                 TestUtil.nextInt(random(), 20, 50)));\n    }\n    if (useField()) {\n      doc.addField(\"long\", skewed(random().nextLong(), \n                                  TestUtil.nextInt(random(), 5000, 5100)));\n    }\n    if (useField()) {\n      doc.addField(\"float\", skewed(random().nextFloat() * random().nextInt(), \n                                   1.0F / random().nextInt(23)));\n    }\n    if (useField()) {\n      doc.addField(\"double\", skewed(random().nextDouble() * random().nextInt(), \n                                    1.0D / random().nextInt(37)));\n    }\n    if (useField()) {\n      doc.addField(\"str\", skewed(randomUsableUnicodeString(),\n                                 TestUtil.randomSimpleString(random(), 1, 1)));\n    }\n    if (useField()) {\n      int numBytes = (int) skewed(TestUtil.nextInt(random(), 20, 50), 2);\n      byte[] randBytes = new byte[numBytes];\n      random().nextBytes(randBytes);\n      doc.addField(\"bin\", ByteBuffer.wrap(randBytes));\n    }\n    if (useField()) {\n      doc.addField(\"date\", skewed(randomDate(),\n                                  dateWithRandomSecondOn2010_10_31_at_10_31()));\n    }\n    if (useField()) {\n      doc.addField(\"uuid\", UUID.randomUUID().toString());\n    }\n    if (useField()) {\n      doc.addField(\"currency\", skewed(\"\" + (random().nextInt() / 100.) + \",\" + randomCurrency(),\n                                      \"\" + TestUtil.nextInt(random(), 250, 320) + \",USD\"));\n    }\n    if (useField()) {\n      doc.addField(\"bool\", random().nextBoolean() ? \"t\" : \"f\");\n    }\n    if (useField()) {\n      doc.addField(\"enum\", randomEnumValue());\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["6613659748fe4411a7dcf85266e55db1f95f7315","cd3693b696a64d987bf4b3a14399d2105f16b05e"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["cd3693b696a64d987bf4b3a14399d2105f16b05e"],"6613659748fe4411a7dcf85266e55db1f95f7315":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd3693b696a64d987bf4b3a14399d2105f16b05e":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["92751ba9273251eab6a2e379ec42a1697a32ff96"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"92751ba9273251eab6a2e379ec42a1697a32ff96":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6613659748fe4411a7dcf85266e55db1f95f7315":["5eb2511ababf862ea11e10761c70ee560cd84510","cd3693b696a64d987bf4b3a14399d2105f16b05e"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"cd3693b696a64d987bf4b3a14399d2105f16b05e":["5eb2511ababf862ea11e10761c70ee560cd84510","92751ba9273251eab6a2e379ec42a1697a32ff96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}