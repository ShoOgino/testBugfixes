{"path":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#and(DocIdSetIterator).mjava","commits":[{"id":"22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b","date":1414400081,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#and(DocIdSetIterator).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void and(DocIdSetIterator it) throws IOException {\n    final SparseFixedBitSet other = BitSetIterator.getSparseFixedBitSetOrNull(it);\n    if (other != null) {\n      // if we are merging with another SparseFixedBitSet, a quick win is\n      // to clear up some blocks by only looking at their index. Then the set\n      // is sparser and the leap-frog approach of the parent class is more\n      // efficient. Since SparseFixedBitSet is supposed to be used for sparse\n      // sets, the intersection of two SparseFixedBitSet is likely very sparse\n      final int numCommonBlocks = Math.min(indices.length, other.indices.length);\n      for (int i = 0; i < numCommonBlocks; ++i) {\n        if ((indices[i] & other.indices[i]) == 0) {\n          this.nonZeroLongCount -= Long.bitCount(this.indices[i]);\n          this.indices[i] = 0;\n          this.bits[i] = null;\n        }\n      }\n    }\n    super.and(it);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"099c774ddd27f4ad437ca5df14d153bab0a3affe","date":1424527689,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#and(DocIdSetIterator).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void and(DocIdSetIterator it) throws IOException {\n    final SparseFixedBitSet other = BitSetIterator.getSparseFixedBitSetOrNull(it);\n    if (other != null) {\n      // if we are merging with another SparseFixedBitSet, a quick win is\n      // to clear up some blocks by only looking at their index. Then the set\n      // is sparser and the leap-frog approach of the parent class is more\n      // efficient. Since SparseFixedBitSet is supposed to be used for sparse\n      // sets, the intersection of two SparseFixedBitSet is likely very sparse\n      final int numCommonBlocks = Math.min(indices.length, other.indices.length);\n      for (int i = 0; i < numCommonBlocks; ++i) {\n        if ((indices[i] & other.indices[i]) == 0) {\n          this.nonZeroLongCount -= Long.bitCount(this.indices[i]);\n          this.indices[i] = 0;\n          this.bits[i] = null;\n        }\n      }\n    }\n    super.and(it);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"099c774ddd27f4ad437ca5df14d153bab0a3affe":["22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b"],"22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["099c774ddd27f4ad437ca5df14d153bab0a3affe"]},"commit2Childs":{"099c774ddd27f4ad437ca5df14d153bab0a3affe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b":["099c774ddd27f4ad437ca5df14d153bab0a3affe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22aee0e0ecb0d10ebe6ce415b293e64ccf1c0e4b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}