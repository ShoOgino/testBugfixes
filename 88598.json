{"path":"modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl#relateRectanglePhase2(Rectangle,SpatialRelation,SpatialContext).mjava","commits":[{"id":"c2047ba81272a0c4edeb11b1c7810ee23ba73502","date":1329808655,"type":1,"author":"Ryan McKinley","isMerge":false,"pathNew":"modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl#relateRectanglePhase2(Rectangle,SpatialRelation,SpatialContext).mjava","pathOld":"modules/spatial-TEMP/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl#relateRectanglePhase2(Rectangle,SpatialRelation,SpatialContext).mjava","sourceNew":"  protected SpatialRelation relateRectanglePhase2(final Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {\n    /*\n     !! DOES NOT WORK WITH GEO CROSSING DATELINE OR WORLD-WRAP.\n     TODO upgrade to handle crossing dateline, but not world-wrap; use some x-shifting code from RectangleImpl.\n     */\n\n    //At this point, the only thing we are certain of is that circle is *NOT* WITHIN r, since the bounding box of a\n    // circle MUST be within r for the circle to be within r.\n\n    //--Quickly determine if they are DISJOINT or not.\n    //see http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection/1879223#1879223\n    final double closestX;\n    double ctr_x = getXAxis();\n    if ( ctr_x < r.getMinX() )\n      closestX = r.getMinX();\n    else if (ctr_x > r.getMaxX())\n      closestX = r.getMaxX();\n    else\n      closestX = ctr_x;\n\n    final double closestY;\n    double ctr_y = getYAxis();\n    if ( ctr_y < r.getMinY() )\n      closestY = r.getMinY();\n    else if (ctr_y > r.getMaxY())\n      closestY = r.getMaxY();\n    else\n      closestY = ctr_y;\n\n    //Check if there is an intersection from this circle to closestXY\n    boolean didContainOnClosestXY = false;\n    if (ctr_x == closestX) {\n      double deltaY = Math.abs(ctr_y - closestY);\n      double distYCirc = (ctr_y < closestY ? enclosingBox.getMaxY() - ctr_y : ctr_y - enclosingBox.getMinY());\n      if (deltaY > distYCirc)\n        return SpatialRelation.DISJOINT;\n    } else if (ctr_y == closestY) {\n      double deltaX = Math.abs(ctr_x - closestX);\n      double distXCirc = (ctr_x < closestX ? enclosingBox.getMaxX() - ctr_x : ctr_x - enclosingBox.getMinX());\n      if (deltaX > distXCirc)\n        return SpatialRelation.DISJOINT;\n    } else {\n      //fallback on more expensive calculation\n      didContainOnClosestXY = true;\n      if(! contains(closestX,closestY) )\n        return SpatialRelation.DISJOINT;\n    }\n\n    //At this point we know that it's *NOT* DISJOINT, so there is some level of intersection. It's *NOT* WITHIN either.\n    // The only question left is whether circle CONTAINS r or simply intersects it.\n\n    //If circle contains r, then its bbox MUST also CONTAIN r.\n    if (bboxSect != SpatialRelation.CONTAINS)\n      return SpatialRelation.INTERSECTS;\n\n    //Find the farthest point of r away from the center of the circle. If that point is contained, then all of r is\n    // contained.\n    double farthestX = r.getMaxX() - ctr_x > ctr_x - r.getMinX() ? r.getMaxX() : r.getMinX();\n    double farthestY = r.getMaxY() - ctr_y > ctr_y - r.getMinY() ? r.getMaxY() : r.getMinY();\n    if (contains(farthestX,farthestY))\n      return SpatialRelation.CONTAINS;\n    return SpatialRelation.INTERSECTS;\n  }\n\n","sourceOld":"  protected SpatialRelation relateRectanglePhase2(final Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {\n    /*\n     !! DOES NOT WORK WITH GEO CROSSING DATELINE OR WORLD-WRAP.\n     TODO upgrade to handle crossing dateline, but not world-wrap; use some x-shifting code from RectangleImpl.\n     */\n\n    //At this point, the only thing we are certain of is that circle is *NOT* WITHIN r, since the bounding box of a\n    // circle MUST be within r for the circle to be within r.\n\n    //--Quickly determine if they are DISJOINT or not.\n    //see http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection/1879223#1879223\n    final double closestX;\n    double ctr_x = getXAxis();\n    if ( ctr_x < r.getMinX() )\n      closestX = r.getMinX();\n    else if (ctr_x > r.getMaxX())\n      closestX = r.getMaxX();\n    else\n      closestX = ctr_x;\n\n    final double closestY;\n    double ctr_y = getYAxis();\n    if ( ctr_y < r.getMinY() )\n      closestY = r.getMinY();\n    else if (ctr_y > r.getMaxY())\n      closestY = r.getMaxY();\n    else\n      closestY = ctr_y;\n\n    //Check if there is an intersection from this circle to closestXY\n    boolean didContainOnClosestXY = false;\n    if (ctr_x == closestX) {\n      double deltaY = Math.abs(ctr_y - closestY);\n      double distYCirc = (ctr_y < closestY ? enclosingBox.getMaxY() - ctr_y : ctr_y - enclosingBox.getMinY());\n      if (deltaY > distYCirc)\n        return SpatialRelation.DISJOINT;\n    } else if (ctr_y == closestY) {\n      double deltaX = Math.abs(ctr_x - closestX);\n      double distXCirc = (ctr_x < closestX ? enclosingBox.getMaxX() - ctr_x : ctr_x - enclosingBox.getMinX());\n      if (deltaX > distXCirc)\n        return SpatialRelation.DISJOINT;\n    } else {\n      //fallback on more expensive calculation\n      didContainOnClosestXY = true;\n      if(! contains(closestX,closestY) )\n        return SpatialRelation.DISJOINT;\n    }\n\n    //At this point we know that it's *NOT* DISJOINT, so there is some level of intersection. It's *NOT* WITHIN either.\n    // The only question left is whether circle CONTAINS r or simply intersects it.\n\n    //If circle contains r, then its bbox MUST also CONTAIN r.\n    if (bboxSect != SpatialRelation.CONTAINS)\n      return SpatialRelation.INTERSECTS;\n\n    //Find the farthest point of r away from the center of the circle. If that point is contained, then all of r is\n    // contained.\n    double farthestX = r.getMaxX() - ctr_x > ctr_x - r.getMinX() ? r.getMaxX() : r.getMinX();\n    double farthestY = r.getMaxY() - ctr_y > ctr_y - r.getMinY() ? r.getMaxY() : r.getMinY();\n    if (contains(farthestX,farthestY))\n      return SpatialRelation.CONTAINS;\n    return SpatialRelation.INTERSECTS;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a","date":1329809096,"type":5,"author":"Ryan McKinley","isMerge":false,"pathNew":"modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl#relateRectanglePhase2(Rectangle,SpatialRelation,SpatialContext).mjava","pathOld":"modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl#relateRectanglePhase2(Rectangle,SpatialRelation,SpatialContext).mjava","sourceNew":"  protected SpatialRelation relateRectanglePhase2(final Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {\n    /*\n     !! DOES NOT WORK WITH GEO CROSSING DATELINE OR WORLD-WRAP.\n     TODO upgrade to handle crossing dateline, but not world-wrap; use some x-shifting code from RectangleImpl.\n     */\n\n    //At this point, the only thing we are certain of is that circle is *NOT* WITHIN r, since the bounding box of a\n    // circle MUST be within r for the circle to be within r.\n\n    //--Quickly determine if they are DISJOINT or not.\n    //see http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection/1879223#1879223\n    final double closestX;\n    double ctr_x = getXAxis();\n    if ( ctr_x < r.getMinX() )\n      closestX = r.getMinX();\n    else if (ctr_x > r.getMaxX())\n      closestX = r.getMaxX();\n    else\n      closestX = ctr_x;\n\n    final double closestY;\n    double ctr_y = getYAxis();\n    if ( ctr_y < r.getMinY() )\n      closestY = r.getMinY();\n    else if (ctr_y > r.getMaxY())\n      closestY = r.getMaxY();\n    else\n      closestY = ctr_y;\n\n    //Check if there is an intersection from this circle to closestXY\n    boolean didContainOnClosestXY = false;\n    if (ctr_x == closestX) {\n      double deltaY = Math.abs(ctr_y - closestY);\n      double distYCirc = (ctr_y < closestY ? enclosingBox.getMaxY() - ctr_y : ctr_y - enclosingBox.getMinY());\n      if (deltaY > distYCirc)\n        return SpatialRelation.DISJOINT;\n    } else if (ctr_y == closestY) {\n      double deltaX = Math.abs(ctr_x - closestX);\n      double distXCirc = (ctr_x < closestX ? enclosingBox.getMaxX() - ctr_x : ctr_x - enclosingBox.getMinX());\n      if (deltaX > distXCirc)\n        return SpatialRelation.DISJOINT;\n    } else {\n      //fallback on more expensive calculation\n      didContainOnClosestXY = true;\n      if(! contains(closestX,closestY) )\n        return SpatialRelation.DISJOINT;\n    }\n\n    //At this point we know that it's *NOT* DISJOINT, so there is some level of intersection. It's *NOT* WITHIN either.\n    // The only question left is whether circle CONTAINS r or simply intersects it.\n\n    //If circle contains r, then its bbox MUST also CONTAIN r.\n    if (bboxSect != SpatialRelation.CONTAINS)\n      return SpatialRelation.INTERSECTS;\n\n    //Find the farthest point of r away from the center of the circle. If that point is contained, then all of r is\n    // contained.\n    double farthestX = r.getMaxX() - ctr_x > ctr_x - r.getMinX() ? r.getMaxX() : r.getMinX();\n    double farthestY = r.getMaxY() - ctr_y > ctr_y - r.getMinY() ? r.getMaxY() : r.getMinY();\n    if (contains(farthestX,farthestY))\n      return SpatialRelation.CONTAINS;\n    return SpatialRelation.INTERSECTS;\n  }\n\n","sourceOld":"  protected SpatialRelation relateRectanglePhase2(final Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {\n    /*\n     !! DOES NOT WORK WITH GEO CROSSING DATELINE OR WORLD-WRAP.\n     TODO upgrade to handle crossing dateline, but not world-wrap; use some x-shifting code from RectangleImpl.\n     */\n\n    //At this point, the only thing we are certain of is that circle is *NOT* WITHIN r, since the bounding box of a\n    // circle MUST be within r for the circle to be within r.\n\n    //--Quickly determine if they are DISJOINT or not.\n    //see http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection/1879223#1879223\n    final double closestX;\n    double ctr_x = getXAxis();\n    if ( ctr_x < r.getMinX() )\n      closestX = r.getMinX();\n    else if (ctr_x > r.getMaxX())\n      closestX = r.getMaxX();\n    else\n      closestX = ctr_x;\n\n    final double closestY;\n    double ctr_y = getYAxis();\n    if ( ctr_y < r.getMinY() )\n      closestY = r.getMinY();\n    else if (ctr_y > r.getMaxY())\n      closestY = r.getMaxY();\n    else\n      closestY = ctr_y;\n\n    //Check if there is an intersection from this circle to closestXY\n    boolean didContainOnClosestXY = false;\n    if (ctr_x == closestX) {\n      double deltaY = Math.abs(ctr_y - closestY);\n      double distYCirc = (ctr_y < closestY ? enclosingBox.getMaxY() - ctr_y : ctr_y - enclosingBox.getMinY());\n      if (deltaY > distYCirc)\n        return SpatialRelation.DISJOINT;\n    } else if (ctr_y == closestY) {\n      double deltaX = Math.abs(ctr_x - closestX);\n      double distXCirc = (ctr_x < closestX ? enclosingBox.getMaxX() - ctr_x : ctr_x - enclosingBox.getMinX());\n      if (deltaX > distXCirc)\n        return SpatialRelation.DISJOINT;\n    } else {\n      //fallback on more expensive calculation\n      didContainOnClosestXY = true;\n      if(! contains(closestX,closestY) )\n        return SpatialRelation.DISJOINT;\n    }\n\n    //At this point we know that it's *NOT* DISJOINT, so there is some level of intersection. It's *NOT* WITHIN either.\n    // The only question left is whether circle CONTAINS r or simply intersects it.\n\n    //If circle contains r, then its bbox MUST also CONTAIN r.\n    if (bboxSect != SpatialRelation.CONTAINS)\n      return SpatialRelation.INTERSECTS;\n\n    //Find the farthest point of r away from the center of the circle. If that point is contained, then all of r is\n    // contained.\n    double farthestX = r.getMaxX() - ctr_x > ctr_x - r.getMinX() ? r.getMaxX() : r.getMinX();\n    double farthestY = r.getMaxY() - ctr_y > ctr_y - r.getMinY() ? r.getMaxY() : r.getMinY();\n    if (contains(farthestX,farthestY))\n      return SpatialRelation.CONTAINS;\n    return SpatialRelation.INTERSECTS;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c2047ba81272a0c4edeb11b1c7810ee23ba73502":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a":["c2047ba81272a0c4edeb11b1c7810ee23ba73502"]},"commit2Childs":{"c2047ba81272a0c4edeb11b1c7810ee23ba73502":["d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c2047ba81272a0c4edeb11b1c7810ee23ba73502","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}