{"path":"lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator#testLargeSetOfByteArrays().mjava","commits":[{"id":"dd6c9e9b1251473f465b0443b56046b2658402da","date":1332082750,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator#testLargeSetOfByteArrays().mjava","pathOld":"/dev/null","sourceNew":"  // This shows an easy stack overflow because we're counting recursively.\n  public void testLargeSetOfByteArrays() {\n    MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n\n    causeGc();\n    long before = memoryMXBean.getHeapMemoryUsage().getUsed(); \n    Object [] all = new Object [1000000]; \n    for (int i = 0; i < all.length; i++) {\n      all[i] = new byte[random.nextInt(3)];\n    }\n    causeGc();\n    long after = memoryMXBean.getHeapMemoryUsage().getUsed();\n    System.out.println(\"mx:  \" + RamUsageEstimator.humanReadableUnits(after - before));\n    System.out.println(\"rue: \" + RamUsageEstimator.humanReadableUnits(shallowSizeOf(all)));\n\n    guard = all;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator#testLargeSetOfByteArrays().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator#testLargeSetOfByteArrays().mjava","sourceNew":"  // This shows an easy stack overflow because we're counting recursively.\n  public void testLargeSetOfByteArrays() {\n    MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n\n    causeGc();\n    long before = memoryMXBean.getHeapMemoryUsage().getUsed(); \n    Object [] all = new Object [1000000]; \n    for (int i = 0; i < all.length; i++) {\n      all[i] = new byte[random().nextInt(3)];\n    }\n    causeGc();\n    long after = memoryMXBean.getHeapMemoryUsage().getUsed();\n    System.out.println(\"mx:  \" + RamUsageEstimator.humanReadableUnits(after - before));\n    System.out.println(\"rue: \" + RamUsageEstimator.humanReadableUnits(shallowSizeOf(all)));\n\n    guard = all;\n  }\n\n","sourceOld":"  // This shows an easy stack overflow because we're counting recursively.\n  public void testLargeSetOfByteArrays() {\n    MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n\n    causeGc();\n    long before = memoryMXBean.getHeapMemoryUsage().getUsed(); \n    Object [] all = new Object [1000000]; \n    for (int i = 0; i < all.length; i++) {\n      all[i] = new byte[random.nextInt(3)];\n    }\n    causeGc();\n    long after = memoryMXBean.getHeapMemoryUsage().getUsed();\n    System.out.println(\"mx:  \" + RamUsageEstimator.humanReadableUnits(after - before));\n    System.out.println(\"rue: \" + RamUsageEstimator.humanReadableUnits(shallowSizeOf(all)));\n\n    guard = all;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01578325020f17ab9d0ae59f122d17f90c5fecbc","date":1423765178,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator#testLargeSetOfByteArrays().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator#testLargeSetOfByteArrays().mjava","sourceNew":"  // This shows an easy stack overflow because we're counting recursively.\n  public void testLargeSetOfByteArrays() {\n\n    System.gc();\n    long before = Runtime.getRuntime().totalMemory();\n    Object [] all = new Object [1000000]; \n    for (int i = 0; i < all.length; i++) {\n      all[i] = new byte[random().nextInt(3)];\n    }\n    System.gc();\n    long after = Runtime.getRuntime().totalMemory();\n    System.out.println(\"mx:  \" + RamUsageEstimator.humanReadableUnits(after - before));\n    System.out.println(\"rue: \" + RamUsageEstimator.humanReadableUnits(shallowSizeOf(all)));\n\n    guard = all;\n  }\n\n","sourceOld":"  // This shows an easy stack overflow because we're counting recursively.\n  public void testLargeSetOfByteArrays() {\n    MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n\n    causeGc();\n    long before = memoryMXBean.getHeapMemoryUsage().getUsed(); \n    Object [] all = new Object [1000000]; \n    for (int i = 0; i < all.length; i++) {\n      all[i] = new byte[random().nextInt(3)];\n    }\n    causeGc();\n    long after = memoryMXBean.getHeapMemoryUsage().getUsed();\n    System.out.println(\"mx:  \" + RamUsageEstimator.humanReadableUnits(after - before));\n    System.out.println(\"rue: \" + RamUsageEstimator.humanReadableUnits(shallowSizeOf(all)));\n\n    guard = all;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c7ffceea3e516d0dbccfc91acb4ccf856cba19a","date":1579706384,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator#testLargeSetOfByteArrays().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator#testLargeSetOfByteArrays().mjava","sourceNew":"  // This shows an easy stack overflow because we're counting recursively.\n  @Nightly\n  public void testLargeSetOfByteArrays() {\n\n    System.gc();\n    long before = Runtime.getRuntime().totalMemory();\n    Object [] all = new Object [1000000]; \n    for (int i = 0; i < all.length; i++) {\n      all[i] = new byte[random().nextInt(3)];\n    }\n    System.gc();\n    long after = Runtime.getRuntime().totalMemory();\n    System.out.println(\"mx:  \" + RamUsageEstimator.humanReadableUnits(after - before));\n    System.out.println(\"rue: \" + RamUsageEstimator.humanReadableUnits(shallowSizeOf(all)));\n\n    guard = all;\n  }\n\n","sourceOld":"  // This shows an easy stack overflow because we're counting recursively.\n  public void testLargeSetOfByteArrays() {\n\n    System.gc();\n    long before = Runtime.getRuntime().totalMemory();\n    Object [] all = new Object [1000000]; \n    for (int i = 0; i < all.length; i++) {\n      all[i] = new byte[random().nextInt(3)];\n    }\n    System.gc();\n    long after = Runtime.getRuntime().totalMemory();\n    System.out.println(\"mx:  \" + RamUsageEstimator.humanReadableUnits(after - before));\n    System.out.println(\"rue: \" + RamUsageEstimator.humanReadableUnits(shallowSizeOf(all)));\n\n    guard = all;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd6c9e9b1251473f465b0443b56046b2658402da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"01578325020f17ab9d0ae59f122d17f90c5fecbc":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["dd6c9e9b1251473f465b0443b56046b2658402da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c7ffceea3e516d0dbccfc91acb4ccf856cba19a"],"5c7ffceea3e516d0dbccfc91acb4ccf856cba19a":["01578325020f17ab9d0ae59f122d17f90c5fecbc"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dd6c9e9b1251473f465b0443b56046b2658402da"],"dd6c9e9b1251473f465b0443b56046b2658402da":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"01578325020f17ab9d0ae59f122d17f90c5fecbc":["5c7ffceea3e516d0dbccfc91acb4ccf856cba19a"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["01578325020f17ab9d0ae59f122d17f90c5fecbc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"5c7ffceea3e516d0dbccfc91acb4ccf856cba19a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}