{"path":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (ulog == null) return;\n      \n      ulog.bufferUpdates();\n      replayed = false;\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      try {\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        \n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        // System.out.println(\"recover \" + shardZkNodeName + \" against \" +\n        // leaderprops);\n        replicate(zkController.getNodeName(), core, coreZkNodeName,\n            leaderprops, ZkCoreNodeProps.getCoreUrl(baseUrl, coreName));\n        \n        replay(ulog);\n        replayed = true;\n        \n        // if there are pending recovery requests, don't advert as active\n        zkController.publishAsActive(baseUrl, core.getCoreDescriptor(), coreZkNodeName,\n            coreName);\n        \n        succesfulRecovery = true;\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"Recovery was interrupted\", e);\n        retries = INTERRUPTED;\n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      } finally {\n        if (!replayed) {\n          try {\n            ulog.dropBufferedUpdates();\n          } catch (Throwable t) {\n            SolrException.log(log, \"\", t);\n          }\n        }\n        \n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n\n            } else {\n              // TODO: for now, give up after 10 tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (ulog == null) return;\n      \n      ulog.bufferUpdates();\n      replayed = false;\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      try {\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        \n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        // System.out.println(\"recover \" + shardZkNodeName + \" against \" +\n        // leaderprops);\n        replicate(zkController.getNodeName(), core, coreZkNodeName,\n            leaderprops, ZkCoreNodeProps.getCoreUrl(baseUrl, coreName));\n        \n        replay(ulog);\n        replayed = true;\n        \n        // if there are pending recovery requests, don't advert as active\n        zkController.publishAsActive(baseUrl, core.getCoreDescriptor(), coreZkNodeName,\n            coreName);\n        \n        succesfulRecovery = true;\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"Recovery was interrupted\", e);\n        retries = INTERRUPTED;\n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      } finally {\n        if (!replayed) {\n          try {\n            ulog.dropBufferedUpdates();\n          } catch (Throwable t) {\n            SolrException.log(log, \"\", t);\n          }\n        }\n        \n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n\n            } else {\n              // TODO: for now, give up after 10 tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (ulog == null) return;\n      \n      ulog.bufferUpdates();\n      replayed = false;\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      try {\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        \n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        // System.out.println(\"recover \" + shardZkNodeName + \" against \" +\n        // leaderprops);\n        replicate(zkController.getNodeName(), core, coreZkNodeName,\n            leaderprops, ZkCoreNodeProps.getCoreUrl(baseUrl, coreName));\n        \n        replay(ulog);\n        replayed = true;\n        \n        // if there are pending recovery requests, don't advert as active\n        zkController.publishAsActive(baseUrl, core.getCoreDescriptor(), coreZkNodeName,\n            coreName);\n        \n        succesfulRecovery = true;\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"Recovery was interrupted\", e);\n        retries = INTERRUPTED;\n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      } finally {\n        if (!replayed) {\n          try {\n            ulog.dropBufferedUpdates();\n          } catch (Throwable t) {\n            SolrException.log(log, \"\", t);\n          }\n        }\n        \n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n\n            } else {\n              // TODO: for now, give up after 10 tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a752b89ed4b8bfa40e21a23601fbc376340bb3f4","date":1329246954,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      try {\n        // first thing we just try to sync\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = null;\n        \n        leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops.get(ZkStateReader.BASE_URL_PROP), leaderprops.get(ZkStateReader.CORE_NAME_PROP));\n        \n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          return;\n        }\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        if (ulog == null) return;\n        \n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          \n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n      if (ulog == null) return;\n      \n      ulog.bufferUpdates();\n      replayed = false;\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      try {\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        \n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        // System.out.println(\"recover \" + shardZkNodeName + \" against \" +\n        // leaderprops);\n        replicate(zkController.getNodeName(), core, coreZkNodeName,\n            leaderprops, ZkCoreNodeProps.getCoreUrl(baseUrl, coreName));\n        \n        replay(ulog);\n        replayed = true;\n        \n        // if there are pending recovery requests, don't advert as active\n        zkController.publishAsActive(baseUrl, core.getCoreDescriptor(), coreZkNodeName,\n            coreName);\n        \n        succesfulRecovery = true;\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"Recovery was interrupted\", e);\n        retries = INTERRUPTED;\n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      } finally {\n        if (!replayed) {\n          try {\n            ulog.dropBufferedUpdates();\n          } catch (Throwable t) {\n            SolrException.log(log, \"\", t);\n          }\n        }\n        \n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n\n            } else {\n              // TODO: for now, give up after 10 tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":["99a533edf1b9ea2c1b85e012d6e826545389e9c8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"99a533edf1b9ea2c1b85e012d6e826545389e9c8","date":1329256696,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      try {\n        // first thing we just try to sync\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = null;\n        \n        leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops.get(ZkStateReader.BASE_URL_PROP), leaderprops.get(ZkStateReader.CORE_NAME_PROP));\n        \n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          return;\n        }\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        if (ulog == null) {\n          SolrException.log(log, \"No UpdateLog found - cannot recover\");\n          recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n              core.getCoreDescriptor());\n          return;\n        }\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          \n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      try {\n        // first thing we just try to sync\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = null;\n        \n        leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops.get(ZkStateReader.BASE_URL_PROP), leaderprops.get(ZkStateReader.CORE_NAME_PROP));\n        \n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          return;\n        }\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        if (ulog == null) return;\n        \n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          \n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":["a752b89ed4b8bfa40e21a23601fbc376340bb3f4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5d4fc4244db21f4ed1c00098f9c4deeab5275aa","date":1329352216,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(100);\n    } finally {\n      startingRecentUpdates.close();\n    }\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      try {\n        // first thing we just try to sync\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = null;\n        \n        leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops.get(ZkStateReader.BASE_URL_PROP), leaderprops.get(ZkStateReader.CORE_NAME_PROP));\n\n        // TODO: we should only try this the first time through the loop?\n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        peerSync.setStartingVersions(startingRecentVersions);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          return;\n        }\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          \n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      try {\n        // first thing we just try to sync\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = null;\n        \n        leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops.get(ZkStateReader.BASE_URL_PROP), leaderprops.get(ZkStateReader.CORE_NAME_PROP));\n        \n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          return;\n        }\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        if (ulog == null) {\n          SolrException.log(log, \"No UpdateLog found - cannot recover\");\n          recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n              core.getCoreDescriptor());\n          return;\n        }\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          \n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c850a9faa7f2268d78aa6e8a611d281658781a99","date":1329403874,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(100);\n    } finally {\n      startingRecentUpdates.close();\n    }\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n        // first thing we just try to sync\n        zkController.publish(core, ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        peerSync.setStartingVersions(startingRecentVersions);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          succesfulRecovery = true;\n          close = true;\n          return;\n        }\n\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(100);\n    } finally {\n      startingRecentUpdates.close();\n    }\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) {\n      try {\n        // first thing we just try to sync\n        zkController.publish(core, ZkStateReader.RECOVERING);\n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = null;\n        \n        leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops.get(ZkStateReader.BASE_URL_PROP), leaderprops.get(ZkStateReader.CORE_NAME_PROP));\n\n        // TODO: we should only try this the first time through the loop?\n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        peerSync.setStartingVersions(startingRecentVersions);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          return;\n        }\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          \n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a80994db3380cd78c6f65b84515e2e931b6b3da","date":1329530403,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(100);\n    } finally {\n      startingRecentUpdates.close();\n    }\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        peerSync.setStartingVersions(startingRecentVersions);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          succesfulRecovery = true;\n          close = true;\n          return;\n        }\n\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(100);\n    } finally {\n      startingRecentUpdates.close();\n    }\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n        // first thing we just try to sync\n        zkController.publish(core, ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        peerSync.setStartingVersions(startingRecentVersions);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          succesfulRecovery = true;\n          close = true;\n          return;\n        }\n\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5620d3cb34306ea5b7d016a832fbc964b74c2650","date":1329755478,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx < startingRecentVersions.size()) {\n        log.info(\"####### Found new versions added after startup: num=\" + (startingRecentVersions.size()-oldIdx));\n      }\n      \n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n\n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n\n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n\n\n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false;    // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl + \" recoveringAfterStartup=\"+recoveringAfterStartup);\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n\n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n\n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(100);\n    } finally {\n      startingRecentUpdates.close();\n    }\n    \n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        log.info(\"Attempting to PeerSync from \" + leaderUrl);\n        PeerSync peerSync = new PeerSync(core,\n            Collections.singletonList(leaderUrl), 100);\n        peerSync.setStartingVersions(startingRecentVersions);\n        boolean syncSuccess = peerSync.sync();\n        if (syncSuccess) {\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n          log.info(\"Sync Recovery was succesful - registering as Active\");\n          // sync success - register as active and return\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          succesfulRecovery = true;\n          close = true;\n          return;\n        }\n\n        log.info(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b834dd353486678973f4157b3ba402ac3a7ca88","date":1329782329,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx < startingRecentVersions.size()) {\n        log.info(\"####### Found new versions added after startup: num=\" + (startingRecentVersions.size()-oldIdx));\n      }\n      \n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        \n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false; // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl);\n          // System.out.println(\"Attempting to PeerSync from \" + leaderUrl\n          // + \" i am:\" + zkController.getNodeName());\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // System.out\n            // .println(\"Sync Recovery was succesful - registering as Active \"\n            // + zkController.getNodeName());\n            \n            // solrcloud_debug\n            // try {\n            // RefCounted<SolrIndexSearcher> searchHolder =\n            // core.getNewestSearcher(false);\n            // SolrIndexSearcher searcher = searchHolder.get();\n            // try {\n            // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n            // + \" synched \"\n            // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            // } finally {\n            // searchHolder.decref();\n            // }\n            // } catch (Exception e) {\n            //\n            // }\n            \n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n          \n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n        //System.out.println(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx < startingRecentVersions.size()) {\n        log.info(\"####### Found new versions added after startup: num=\" + (startingRecentVersions.size()-oldIdx));\n      }\n      \n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n\n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n\n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n\n\n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false;    // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl + \" recoveringAfterStartup=\"+recoveringAfterStartup);\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n\n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n\n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27cf935b6aeba2a420d4604c00d0e9cef3aae6f6","date":1329788696,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx < startingRecentVersions.size()) {\n        log.info(\"####### Found new versions added after startup: num=\" + (startingRecentVersions.size()-oldIdx));\n      }\n      \n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        \n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false; // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl + \" recoveringAfterStartup=\"+recoveringAfterStartup);\n          // System.out.println(\"Attempting to PeerSync from \" + leaderUrl\n          // + \" i am:\" + zkController.getNodeName());\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // System.out\n            // .println(\"Sync Recovery was succesful - registering as Active \"\n            // + zkController.getNodeName());\n            \n            // solrcloud_debug\n            // try {\n            // RefCounted<SolrIndexSearcher> searchHolder =\n            // core.getNewestSearcher(false);\n            // SolrIndexSearcher searcher = searchHolder.get();\n            // try {\n            // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n            // + \" synched \"\n            // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            // } finally {\n            // searchHolder.decref();\n            // }\n            // } catch (Exception e) {\n            //\n            // }\n            \n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n          \n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n        //System.out.println(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx < startingRecentVersions.size()) {\n        log.info(\"####### Found new versions added after startup: num=\" + (startingRecentVersions.size()-oldIdx));\n      }\n      \n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        \n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false; // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl);\n          // System.out.println(\"Attempting to PeerSync from \" + leaderUrl\n          // + \" i am:\" + zkController.getNodeName());\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // System.out\n            // .println(\"Sync Recovery was succesful - registering as Active \"\n            // + zkController.getNodeName());\n            \n            // solrcloud_debug\n            // try {\n            // RefCounted<SolrIndexSearcher> searchHolder =\n            // core.getNewestSearcher(false);\n            // SolrIndexSearcher searcher = searchHolder.get();\n            // try {\n            // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n            // + \" synched \"\n            // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            // } finally {\n            // searchHolder.decref();\n            // }\n            // } catch (Exception e) {\n            //\n            // }\n            \n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n          \n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n        //System.out.println(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"221ff19d62d5ff429ffecf8e7f3e01ff93754854","date":1329974551,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n    UpdateLog ulog;\n    try {\n      ulog = core.getUpdateHandler().getUpdateLog();\n      if (ulog == null) {\n        SolrException.log(log, \"No UpdateLog found - cannot recover\");\n        recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n            core.getCoreDescriptor());\n        return;\n      }\n    } finally {\n      core.close();\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx < startingRecentVersions.size()) {\n        log.info(\"####### Found new versions added after startup: num=\" + (startingRecentVersions.size()-oldIdx));\n      }\n      \n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      core = cc.getCore(coreName);\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        \n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false; // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl + \" recoveringAfterStartup=\"+recoveringAfterStartup);\n          // System.out.println(\"Attempting to PeerSync from \" + leaderUrl\n          // + \" i am:\" + zkController.getNodeName());\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // System.out\n            // .println(\"Sync Recovery was succesful - registering as Active \"\n            // + zkController.getNodeName());\n            \n            // solrcloud_debug\n            // try {\n            // RefCounted<SolrIndexSearcher> searchHolder =\n            // core.getNewestSearcher(false);\n            // SolrIndexSearcher searcher = searchHolder.get();\n            // try {\n            // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n            // + \" synched \"\n            // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            // } finally {\n            // searchHolder.decref();\n            // }\n            // } catch (Exception e) {\n            //\n            // }\n            \n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n          \n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n        //System.out.println(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n\n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              core = cc.getCore(coreName);\n              try {\n                recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                    core.getCoreDescriptor());\n              } finally {\n                if (core != null) {\n                  core.close();\n                }\n              }\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n    \n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx < startingRecentVersions.size()) {\n        log.info(\"####### Found new versions added after startup: num=\" + (startingRecentVersions.size()-oldIdx));\n      }\n      \n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        \n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false; // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl + \" recoveringAfterStartup=\"+recoveringAfterStartup);\n          // System.out.println(\"Attempting to PeerSync from \" + leaderUrl\n          // + \" i am:\" + zkController.getNodeName());\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // System.out\n            // .println(\"Sync Recovery was succesful - registering as Active \"\n            // + zkController.getNodeName());\n            \n            // solrcloud_debug\n            // try {\n            // RefCounted<SolrIndexSearcher> searchHolder =\n            // core.getNewestSearcher(false);\n            // SolrIndexSearcher searcher = searchHolder.get();\n            // try {\n            // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n            // + \" synched \"\n            // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            // } finally {\n            // searchHolder.decref();\n            // }\n            // } catch (Exception e) {\n            //\n            // }\n            \n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n          \n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n        //System.out.println(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5e10623b80591db7d0c94b1096ee7206cd4641f","date":1330274059,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n    UpdateLog ulog;\n    try {\n      ulog = core.getUpdateHandler().getUpdateLog();\n      if (ulog == null) {\n        SolrException.log(log, \"No UpdateLog found - cannot recover\");\n        recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n            core.getCoreDescriptor());\n        return;\n      }\n    } finally {\n      core.close();\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx > 0) {\n        log.info(\"####### Found new versions added after startup: num=\" + oldIdx);\n      }\n\n      // TODO: only log at debug level in the future (or move to oldIdx > 0 block)\n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      core = cc.getCore(coreName);\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        \n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false; // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl + \" recoveringAfterStartup=\"+recoveringAfterStartup);\n          // System.out.println(\"Attempting to PeerSync from \" + leaderUrl\n          // + \" i am:\" + zkController.getNodeName());\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // System.out\n            // .println(\"Sync Recovery was succesful - registering as Active \"\n            // + zkController.getNodeName());\n            \n            // solrcloud_debug\n            // try {\n            // RefCounted<SolrIndexSearcher> searchHolder =\n            // core.getNewestSearcher(false);\n            // SolrIndexSearcher searcher = searchHolder.get();\n            // try {\n            // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n            // + \" synched \"\n            // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            // } finally {\n            // searchHolder.decref();\n            // }\n            // } catch (Exception e) {\n            //\n            // }\n            \n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n          \n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n        //System.out.println(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n\n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              core = cc.getCore(coreName);\n              try {\n                recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                    core.getCoreDescriptor());\n              } finally {\n                if (core != null) {\n                  core.close();\n                }\n              }\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n    \n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n    UpdateLog ulog;\n    try {\n      ulog = core.getUpdateHandler().getUpdateLog();\n      if (ulog == null) {\n        SolrException.log(log, \"No UpdateLog found - cannot recover\");\n        recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n            core.getCoreDescriptor());\n        return;\n      }\n    } finally {\n      core.close();\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx < startingRecentVersions.size()) {\n        log.info(\"####### Found new versions added after startup: num=\" + (startingRecentVersions.size()-oldIdx));\n      }\n      \n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      core = cc.getCore(coreName);\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        \n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false; // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl + \" recoveringAfterStartup=\"+recoveringAfterStartup);\n          // System.out.println(\"Attempting to PeerSync from \" + leaderUrl\n          // + \" i am:\" + zkController.getNodeName());\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // System.out\n            // .println(\"Sync Recovery was succesful - registering as Active \"\n            // + zkController.getNodeName());\n            \n            // solrcloud_debug\n            // try {\n            // RefCounted<SolrIndexSearcher> searchHolder =\n            // core.getNewestSearcher(false);\n            // SolrIndexSearcher searcher = searchHolder.get();\n            // try {\n            // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n            // + \" synched \"\n            // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            // } finally {\n            // searchHolder.decref();\n            // }\n            // } catch (Exception e) {\n            //\n            // }\n            \n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n          \n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n        //System.out.println(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n\n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              core = cc.getCore(coreName);\n              try {\n                recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                    core.getCoreDescriptor());\n              } finally {\n                if (core != null) {\n                  core.close();\n                }\n              }\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n    \n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff2d7326b1f013c8da9bad45b1e98a3d16c38575","date":1330406992,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n    \n    try {\n      doRecovery(core);\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n    \n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n    UpdateLog ulog;\n    try {\n      ulog = core.getUpdateHandler().getUpdateLog();\n      if (ulog == null) {\n        SolrException.log(log, \"No UpdateLog found - cannot recover\");\n        recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n            core.getCoreDescriptor());\n        return;\n      }\n    } finally {\n      core.close();\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx > 0) {\n        log.info(\"####### Found new versions added after startup: num=\" + oldIdx);\n      }\n\n      // TODO: only log at debug level in the future (or move to oldIdx > 0 block)\n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      core = cc.getCore(coreName);\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      try {\n        // first thing we just try to sync\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n \n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        \n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n        \n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName); \n        \n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n        \n        \n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false; // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl + \" recoveringAfterStartup=\"+recoveringAfterStartup);\n          // System.out.println(\"Attempting to PeerSync from \" + leaderUrl\n          // + \" i am:\" + zkController.getNodeName());\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // System.out\n            // .println(\"Sync Recovery was succesful - registering as Active \"\n            // + zkController.getNodeName());\n            \n            // solrcloud_debug\n            // try {\n            // RefCounted<SolrIndexSearcher> searchHolder =\n            // core.getNewestSearcher(false);\n            // SolrIndexSearcher searcher = searchHolder.get();\n            // try {\n            // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()\n            // + \" synched \"\n            // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            // } finally {\n            // searchHolder.decref();\n            // }\n            // } catch (Exception e) {\n            //\n            // }\n            \n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n          \n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n        //System.out.println(\"Sync Recovery was not successful - trying replication\");\n        \n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n\n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      } finally {\n        if (core != null) {\n          core.close();\n        }\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              core = cc.getCore(coreName);\n              try {\n                recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                    core.getCoreDescriptor());\n              } finally {\n                if (core != null) {\n                  core.close();\n                }\n              }\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n    \n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7241f6cadcc9f475e0bf1eaae71c274e8a07b525","date":1330881818,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n    log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n    try {\n      doRecovery(core);\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n    \n    try {\n      doRecovery(core);\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8de248630034b5863f6795325312ed9b0e697794","date":1330887105,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      doRecovery(core);\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n    log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n    try {\n      doRecovery(core);\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      doRecovery(core);\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    boolean replayed = false;\n    boolean succesfulRecovery = false;\n\n    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n    if (ulog == null) {\n      SolrException.log(log, \"No UpdateLog found - cannot recover\");\n      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n          core.getCoreDescriptor());\n      return;\n    }\n\n    List<Long> startingRecentVersions;\n    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();\n    try {\n      startingRecentVersions = startingRecentUpdates.getVersions(ulog.numRecordsToKeep);\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n    List<Long> reallyStartingVersions = ulog.getStartingVersions();\n\n\n    if (reallyStartingVersions != null && recoveringAfterStartup) {\n      int oldIdx = 0;  // index of the start of the old list in the current list\n      long firstStartingVersion = reallyStartingVersions.size() > 0 ? reallyStartingVersions.get(0) : 0;\n\n      for (; oldIdx<startingRecentVersions.size(); oldIdx++) {\n        if (startingRecentVersions.get(oldIdx) == firstStartingVersion) break;\n      }\n\n      if (oldIdx < startingRecentVersions.size()) {\n        log.info(\"####### Found new versions added after startup: num=\" + (startingRecentVersions.size()-oldIdx));\n      }\n      \n      log.info(\"###### startupVersions=\" + reallyStartingVersions);\n      log.info(\"###### currentVersions=\" + startingRecentVersions);\n    }\n    \n    if (recoveringAfterStartup) {\n      // if we're recovering after startup (i.e. we have been down), then we need to know what the last versions were\n      // when we went down.\n      startingRecentVersions = reallyStartingVersions;\n    }\n\n    boolean firstTime = true;\n\n    while (!succesfulRecovery && !close && !isInterrupted()) { // don't use interruption or it will close channels though\n      try {\n\n        zkController.publish(core.getCoreDescriptor(), ZkStateReader.RECOVERING);\n\n        CloudDescriptor cloudDesc = core.getCoreDescriptor()\n            .getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderProps(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n\n        String leaderBaseUrl = leaderprops.get(ZkStateReader.BASE_URL_PROP);\n        String leaderCoreName = leaderprops.get(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        sendPrepRecoveryCmd(leaderBaseUrl, leaderCoreName);\n\n\n        // first thing we just try to sync\n        if (firstTime) {\n          firstTime = false;    // only try sync the first time through the loop\n          log.info(\"Attempting to PeerSync from \" + leaderUrl + \" recoveringAfterStartup=\"+recoveringAfterStartup);\n          PeerSync peerSync = new PeerSync(core,\n              Collections.singletonList(leaderUrl), ulog.numRecordsToKeep);\n          peerSync.setStartingVersions(startingRecentVersions);\n          boolean syncSuccess = peerSync.sync();\n          if (syncSuccess) {\n            SolrQueryRequest req = new LocalSolrQueryRequest(core,\n                new ModifiableSolrParams());\n            core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n            log.info(\"Sync Recovery was succesful - registering as Active\");\n            // sync success - register as active and return\n            zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n                coreZkNodeName, coreName);\n            succesfulRecovery = true;\n            close = true;\n            return;\n          }\n\n          log.info(\"Sync Recovery was not successful - trying replication\");\n        }\n\n        log.info(\"Begin buffering updates\");\n        ulog.bufferUpdates();\n        replayed = false;\n        \n        try {\n          \n          replicate(zkController.getNodeName(), core,\n              leaderprops, leaderUrl);\n          \n          replay(ulog);\n          replayed = true;\n          \n          log.info(\"Recovery was succesful - registering as Active\");\n          // if there are pending recovery requests, don't advert as active\n          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),\n              coreZkNodeName, coreName);\n          close = true;\n          succesfulRecovery = true;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        } catch (Throwable t) {\n          SolrException.log(log, \"Error while trying to recover\", t);\n        } finally {\n          if (!replayed) {\n            try {\n              ulog.dropBufferedUpdates();\n            } catch (Throwable t) {\n              SolrException.log(log, \"\", t);\n            }\n          }\n          \n        }\n        \n      } catch (Throwable t) {\n        SolrException.log(log, \"Error while trying to recover\", t);\n      }\n      \n      if (!succesfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n          \n          SolrException.log(log, \"Recovery failed - trying again...\");\n          retries++;\n          if (retries >= MAX_RETRIES) {\n            if (retries == INTERRUPTED) {\n              \n            } else {\n              // TODO: for now, give up after X tries - should we do more?\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,\n                  core.getCoreDescriptor());\n            }\n            break;\n          }\n          \n        } catch (Exception e) {\n          SolrException.log(log, \"\", e);\n        }\n        \n        try {\n          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted\", e);\n          retries = INTERRUPTED;\n        }\n      }\n      \n      log.info(\"Finished recovery process\");\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5093a9e893633cc091cf2f729d7863671c2b715","date":1339132888,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      doRecovery(core);\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef9583322dbc8650e3cd32d936c0b3e31eefadba","date":1344482424,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  Core:\" + coreName + \" - recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  Core:\" + coreName + \" - recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40c478fcb4e093ac431407a8db2896ac9c867f33","date":1344540116,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  Core:\" + coreName + \" - recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  Core:\" + coreName + \" - recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","date":1346692465,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      }  catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (Throwable t) {\n        log.error(\"\", t);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", t);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      }  catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (Throwable t) {\n        log.error(\"\", t);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", t);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"bugIntro":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e332392bbbdd01cb69ad6a89051f483cda38e15e","date":1395758779,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    SolrCore core = cc.getCore(coreName);\n    if (core == null) {\n      SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n      return;\n    }\n\n    // set request info for logging\n    try {\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    } finally {\n      if (core != null) core.close();\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","date":1423420267,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"\", e);\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","a5093a9e893633cc091cf2f729d7863671c2b715","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n\n      SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams());\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n\n      log.info(\"Starting recovery process.  core=\" + coreName + \" recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"610f5499a87a7113d53e5b621b616890f002e9f1","date":1450873010,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(LOG, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n\n      LOG.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(LOG, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        LOG.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7392b75d2c2f2aecf31188732a0764fe0dc74ade","date":1489420141,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  final public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(LOG, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n\n      LOG.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(LOG, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        LOG.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(LOG, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n\n      LOG.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(LOG, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        LOG.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  final public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  final public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(LOG, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n\n      LOG.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(LOG, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        LOG.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed5005b977107bba28c700351216f1595e7abe4f","date":1585964712,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  final public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  final public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#run().mjava","sourceNew":"  @Override\n  final public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n\n      log.info(\"Starting recovery process. recoveringAfterStartup={}\", recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  final public void run() {\n\n    // set request info for logging\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        SolrException.log(log, \"SolrCore not found - cannot recover:\" + coreName);\n        return;\n      }\n\n      log.info(\"Starting recovery process. recoveringAfterStartup=\" + recoveringAfterStartup);\n\n      try {\n        doRecovery(core);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        SolrException.log(log, \"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      } catch (Exception e) {\n        log.error(\"\", e);\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"610f5499a87a7113d53e5b621b616890f002e9f1":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"5620d3cb34306ea5b7d016a832fbc964b74c2650":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"ff2d7326b1f013c8da9bad45b1e98a3d16c38575":["b5e10623b80591db7d0c94b1096ee7206cd4641f"],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["27cf935b6aeba2a420d4604c00d0e9cef3aae6f6"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["5620d3cb34306ea5b7d016a832fbc964b74c2650","8de248630034b5863f6795325312ed9b0e697794"],"6b834dd353486678973f4157b3ba402ac3a7ca88":["5620d3cb34306ea5b7d016a832fbc964b74c2650"],"a752b89ed4b8bfa40e21a23601fbc376340bb3f4":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"ed5005b977107bba28c700351216f1595e7abe4f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"ad4957cde742defe6db19689abdc267c5d948066":["ed5005b977107bba28c700351216f1595e7abe4f"],"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e":["e332392bbbdd01cb69ad6a89051f483cda38e15e"],"ef9583322dbc8650e3cd32d936c0b3e31eefadba":["a5093a9e893633cc091cf2f729d7863671c2b715"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"b5e10623b80591db7d0c94b1096ee7206cd4641f":["221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"b5d4fc4244db21f4ed1c00098f9c4deeab5275aa":["99a533edf1b9ea2c1b85e012d6e826545389e9c8"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"40c478fcb4e093ac431407a8db2896ac9c867f33":["ef9583322dbc8650e3cd32d936c0b3e31eefadba"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a5093a9e893633cc091cf2f729d7863671c2b715","40c478fcb4e093ac431407a8db2896ac9c867f33"],"8de248630034b5863f6795325312ed9b0e697794":["7241f6cadcc9f475e0bf1eaae71c274e8a07b525"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e332392bbbdd01cb69ad6a89051f483cda38e15e":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"27cf935b6aeba2a420d4604c00d0e9cef3aae6f6":["6b834dd353486678973f4157b3ba402ac3a7ca88"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["d6f074e73200c07d54f242d3880a8da5a35ff97b","40c478fcb4e093ac431407a8db2896ac9c867f33"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"99a533edf1b9ea2c1b85e012d6e826545389e9c8":["a752b89ed4b8bfa40e21a23601fbc376340bb3f4"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["40c478fcb4e093ac431407a8db2896ac9c867f33"],"c850a9faa7f2268d78aa6e8a611d281658781a99":["b5d4fc4244db21f4ed1c00098f9c4deeab5275aa"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"7241f6cadcc9f475e0bf1eaae71c274e8a07b525":["ff2d7326b1f013c8da9bad45b1e98a3d16c38575"],"a5093a9e893633cc091cf2f729d7863671c2b715":["8de248630034b5863f6795325312ed9b0e697794"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a5093a9e893633cc091cf2f729d7863671c2b715","ef9583322dbc8650e3cd32d936c0b3e31eefadba"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["610f5499a87a7113d53e5b621b616890f002e9f1"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["c850a9faa7f2268d78aa6e8a611d281658781a99"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad4957cde742defe6db19689abdc267c5d948066"]},"commit2Childs":{"610f5499a87a7113d53e5b621b616890f002e9f1":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"5620d3cb34306ea5b7d016a832fbc964b74c2650":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","6b834dd353486678973f4157b3ba402ac3a7ca88"],"ff2d7326b1f013c8da9bad45b1e98a3d16c38575":["7241f6cadcc9f475e0bf1eaae71c274e8a07b525"],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["b5e10623b80591db7d0c94b1096ee7206cd4641f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"6b834dd353486678973f4157b3ba402ac3a7ca88":["27cf935b6aeba2a420d4604c00d0e9cef3aae6f6"],"a752b89ed4b8bfa40e21a23601fbc376340bb3f4":["99a533edf1b9ea2c1b85e012d6e826545389e9c8"],"ed5005b977107bba28c700351216f1595e7abe4f":["ad4957cde742defe6db19689abdc267c5d948066"],"ad4957cde742defe6db19689abdc267c5d948066":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"ef9583322dbc8650e3cd32d936c0b3e31eefadba":["40c478fcb4e093ac431407a8db2896ac9c867f33","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["610f5499a87a7113d53e5b621b616890f002e9f1"],"b5e10623b80591db7d0c94b1096ee7206cd4641f":["ff2d7326b1f013c8da9bad45b1e98a3d16c38575"],"b5d4fc4244db21f4ed1c00098f9c4deeab5275aa":["c850a9faa7f2268d78aa6e8a611d281658781a99"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"40c478fcb4e093ac431407a8db2896ac9c867f33":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"8de248630034b5863f6795325312ed9b0e697794":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a5093a9e893633cc091cf2f729d7863671c2b715"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"e332392bbbdd01cb69ad6a89051f483cda38e15e":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"27cf935b6aeba2a420d4604c00d0e9cef3aae6f6":["221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["e332392bbbdd01cb69ad6a89051f483cda38e15e"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["ed5005b977107bba28c700351216f1595e7abe4f"],"99a533edf1b9ea2c1b85e012d6e826545389e9c8":["b5d4fc4244db21f4ed1c00098f9c4deeab5275aa"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"c850a9faa7f2268d78aa6e8a611d281658781a99":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"7241f6cadcc9f475e0bf1eaae71c274e8a07b525":["8de248630034b5863f6795325312ed9b0e697794"],"a5093a9e893633cc091cf2f729d7863671c2b715":["ef9583322dbc8650e3cd32d936c0b3e31eefadba","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a752b89ed4b8bfa40e21a23601fbc376340bb3f4","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["5620d3cb34306ea5b7d016a832fbc964b74c2650"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0d22ac6a4146774c1bc8400160fc0b6150294e92","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}