{"path":"lucene/join/src/java/org/apache/lucene/search/join/CheckJoinIndex#check(IndexReader,BitSetProducer).mjava","commits":[{"id":"a67f37df79147ed4dd608300c2336c2979db98be","date":1436271524,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/CheckJoinIndex#check(IndexReader,BitSetProducer).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Check that the given index is good to use for block joins.\n   * @throws IllegalStateException if the index does not have an appropriate structure\n   */\n  public static void check(IndexReader reader, BitSetProducer parentsFilter) throws IOException {\n    for (LeafReaderContext context : reader.leaves()) {\n      if (context.reader().maxDoc() == 0) {\n        continue;\n      }\n      final BitSet parents = parentsFilter.getBitSet(context);\n      if (parents == null || parents.cardinality() == 0) {\n        throw new IllegalStateException(\"Every segment should have at least one parent, but \" + context.reader() + \" does not have any\");\n      }\n      if (parents.get(context.reader().maxDoc() - 1) == false) {\n        throw new IllegalStateException(\"The last document of a segment must always be a parent, but \" + context.reader() + \" has a child as a last doc\");\n      }\n      final Bits liveDocs = context.reader().getLiveDocs();\n      if (liveDocs != null) {\n        int prevParentDoc = -1;\n        DocIdSetIterator it = new BitSetIterator(parents, 0L);\n        for (int parentDoc = it.nextDoc(); parentDoc != DocIdSetIterator.NO_MORE_DOCS; parentDoc = it.nextDoc()) {\n          final boolean parentIsLive = liveDocs.get(parentDoc);\n          for (int child = prevParentDoc + 1; child != parentDoc; child++) {\n            final boolean childIsLive = liveDocs.get(child);\n            if (parentIsLive != childIsLive) {\n              if (childIsLive) {\n                throw new IllegalStateException(\"Parent doc \" + parentDoc + \" of segment \" + context.reader() + \" is live but has a deleted child document \" + child);\n              } else {\n                throw new IllegalStateException(\"Parent doc \" + parentDoc + \" of segment \" + context.reader() + \" is deleted but has a live child document \" + child);\n              }\n            }\n          }\n          prevParentDoc = parentDoc;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a67f37df79147ed4dd608300c2336c2979db98be":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a67f37df79147ed4dd608300c2336c2979db98be"]},"commit2Childs":{"a67f37df79147ed4dd608300c2336c2979db98be":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a67f37df79147ed4dd608300c2336c2979db98be"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}