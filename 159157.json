{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","commits":[{"id":"6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09","date":1492411712,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","pathOld":"/dev/null","sourceNew":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n          updateLock.lock();\n\n          if (isClosed) {\n            return;\n          }\n\n          try {\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"326b5c746af092eb827c5c1accdab1b47fe0cf3c","date":1492433195,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","pathOld":"/dev/null","sourceNew":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n          updateLock.lock();\n\n          if (isClosed) {\n            return;\n          }\n\n          try {\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71400ca715aad94c0021a3c96117b63da3a8ebd0","date":1493192933,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","sourceNew":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n          updateLock.lock();\n\n          if (isClosed) {\n            return;\n          }\n\n          try {\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","sourceOld":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n          updateLock.lock();\n\n          if (isClosed) {\n            return;\n          }\n\n          try {\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"905aa4563e11cf584dfe529dc9d3cb4b40cf09e6","date":1493273357,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","sourceNew":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n          updateLock.lock();\n\n          if (isClosed) {\n            return;\n          }\n\n          try {\n            refreshAndWatch();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          } finally {\n            updateLock.unlock();\n          }\n        }\n\n        private void refreshAndWatch() throws KeeperException, InterruptedException {\n          final Stat stat = new Stat();\n          final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n          if (znodeVersion >= stat.getVersion()) {\n            // protect against reordered watcher fires by ensuring that we only move forward\n            return;\n          }\n          znodeVersion = stat.getVersion();\n          Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n          for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n            String triggerName = entry.getKey();\n            AutoScaling.Trigger trigger = entry.getValue();\n            if (trigger.isEnabled()) {\n              activeTriggers.put(triggerName, trigger);\n            } else {\n              activeTriggers.remove(triggerName);\n            }\n          }\n          updated.signalAll();\n        }\n      }, true);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","sourceOld":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n          updateLock.lock();\n\n          if (isClosed) {\n            return;\n          }\n\n          try {\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dba66a8ab7a41db3f6d9b9593a62054ea550a029","date":1493274218,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","sourceNew":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n\n          try {\n            refreshAndWatch();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          }\n        }\n\n        private void refreshAndWatch() throws KeeperException, InterruptedException {\n          updateLock.lock();\n          try {\n            if (isClosed) {\n              return;\n            }\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","sourceOld":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n          updateLock.lock();\n\n          if (isClosed) {\n            return;\n          }\n\n          try {\n            refreshAndWatch();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          } finally {\n            updateLock.unlock();\n          }\n        }\n\n        private void refreshAndWatch() throws KeeperException, InterruptedException {\n          final Stat stat = new Stat();\n          final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n          if (znodeVersion >= stat.getVersion()) {\n            // protect against reordered watcher fires by ensuring that we only move forward\n            return;\n          }\n          znodeVersion = stat.getVersion();\n          Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n          for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n            String triggerName = entry.getKey();\n            AutoScaling.Trigger trigger = entry.getValue();\n            if (trigger.isEnabled()) {\n              activeTriggers.put(triggerName, trigger);\n            } else {\n              activeTriggers.remove(triggerName);\n            }\n          }\n          updated.signalAll();\n        }\n      }, true);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeab392ae80236a184802072a1c27c47d2f6138b","date":1493361556,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","sourceNew":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n\n          try {\n            refreshAndWatch();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          }\n        }\n\n        private void refreshAndWatch() throws KeeperException, InterruptedException {\n          updateLock.lock();\n          try {\n            if (isClosed) {\n              return;\n            }\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n      log.error(\"OverseerTriggerThread could not talk to ZooKeeper\", e);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","sourceOld":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n\n          try {\n            refreshAndWatch();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          }\n        }\n\n        private void refreshAndWatch() throws KeeperException, InterruptedException {\n          updateLock.lock();\n          try {\n            if (isClosed) {\n              return;\n            }\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7699e9ae4550ba2a55335a64ae7de9d5d9de39e","date":1493894873,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","sourceNew":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n\n          try {\n            refreshAndWatch();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          }\n        }\n\n        private void refreshAndWatch() throws KeeperException, InterruptedException {\n          updateLock.lock();\n          try {\n            if (isClosed) {\n              return;\n            }\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            log.debug(\"{} watcher fired with znode version {}\", ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, stat.getVersion());\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n\n            // remove all active triggers that have been removed from ZK\n            Set<String> trackingKeySet = activeTriggers.keySet();\n            trackingKeySet.retainAll(triggerMap.keySet());\n\n            // now lets add or remove triggers which have been enabled or disabled respectively\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n      log.error(\"OverseerTriggerThread could not talk to ZooKeeper\", e);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","sourceOld":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n\n          try {\n            refreshAndWatch();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          }\n        }\n\n        private void refreshAndWatch() throws KeeperException, InterruptedException {\n          updateLock.lock();\n          try {\n            if (isClosed) {\n              return;\n            }\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n      log.error(\"OverseerTriggerThread could not talk to ZooKeeper\", e);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7aa2c1715ef9a80383edea1048655da291ed9b8f","date":1495196478,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/OverseerTriggerThread#createWatcher(SolrZkClient).mjava","sourceNew":null,"sourceOld":"  private void createWatcher(SolrZkClient zkClient) {\n    try {\n      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {\n        @Override\n        public void process(WatchedEvent watchedEvent) {\n          // session events are not change events, and do not remove the watcher\n          if (Event.EventType.None.equals(watchedEvent.getType())) {\n            return;\n          }\n\n          try {\n            refreshAndWatch();\n          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n            log.warn(\"ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n          } catch (KeeperException e) {\n            log.error(\"A ZK error has occurred\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"Interrupted\", e);\n          } catch (Exception e)  {\n            log.error(\"Unexpected exception\", e);\n          }\n        }\n\n        private void refreshAndWatch() throws KeeperException, InterruptedException {\n          updateLock.lock();\n          try {\n            if (isClosed) {\n              return;\n            }\n            final Stat stat = new Stat();\n            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);\n            log.debug(\"{} watcher fired with znode version {}\", ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, stat.getVersion());\n            if (znodeVersion >= stat.getVersion()) {\n              // protect against reordered watcher fires by ensuring that we only move forward\n              return;\n            }\n            znodeVersion = stat.getVersion();\n            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);\n\n            // remove all active triggers that have been removed from ZK\n            Set<String> trackingKeySet = activeTriggers.keySet();\n            trackingKeySet.retainAll(triggerMap.keySet());\n\n            // now lets add or remove triggers which have been enabled or disabled respectively\n            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {\n              String triggerName = entry.getKey();\n              AutoScaling.Trigger trigger = entry.getValue();\n              if (trigger.isEnabled()) {\n                activeTriggers.put(triggerName, trigger);\n              } else {\n                activeTriggers.remove(triggerName);\n              }\n            }\n            updated.signalAll();\n          } finally {\n            updateLock.unlock();\n          }\n        }\n      }, true);\n    } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n      log.error(\"OverseerTriggerThread could not talk to ZooKeeper\", e);\n    } catch (KeeperException e) {\n      log.error(\"Exception in OverseerTriggerThread\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.error(\"OverseerTriggerThread interrupted\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eeab392ae80236a184802072a1c27c47d2f6138b":["dba66a8ab7a41db3f6d9b9593a62054ea550a029"],"dba66a8ab7a41db3f6d9b9593a62054ea550a029":["905aa4563e11cf584dfe529dc9d3cb4b40cf09e6"],"905aa4563e11cf584dfe529dc9d3cb4b40cf09e6":["71400ca715aad94c0021a3c96117b63da3a8ebd0"],"71400ca715aad94c0021a3c96117b63da3a8ebd0":["326b5c746af092eb827c5c1accdab1b47fe0cf3c"],"6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a7699e9ae4550ba2a55335a64ae7de9d5d9de39e":["eeab392ae80236a184802072a1c27c47d2f6138b"],"7aa2c1715ef9a80383edea1048655da291ed9b8f":["a7699e9ae4550ba2a55335a64ae7de9d5d9de39e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"326b5c746af092eb827c5c1accdab1b47fe0cf3c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"eeab392ae80236a184802072a1c27c47d2f6138b":["a7699e9ae4550ba2a55335a64ae7de9d5d9de39e"],"dba66a8ab7a41db3f6d9b9593a62054ea550a029":["eeab392ae80236a184802072a1c27c47d2f6138b"],"905aa4563e11cf584dfe529dc9d3cb4b40cf09e6":["dba66a8ab7a41db3f6d9b9593a62054ea550a029"],"71400ca715aad94c0021a3c96117b63da3a8ebd0":["905aa4563e11cf584dfe529dc9d3cb4b40cf09e6"],"6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09":["326b5c746af092eb827c5c1accdab1b47fe0cf3c"],"a7699e9ae4550ba2a55335a64ae7de9d5d9de39e":["7aa2c1715ef9a80383edea1048655da291ed9b8f"],"7aa2c1715ef9a80383edea1048655da291ed9b8f":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09","326b5c746af092eb827c5c1accdab1b47fe0cf3c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"326b5c746af092eb827c5c1accdab1b47fe0cf3c":["71400ca715aad94c0021a3c96117b63da3a8ebd0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7aa2c1715ef9a80383edea1048655da291ed9b8f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}