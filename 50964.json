{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum.Frame#load(BytesRef).mjava","commits":[{"id":"7266c313bb3b4fbcde3dcc82556182e1fae90080","date":1400183760,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum.Frame#load(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectEnum.Frame#load(BytesRef).mjava","sourceNew":"    void load(BytesRef frameIndexData) throws IOException {\n\n      // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n      if (frameIndexData != null && transitions.length != 0) {\n        // Floor frame\n        if (floorData.length < frameIndexData.length) {\n          this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n        }\n        System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n        floorDataReader.reset(floorData, 0, frameIndexData.length);\n        // Skip first long -- has redundant fp, hasTerms\n        // flag, isFloor flag\n        final long code = floorDataReader.readVLong();\n        if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n          numFollowFloorBlocks = floorDataReader.readVInt();\n          nextFloorLabel = floorDataReader.readByte() & 0xff;\n          // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n          // If current state is accept, we must process\n          // first block in case it has empty suffix:\n          if (!runAutomaton.isAccept(state)) {\n            // Maybe skip floor blocks:\n            while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n              fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n              numFollowFloorBlocks--;\n              // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n              if (numFollowFloorBlocks != 0) {\n                nextFloorLabel = floorDataReader.readByte() & 0xff;\n              } else {\n                nextFloorLabel = 256;\n              }\n            }\n          }\n        }\n      }\n\n      in.seek(fp);\n      int code = in.readVInt();\n      entCount = code >>> 1;\n      assert entCount > 0;\n      isLastInFloor = (code & 1) != 0;\n\n      // term suffixes:\n      code = in.readVInt();\n      isLeafBlock = (code & 1) != 0;\n      int numBytes = code >>> 1;\n      // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n      if (suffixBytes.length < numBytes) {\n        suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      in.readBytes(suffixBytes, 0, numBytes);\n      suffixesReader.reset(suffixBytes, 0, numBytes);\n\n      // stats\n      numBytes = in.readVInt();\n      if (statBytes.length < numBytes) {\n        statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      in.readBytes(statBytes, 0, numBytes);\n      statsReader.reset(statBytes, 0, numBytes);\n      metaDataUpto = 0;\n\n      termState.termBlockOrd = 0;\n      nextEnt = 0;\n         \n      // metadata\n      numBytes = in.readVInt();\n      if (bytes == null) {\n        bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n        bytesReader = new ByteArrayDataInput();\n      } else if (bytes.length < numBytes) {\n        bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      in.readBytes(bytes, 0, numBytes);\n      bytesReader.reset(bytes, 0, numBytes);\n\n      if (!isLastInFloor) {\n        // Sub-blocks of a single floor block are always\n        // written one after another -- tail recurse:\n        fpEnd = in.getFilePointer();\n      }\n    }\n\n","sourceOld":"    void load(BytesRef frameIndexData) throws IOException {\n\n      // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n      if (frameIndexData != null && transitions.length != 0) {\n        // Floor frame\n        if (floorData.length < frameIndexData.length) {\n          this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n        }\n        System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n        floorDataReader.reset(floorData, 0, frameIndexData.length);\n        // Skip first long -- has redundant fp, hasTerms\n        // flag, isFloor flag\n        final long code = floorDataReader.readVLong();\n        if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n          numFollowFloorBlocks = floorDataReader.readVInt();\n          nextFloorLabel = floorDataReader.readByte() & 0xff;\n          // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n          // If current state is accept, we must process\n          // first block in case it has empty suffix:\n          if (!runAutomaton.isAccept(state)) {\n            // Maybe skip floor blocks:\n            while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n              fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n              numFollowFloorBlocks--;\n              // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n              if (numFollowFloorBlocks != 0) {\n                nextFloorLabel = floorDataReader.readByte() & 0xff;\n              } else {\n                nextFloorLabel = 256;\n              }\n            }\n          }\n        }\n      }\n\n      in.seek(fp);\n      int code = in.readVInt();\n      entCount = code >>> 1;\n      assert entCount > 0;\n      isLastInFloor = (code & 1) != 0;\n\n      // term suffixes:\n      code = in.readVInt();\n      isLeafBlock = (code & 1) != 0;\n      int numBytes = code >>> 1;\n      // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n      if (suffixBytes.length < numBytes) {\n        suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      in.readBytes(suffixBytes, 0, numBytes);\n      suffixesReader.reset(suffixBytes, 0, numBytes);\n\n      // stats\n      numBytes = in.readVInt();\n      if (statBytes.length < numBytes) {\n        statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      in.readBytes(statBytes, 0, numBytes);\n      statsReader.reset(statBytes, 0, numBytes);\n      metaDataUpto = 0;\n\n      termState.termBlockOrd = 0;\n      nextEnt = 0;\n         \n      // metadata\n      numBytes = in.readVInt();\n      if (bytes == null) {\n        bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n        bytesReader = new ByteArrayDataInput();\n      } else if (bytes.length < numBytes) {\n        bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      in.readBytes(bytes, 0, numBytes);\n      bytesReader.reset(bytes, 0, numBytes);\n\n      if (!isLastInFloor) {\n        // Sub-blocks of a single floor block are always\n        // written one after another -- tail recurse:\n        fpEnd = in.getFilePointer();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f5c96ee46366b5feece8b0b328368c6237fc087a","date":1400184255,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum.Frame#load(BytesRef).mjava","sourceNew":null,"sourceOld":"    void load(BytesRef frameIndexData) throws IOException {\n\n      // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n      if (frameIndexData != null && transitions.length != 0) {\n        // Floor frame\n        if (floorData.length < frameIndexData.length) {\n          this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n        }\n        System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n        floorDataReader.reset(floorData, 0, frameIndexData.length);\n        // Skip first long -- has redundant fp, hasTerms\n        // flag, isFloor flag\n        final long code = floorDataReader.readVLong();\n        if ((code & BlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n          numFollowFloorBlocks = floorDataReader.readVInt();\n          nextFloorLabel = floorDataReader.readByte() & 0xff;\n          // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n          // If current state is accept, we must process\n          // first block in case it has empty suffix:\n          if (!runAutomaton.isAccept(state)) {\n            // Maybe skip floor blocks:\n            while (numFollowFloorBlocks != 0 && nextFloorLabel <= transitions[0].getMin()) {\n              fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n              numFollowFloorBlocks--;\n              // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n              if (numFollowFloorBlocks != 0) {\n                nextFloorLabel = floorDataReader.readByte() & 0xff;\n              } else {\n                nextFloorLabel = 256;\n              }\n            }\n          }\n        }\n      }\n\n      in.seek(fp);\n      int code = in.readVInt();\n      entCount = code >>> 1;\n      assert entCount > 0;\n      isLastInFloor = (code & 1) != 0;\n\n      // term suffixes:\n      code = in.readVInt();\n      isLeafBlock = (code & 1) != 0;\n      int numBytes = code >>> 1;\n      // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n      if (suffixBytes.length < numBytes) {\n        suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      in.readBytes(suffixBytes, 0, numBytes);\n      suffixesReader.reset(suffixBytes, 0, numBytes);\n\n      // stats\n      numBytes = in.readVInt();\n      if (statBytes.length < numBytes) {\n        statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      in.readBytes(statBytes, 0, numBytes);\n      statsReader.reset(statBytes, 0, numBytes);\n      metaDataUpto = 0;\n\n      termState.termBlockOrd = 0;\n      nextEnt = 0;\n         \n      // metadata\n      numBytes = in.readVInt();\n      if (bytes == null) {\n        bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n        bytesReader = new ByteArrayDataInput();\n      } else if (bytes.length < numBytes) {\n        bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      }\n      in.readBytes(bytes, 0, numBytes);\n      bytesReader.reset(bytes, 0, numBytes);\n\n      if (!isLastInFloor) {\n        // Sub-blocks of a single floor block are always\n        // written one after another -- tail recurse:\n        fpEnd = in.getFilePointer();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7266c313bb3b4fbcde3dcc82556182e1fae90080":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f5c96ee46366b5feece8b0b328368c6237fc087a":["7266c313bb3b4fbcde3dcc82556182e1fae90080"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"7266c313bb3b4fbcde3dcc82556182e1fae90080":["f5c96ee46366b5feece8b0b328368c6237fc087a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7266c313bb3b4fbcde3dcc82556182e1fae90080","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f5c96ee46366b5feece8b0b328368c6237fc087a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f5c96ee46366b5feece8b0b328368c6237fc087a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}