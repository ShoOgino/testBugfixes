{"path":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","commits":[{"id":"f7ded2c2e6e2974f9824068a6d9c3a5edfe8843c","date":1274823128,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","pathOld":"/dev/null","sourceNew":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an exception if invalid UTF8 is passed).\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char. */ \n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n\n    while (offset < len) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ba7a352ee55bf079f41a3af0f9ff15eec2de269","date":1274959729,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","pathOld":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","sourceNew":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n\n    while (offset < len) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","sourceOld":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an exception if invalid UTF8 is passed).\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char. */ \n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n\n    while (offset < len) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be20f9fed1d3edcb1c84abcc39df87a90fab22df","date":1275590285,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","pathOld":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","sourceNew":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","sourceOld":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n\n    while (offset < len) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1b3a24d5d9b47345473ff564f5cc127a7b526b4","date":1306277076,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["5ba7a352ee55bf079f41a3af0f9ff15eec2de269"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["be20f9fed1d3edcb1c84abcc39df87a90fab22df","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"5ba7a352ee55bf079f41a3af0f9ff15eec2de269":["f7ded2c2e6e2974f9824068a6d9c3a5edfe8843c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"f7ded2c2e6e2974f9824068a6d9c3a5edfe8843c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["be20f9fed1d3edcb1c84abcc39df87a90fab22df","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"]},"commit2Childs":{"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","a1b3a24d5d9b47345473ff564f5cc127a7b526b4","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f7ded2c2e6e2974f9824068a6d9c3a5edfe8843c"],"5ba7a352ee55bf079f41a3af0f9ff15eec2de269":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"f7ded2c2e6e2974f9824068a6d9c3a5edfe8843c":["5ba7a352ee55bf079f41a3af0f9ff15eec2de269"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}