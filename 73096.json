{"path":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","commits":[{"id":"ccc08aa684aee4964baee0644a6ba047bfd70829","date":1316263707,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, String>> tempSearchGroupToShard = new HashMap<String, Map<SearchGroup<BytesRef>, String>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShard.put(field, new HashMap<SearchGroup<BytesRef>, String>());\n      if (!rb.searchGroupToShard.containsKey(field)) {\n        rb.searchGroupToShard.put(field, new HashMap<SearchGroup<BytesRef>, String>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      for (ShardResponse srsp : shardRequest.responses) {\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            tempSearchGroupToShard.get(field).put(searchGroup, srsp.getShard());\n          }\n        }\n      }\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShard.get(groupField).put(mergedTopGroup, tempSearchGroupToShard.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["27270b721a573cf4b774ce70b062078ef490388e","af20870f6eab3807c968eec0b24e0c4358d0c1e5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27270b721a573cf4b774ce70b062078ef490388e","date":1329092012,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      for (ShardResponse srsp : shardRequest.responses) {\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n      }\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, String>> tempSearchGroupToShard = new HashMap<String, Map<SearchGroup<BytesRef>, String>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShard.put(field, new HashMap<SearchGroup<BytesRef>, String>());\n      if (!rb.searchGroupToShard.containsKey(field)) {\n        rb.searchGroupToShard.put(field, new HashMap<SearchGroup<BytesRef>, String>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      for (ShardResponse srsp : shardRequest.responses) {\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            tempSearchGroupToShard.get(field).put(searchGroup, srsp.getShard());\n          }\n        }\n      }\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShard.get(groupField).put(mergedTopGroup, tempSearchGroupToShard.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a250ecd3e83b1c6595bcae0474f5b258df42021b","date":1330943490,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n      }\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      for (ShardResponse srsp : shardRequest.responses) {\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n      }\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n      }\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      for (ShardResponse srsp : shardRequest.responses) {\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n      }\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"612521de57bdf68711c68b6d8565e4a80ca0d7f6","date":1333716414,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n      }\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af20870f6eab3807c968eec0b24e0c4358d0c1e5","date":1337002937,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Collection<SearchGroup<BytesRef>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Collection<SearchGroup<BytesRef>> searchGroups = result.get(field);\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2d7ec084be7fa496e6f93352b6e10427881eb35","date":1372781416,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n      for (ShardResponse srsp : shardRequest.responses) {\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d31e5ade44c0d23378d22781e2f2c293afdb25d","date":1386771146,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"167c9d3137acf706f53c875de69f3165df85fd3b","date":1391327271,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n            rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n            rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<String, List<Collection<SearchGroup<BytesRef>>>>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<String, Map<SearchGroup<BytesRef>, Set<String>>>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<Object>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n            rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<String>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"97b865fb5b6ef0e08dcafe96ab9cdbcd1cbd0943","date":1440670426,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n            rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n            rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        Map<String, Pair<Integer, Collection<SearchGroup<BytesRef>>>> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          Pair<Integer, Collection<SearchGroup<BytesRef>>> firstPhaseCommandResult = result.get(field);\n          Integer groupCount = firstPhaseCommandResult.getA();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getB();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","date":1448513807,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n            rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n            rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, null, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83b038ad0480d5e81e058bf9fafb2dd85399985d","date":1450812495,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n            rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbbb695ed8551289ce2b81a666fa48b6b091fdec","date":1452861799,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>();\n    Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>();\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a63d32fe2b29dda520043ef60a1424a4d9ccd5c","date":1480426632,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b101c3c0e7f5871415e80d970cb3289309f3522e","date":1480511898,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03e38c6374c23083c93e212a9498ff0a9c255476","date":1484767039,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    try {\n      int maxElapsedTime = 0;\n      int hitCountDuringFirstPhase = 0;\n\n      NamedList<Object> shardInfo = null;\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n      }\n\n      for (ShardResponse srsp : shardRequest.responses) {\n        if (shardInfo != null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if (t instanceof SolrServerException) {\n              t = ((SolrServerException) t).getCause();\n            }\n            nl.add(\"error\", t.toString());\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString());\n          } else {\n            nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n          }\n          if (srsp.getSolrResponse() != null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n          if (srsp.getShardAddress() != null) {\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n          if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n            rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n          }\n          continue; // continue if there was an error and we're tolerant.  \n        }\n        maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n        @SuppressWarnings(\"unchecked\")\n        NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n        final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n        for (String field : commandSearchGroups.keySet()) {\n          final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n          final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n          if (groupCount != null) {\n            Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n            // Assuming groups don't cross shard boundary...\n            rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n          }\n\n          final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n          if (searchGroups == null) {\n            continue;\n          }\n\n          commandSearchGroups.get(field).add(searchGroups);\n          for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n            Map<SearchGroup<BytesRef>, java.util.Set<String>> map = tempSearchGroupToShards.get(field);\n            Set<String> shards = map.get(searchGroup);\n            if (shards == null) {\n              shards = new HashSet<>();\n              map.put(searchGroup, shards);\n            }\n            shards.add(srsp.getShard());\n          }\n        }\n        hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n      }\n      rb.totalHitCount = hitCountDuringFirstPhase;\n      rb.firstPhaseElapsedTime = maxElapsedTime;\n      for (String groupField : commandSearchGroups.keySet()) {\n        List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n        Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n        if (mergedTopGroups == null) {\n          continue;\n        }\n\n        rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n        for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n          rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4958642f967bfbd6f083ddf50f141bcde89b9ec1","date":1489572234,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bca83a747f8e297ee4412c0d18bdd3a98c09df3b","date":1489651910,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? existingGroupCount + groupCount : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55f7a37353edeecde86a45f4895ef74901a0158b","date":1492601294,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abfb863f06f3864fb823792c7c7e20523f1537ce","date":1495727206,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1f5728f32a4a256b36cfabd7a2636452f599bb9","date":1496231774,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec ss = rb.getSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, ss.getOffset(), ss.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a80a37ae73034270b57bfd57a44f8fcadc952fa0","date":1515440719,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd22dcd3ba035a1626face7319c94be45ae07172","date":1527224634,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":["03e38c6374c23083c93e212a9498ff0a9c255476","a2d7ec084be7fa496e6f93352b6e10427881eb35"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85bef26bbc598445704c1f9c6d7953f3942d5426","date":1562162588,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getWithinGroupSortSpec().getSort();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getWithinGroupSortSpec().getSort();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (Map.Entry<String, List<Collection<SearchGroup<BytesRef>>>> entry : commandSearchGroups.entrySet()) {\n        String field = entry.getKey();\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        entry.getValue().add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (Map.Entry<String, List<Collection<SearchGroup<BytesRef>>>> entry : commandSearchGroups.entrySet()) {\n      String groupField = entry.getKey();\n      List<Collection<SearchGroup<BytesRef>>> topGroups = entry.getValue();\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getWithinGroupSortSpec().getSort();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getWithinGroupSortSpec().getSort();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (Map.Entry<String, List<Collection<SearchGroup<BytesRef>>>> entry : commandSearchGroups.entrySet()) {\n        String field = entry.getKey();\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        entry.getValue().add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (Map.Entry<String, List<Collection<SearchGroup<BytesRef>>>> entry : commandSearchGroups.entrySet()) {\n      String groupField = entry.getKey();\n      List<Collection<SearchGroup<BytesRef>>> topGroups = entry.getValue();\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getWithinGroupSortSpec().getSort();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (String field : commandSearchGroups.keySet()) {\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        commandSearchGroups.get(field).add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (String groupField : commandSearchGroups.keySet()) {\n      List<Collection<SearchGroup<BytesRef>>> topGroups = commandSearchGroups.get(groupField);\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50dfd19525c8d73e856dca6edb64b7aea074037f","date":1591579225,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/SearchGroupShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getWithinGroupSortSpec().getSort();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (Map.Entry<String, List<Collection<SearchGroup<BytesRef>>>> entry : commandSearchGroups.entrySet()) {\n        String field = entry.getKey();\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        entry.getValue().add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (Map.Entry<String, List<Collection<SearchGroup<BytesRef>>>> entry : commandSearchGroups.entrySet()) {\n      String groupField = entry.getKey();\n      List<Collection<SearchGroup<BytesRef>>> topGroups = entry.getValue();\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    SortSpec groupSortSpec = rb.getGroupingSpec().getGroupSortSpec();\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    final String[] fields = rb.getGroupingSpec().getFields();\n    Sort withinGroupSort = rb.getGroupingSpec().getWithinGroupSortSpec().getSort();\n    assert withinGroupSort != null;\n\n    final Map<String, List<Collection<SearchGroup<BytesRef>>>> commandSearchGroups = new HashMap<>(fields.length, 1.0f);\n    final Map<String, Map<SearchGroup<BytesRef>, Set<String>>> tempSearchGroupToShards = new HashMap<>(fields.length, 1.0f);\n    for (String field : fields) {\n      commandSearchGroups.put(field, new ArrayList<Collection<SearchGroup<BytesRef>>>(shardRequest.responses.size()));\n      tempSearchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      if (!rb.searchGroupToShards.containsKey(field)) {\n        rb.searchGroupToShards.put(field, new HashMap<SearchGroup<BytesRef>, Set<String>>());\n      }\n    }\n\n    SearchGroupsResultTransformer serializer = new SearchGroupsResultTransformer(rb.req.getSearcher());\n    int maxElapsedTime = 0;\n    int hitCountDuringFirstPhase = 0;\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>(shardRequest.responses.size());\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO + \".firstPhase\", shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      if (shardInfo != null) {\n        SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>(4);\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          nl.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          nl.add(\"trace\", trace.toString());\n        } else {\n          nl.add(\"numFound\", (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\"));\n        }\n        if (srsp.getSolrResponse() != null) {\n          nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          nl.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), nl);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.\n      }\n      maxElapsedTime = (int) Math.max(maxElapsedTime, srsp.getSolrResponse().getElapsedTime());\n      @SuppressWarnings(\"unchecked\")\n      NamedList<NamedList> firstPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"firstPhase\");\n      final Map<String, SearchGroupsFieldCommandResult> result = serializer.transformToNative(firstPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      for (Map.Entry<String, List<Collection<SearchGroup<BytesRef>>>> entry : commandSearchGroups.entrySet()) {\n        String field = entry.getKey();\n        final SearchGroupsFieldCommandResult firstPhaseCommandResult = result.get(field);\n\n        final Integer groupCount = firstPhaseCommandResult.getGroupCount();\n        if (groupCount != null) {\n          Integer existingGroupCount = rb.mergedGroupCounts.get(field);\n          // Assuming groups don't cross shard boundary...\n          rb.mergedGroupCounts.put(field, existingGroupCount != null ? Integer.valueOf(existingGroupCount + groupCount) : groupCount);\n        }\n\n        final Collection<SearchGroup<BytesRef>> searchGroups = firstPhaseCommandResult.getSearchGroups();\n        if (searchGroups == null) {\n          continue;\n        }\n\n        entry.getValue().add(searchGroups);\n        for (SearchGroup<BytesRef> searchGroup : searchGroups) {\n          Map<SearchGroup<BytesRef>, Set<String>> map = tempSearchGroupToShards.get(field);\n          Set<String> shards = map.get(searchGroup);\n          if (shards == null) {\n            shards = new HashSet<>();\n            map.put(searchGroup, shards);\n          }\n          shards.add(srsp.getShard());\n        }\n      }\n      hitCountDuringFirstPhase += (Integer) srsp.getSolrResponse().getResponse().get(\"totalHitCount\");\n    }\n    rb.totalHitCount = hitCountDuringFirstPhase;\n    rb.firstPhaseElapsedTime = maxElapsedTime;\n    for (Map.Entry<String, List<Collection<SearchGroup<BytesRef>>>> entry : commandSearchGroups.entrySet()) {\n      String groupField = entry.getKey();\n      List<Collection<SearchGroup<BytesRef>>> topGroups = entry.getValue();\n      Collection<SearchGroup<BytesRef>> mergedTopGroups = SearchGroup.merge(topGroups, groupSortSpec.getOffset(), groupSortSpec.getCount(), groupSort);\n      if (mergedTopGroups == null) {\n        continue;\n      }\n\n      rb.mergedSearchGroups.put(groupField, mergedTopGroups);\n      for (SearchGroup<BytesRef> mergedTopGroup : mergedTopGroups) {\n        rb.searchGroupToShards.get(groupField).put(mergedTopGroup, tempSearchGroupToShards.get(groupField).get(mergedTopGroup));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["ab68488225b6a6c357dda72ed11dedca9914a192"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["af20870f6eab3807c968eec0b24e0c4358d0c1e5","7530de27b87b961b51f01bd1299b7004d46e8823"],"b94236357aaa22b76c10629851fe4e376e0cea82":["d1f5728f32a4a256b36cfabd7a2636452f599bb9","a80a37ae73034270b57bfd57a44f8fcadc952fa0"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["7530de27b87b961b51f01bd1299b7004d46e8823","a2d7ec084be7fa496e6f93352b6e10427881eb35"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["27270b721a573cf4b774ce70b062078ef490388e","a250ecd3e83b1c6595bcae0474f5b258df42021b"],"5d31e5ade44c0d23378d22781e2f2c293afdb25d":["a2d7ec084be7fa496e6f93352b6e10427881eb35"],"a250ecd3e83b1c6595bcae0474f5b258df42021b":["27270b721a573cf4b774ce70b062078ef490388e"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a80a37ae73034270b57bfd57a44f8fcadc952fa0":["d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["bd22dcd3ba035a1626face7319c94be45ae07172"],"a2d7ec084be7fa496e6f93352b6e10427881eb35":["7530de27b87b961b51f01bd1299b7004d46e8823"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["97b865fb5b6ef0e08dcafe96ab9cdbcd1cbd0943"],"612521de57bdf68711c68b6d8565e4a80ca0d7f6":["a250ecd3e83b1c6595bcae0474f5b258df42021b"],"55f7a37353edeecde86a45f4895ef74901a0158b":["4958642f967bfbd6f083ddf50f141bcde89b9ec1"],"0a63d32fe2b29dda520043ef60a1424a4d9ccd5c":["fbbb695ed8551289ce2b81a666fa48b6b091fdec"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"abfb863f06f3864fb823792c7c7e20523f1537ce":["55f7a37353edeecde86a45f4895ef74901a0158b"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","abfb863f06f3864fb823792c7c7e20523f1537ce"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["85bef26bbc598445704c1f9c6d7953f3942d5426"],"97b865fb5b6ef0e08dcafe96ab9cdbcd1cbd0943":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b101c3c0e7f5871415e80d970cb3289309f3522e":["fbbb695ed8551289ce2b81a666fa48b6b091fdec","0a63d32fe2b29dda520043ef60a1424a4d9ccd5c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"af20870f6eab3807c968eec0b24e0c4358d0c1e5":["612521de57bdf68711c68b6d8565e4a80ca0d7f6"],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["03e38c6374c23083c93e212a9498ff0a9c255476"],"9856095f7afb5a607bf5e65077615ed91273508c":["fbbb695ed8551289ce2b81a666fa48b6b091fdec","b101c3c0e7f5871415e80d970cb3289309f3522e"],"ab68488225b6a6c357dda72ed11dedca9914a192":["03e38c6374c23083c93e212a9498ff0a9c255476","bca83a747f8e297ee4412c0d18bdd3a98c09df3b"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["55f7a37353edeecde86a45f4895ef74901a0158b","abfb863f06f3864fb823792c7c7e20523f1537ce"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["03e38c6374c23083c93e212a9498ff0a9c255476"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["167c9d3137acf706f53c875de69f3165df85fd3b"],"27270b721a573cf4b774ce70b062078ef490388e":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"fbbb695ed8551289ce2b81a666fa48b6b091fdec":["83b038ad0480d5e81e058bf9fafb2dd85399985d"],"167c9d3137acf706f53c875de69f3165df85fd3b":["5d31e5ade44c0d23378d22781e2f2c293afdb25d"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["9856095f7afb5a607bf5e65077615ed91273508c","03e38c6374c23083c93e212a9498ff0a9c255476"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"03e38c6374c23083c93e212a9498ff0a9c255476":["b101c3c0e7f5871415e80d970cb3289309f3522e"],"85bef26bbc598445704c1f9c6d7953f3942d5426":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"bd22dcd3ba035a1626face7319c94be45ae07172":["b94236357aaa22b76c10629851fe4e376e0cea82"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a2d7ec084be7fa496e6f93352b6e10427881eb35","5d31e5ade44c0d23378d22781e2f2c293afdb25d"],"7530de27b87b961b51f01bd1299b7004d46e8823":["af20870f6eab3807c968eec0b24e0c4358d0c1e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"b0b597c65628ca9e73913a07e81691f8229bae35":["85bef26bbc598445704c1f9c6d7953f3942d5426","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"b94236357aaa22b76c10629851fe4e376e0cea82":["bd22dcd3ba035a1626face7319c94be45ae07172"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"5d31e5ade44c0d23378d22781e2f2c293afdb25d":["167c9d3137acf706f53c875de69f3165df85fd3b","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"a80a37ae73034270b57bfd57a44f8fcadc952fa0":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a250ecd3e83b1c6595bcae0474f5b258df42021b":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","612521de57bdf68711c68b6d8565e4a80ca0d7f6"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["27270b721a573cf4b774ce70b062078ef490388e"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["85bef26bbc598445704c1f9c6d7953f3942d5426"],"a2d7ec084be7fa496e6f93352b6e10427881eb35":["37a0f60745e53927c4c876cfe5b5a58170f0646c","5d31e5ade44c0d23378d22781e2f2c293afdb25d","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["83b038ad0480d5e81e058bf9fafb2dd85399985d"],"612521de57bdf68711c68b6d8565e4a80ca0d7f6":["af20870f6eab3807c968eec0b24e0c4358d0c1e5"],"55f7a37353edeecde86a45f4895ef74901a0158b":["abfb863f06f3864fb823792c7c7e20523f1537ce","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"0a63d32fe2b29dda520043ef60a1424a4d9ccd5c":["b101c3c0e7f5871415e80d970cb3289309f3522e"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["fbbb695ed8551289ce2b81a666fa48b6b091fdec"],"abfb863f06f3864fb823792c7c7e20523f1537ce":["e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"97b865fb5b6ef0e08dcafe96ab9cdbcd1cbd0943":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["50dfd19525c8d73e856dca6edb64b7aea074037f","b0b597c65628ca9e73913a07e81691f8229bae35"],"b101c3c0e7f5871415e80d970cb3289309f3522e":["9856095f7afb5a607bf5e65077615ed91273508c","03e38c6374c23083c93e212a9498ff0a9c255476"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"af20870f6eab3807c968eec0b24e0c4358d0c1e5":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["ab68488225b6a6c357dda72ed11dedca9914a192"],"9856095f7afb5a607bf5e65077615ed91273508c":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"ab68488225b6a6c357dda72ed11dedca9914a192":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["b94236357aaa22b76c10629851fe4e376e0cea82","a80a37ae73034270b57bfd57a44f8fcadc952fa0"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["55f7a37353edeecde86a45f4895ef74901a0158b"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["97b865fb5b6ef0e08dcafe96ab9cdbcd1cbd0943"],"27270b721a573cf4b774ce70b062078ef490388e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a250ecd3e83b1c6595bcae0474f5b258df42021b"],"fbbb695ed8551289ce2b81a666fa48b6b091fdec":["0a63d32fe2b29dda520043ef60a1424a4d9ccd5c","b101c3c0e7f5871415e80d970cb3289309f3522e","9856095f7afb5a607bf5e65077615ed91273508c"],"167c9d3137acf706f53c875de69f3165df85fd3b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"03e38c6374c23083c93e212a9498ff0a9c255476":["bca83a747f8e297ee4412c0d18bdd3a98c09df3b","ab68488225b6a6c357dda72ed11dedca9914a192","4958642f967bfbd6f083ddf50f141bcde89b9ec1","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bd22dcd3ba035a1626face7319c94be45ae07172":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"85bef26bbc598445704c1f9c6d7953f3942d5426":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","b0b597c65628ca9e73913a07e81691f8229bae35"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","a2d7ec084be7fa496e6f93352b6e10427881eb35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e9017cf144952056066919f1ebc7897ff9bd71b1","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}