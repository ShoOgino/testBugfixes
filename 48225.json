{"path":"modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl#GeoCircleImpl(Point,double,SpatialContext).mjava","commits":[{"id":"c2047ba81272a0c4edeb11b1c7810ee23ba73502","date":1329808655,"type":1,"author":"Ryan McKinley","isMerge":false,"pathNew":"modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl#GeoCircleImpl(Point,double,SpatialContext).mjava","pathOld":"modules/spatial-TEMP/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl#GeoCircleImpl(Point,double,SpatialContext).mjava","sourceNew":"  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {\n    super(p, dist, ctx);\n    assert ctx.isGeo();\n\n    //In the direction of latitude (N,S), distance is the same number of degrees.\n    distDEG = ctx.getDistCalc().distanceToDegrees(distance);\n\n    if (distDEG > 90) {\n      assert enclosingBox.getWidth() == 360;\n      double backDistDEG = 180 - distDEG;\n      if (backDistDEG >= 0) {\n        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);\n        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);\n        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);\n      } else\n        inverseCircle = null;//whole globe\n      horizAxisY = getCenter().getY();//although probably not used\n    } else {\n      inverseCircle = null;\n      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);\n      //some rare numeric conditioning cases can cause this to be barely beyond the box\n      if (_horizAxisY > enclosingBox.getMaxY()) {\n        horizAxisY = enclosingBox.getMaxY();\n      } else if (_horizAxisY < enclosingBox.getMinY()) {\n        horizAxisY = enclosingBox.getMinY();\n      } else {\n        horizAxisY = _horizAxisY;\n      }\n      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();\n    }\n\n  }\n\n","sourceOld":"  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {\n    super(p, dist, ctx);\n    assert ctx.isGeo();\n\n    //In the direction of latitude (N,S), distance is the same number of degrees.\n    distDEG = ctx.getDistCalc().distanceToDegrees(distance);\n\n    if (distDEG > 90) {\n      assert enclosingBox.getWidth() == 360;\n      double backDistDEG = 180 - distDEG;\n      if (backDistDEG >= 0) {\n        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);\n        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);\n        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);\n      } else\n        inverseCircle = null;//whole globe\n      horizAxisY = getCenter().getY();//although probably not used\n    } else {\n      inverseCircle = null;\n      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);\n      //some rare numeric conditioning cases can cause this to be barely beyond the box\n      if (_horizAxisY > enclosingBox.getMaxY()) {\n        horizAxisY = enclosingBox.getMaxY();\n      } else if (_horizAxisY < enclosingBox.getMinY()) {\n        horizAxisY = enclosingBox.getMinY();\n      } else {\n        horizAxisY = _horizAxisY;\n      }\n      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a","date":1329809096,"type":5,"author":"Ryan McKinley","isMerge":false,"pathNew":"modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl#GeoCircleImpl(Point,double,SpatialContext).mjava","pathOld":"modules/spatial/strategy/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl#GeoCircleImpl(Point,double,SpatialContext).mjava","sourceNew":"  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {\n    super(p, dist, ctx);\n    assert ctx.isGeo();\n\n    //In the direction of latitude (N,S), distance is the same number of degrees.\n    distDEG = ctx.getDistCalc().distanceToDegrees(distance);\n\n    if (distDEG > 90) {\n      assert enclosingBox.getWidth() == 360;\n      double backDistDEG = 180 - distDEG;\n      if (backDistDEG >= 0) {\n        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);\n        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);\n        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);\n      } else\n        inverseCircle = null;//whole globe\n      horizAxisY = getCenter().getY();//although probably not used\n    } else {\n      inverseCircle = null;\n      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);\n      //some rare numeric conditioning cases can cause this to be barely beyond the box\n      if (_horizAxisY > enclosingBox.getMaxY()) {\n        horizAxisY = enclosingBox.getMaxY();\n      } else if (_horizAxisY < enclosingBox.getMinY()) {\n        horizAxisY = enclosingBox.getMinY();\n      } else {\n        horizAxisY = _horizAxisY;\n      }\n      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();\n    }\n\n  }\n\n","sourceOld":"  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {\n    super(p, dist, ctx);\n    assert ctx.isGeo();\n\n    //In the direction of latitude (N,S), distance is the same number of degrees.\n    distDEG = ctx.getDistCalc().distanceToDegrees(distance);\n\n    if (distDEG > 90) {\n      assert enclosingBox.getWidth() == 360;\n      double backDistDEG = 180 - distDEG;\n      if (backDistDEG >= 0) {\n        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);\n        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);\n        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);\n      } else\n        inverseCircle = null;//whole globe\n      horizAxisY = getCenter().getY();//although probably not used\n    } else {\n      inverseCircle = null;\n      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);\n      //some rare numeric conditioning cases can cause this to be barely beyond the box\n      if (_horizAxisY > enclosingBox.getMaxY()) {\n        horizAxisY = enclosingBox.getMaxY();\n      } else if (_horizAxisY < enclosingBox.getMinY()) {\n        horizAxisY = enclosingBox.getMinY();\n      } else {\n        horizAxisY = _horizAxisY;\n      }\n      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c2047ba81272a0c4edeb11b1c7810ee23ba73502":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a":["c2047ba81272a0c4edeb11b1c7810ee23ba73502"]},"commit2Childs":{"c2047ba81272a0c4edeb11b1c7810ee23ba73502":["d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c2047ba81272a0c4edeb11b1c7810ee23ba73502","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","d0df2b6e5bc4da595d109453e90eff8dc0ffeb8a"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}