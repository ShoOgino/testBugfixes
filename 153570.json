{"path":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","commits":[{"id":"8f9abf22470be69ffd1583ddf1cf2a0a275c4152","date":1130187285,"type":0,"author":"Daniel Naber","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","pathOld":"/dev/null","sourceNew":"  public void run() {\n    try {\n      for(int i = 0; i < ITERATIONS; i++) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", new Integer(delId).toString());\n          int delCount = index.delete(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          try {\n            rand = random.nextInt(maxWait);\n            //System.out.println(\"waiting \" + rand + \"ms\");\n            Thread.sleep(rand);\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69e98ffd83f56083b99e5443ca713cd5783a2ae","date":1142955392,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","pathOld":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","sourceNew":"  public void run() {\n    try {\n      for(int i = 0; i < ITERATIONS; i++) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", new Integer(delId).toString());\n          int delCount = index.deleteDocuments(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          try {\n            rand = random.nextInt(maxWait);\n            //System.out.println(\"waiting \" + rand + \"ms\");\n            Thread.sleep(rand);\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      for(int i = 0; i < ITERATIONS; i++) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", new Integer(delId).toString());\n          int delCount = index.delete(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          try {\n            rand = random.nextInt(maxWait);\n            //System.out.println(\"waiting \" + rand + \"ms\");\n            Thread.sleep(rand);\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","pathOld":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","sourceNew":"  public void run() {\n\n    final long endTime = System.currentTimeMillis() + 1000*TEST_SECONDS;\n    try {\n      while(System.currentTimeMillis() < endTime) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", new Integer(delId).toString());\n          int delCount = index.deleteDocuments(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          try {\n            rand = random.nextInt(maxWait);\n            //System.out.println(\"waiting \" + rand + \"ms\");\n            Thread.sleep(rand);\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      for(int i = 0; i < ITERATIONS; i++) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", new Integer(delId).toString());\n          int delCount = index.deleteDocuments(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          try {\n            rand = random.nextInt(maxWait);\n            //System.out.println(\"waiting \" + rand + \"ms\");\n            Thread.sleep(rand);\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","pathOld":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","sourceNew":"  public void run() {\n\n    final long endTime = System.currentTimeMillis() + 1000*TEST_SECONDS;\n    try {\n      while(System.currentTimeMillis() < endTime) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", new Integer(delId).toString());\n          int delCount = index.deleteDocuments(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          rand = random.nextInt(maxWait);\n          //System.out.println(\"waiting \" + rand + \"ms\");\n          try {\n            Thread.sleep(rand);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(ie);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  public void run() {\n\n    final long endTime = System.currentTimeMillis() + 1000*TEST_SECONDS;\n    try {\n      while(System.currentTimeMillis() < endTime) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", new Integer(delId).toString());\n          int delCount = index.deleteDocuments(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          try {\n            rand = random.nextInt(maxWait);\n            //System.out.println(\"waiting \" + rand + \"ms\");\n            Thread.sleep(rand);\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bcde5e3f23911110baa101ed062b544162825b5","date":1254521804,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","pathOld":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","sourceNew":"  public void run() {\n\n    final long endTime = System.currentTimeMillis() + 1000*TEST_SECONDS;\n    try {\n      while(System.currentTimeMillis() < endTime) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", Integer.valueOf(delId).toString());\n          int delCount = index.deleteDocuments(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          rand = random.nextInt(maxWait);\n          //System.out.println(\"waiting \" + rand + \"ms\");\n          try {\n            Thread.sleep(rand);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(ie);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  public void run() {\n\n    final long endTime = System.currentTimeMillis() + 1000*TEST_SECONDS;\n    try {\n      while(System.currentTimeMillis() < endTime) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", new Integer(delId).toString());\n          int delCount = index.deleteDocuments(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          rand = random.nextInt(maxWait);\n          //System.out.println(\"waiting \" + rand + \"ms\");\n          try {\n            Thread.sleep(rand);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(ie);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8d1458a2543cbd30cbfe7929be4dcb5c5251659","date":1254582241,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","sourceNew":null,"sourceOld":"  public void run() {\n\n    final long endTime = System.currentTimeMillis() + 1000*TEST_SECONDS;\n    try {\n      while(System.currentTimeMillis() < endTime) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", new Integer(delId).toString());\n          int delCount = index.deleteDocuments(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          rand = random.nextInt(maxWait);\n          //System.out.println(\"waiting \" + rand + \"ms\");\n          try {\n            Thread.sleep(rand);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(ie);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a046c0c310bc77931fc8441bd920053b607dd14","date":1254584734,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"src/test/org/apache/lucene/index/IndexThread[TestIndexModifier]#run().mjava","sourceNew":null,"sourceOld":"  public void run() {\n\n    final long endTime = System.currentTimeMillis() + 1000*TEST_SECONDS;\n    try {\n      while(System.currentTimeMillis() < endTime) {\n        int rand = random.nextInt(101);\n        if (rand < 5) {\n          index.optimize();\n        } else if (rand < 60) {\n          Document doc = getDocument();\n          index.addDocument(doc);\n          idStack.push(doc.get(\"id\"));\n          added++;\n        } else {\n          // we just delete the last document added and remove it\n          // from the id stack so that it won't be removed twice:\n          String delId = null;\n          try {\n            delId = (String)idStack.pop();\n          } catch (EmptyStackException e) {\n            continue;\n          }\n          Term delTerm = new Term(\"id\", Integer.valueOf(delId).toString());\n          int delCount = index.deleteDocuments(delTerm);\n          if (delCount != 1) {\n            throw new RuntimeException(\"Internal error: \" + threadNumber + \" deleted \" + delCount + \n                \" documents, term=\" + delTerm);\n          }\n          deleted++;\n        }\n        if (maxWait > 0) {\n          rand = random.nextInt(maxWait);\n          //System.out.println(\"waiting \" + rand + \"ms\");\n          try {\n            Thread.sleep(rand);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(ie);\n          }\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6bcde5e3f23911110baa101ed062b544162825b5":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["8f9abf22470be69ffd1583ddf1cf2a0a275c4152"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0a046c0c310bc77931fc8441bd920053b607dd14":["6bcde5e3f23911110baa101ed062b544162825b5","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"8f9abf22470be69ffd1583ddf1cf2a0a275c4152":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e82780afe6097066eb5befb86e9432f077667e3d":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["e82780afe6097066eb5befb86e9432f077667e3d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0a046c0c310bc77931fc8441bd920053b607dd14"]},"commit2Childs":{"6bcde5e3f23911110baa101ed062b544162825b5":["0a046c0c310bc77931fc8441bd920053b607dd14"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["0a046c0c310bc77931fc8441bd920053b607dd14"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["e82780afe6097066eb5befb86e9432f077667e3d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8f9abf22470be69ffd1583ddf1cf2a0a275c4152"],"0a046c0c310bc77931fc8441bd920053b607dd14":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8f9abf22470be69ffd1583ddf1cf2a0a275c4152":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"],"e82780afe6097066eb5befb86e9432f077667e3d":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["6bcde5e3f23911110baa101ed062b544162825b5","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}