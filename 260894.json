{"path":"solr/core/src/java/org/apache/solr/analysis/LowerCaseTokenizer#incrementToken().mjava","commits":[{"id":"56c041816b965f9260d1c3806110f2e6e2fd43ce","date":1542894879,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/analysis/LowerCaseTokenizer#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    int length = 0;\n    int start = -1; // this variable is always initialized\n    int end = -1;\n    char[] buffer = termAtt.buffer();\n    while (true) {\n      if (bufferIndex >= dataLen) {\n        offset += dataLen;\n        CharacterUtils.fill(ioBuffer, input); // read supplementary char aware with CharacterUtils\n        if (ioBuffer.getLength() == 0) {\n          dataLen = 0; // so next offset += dataLen won't decrement offset\n          if (length > 0) {\n            break;\n          } else {\n            finalOffset = correctOffset(offset);\n            return false;\n          }\n        }\n        dataLen = ioBuffer.getLength();\n        bufferIndex = 0;\n      }\n      // use CharacterUtils here to support < 3.1 UTF-16 code unit behavior if the char based methods are gone\n      final int c = Character.codePointAt(ioBuffer.getBuffer(), bufferIndex, ioBuffer.getLength());\n      final int charCount = Character.charCount(c);\n      bufferIndex += charCount;\n\n      if (Character.isLetter(c)) {               // if it's a token char\n        if (length == 0) {                // start of token\n          assert start == -1;\n          start = offset + bufferIndex - charCount;\n          end = start;\n        } else if (length >= buffer.length-1) { // check if a supplementary could run out of bounds\n          buffer = termAtt.resizeBuffer(2+length); // make sure a supplementary fits in the buffer\n        }\n        end += charCount;\n        length += Character.toChars(Character.toLowerCase(c), buffer, length); // buffer it, normalized\n        if (length >= maxTokenLen) { // buffer overflow! make sure to check for >= surrogate pair could break == test\n          break;\n        }\n      } else if (length > 0) {           // at non-Letter w/ chars\n        break;                           // return 'em\n      }\n    }\n\n    termAtt.setLength(length);\n    assert start != -1;\n    offsetAtt.setOffset(correctOffset(start), finalOffset = correctOffset(end));\n    return true;\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"56c041816b965f9260d1c3806110f2e6e2fd43ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["56c041816b965f9260d1c3806110f2e6e2fd43ce"]},"commit2Childs":{"56c041816b965f9260d1c3806110f2e6e2fd43ce":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["56c041816b965f9260d1c3806110f2e6e2fd43ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}