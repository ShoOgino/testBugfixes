{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Filter,Shape,int,int).mjava","commits":[{"id":"d19946da5b8a6505034a72adcb5bae87dd043ddd","date":1423451445,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Filter,Shape,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param filter a Filter to limit counted docs. For optimal performance, it's\n   *               {@link org.apache.lucene.search.DocIdSet#bits()} should be non-null. If no filter is provided, live\n   *               docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link com.spatial4j.core.shape.Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   *                 IllegalArgumentException is thrown.\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Filter filter,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, filter, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey();\n      final int count = entry.getValue();\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        //left half of dateline:\n        if (rect.getMaxX() >= heatMinX) {\n          final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth) + 1;\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinY() <= heatMaxX) {\n          final int rightColumns = (int) Math.round(heatMaxX / cellWidth) + 1;\n          intersectInterval(0, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ceee459b5d9af86f3490334133c7cf34a5b69beb","ceee459b5d9af86f3490334133c7cf34a5b69beb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"672b198fc3dce868916c727917cae58c2906763d","date":1443669960,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Bits,Shape,int,int).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/HeatmapFacetCounter#calcFacets(PrefixTreeStrategy,IndexReaderContext,Filter,Shape,int,int).mjava","sourceNew":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param topAcceptDocs a Bits to limit counted docs.  If null, live docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Bits topAcceptDocs,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, topAcceptDocs, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey();\n      final int count = entry.getValue();\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        //left half of dateline:\n        if (rect.getMaxX() >= heatMinX) {\n          final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth) + 1;\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinY() <= heatMaxX) {\n          final int rightColumns = (int) Math.round(heatMaxX / cellWidth) + 1;\n          intersectInterval(0, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n\n    }\n\n    return heatmap;\n  }\n\n","sourceOld":"  /**\n   * Calculates spatial 2D facets (aggregated counts) in a grid, sometimes called a heatmap.\n   * Facet computation is implemented by navigating the underlying indexed terms efficiently. If you don't know exactly\n   * what facetLevel to go to for a given input box but you have some sense of how many cells there should be relative\n   * to the size of the shape, then consider using the logic that {@link org.apache.lucene.spatial.prefix.PrefixTreeStrategy}\n   * uses when approximating what level to go to when indexing a shape given a distErrPct.\n   *\n   * @param context the IndexReader's context\n   * @param filter a Filter to limit counted docs. For optimal performance, it's\n   *               {@link org.apache.lucene.search.DocIdSet#bits()} should be non-null. If no filter is provided, live\n   *               docs are counted.\n   * @param inputShape the shape to gather grid squares for; typically a {@link com.spatial4j.core.shape.Rectangle}.\n   *                   The <em>actual</em> heatmap area will usually be larger since the cells on the edge that overlap\n   *                   are returned. We always return a rectangle of integers even if the inputShape isn't a rectangle\n   *                   -- the non-intersecting cells will all be 0.\n   *                   If null is given, the entire world is assumed.\n   * @param facetLevel the target depth (detail) of cells.\n   * @param maxCells the maximum number of cells to return. If the cells exceed this count, an\n   *                 IllegalArgumentException is thrown.\n   */\n  public static Heatmap calcFacets(PrefixTreeStrategy strategy, IndexReaderContext context, Filter filter,\n                                   Shape inputShape, final int facetLevel, int maxCells) throws IOException {\n    if (maxCells > (MAX_ROWS_OR_COLUMNS * MAX_ROWS_OR_COLUMNS)) {\n      throw new IllegalArgumentException(\"maxCells (\" + maxCells + \") should be <= \" + MAX_ROWS_OR_COLUMNS);\n    }\n    if (inputShape == null) {\n      inputShape = strategy.getSpatialContext().getWorldBounds();\n    }\n    final Rectangle inputRect = inputShape.getBoundingBox();\n    //First get the rect of the cell at the bottom-left at depth facetLevel\n    final SpatialPrefixTree grid = strategy.getGrid();\n    final SpatialContext ctx = grid.getSpatialContext();\n    final Point cornerPt = ctx.makePoint(inputRect.getMinX(), inputRect.getMinY());\n    final CellIterator cellIterator = grid.getTreeCellIterator(cornerPt, facetLevel);\n    Cell cornerCell = null;\n    while (cellIterator.hasNext()) {\n      cornerCell = cellIterator.next();\n    }\n    assert cornerCell != null && cornerCell.getLevel() == facetLevel : \"Cell not at target level: \" + cornerCell;\n    final Rectangle cornerRect = (Rectangle) cornerCell.getShape();\n    assert cornerRect.hasArea();\n    //Now calculate the number of columns and rows necessary to cover the inputRect\n    double heatMinX = cornerRect.getMinX();//note: we might change this below...\n    final double cellWidth = cornerRect.getWidth();\n    final Rectangle worldRect = ctx.getWorldBounds();\n    final int columns = calcRowsOrCols(cellWidth, heatMinX, inputRect.getWidth(), inputRect.getMinX(), worldRect.getWidth());\n    final double heatMinY = cornerRect.getMinY();\n    final double cellHeight = cornerRect.getHeight();\n    final int rows = calcRowsOrCols(cellHeight, heatMinY, inputRect.getHeight(), inputRect.getMinY(), worldRect.getHeight());\n    assert rows > 0 && columns > 0;\n    if (columns > MAX_ROWS_OR_COLUMNS || rows > MAX_ROWS_OR_COLUMNS || columns * rows > maxCells) {\n      throw new IllegalArgumentException(\n          \"Too many cells (\" + columns + \" x \" + rows + \") for level \" + facetLevel + \" shape \" + inputRect);\n    }\n\n    //Create resulting heatmap bounding rectangle & Heatmap object.\n    final double halfCellWidth = cellWidth / 2.0;\n    // if X world-wraps, use world bounds' range\n    if (columns * cellWidth + halfCellWidth > worldRect.getWidth()) {\n      heatMinX = worldRect.getMinX();\n    }\n    double heatMaxX = heatMinX + columns * cellWidth;\n    if (Math.abs(heatMaxX - worldRect.getMaxX()) < halfCellWidth) {//numeric conditioning issue\n      heatMaxX = worldRect.getMaxX();\n    } else if (heatMaxX > worldRect.getMaxX()) {//wraps dateline (won't happen if !geo)\n      heatMaxX = heatMaxX - worldRect.getMaxX() +  worldRect.getMinX();\n    }\n    final double halfCellHeight = cellHeight / 2.0;\n    double heatMaxY = heatMinY + rows * cellHeight;\n    if (Math.abs(heatMaxY - worldRect.getMaxY()) < halfCellHeight) {//numeric conditioning issue\n      heatMaxY = worldRect.getMaxY();\n    }\n\n    final Heatmap heatmap = new Heatmap(columns, rows, ctx.makeRectangle(heatMinX, heatMaxX, heatMinY, heatMaxY));\n\n    //All ancestor cell counts (of facetLevel) will be captured during facet visiting and applied later. If the data is\n    // just points then there won't be any ancestors.\n    //Facet count of ancestors covering all of the heatmap:\n    int[] allCellsAncestorCount = new int[1]; // single-element array so it can be accumulated in the inner class\n    //All other ancestors:\n    Map<Rectangle,Integer> ancestors = new HashMap<>();\n\n    //Now lets count some facets!\n    PrefixTreeFacetCounter.compute(strategy, context, filter, inputShape, facetLevel,\n        new PrefixTreeFacetCounter.FacetVisitor() {\n      @Override\n      public void visit(Cell cell, int count) {\n        final double heatMinX = heatmap.region.getMinX();\n        final Rectangle rect = (Rectangle) cell.getShape();\n        if (cell.getLevel() == facetLevel) {//heatmap level; count it directly\n          //convert to col & row\n          int column;\n          if (rect.getMinX() >= heatMinX) {\n            column = (int) Math.round((rect.getMinX() - heatMinX) / cellWidth);\n          } else { // due to dateline wrap\n            column = (int) Math.round((rect.getMinX() + 360 - heatMinX) / cellWidth);\n          }\n          int row = (int) Math.round((rect.getMinY() - heatMinY) / cellHeight);\n          //note: unfortunately, it's possible for us to visit adjacent cells to the heatmap (if the SpatialPrefixTree\n          // allows adjacent cells to overlap on the seam), so we need to skip them\n          if (column < 0 || column >= heatmap.columns || row < 0 || row >= heatmap.rows) {\n            return;\n          }\n          // increment\n          heatmap.counts[column * heatmap.rows + row] += count;\n\n        } else if (rect.relate(heatmap.region) == SpatialRelation.CONTAINS) {//containing ancestor\n          allCellsAncestorCount[0] += count;\n\n        } else { // ancestor\n          // note: not particularly efficient (possible put twice, and Integer wrapper); oh well\n          Integer existingCount = ancestors.put(rect, count);\n          if (existingCount != null) {\n            ancestors.put(rect, count + existingCount);\n          }\n        }\n      }\n    });\n\n    //Update the heatmap counts with ancestor counts\n\n    // Apply allCellsAncestorCount\n    if (allCellsAncestorCount[0] > 0) {\n      for (int i = 0; i < heatmap.counts.length; i++) {\n        heatmap.counts[i] += allCellsAncestorCount[0];\n      }\n    }\n\n    // Apply ancestors\n    //  note: This approach isn't optimized for a ton of ancestor cells. We'll potentially increment the same cells\n    //    multiple times in separate passes if any ancestors overlap. IF this poses a problem, we could optimize it\n    //    with additional complication by keeping track of intervals in a sorted tree structure (possible TreeMap/Set)\n    //    and iterate them cleverly such that we just make one pass at this stage.\n\n    int[] pair = new int[2];//output of intersectInterval\n    for (Map.Entry<Rectangle, Integer> entry : ancestors.entrySet()) {\n      Rectangle rect = entry.getKey();\n      final int count = entry.getValue();\n      //note: we approach this in a way that eliminates int overflow/underflow (think huge cell, tiny heatmap)\n      intersectInterval(heatMinY, heatMaxY, cellHeight, rows, rect.getMinY(), rect.getMaxY(), pair);\n      final int startRow = pair[0];\n      final int endRow = pair[1];\n\n      if (!heatmap.region.getCrossesDateLine()) {\n        intersectInterval(heatMinX, heatMaxX, cellWidth, columns, rect.getMinX(), rect.getMaxX(), pair);\n        final int startCol = pair[0];\n        final int endCol = pair[1];\n        incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n\n      } else {\n        //left half of dateline:\n        if (rect.getMaxX() >= heatMinX) {\n          final int leftColumns = (int) Math.round((180 - heatMinX) / cellWidth) + 1;\n          intersectInterval(heatMinX, 180, cellWidth, leftColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n        //right half of dateline\n        if (rect.getMinY() <= heatMaxX) {\n          final int rightColumns = (int) Math.round(heatMaxX / cellWidth) + 1;\n          intersectInterval(0, heatMaxX, cellWidth, rightColumns, rect.getMinX(), rect.getMaxX(), pair);\n          final int startCol = pair[0];\n          final int endCol = pair[1];\n          incrementRange(heatmap, startCol, endCol, startRow, endRow, count);\n        }\n      }\n\n    }\n\n    return heatmap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"672b198fc3dce868916c727917cae58c2906763d":["d19946da5b8a6505034a72adcb5bae87dd043ddd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d19946da5b8a6505034a72adcb5bae87dd043ddd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["672b198fc3dce868916c727917cae58c2906763d"]},"commit2Childs":{"672b198fc3dce868916c727917cae58c2906763d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d19946da5b8a6505034a72adcb5bae87dd043ddd"],"d19946da5b8a6505034a72adcb5bae87dd043ddd":["672b198fc3dce868916c727917cae58c2906763d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}