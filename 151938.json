{"path":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","pathOld":"/dev/null","sourceNew":"  final void score(HitCollector results, int maxDoc) throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    while (currentDoc < maxDoc) {\n      currentDoc = Math.min(currentDoc+BucketTable.SIZE, maxDoc);\n      for (SubScorer t = scorers; t != null; t = t.next)\n\tt.scorer.score(t.collector, currentDoc);\n      bucketTable.collectHits(results);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27274410c91546fcfc28e692abd2dd77ca99be4b","date":1042501834,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","sourceNew":"  public final void score(HitCollector results, int maxDoc)\n    throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    while (currentDoc < maxDoc) {\n      currentDoc = Math.min(currentDoc+BucketTable.SIZE, maxDoc);\n      for (SubScorer t = scorers; t != null; t = t.next)\n\tt.scorer.score(t.collector, currentDoc);\n      bucketTable.collectHits(results);\n    }\n  }\n\n","sourceOld":"  final void score(HitCollector results, int maxDoc) throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    while (currentDoc < maxDoc) {\n      currentDoc = Math.min(currentDoc+BucketTable.SIZE, maxDoc);\n      for (SubScorer t = scorers; t != null; t = t.next)\n\tt.scorer.score(t.collector, currentDoc);\n      bucketTable.collectHits(results);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15c469602973ef1a33c9a07367a380d278ffab20","date":1074206555,"type":4,"author":"Doug Cutting","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","sourceNew":null,"sourceOld":"  public final void score(HitCollector results, int maxDoc)\n    throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    while (currentDoc < maxDoc) {\n      currentDoc = Math.min(currentDoc+BucketTable.SIZE, maxDoc);\n      for (SubScorer t = scorers; t != null; t = t.next)\n\tt.scorer.score(t.collector, currentDoc);\n      bucketTable.collectHits(results);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a53bff5f7abfecc50821f3dfcdca3d4c445cf88","date":1095875760,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","pathOld":"/dev/null","sourceNew":"  protected boolean score(HitCollector hc, int max) throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        if (current.doc >= max)\n          return true;\n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          hc.collect(current.doc, current.score * coordFactors[current.coord]);\n        }\n        \n        bucketTable.first = current.next;         // pop the queue\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        if (!sub.done) {\n          sub.done = !sub.scorer.score(sub.collector, end);\n          if (!sub.done)\n            more = true;\n        }\n      }\n    } while (bucketTable.first != null || more);\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33cf48cae782ce2724b5b2c5281d4d64b06afe64","date":1102707400,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","sourceNew":"  protected boolean score(HitCollector hc, int max) throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    boolean more;\n    Bucket tmp;\n    \n    do {\n      bucketTable.first = null;\n      \n      while (current != null) {         // more queued \n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          \n          if (current.doc >= max){\n            tmp = current;\n            current = current.next;\n            tmp.next = bucketTable.first;\n            bucketTable.first = tmp;\n            continue;\n          }\n          \n          hc.collect(current.doc, current.score * coordFactors[current.coord]);\n        }\n        \n        current = current.next;         // pop the queue\n      }\n      \n      if( bucketTable.first != null){\n        current = bucketTable.first;\n        bucketTable.first = current.next;\n        return true;\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        if (!sub.done) {\n          sub.done = !sub.scorer.score(sub.collector, end);\n          if (!sub.done)\n            more = true;\n        }\n      }\n      current = bucketTable.first;\n      \n    } while (current != null || more);\n\n    return false;\n  }\n\n","sourceOld":"  protected boolean score(HitCollector hc, int max) throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        if (current.doc >= max)\n          return true;\n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          hc.collect(current.doc, current.score * coordFactors[current.coord]);\n        }\n        \n        bucketTable.first = current.next;         // pop the queue\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        if (!sub.done) {\n          sub.done = !sub.scorer.score(sub.collector, end);\n          if (!sub.done)\n            more = true;\n        }\n      }\n    } while (bucketTable.first != null || more);\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76349ae49451ab1e1e63e8eeb254f82684b1da25","date":1176847207,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","sourceNew":"  protected boolean score(HitCollector hc, int max) throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    boolean more;\n    Bucket tmp;\n    \n    do {\n      bucketTable.first = null;\n      \n      while (current != null) {         // more queued \n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          \n          if (current.doc >= max){\n            tmp = current;\n            current = current.next;\n            tmp.next = bucketTable.first;\n            bucketTable.first = tmp;\n            continue;\n          }\n          \n          if (current.coord >= minNrShouldMatch) {\n            hc.collect(current.doc, current.score * coordFactors[current.coord]);\n          }\n        }\n        \n        current = current.next;         // pop the queue\n      }\n      \n      if (bucketTable.first != null){\n        current = bucketTable.first;\n        bucketTable.first = current.next;\n        return true;\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        if (!sub.done) {\n          sub.done = !sub.scorer.score(sub.collector, end);\n          if (!sub.done)\n            more = true;\n        }\n      }\n      current = bucketTable.first;\n      \n    } while (current != null || more);\n\n    return false;\n  }\n\n","sourceOld":"  protected boolean score(HitCollector hc, int max) throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    boolean more;\n    Bucket tmp;\n    \n    do {\n      bucketTable.first = null;\n      \n      while (current != null) {         // more queued \n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          \n          if (current.doc >= max){\n            tmp = current;\n            current = current.next;\n            tmp.next = bucketTable.first;\n            bucketTable.first = tmp;\n            continue;\n          }\n          \n          hc.collect(current.doc, current.score * coordFactors[current.coord]);\n        }\n        \n        current = current.next;         // pop the queue\n      }\n      \n      if( bucketTable.first != null){\n        current = bucketTable.first;\n        bucketTable.first = current.next;\n        return true;\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        if (!sub.done) {\n          sub.done = !sub.scorer.score(sub.collector, end);\n          if (!sub.done)\n            more = true;\n        }\n      }\n      current = bucketTable.first;\n      \n    } while (current != null || more);\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"64714133cf5ec732e3bbceee63351bb9af0117dc","date":1239647636,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","sourceNew":"  /** @deprecated use {@link #score(Collector, int)} instead. */\n  protected boolean score(HitCollector hc, int max) throws IOException {\n    return score(new HitCollectorWrapper(hc), max);\n  }\n\n","sourceOld":"  protected boolean score(HitCollector hc, int max) throws IOException {\n    if (coordFactors == null)\n      computeCoordFactors();\n\n    boolean more;\n    Bucket tmp;\n    \n    do {\n      bucketTable.first = null;\n      \n      while (current != null) {         // more queued \n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          \n          if (current.doc >= max){\n            tmp = current;\n            current = current.next;\n            tmp.next = bucketTable.first;\n            bucketTable.first = tmp;\n            continue;\n          }\n          \n          if (current.coord >= minNrShouldMatch) {\n            hc.collect(current.doc, current.score * coordFactors[current.coord]);\n          }\n        }\n        \n        current = current.next;         // pop the queue\n      }\n      \n      if (bucketTable.first != null){\n        current = bucketTable.first;\n        bucketTable.first = current.next;\n        return true;\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        if (!sub.done) {\n          sub.done = !sub.scorer.score(sub.collector, end);\n          if (!sub.done)\n            more = true;\n        }\n      }\n      current = bucketTable.first;\n      \n    } while (current != null || more);\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30a558487f2298c2c19ceca9103c1b6865d64708","date":1244393921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","sourceNew":"  /** @deprecated use {@link #score(Collector, int)} instead. */\n  protected boolean score(HitCollector hc, int max) throws IOException {\n    return score(new HitCollectorWrapper(hc), max, docID());\n  }\n\n","sourceOld":"  /** @deprecated use {@link #score(Collector, int)} instead. */\n  protected boolean score(HitCollector hc, int max) throws IOException {\n    return score(new HitCollectorWrapper(hc), max);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa6b36d4f0afdb006498f433653ee214a61be4fa","date":1251387263,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","sourceNew":"  /** @deprecated use {@link #score(Collector, int, int)} instead. */\n  protected boolean score(HitCollector hc, int max) throws IOException {\n    return score(new HitCollectorWrapper(hc), max, docID());\n  }\n\n","sourceOld":"  /** @deprecated use {@link #score(Collector, int)} instead. */\n  protected boolean score(HitCollector hc, int max) throws IOException {\n    return score(new HitCollectorWrapper(hc), max, docID());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61cbcf396559d597a914594d7e2830c142ecfd91","date":1255444081,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#score(HitCollector,int).mjava","sourceNew":null,"sourceOld":"  /** @deprecated use {@link #score(Collector, int, int)} instead. */\n  protected boolean score(HitCollector hc, int max) throws IOException {\n    return score(new HitCollectorWrapper(hc), max, docID());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aa6b36d4f0afdb006498f433653ee214a61be4fa":["30a558487f2298c2c19ceca9103c1b6865d64708"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"30a558487f2298c2c19ceca9103c1b6865d64708":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["76349ae49451ab1e1e63e8eeb254f82684b1da25"],"76349ae49451ab1e1e63e8eeb254f82684b1da25":["33cf48cae782ce2724b5b2c5281d4d64b06afe64"],"33cf48cae782ce2724b5b2c5281d4d64b06afe64":["9a53bff5f7abfecc50821f3dfcdca3d4c445cf88"],"27274410c91546fcfc28e692abd2dd77ca99be4b":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"61cbcf396559d597a914594d7e2830c142ecfd91":["aa6b36d4f0afdb006498f433653ee214a61be4fa"],"9a53bff5f7abfecc50821f3dfcdca3d4c445cf88":["15c469602973ef1a33c9a07367a380d278ffab20"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["61cbcf396559d597a914594d7e2830c142ecfd91"],"15c469602973ef1a33c9a07367a380d278ffab20":["27274410c91546fcfc28e692abd2dd77ca99be4b"]},"commit2Childs":{"aa6b36d4f0afdb006498f433653ee214a61be4fa":["61cbcf396559d597a914594d7e2830c142ecfd91"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["27274410c91546fcfc28e692abd2dd77ca99be4b"],"30a558487f2298c2c19ceca9103c1b6865d64708":["aa6b36d4f0afdb006498f433653ee214a61be4fa"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["30a558487f2298c2c19ceca9103c1b6865d64708"],"76349ae49451ab1e1e63e8eeb254f82684b1da25":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"33cf48cae782ce2724b5b2c5281d4d64b06afe64":["76349ae49451ab1e1e63e8eeb254f82684b1da25"],"27274410c91546fcfc28e692abd2dd77ca99be4b":["15c469602973ef1a33c9a07367a380d278ffab20"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"61cbcf396559d597a914594d7e2830c142ecfd91":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9a53bff5f7abfecc50821f3dfcdca3d4c445cf88":["33cf48cae782ce2724b5b2c5281d4d64b06afe64"],"15c469602973ef1a33c9a07367a380d278ffab20":["9a53bff5f7abfecc50821f3dfcdca3d4c445cf88"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}