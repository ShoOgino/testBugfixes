{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","commits":[{"id":"8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5","date":1290247889,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e8cc373c801e54cec75daf9f52792cb4b17f536","date":1291116159,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44fcbde6fb2ac44ee3b45e013e54a42911e689ff","date":1292065621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","date":1297940445,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers.get(i), false);\n          } catch (Throwable t) {\n          }\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          try {\n            merge.readerClones.get(i).close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n          merge.readerClones.set(i, null);\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          readerPool.release(merge.readers.get(i), true);\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          merge.readerClones.get(i).close();\n          // This was a private clone and we had the only reference\n          assert merge.readerClones.get(i).getRefCount() == 0;\n          merge.readerClones.set(i, null);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers.get(i), false);\n          } catch (Throwable t) {\n          }\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          try {\n            merge.readerClones.get(i).close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n          merge.readerClones.set(i, null);\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          readerPool.release(merge.readers.get(i), true);\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          merge.readerClones.get(i).close();\n          // This was a private clone and we had the only reference\n          assert merge.readerClones.get(i).getRefCount() == 0;\n          merge.readerClones.set(i, null);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers.get(i), false);\n          } catch (Throwable t) {\n          }\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          try {\n            merge.readerClones.get(i).close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n          merge.readerClones.set(i, null);\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          readerPool.release(merge.readers.get(i), true);\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          merge.readerClones.get(i).close();\n          // This was a private clone and we had the only reference\n          assert merge.readerClones.get(i).getRefCount() == 0;\n          merge.readerClones.set(i, null);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.segments.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers[i], false);\n          } catch (Throwable t) {\n          }\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          try {\n            merge.readersClone[i].close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readersClone[i].getRefCount() == 0: \"refCount should be 0 but is \" + merge.readersClone[i].getRefCount();\n          merge.readersClone[i] = null;\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers[i] != null) {\n          readerPool.release(merge.readers[i], true);\n          merge.readers[i] = null;\n        }\n\n        if (merge.readersClone[i] != null) {\n          merge.readersClone[i].close();\n          // This was a private clone and we had the only reference\n          assert merge.readersClone[i].getRefCount() == 0;\n          merge.readersClone[i] = null;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98b72bcae3162dc10643ec8f09ce31fc3fb902b","date":1306688330,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n    \n    boolean drop = !suppressExceptions;\n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n      \n      if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n        try {\n          merge.readerClones.get(i).close();\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        // This was a private clone and we had the\n        // only reference\n        assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n        merge.readerClones.set(i, null);\n      }\n    }\n    \n    // If any errors occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      // defensive code - we should not hit unchecked exceptions\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers.get(i), false);\n          } catch (Throwable t) {\n          }\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          try {\n            merge.readerClones.get(i).close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n          merge.readerClones.set(i, null);\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          readerPool.release(merge.readers.get(i), true);\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          merge.readerClones.get(i).close();\n          // This was a private clone and we had the only reference\n          assert merge.readerClones.get(i).getRefCount() == 0;\n          merge.readerClones.set(i, null);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab98afaf187d890a5304cced235eb99bfdc6c32a","date":1306694214,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n    \n    boolean anyChanges = false;\n    boolean drop = !suppressExceptions;\n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          anyChanges |= readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n      \n      if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n        try {\n          merge.readerClones.get(i).close();\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        // This was a private clone and we had the\n        // only reference\n        assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n        merge.readerClones.set(i, null);\n      }\n    }\n    \n    if (suppressExceptions && anyChanges) {\n      checkpoint();\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n    \n    boolean drop = !suppressExceptions;\n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n      \n      if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n        try {\n          merge.readerClones.get(i).close();\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        // This was a private clone and we had the\n        // only reference\n        assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n        merge.readerClones.set(i, null);\n      }\n    }\n    \n    // If any errors occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      // defensive code - we should not hit unchecked exceptions\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n    \n    boolean anyChanges = false;\n    boolean drop = !suppressExceptions;\n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          anyChanges |= readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n      \n      if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n        try {\n          merge.readerClones.get(i).close();\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        // This was a private clone and we had the\n        // only reference\n        assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n        merge.readerClones.set(i, null);\n      }\n    }\n    \n    if (suppressExceptions && anyChanges) {\n      checkpoint();\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers.get(i), false);\n          } catch (Throwable t) {\n          }\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          try {\n            merge.readerClones.get(i).close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n          merge.readerClones.set(i, null);\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          readerPool.release(merge.readers.get(i), true);\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          merge.readerClones.get(i).close();\n          // This was a private clone and we had the only reference\n          assert merge.readerClones.get(i).getRefCount() == 0;\n          merge.readerClones.set(i, null);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n    \n    boolean anyChanges = false;\n    boolean drop = !suppressExceptions;\n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          anyChanges |= readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n      \n      if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n        try {\n          merge.readerClones.get(i).close();\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        // This was a private clone and we had the\n        // only reference\n        assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n        merge.readerClones.set(i, null);\n      }\n    }\n    \n    if (suppressExceptions && anyChanges) {\n      checkpoint();\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    if (suppressExceptions) {\n      // Suppress any new exceptions so we throw the\n      // original cause\n      boolean anyChanges = false;\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          try {\n            anyChanges |= readerPool.release(merge.readers.get(i), false);\n          } catch (Throwable t) {\n          }\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          try {\n            merge.readerClones.get(i).close();\n          } catch (Throwable t) {\n          }\n          // This was a private clone and we had the\n          // only reference\n          assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n          merge.readerClones.set(i, null);\n        }\n      }\n      if (anyChanges) {\n        checkpoint();\n      }\n    } else {\n      for (int i=0;i<numSegments;i++) {\n        if (merge.readers.get(i) != null) {\n          readerPool.release(merge.readers.get(i), true);\n          merge.readers.set(i, null);\n        }\n\n        if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n          merge.readerClones.get(i).close();\n          // This was a private clone and we had the only reference\n          assert merge.readerClones.get(i).getRefCount() == 0;\n          merge.readerClones.set(i, null);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0061262413ecc163d6eebba1b5c43ab91a0c2dc5","date":1311195279,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean anyChanges = false;\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          anyChanges |= readerPool.release(merge.readers.get(i), drop, IOContext.Context.MERGE);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    if (suppressExceptions && anyChanges) {\n      checkpoint();\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n    \n    boolean anyChanges = false;\n    boolean drop = !suppressExceptions;\n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          anyChanges |= readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n      \n      if (i < merge.readerClones.size() && merge.readerClones.get(i) != null) {\n        try {\n          merge.readerClones.get(i).close();\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        // This was a private clone and we had the\n        // only reference\n        assert merge.readerClones.get(i).getRefCount() == 0: \"refCount should be 0 but is \" + merge.readerClones.get(i).getRefCount();\n        merge.readerClones.set(i, null);\n      }\n    }\n    \n    if (suppressExceptions && anyChanges) {\n      checkpoint();\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean anyChanges = false;\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          anyChanges |= readerPool.release(merge.readers.get(i), drop, IOContext.Context.MERGE);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    if (suppressExceptions && anyChanges) {\n      checkpoint();\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["4e8cc373c801e54cec75daf9f52792cb4b17f536"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["ab98afaf187d890a5304cced235eb99bfdc6c32a"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["3bb13258feba31ab676502787ab2e1779f129b7a","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","ab98afaf187d890a5304cced235eb99bfdc6c32a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ce667c6d3400b22523701c549c0d35e26da8b46":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5"],"e98b72bcae3162dc10643ec8f09ce31fc3fb902b":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"3bb13258feba31ab676502787ab2e1779f129b7a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4e8cc373c801e54cec75daf9f52792cb4b17f536"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ab98afaf187d890a5304cced235eb99bfdc6c32a":["e98b72bcae3162dc10643ec8f09ce31fc3fb902b"],"4e8cc373c801e54cec75daf9f52792cb4b17f536":["8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["f1bdbf92da222965b46c0a942c3857ba56e5c638","ab98afaf187d890a5304cced235eb99bfdc6c32a"]},"commit2Childs":{"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5":["4e8cc373c801e54cec75daf9f52792cb4b17f536"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["f1bdbf92da222965b46c0a942c3857ba56e5c638","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","e98b72bcae3162dc10643ec8f09ce31fc3fb902b","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8cac9bbcf5acbef2d0d83f6e9e32a22d71301db5","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3bb13258feba31ab676502787ab2e1779f129b7a"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3bb13258feba31ab676502787ab2e1779f129b7a":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"e98b72bcae3162dc10643ec8f09ce31fc3fb902b":["ab98afaf187d890a5304cced235eb99bfdc6c32a"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"4e8cc373c801e54cec75daf9f52792cb4b17f536":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff","3bb13258feba31ab676502787ab2e1779f129b7a"],"ab98afaf187d890a5304cced235eb99bfdc6c32a":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}