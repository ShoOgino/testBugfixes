{"path":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","commits":[{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#setShardLeader(CloudState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collection, String sliceName, String leaderUrl) {\n        \n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>();\n        newStates.putAll(state.getCollectionStates());\n        \n        final Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n        \n        if (!slices.containsKey(sliceName)) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          final Map<String,ZkNodeProps> newShards = new LinkedHashMap<String,ZkNodeProps>();\n          for(Entry<String, ZkNodeProps> shard: slices.get(sliceName).getShards().entrySet()) {\n            Map<String, String> newShardProps = new LinkedHashMap<String,String>();\n            newShardProps.putAll(shard.getValue().getProperties());\n            \n            newShardProps.remove(ZkStateReader.LEADER_PROP);  //clean any previously existed flag\n            \n            ZkCoreNodeProps zkCoreNodeProps = new ZkCoreNodeProps(new ZkNodeProps(newShardProps));\n            if(leaderUrl!=null && leaderUrl.equals(zkCoreNodeProps.getCoreUrl())) {\n              newShardProps.put(ZkStateReader.LEADER_PROP,\"true\");\n            }\n            newShards.put(shard.getKey(), new ZkNodeProps(newShardProps));\n          }\n          Slice slice = new Slice(sliceName, newShards);\n          slices.put(sliceName, slice);\n        }\n        return new ClusterState(state.getLiveNodes(), newStates);\n      }\n\n","sourceOld":"      private CloudState setShardLeader(CloudState state, String collection, String sliceName, String leaderUrl) {\n        \n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>();\n        newStates.putAll(state.getCollectionStates());\n        \n        final Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n        \n        if (!slices.containsKey(sliceName)) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          final Map<String,ZkNodeProps> newShards = new LinkedHashMap<String,ZkNodeProps>();\n          for(Entry<String, ZkNodeProps> shard: slices.get(sliceName).getShards().entrySet()) {\n            Map<String, String> newShardProps = new LinkedHashMap<String,String>();\n            newShardProps.putAll(shard.getValue().getProperties());\n            \n            newShardProps.remove(ZkStateReader.LEADER_PROP);  //clean any previously existed flag\n            \n            ZkCoreNodeProps zkCoreNodeProps = new ZkCoreNodeProps(new ZkNodeProps(newShardProps));\n            if(leaderUrl!=null && leaderUrl.equals(zkCoreNodeProps.getCoreUrl())) {\n              newShardProps.put(ZkStateReader.LEADER_PROP,\"true\");\n            }\n            newShards.put(shard.getKey(), new ZkNodeProps(newShardProps));\n          }\n          Slice slice = new Slice(sliceName, newShards);\n          slices.put(sliceName, slice);\n        }\n        return new CloudState(state.getLiveNodes(), newStates);\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#setShardLeader(CloudState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collection, String sliceName, String leaderUrl) {\n        \n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>();\n        newStates.putAll(state.getCollectionStates());\n        \n        final Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n        \n        if (!slices.containsKey(sliceName)) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          final Map<String,ZkNodeProps> newShards = new LinkedHashMap<String,ZkNodeProps>();\n          for(Entry<String, ZkNodeProps> shard: slices.get(sliceName).getShards().entrySet()) {\n            Map<String, String> newShardProps = new LinkedHashMap<String,String>();\n            newShardProps.putAll(shard.getValue().getProperties());\n            \n            newShardProps.remove(ZkStateReader.LEADER_PROP);  //clean any previously existed flag\n            \n            ZkCoreNodeProps zkCoreNodeProps = new ZkCoreNodeProps(new ZkNodeProps(newShardProps));\n            if(leaderUrl!=null && leaderUrl.equals(zkCoreNodeProps.getCoreUrl())) {\n              newShardProps.put(ZkStateReader.LEADER_PROP,\"true\");\n            }\n            newShards.put(shard.getKey(), new ZkNodeProps(newShardProps));\n          }\n          Slice slice = new Slice(sliceName, newShards);\n          slices.put(sliceName, slice);\n        }\n        return new ClusterState(state.getLiveNodes(), newStates);\n      }\n\n","sourceOld":"      private CloudState setShardLeader(CloudState state, String collection, String sliceName, String leaderUrl) {\n        \n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>();\n        newStates.putAll(state.getCollectionStates());\n        \n        final Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n        \n        if (!slices.containsKey(sliceName)) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          final Map<String,ZkNodeProps> newShards = new LinkedHashMap<String,ZkNodeProps>();\n          for(Entry<String, ZkNodeProps> shard: slices.get(sliceName).getShards().entrySet()) {\n            Map<String, String> newShardProps = new LinkedHashMap<String,String>();\n            newShardProps.putAll(shard.getValue().getProperties());\n            \n            newShardProps.remove(ZkStateReader.LEADER_PROP);  //clean any previously existed flag\n            \n            ZkCoreNodeProps zkCoreNodeProps = new ZkCoreNodeProps(new ZkNodeProps(newShardProps));\n            if(leaderUrl!=null && leaderUrl.equals(zkCoreNodeProps.getCoreUrl())) {\n              newShardProps.put(ZkStateReader.LEADER_PROP,\"true\");\n            }\n            newShards.put(shard.getKey(), new ZkNodeProps(newShardProps));\n          }\n          Slice slice = new Slice(sliceName, newShards);\n          slices.put(sliceName, slice);\n        }\n        return new CloudState(state.getLiveNodes(), newStates);\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"/dev/null","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collection, String sliceName, String leaderUrl) {\n        \n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>();\n        newStates.putAll(state.getCollectionStates());\n        \n        final Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n        \n        if (!slices.containsKey(sliceName)) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          final Map<String,ZkNodeProps> newShards = new LinkedHashMap<String,ZkNodeProps>();\n          for(Entry<String, ZkNodeProps> shard: slices.get(sliceName).getShards().entrySet()) {\n            Map<String, String> newShardProps = new LinkedHashMap<String,String>();\n            newShardProps.putAll(shard.getValue().getProperties());\n            \n            newShardProps.remove(ZkStateReader.LEADER_PROP);  //clean any previously existed flag\n            \n            ZkCoreNodeProps zkCoreNodeProps = new ZkCoreNodeProps(new ZkNodeProps(newShardProps));\n            if(leaderUrl!=null && leaderUrl.equals(zkCoreNodeProps.getCoreUrl())) {\n              newShardProps.put(ZkStateReader.LEADER_PROP,\"true\");\n            }\n            newShards.put(shard.getKey(), new ZkNodeProps(newShardProps));\n          }\n          Slice slice = new Slice(sliceName, newShards);\n          slices.put(sliceName, slice);\n        }\n        return new ClusterState(state.getLiveNodes(), newStates);\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collection, String sliceName, String leaderUrl) {\n        \n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>();\n        newStates.putAll(state.getCollectionStates());\n        \n        final Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n        \n        if (!slices.containsKey(sliceName)) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          final Map<String,Replica> newShards = new LinkedHashMap<String,Replica>();\n          for(Entry<String, Replica> shard: slices.get(sliceName).getReplicasMap().entrySet()) {\n            Map<String, Object> newShardProps = new LinkedHashMap<String,Object>();\n            newShardProps.putAll(shard.getValue().getProperties());\n            \n            newShardProps.remove(ZkStateReader.LEADER_PROP);  //clean any previously existed flag\n            \n            ZkCoreNodeProps zkCoreNodeProps = new ZkCoreNodeProps(new ZkNodeProps(newShardProps));\n            if(leaderUrl!=null && leaderUrl.equals(zkCoreNodeProps.getCoreUrl())) {\n              newShardProps.put(ZkStateReader.LEADER_PROP,\"true\");\n            }\n            newShards.put(shard.getKey(), new Replica(shard.getKey(), newShardProps));\n          }\n          Slice slice = new Slice(sliceName, newShards);\n          slices.put(sliceName, slice);\n        }\n        return new ClusterState(state.getLiveNodes(), newStates);\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collection, String sliceName, String leaderUrl) {\n        \n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>();\n        newStates.putAll(state.getCollectionStates());\n        \n        final Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n        \n        if (!slices.containsKey(sliceName)) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          final Map<String,ZkNodeProps> newShards = new LinkedHashMap<String,ZkNodeProps>();\n          for(Entry<String, ZkNodeProps> shard: slices.get(sliceName).getShards().entrySet()) {\n            Map<String, String> newShardProps = new LinkedHashMap<String,String>();\n            newShardProps.putAll(shard.getValue().getProperties());\n            \n            newShardProps.remove(ZkStateReader.LEADER_PROP);  //clean any previously existed flag\n            \n            ZkCoreNodeProps zkCoreNodeProps = new ZkCoreNodeProps(new ZkNodeProps(newShardProps));\n            if(leaderUrl!=null && leaderUrl.equals(zkCoreNodeProps.getCoreUrl())) {\n              newShardProps.put(ZkStateReader.LEADER_PROP,\"true\");\n            }\n            newShards.put(shard.getKey(), new ZkNodeProps(newShardProps));\n          }\n          Slice slice = new Slice(sliceName, newShards);\n          slices.put(sliceName, slice);\n        }\n        return new ClusterState(state.getLiveNodes(), newStates);\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5280dd0bd8aa6103cae92307392505c83841c9d5","date":1348001289,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collection, String sliceName, String leaderUrl) {\n\n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>(state.getCollectionStates());\n\n        Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<String,Slice>(slices);\n        newStates.put(collection, slices);\n\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<String,Replica>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n        return new ClusterState(state.getLiveNodes(), newStates);\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collection, String sliceName, String leaderUrl) {\n        \n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>();\n        newStates.putAll(state.getCollectionStates());\n        \n        final Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n        \n        if (!slices.containsKey(sliceName)) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          final Map<String,Replica> newShards = new LinkedHashMap<String,Replica>();\n          for(Entry<String, Replica> shard: slices.get(sliceName).getReplicasMap().entrySet()) {\n            Map<String, Object> newShardProps = new LinkedHashMap<String,Object>();\n            newShardProps.putAll(shard.getValue().getProperties());\n            \n            newShardProps.remove(ZkStateReader.LEADER_PROP);  //clean any previously existed flag\n            \n            ZkCoreNodeProps zkCoreNodeProps = new ZkCoreNodeProps(new ZkNodeProps(newShardProps));\n            if(leaderUrl!=null && leaderUrl.equals(zkCoreNodeProps.getCoreUrl())) {\n              newShardProps.put(ZkStateReader.LEADER_PROP,\"true\");\n            }\n            newShards.put(shard.getKey(), new Replica(shard.getKey(), newShardProps));\n          }\n          Slice slice = new Slice(sliceName, newShards);\n          slices.put(sliceName, slice);\n        }\n        return new ClusterState(state.getLiveNodes(), newStates);\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n\n        final Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>(state.getCollectionStates());\n        DocCollection coll = newCollections.get(collectionName);\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<String,Slice>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<String,Replica>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        newCollections.put(collectionName, newCollection);\n        return new ClusterState(state.getLiveNodes(), newCollections);\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collection, String sliceName, String leaderUrl) {\n\n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>(state.getCollectionStates());\n\n        Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<String,Slice>(slices);\n        newStates.put(collection, slices);\n\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<String,Replica>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n        return new ClusterState(state.getLiveNodes(), newStates);\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n\n        final Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>(state.getCollectionStates());\n        DocCollection coll = newCollections.get(collectionName);\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<String,Slice>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<String,Replica>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        newCollections.put(collectionName, newCollection);\n        return new ClusterState(state.getLiveNodes(), newCollections);\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collection, String sliceName, String leaderUrl) {\n\n        final Map<String, Map<String, Slice>> newStates = new LinkedHashMap<String,Map<String,Slice>>(state.getCollectionStates());\n\n        Map<String, Slice> slices = newStates.get(collection);\n\n        if(slices==null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collection);\n          return state;\n        }\n\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<String,Slice>(slices);\n        newStates.put(collection, slices);\n\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<String,Replica>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n        return new ClusterState(state.getLiveNodes(), newStates);\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n\n        final Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>(state.getCollectionStates());\n        DocCollection coll = newCollections.get(collectionName);\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<String,Slice>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<String,Replica>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        newCollections.put(collectionName, newCollection);\n        return new ClusterState(state.getLiveNodes(), newCollections);\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n\n        final Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>(state.getCollectionStates());\n        DocCollection coll = newCollections.get(collectionName);\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<String,Slice>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<String,Replica>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        newCollections.put(collectionName, newCollection);\n        return new ClusterState(state.getLiveNodes(), newCollections);\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n\n        final Map<String, DocCollection> newCollections = new LinkedHashMap<>(state.getCollectionStates());\n        DocCollection coll = newCollections.get(collectionName);\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        newCollections.put(collectionName, newCollection);\n        return new ClusterState(state.getLiveNodes(), newCollections);\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n\n        final Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>(state.getCollectionStates());\n        DocCollection coll = newCollections.get(collectionName);\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<String,Slice>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<String,Replica>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<String,Object>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        newCollections.put(collectionName, newCollection);\n        return new ClusterState(state.getLiveNodes(), newCollections);\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n        DocCollection coll = state.getCollectionOrNull(collectionName);\n\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        return newState(state, singletonMap(collectionName, newCollection));\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n\n        final Map<String, DocCollection> newCollections = new LinkedHashMap<>(state.getCollectionStates());\n        DocCollection coll = newCollections.get(collectionName);\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        newCollections.put(collectionName, newCollection);\n        return new ClusterState(state.getLiveNodes(), newCollections);\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n        DocCollection coll = state.getCollectionOrNull(collectionName);\n\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = coll.copyWith(slices);\n        return newState(state, singletonMap(collectionName, newCollection));\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n        DocCollection coll = state.getCollectionOrNull(collectionName);\n\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        return newState(state, singletonMap(collectionName, newCollection));\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n        DocCollection coll = state.getCollectionOrNull(collectionName);\n\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        return newState(state, singletonMap(collectionName, newCollection));\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n        DocCollection coll = state.getCollectionOrNull(collectionName);\n\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = coll.copyWith(slices);\n        return newState(state, singletonMap(collectionName, newCollection));\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n        DocCollection coll = state.getCollectionOrNull(collectionName);\n\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = coll.copyWithSlices(slices);\n        return newState(state, singletonMap(collectionName, newCollection));\n      }\n\n","sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n        DocCollection coll = state.getCollectionOrNull(collectionName);\n\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = new DocCollection(coll.getName(), slices, coll.getProperties(), coll.getRouter());\n        return newState(state, singletonMap(collectionName, newCollection));\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#setShardLeader(ClusterState,String,String,String).mjava","sourceNew":null,"sourceOld":"      private ClusterState setShardLeader(ClusterState state, String collectionName, String sliceName, String leaderUrl) {\n        DocCollection coll = state.getCollectionOrNull(collectionName);\n\n        if(coll == null) {\n          log.error(\"Could not mark shard leader for non existing collection:\" + collectionName);\n          return state;\n        }\n\n        Map<String, Slice> slices = coll.getSlicesMap();\n        // make a shallow copy and add it to the new collection\n        slices = new LinkedHashMap<>(slices);\n\n        Slice slice = slices.get(sliceName);\n        if (slice == null) {\n          slice = coll.getSlice(sliceName);\n        }\n\n        if (slice == null) {\n          log.error(\"Could not mark leader for non existing/active slice:\" + sliceName);\n          return state;\n        } else {\n          // TODO: consider just putting the leader property on the shard, not on individual replicas\n\n          Replica oldLeader = slice.getLeader();\n\n          final Map<String,Replica> newReplicas = new LinkedHashMap<>();\n\n          for (Replica replica : slice.getReplicas()) {\n\n            // TODO: this should only be calculated once and cached somewhere?\n            String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getStr(ZkStateReader.BASE_URL_PROP), replica.getStr(ZkStateReader.CORE_NAME_PROP));\n\n            if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.remove(Slice.LEADER);\n              replica = new Replica(replica.getName(), replicaProps);\n            } else if (coreURL.equals(leaderUrl)) {\n              Map<String,Object> replicaProps = new LinkedHashMap<>(replica.getProperties());\n              replicaProps.put(Slice.LEADER, \"true\");  // TODO: allow booleans instead of strings\n              replica = new Replica(replica.getName(), replicaProps);\n            }\n\n            newReplicas.put(replica.getName(), replica);\n          }\n\n          Map<String,Object> newSliceProps = slice.shallowCopy();\n          newSliceProps.put(Slice.REPLICAS, newReplicas);\n          Slice newSlice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n          slices.put(newSlice.getName(), newSlice);\n        }\n\n\n        DocCollection newCollection = coll.copyWithSlices(slices);\n        return newState(state, singletonMap(collectionName, newCollection));\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"5280dd0bd8aa6103cae92307392505c83841c9d5":["fa64435b5902ce266c23755a4a00691a3285dab8"],"fa64435b5902ce266c23755a4a00691a3285dab8":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"407687e67faf6e1f02a211ca078d8e3eed631027":["5280dd0bd8aa6103cae92307392505c83841c9d5","c5a558d54519c651068ddb202f03befefb1514a7"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["c5a558d54519c651068ddb202f03befefb1514a7"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"c5a558d54519c651068ddb202f03befefb1514a7":["5280dd0bd8aa6103cae92307392505c83841c9d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"5280dd0bd8aa6103cae92307392505c83841c9d5":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"fa64435b5902ce266c23755a4a00691a3285dab8":["5280dd0bd8aa6103cae92307392505c83841c9d5"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"9279b175e5e66258442d2123a50f052219a9cc1b":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["fa64435b5902ce266c23755a4a00691a3285dab8","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"c5a558d54519c651068ddb202f03befefb1514a7":["407687e67faf6e1f02a211ca078d8e3eed631027","0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8fd5be977c105554c6a7b68afcdbc511439723ab","3f767f8c99eaedb984df754fe61f21c5de260f94","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}