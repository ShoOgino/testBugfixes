{"path":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud#assertSpinLoopAllJettyAreRunning(MiniSolrCloudCluster).mjava","commits":[{"id":"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","date":1458928975,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud#assertSpinLoopAllJettyAreRunning(MiniSolrCloudCluster).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * HACK: Loops over every Jetty instance in the specified MiniSolrCloudCluster to see if they are running,\n   * and sleeps small increments until they all report that they are, or a max num iters is reached\n   * \n   * (work around for SOLR-8862.  Maybe something like this should be promoted into MiniSolrCloudCluster's \n   * start() method? or SolrCloudTestCase's configureCluster?)\n   */\n  public static void assertSpinLoopAllJettyAreRunning(MiniSolrCloudCluster cluster) throws InterruptedException {\n    // NOTE: idealy we could use an ExecutorService that tried to open Sockets (with a long timeout)\n    // to each of the jetty instances in parallel w/o any sleeping -- but since they pick their ports\n    // dynamically and don't report them until/unless the server is up, that won't neccessarily do us\n    // any good.\n    final int numServers = cluster.getJettySolrRunners().size();\n    int numRunning = 0;\n    for (int i = 5; 0 <= i; i--) {\n      numRunning = 0;\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        if (jetty.isRunning()) {\n          numRunning++;\n        }\n      }\n      if (numServers == numRunning) {\n        return;\n      } else if (0 == i) {\n        // give up\n        break;\n      }\n      // the more nodes we're waiting on, the longer we should try to sleep (within reason)\n      Thread.sleep(Math.min((numServers - numRunning) * 100, 1000));\n    }\n    assertEquals(\"giving up waiting for all jetty instances to be running\",\n                 numServers, numRunning);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":4,"author":"markrmiller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud#assertSpinLoopAllJettyAreRunning(MiniSolrCloudCluster).mjava","sourceNew":null,"sourceOld":"  /**\n   * HACK: Loops over every Jetty instance in the specified MiniSolrCloudCluster to see if they are running,\n   * and sleeps small increments until they all report that they are, or a max num iters is reached\n   * \n   * (work around for SOLR-8862.  Maybe something like this should be promoted into MiniSolrCloudCluster's \n   * start() method? or SolrCloudTestCase's configureCluster?)\n   */\n  public static void assertSpinLoopAllJettyAreRunning(MiniSolrCloudCluster cluster) throws InterruptedException {\n    // NOTE: idealy we could use an ExecutorService that tried to open Sockets (with a long timeout)\n    // to each of the jetty instances in parallel w/o any sleeping -- but since they pick their ports\n    // dynamically and don't report them until/unless the server is up, that won't neccessarily do us\n    // any good.\n    final int numServers = cluster.getJettySolrRunners().size();\n    int numRunning = 0;\n    for (int i = 5; 0 <= i; i--) {\n      numRunning = 0;\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        if (jetty.isRunning()) {\n          numRunning++;\n        }\n      }\n      if (numServers == numRunning) {\n        return;\n      } else if (0 == i) {\n        // give up\n        break;\n      }\n      // the more nodes we're waiting on, the longer we should try to sleep (within reason)\n      Thread.sleep(Math.min((numServers - numRunning) * 100, 1000));\n    }\n    assertEquals(\"giving up waiting for all jetty instances to be running\",\n                 numServers, numRunning);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}