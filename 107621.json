{"path":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","commits":[{"id":"6f26f74e4969851a019d28f10315cb1c77786f22","date":1400539241,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"/dev/null","sourceNew":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n    CollectionAdminRequest.createCollection(\"ocptest_shardsplit\", 4, \"conf1\", server, \"1000\");\n\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD1, server, \"1001\");\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD2, server, \"1002\");\n\n    int iterations = 0;\n    while(true) {\n      int runningTasks = 0;\n      int completedTasks = 0;\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestState(i, server);\n        if (state.equals(\"running\"))\n          runningTasks++;\n        if (state.equals(\"completed\"))\n          completedTasks++;\n        assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n      }\n      // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n      // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n      \n      assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n\n      if(completedTasks == 2 || iterations++ > 90)\n        break;\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n    for (int i=1001;i<=1002;i++) {\n      String state = getRequestStateAfterCompletion(i + \"\", 30, server);\n      assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"/dev/null","sourceNew":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n    CollectionAdminRequest.createCollection(\"ocptest_shardsplit\", 4, \"conf1\", server, \"1000\");\n\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD1, server, \"1001\");\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD2, server, \"1002\");\n\n    int iterations = 0;\n    while(true) {\n      int runningTasks = 0;\n      int completedTasks = 0;\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestState(i, server);\n        if (state.equals(\"running\"))\n          runningTasks++;\n        if (state.equals(\"completed\"))\n          completedTasks++;\n        assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n      }\n      // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n      // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n      \n      assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n\n      if(completedTasks == 2 || iterations++ > 90)\n        break;\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n    for (int i=1001;i<=1002;i++) {\n      String state = getRequestStateAfterCompletion(i + \"\", 30, server);\n      assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c8fec3cd782d7ae08ef7a6459a3e3ef41005c83","date":1404591706,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n    CollectionAdminRequest.createCollection(\"ocptest_shardsplit\", 4, \"conf1\", server, \"1000\");\n\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD1, server, \"1001\");\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD2, server, \"1002\");\n\n    int iterations = 0;\n    while(true) {\n      int runningTasks = 0;\n      int completedTasks = 0;\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestState(i, server);\n        if (state.equals(\"running\"))\n          runningTasks++;\n        if (state.equals(\"completed\"))\n          completedTasks++;\n        assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n      }\n      // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n      // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n      \n      assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n\n      if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n        break;\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n    for (int i=1001;i<=1002;i++) {\n      String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, server);\n      assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n    CollectionAdminRequest.createCollection(\"ocptest_shardsplit\", 4, \"conf1\", server, \"1000\");\n\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD1, server, \"1001\");\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD2, server, \"1002\");\n\n    int iterations = 0;\n    while(true) {\n      int runningTasks = 0;\n      int completedTasks = 0;\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestState(i, server);\n        if (state.equals(\"running\"))\n          runningTasks++;\n        if (state.equals(\"completed\"))\n          completedTasks++;\n        assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n      }\n      // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n      // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n      \n      assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n\n      if(completedTasks == 2 || iterations++ > 90)\n        break;\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n    for (int i=1001;i<=1002;i++) {\n      String state = getRequestStateAfterCompletion(i + \"\", 30, server);\n      assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a7d7ef06ef6f04ba2de657e90e0458048a967c6","date":1409691631,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(\"ocptest_shardsplit\");\n    createCollectionRequest.setNumShards(4);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setAsyncId(\"1000\");\n    createCollectionRequest.process(server);\n\n    SplitShard splitShardRequest = new SplitShard();\n    splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n    splitShardRequest.setShardName(SHARD1);\n    splitShardRequest.setAsyncId(\"1001\");\n    splitShardRequest.process(server);\n\n    splitShardRequest = new SplitShard();\n    splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n    splitShardRequest.setShardName(SHARD2);\n    splitShardRequest.setAsyncId(\"1002\");\n    splitShardRequest.process(server);\n\n    int iterations = 0;\n    while(true) {\n      int runningTasks = 0;\n      int completedTasks = 0;\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestState(i, server);\n        if (state.equals(\"running\"))\n          runningTasks++;\n        if (state.equals(\"completed\"))\n          completedTasks++;\n        assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n      }\n      // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n      // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n      \n      assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n\n      if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n        break;\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n    for (int i=1001;i<=1002;i++) {\n      String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, server);\n      assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n    CollectionAdminRequest.createCollection(\"ocptest_shardsplit\", 4, \"conf1\", server, \"1000\");\n\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD1, server, \"1001\");\n    CollectionAdminRequest.splitShard(\"ocptest_shardsplit\", SHARD2, server, \"1002\");\n\n    int iterations = 0;\n    while(true) {\n      int runningTasks = 0;\n      int completedTasks = 0;\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestState(i, server);\n        if (state.equals(\"running\"))\n          runningTasks++;\n        if (state.equals(\"completed\"))\n          completedTasks++;\n        assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n      }\n      // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n      // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n      \n      assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n\n      if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n        break;\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n    for (int i=1001;i<=1002;i++) {\n      String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, server);\n      assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(\"ocptest_shardsplit\");\n    createCollectionRequest.setNumShards(4);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setAsyncId(\"1000\");\n    createCollectionRequest.process(client);\n\n    SplitShard splitShardRequest = new SplitShard();\n    splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n    splitShardRequest.setShardName(SHARD1);\n    splitShardRequest.setAsyncId(\"1001\");\n    splitShardRequest.process(client);\n\n    splitShardRequest = new SplitShard();\n    splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n    splitShardRequest.setShardName(SHARD2);\n    splitShardRequest.setAsyncId(\"1002\");\n    splitShardRequest.process(client);\n\n    int iterations = 0;\n    while(true) {\n      int runningTasks = 0;\n      int completedTasks = 0;\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestState(i, client);\n        if (state.equals(\"running\"))\n          runningTasks++;\n        if (state.equals(\"completed\"))\n          completedTasks++;\n        assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n      }\n      // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n      // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n      \n      assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n\n      if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n        break;\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n    for (int i=1001;i<=1002;i++) {\n      String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n      assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(\"ocptest_shardsplit\");\n    createCollectionRequest.setNumShards(4);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setAsyncId(\"1000\");\n    createCollectionRequest.process(server);\n\n    SplitShard splitShardRequest = new SplitShard();\n    splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n    splitShardRequest.setShardName(SHARD1);\n    splitShardRequest.setAsyncId(\"1001\");\n    splitShardRequest.process(server);\n\n    splitShardRequest = new SplitShard();\n    splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n    splitShardRequest.setShardName(SHARD2);\n    splitShardRequest.setAsyncId(\"1002\");\n    splitShardRequest.process(server);\n\n    int iterations = 0;\n    while(true) {\n      int runningTasks = 0;\n      int completedTasks = 0;\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestState(i, server);\n        if (state.equals(\"running\"))\n          runningTasks++;\n        if (state.equals(\"completed\"))\n          completedTasks++;\n        assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n      }\n      // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n      // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n      \n      assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n\n      if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n        break;\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n    for (int i=1001;i<=1002;i++) {\n      String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, server);\n      assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n    try {\n      Create createCollectionRequest = new Create();\n      createCollectionRequest.setCollectionName(\"ocptest_shardsplit\");\n      createCollectionRequest.setNumShards(4);\n      createCollectionRequest.setConfigName(\"conf1\");\n      createCollectionRequest.setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n  \n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"1001\");\n      splitShardRequest.process(client);\n  \n      splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n      splitShardRequest.setShardName(SHARD2);\n      splitShardRequest.setAsyncId(\"1002\");\n      splitShardRequest.process(client);\n  \n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i=1001;i<=1002;i++) {\n          String state = getRequestState(i, client);\n          if (state.equals(\"running\"))\n            runningTasks++;\n          if (state.equals(\"completed\"))\n            completedTasks++;\n          assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n      }\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n    Create createCollectionRequest = new Create();\n    createCollectionRequest.setCollectionName(\"ocptest_shardsplit\");\n    createCollectionRequest.setNumShards(4);\n    createCollectionRequest.setConfigName(\"conf1\");\n    createCollectionRequest.setAsyncId(\"1000\");\n    createCollectionRequest.process(client);\n\n    SplitShard splitShardRequest = new SplitShard();\n    splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n    splitShardRequest.setShardName(SHARD1);\n    splitShardRequest.setAsyncId(\"1001\");\n    splitShardRequest.process(client);\n\n    splitShardRequest = new SplitShard();\n    splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n    splitShardRequest.setShardName(SHARD2);\n    splitShardRequest.setAsyncId(\"1002\");\n    splitShardRequest.process(client);\n\n    int iterations = 0;\n    while(true) {\n      int runningTasks = 0;\n      int completedTasks = 0;\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestState(i, client);\n        if (state.equals(\"running\"))\n          runningTasks++;\n        if (state.equals(\"completed\"))\n          completedTasks++;\n        assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n      }\n      // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n      // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n      \n      assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n\n      if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n        break;\n\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n    for (int i=1001;i<=1002;i++) {\n      String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n      assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n    }\n  }\n\n","bugFix":["6f26f74e4969851a019d28f10315cb1c77786f22","bafca15d8e408346a67f4282ad1143b88023893b","7c8fec3cd782d7ae08ef7a6459a3e3ef41005c83","4a7d7ef06ef6f04ba2de657e90e0458048a967c6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n      Create createCollectionRequest = new Create();\n      createCollectionRequest.setCollectionName(\"ocptest_shardsplit\");\n      createCollectionRequest.setNumShards(4);\n      createCollectionRequest.setConfigName(\"conf1\");\n      createCollectionRequest.setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n  \n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"1001\");\n      splitShardRequest.process(client);\n  \n      splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n      splitShardRequest.setShardName(SHARD2);\n      splitShardRequest.setAsyncId(\"1002\");\n      splitShardRequest.process(client);\n  \n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i=1001;i<=1002;i++) {\n          String state = getRequestState(i, client);\n          if (state.equals(\"running\"))\n            runningTasks++;\n          if (state.equals(\"completed\"))\n            completedTasks++;\n          assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n    try {\n      Create createCollectionRequest = new Create();\n      createCollectionRequest.setCollectionName(\"ocptest_shardsplit\");\n      createCollectionRequest.setNumShards(4);\n      createCollectionRequest.setConfigName(\"conf1\");\n      createCollectionRequest.setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n  \n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"1001\");\n      splitShardRequest.process(client);\n  \n      splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n      splitShardRequest.setShardName(SHARD2);\n      splitShardRequest.setAsyncId(\"1002\");\n      splitShardRequest.process(client);\n  \n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i=1001;i<=1002;i++) {\n          String state = getRequestState(i, client);\n          if (state.equals(\"running\"))\n            runningTasks++;\n          if (state.equals(\"completed\"))\n            completedTasks++;\n          assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n      }\n    } finally {\n      client.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"182acd29cf4cb1644a02b8517f3a5b867c0d7cce","date":1432665213,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n  \n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"1001\");\n      splitShardRequest.process(client);\n  \n      splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD2)\n              .setAsyncId(\"1002\");\n      splitShardRequest.process(client);\n  \n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i=1001;i<=1002;i++) {\n          String state = getRequestState(i, client);\n          if (state.equals(\"running\"))\n            runningTasks++;\n          if (state.equals(\"completed\"))\n            completedTasks++;\n          assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n      Create createCollectionRequest = new Create();\n      createCollectionRequest.setCollectionName(\"ocptest_shardsplit\");\n      createCollectionRequest.setNumShards(4);\n      createCollectionRequest.setConfigName(\"conf1\");\n      createCollectionRequest.setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n  \n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"1001\");\n      splitShardRequest.process(client);\n  \n      splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"ocptest_shardsplit\");\n      splitShardRequest.setShardName(SHARD2);\n      splitShardRequest.setAsyncId(\"1002\");\n      splitShardRequest.process(client);\n  \n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i=1001;i<=1002;i++) {\n          String state = getRequestState(i, client);\n          if (state.equals(\"running\"))\n            runningTasks++;\n          if (state.equals(\"completed\"))\n            completedTasks++;\n          assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3088cdaa24ffe3ef44713ac9484114bd56eca2af","date":1453441194,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n  \n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"1001\");\n      splitShardRequest.process(client);\n  \n      splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD2)\n              .setAsyncId(\"1002\");\n      splitShardRequest.process(client);\n  \n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n  \n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"1001\");\n      splitShardRequest.process(client);\n  \n      splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD2)\n              .setAsyncId(\"1002\");\n      splitShardRequest.process(client);\n  \n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i=1001;i<=1002;i++) {\n          String state = getRequestState(i, client);\n          if (state.equals(\"running\"))\n            runningTasks++;\n          if (state.equals(\"completed\"))\n            completedTasks++;\n          assertTrue(\"We have a failed SPLITSHARD task\", !state.equals(\"failed\"));\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i=1001;i<=1002;i++) {\n        String state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertTrue(\"Task \" + i + \" did not complete, final state: \" + state,state.equals(\"completed\"));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"781578ca5d3d2194bc55fc3457c62aef623db6f2","date":1464859077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.MOCK_COLL_TASK.toLower(),\n          CommonAdminParams.ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.MOCK_COLL_TASK.toLower(),\n          CommonAdminParams.ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n  \n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"1001\");\n      splitShardRequest.process(client);\n  \n      splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD2)\n              .setAsyncId(\"1002\");\n      splitShardRequest.process(client);\n  \n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e4014209b24e71d602e579a316f994355596012","date":1465717267,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.MOCK_COLL_TASK.toLower(),\n          CommonAdminParams.ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.MOCK_COLL_TASK.toLower(),\n          CommonAdminParams.ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws IOException, SolrServerException {\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n  \n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"1001\");\n      splitShardRequest.process(client);\n  \n      splitShardRequest = new SplitShard()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setShardName(SHARD2)\n              .setAsyncId(\"1002\");\n      splitShardRequest.process(client);\n  \n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac97ea104d893f16aab430d9904473bc1f233f3c","date":1496249396,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3217321f3e1d7922898c6c633d17acfa840d6875","date":1496257480,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","date":1496281877,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = new Create()\n              .setCollectionName(\"ocptest_shardsplit\")\n              .setNumShards(4)\n              .setConfigName(\"conf1\")\n              .setAsyncId(\"1000\");\n      createCollectionRequest.process(client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new ZkDistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new ZkDistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e","date":1505888025,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new ZkDistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new ZkDistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new DistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testTaskExclusivity().mjava","sourceNew":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new ZkDistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","sourceOld":"  private void testTaskExclusivity() throws Exception, SolrServerException {\n\n    DistributedQueue distributedQueue = new ZkDistributedQueue(cloudClient.getZkStateReader().getZkClient(),\n        \"/overseer/collection-queue-work\", new Overseer.Stats());\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      Create createCollectionRequest = CollectionAdminRequest.createCollection(\"ocptest_shardsplit\",\"conf1\",4,1);\n      createCollectionRequest.processAsync(\"1000\",client);\n\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1001\",\n          \"sleep\", \"100\"\n      )));\n      distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n          \"collection\", \"ocptest_shardsplit\",\n          QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n          ASYNC, \"1002\",\n          \"sleep\", \"100\"\n      )));\n\n      int iterations = 0;\n      while(true) {\n        int runningTasks = 0;\n        int completedTasks = 0;\n        for (int i = 1001; i <= 1002; i++) {\n          final RequestStatusState state = getRequestState(i, client);\n          if (state == RequestStatusState.RUNNING) {\n            runningTasks++;\n          } else if (state == RequestStatusState.COMPLETED) {\n            completedTasks++;\n          }\n          assertNotSame(\"We have a failed SPLITSHARD task\", RequestStatusState.FAILED, state);\n        }\n        // TODO: REQUESTSTATUS might come back with more than 1 running tasks over multiple calls.\n        // The only way to fix this is to support checking of multiple requestids in a single REQUESTSTATUS task.\n        \n        assertTrue(\"Mutual exclusion failed. Found more than one task running for the same collection\", runningTasks < 2);\n  \n        if(completedTasks == 2 || iterations++ > REQUEST_STATUS_TIMEOUT)\n          break;\n  \n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          return;\n        }\n      }\n      for (int i = 1001; i <= 1002; i++) {\n        final RequestStatusState state = getRequestStateAfterCompletion(i + \"\", REQUEST_STATUS_TIMEOUT, client);\n        assertSame(\"Task \" + i + \" did not complete, final state: \" + state, RequestStatusState.COMPLETED, state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3088cdaa24ffe3ef44713ac9484114bd56eca2af":["182acd29cf4cb1644a02b8517f3a5b867c0d7cce"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"1e4014209b24e71d602e579a316f994355596012":["781578ca5d3d2194bc55fc3457c62aef623db6f2"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["1e4014209b24e71d602e579a316f994355596012"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"bafca15d8e408346a67f4282ad1143b88023893b":["4a7d7ef06ef6f04ba2de657e90e0458048a967c6"],"3217321f3e1d7922898c6c633d17acfa840d6875":["1e4014209b24e71d602e579a316f994355596012","ac97ea104d893f16aab430d9904473bc1f233f3c"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"b7605579001505896d48b07160075a5c8b8e128e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6f26f74e4969851a019d28f10315cb1c77786f22"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["1e4014209b24e71d602e579a316f994355596012","3217321f3e1d7922898c6c633d17acfa840d6875"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3088cdaa24ffe3ef44713ac9484114bd56eca2af","1e4014209b24e71d602e579a316f994355596012"],"781578ca5d3d2194bc55fc3457c62aef623db6f2":["3088cdaa24ffe3ef44713ac9484114bd56eca2af"],"4a7d7ef06ef6f04ba2de657e90e0458048a967c6":["7c8fec3cd782d7ae08ef7a6459a3e3ef41005c83"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["1e4014209b24e71d602e579a316f994355596012","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["b869898f50ca80263bac2e3ae0949f7700e5c977","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["3217321f3e1d7922898c6c633d17acfa840d6875"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"182acd29cf4cb1644a02b8517f3a5b867c0d7cce":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"6f26f74e4969851a019d28f10315cb1c77786f22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["bafca15d8e408346a67f4282ad1143b88023893b"],"7c8fec3cd782d7ae08ef7a6459a3e3ef41005c83":["6f26f74e4969851a019d28f10315cb1c77786f22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"]},"commit2Childs":{"3088cdaa24ffe3ef44713ac9484114bd56eca2af":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","781578ca5d3d2194bc55fc3457c62aef623db6f2"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"1e4014209b24e71d602e579a316f994355596012":["ac97ea104d893f16aab430d9904473bc1f233f3c","3217321f3e1d7922898c6c633d17acfa840d6875","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["3217321f3e1d7922898c6c633d17acfa840d6875"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bafca15d8e408346a67f4282ad1143b88023893b":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"3217321f3e1d7922898c6c633d17acfa840d6875":["42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"b7605579001505896d48b07160075a5c8b8e128e":[],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"781578ca5d3d2194bc55fc3457c62aef623db6f2":["1e4014209b24e71d602e579a316f994355596012"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"4a7d7ef06ef6f04ba2de657e90e0458048a967c6":["bafca15d8e408346a67f4282ad1143b88023893b"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b7605579001505896d48b07160075a5c8b8e128e","6f26f74e4969851a019d28f10315cb1c77786f22"],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8","6240b74b884c5587f2a4062dd27d6c32bf228889"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["182acd29cf4cb1644a02b8517f3a5b867c0d7cce"],"182acd29cf4cb1644a02b8517f3a5b867c0d7cce":["3088cdaa24ffe3ef44713ac9484114bd56eca2af"],"6f26f74e4969851a019d28f10315cb1c77786f22":["b7605579001505896d48b07160075a5c8b8e128e","7c8fec3cd782d7ae08ef7a6459a3e3ef41005c83"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"7c8fec3cd782d7ae08ef7a6459a3e3ef41005c83":["4a7d7ef06ef6f04ba2de657e90e0458048a967c6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}