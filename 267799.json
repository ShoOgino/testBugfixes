{"path":"lucene/core/src/java/org/apache/lucene/index/TermStates#build(IndexReaderContext,Term,boolean).mjava","commits":[{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermStates#build(IndexReaderContext,Term,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TermContext#build(IndexReaderContext,Term).mjava","sourceNew":"  /**\n   * Creates a {@link TermStates} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermStates}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   *\n   * @param needsStats if {@code true} then all leaf contexts will be visited up-front to\n   *                   collect term statistics.  Otherwise, the {@link TermState} objects\n   *                   will be built only when requested\n   */\n  public static TermStates build(IndexReaderContext context, Term term, boolean needsStats)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final TermStates perReaderTermState = new TermStates(needsStats ? null : term, context);\n    if (needsStats) {\n      for (final LeafReaderContext ctx : context.leaves()) {\n        //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n        TermsEnum termsEnum = loadTermsEnum(ctx, term);\n        if (termsEnum != null) {\n          final TermState termState = termsEnum.termState();\n          //if (DEBUG) System.out.println(\"    found\");\n          perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermContext}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   */\n  public static TermContext build(IndexReaderContext context, Term term)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final String field = term.field();\n    final BytesRef bytes = term.bytes();\n    final TermContext perReaderTermState = new TermContext(context);\n    //if (DEBUG) System.out.println(\"prts.build term=\" + term);\n    for (final LeafReaderContext ctx : context.leaves()) {\n      //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n      final Terms terms = ctx.reader().terms(field);\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        if (termsEnum.seekExact(bytes)) { \n          final TermState termState = termsEnum.termState();\n          //if (DEBUG) System.out.println(\"    found\");\n          perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TermStates#build(IndexReaderContext,Term,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a {@link TermStates} from a top-level {@link IndexReaderContext} and the\n   * given {@link Term}. This method will lookup the given term in all context's leaf readers \n   * and register each of the readers containing the term in the returned {@link TermStates}\n   * using the leaf reader's ordinal.\n   * <p>\n   * Note: the given context must be a top-level context.\n   *\n   * @param needsStats if {@code true} then all leaf contexts will be visited up-front to\n   *                   collect term statistics.  Otherwise, the {@link TermState} objects\n   *                   will be built only when requested\n   */\n  public static TermStates build(IndexReaderContext context, Term term, boolean needsStats)\n      throws IOException {\n    assert context != null && context.isTopLevel;\n    final TermStates perReaderTermState = new TermStates(needsStats ? null : term, context);\n    if (needsStats) {\n      for (final LeafReaderContext ctx : context.leaves()) {\n        //if (DEBUG) System.out.println(\"  r=\" + leaves[i].reader);\n        TermsEnum termsEnum = loadTermsEnum(ctx, term);\n        if (termsEnum != null) {\n          final TermState termState = termsEnum.termState();\n          //if (DEBUG) System.out.println(\"    found\");\n          perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());\n        }\n      }\n    }\n    return perReaderTermState;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a6e9f769521480a623f897c0d59089b919fa4239"],"a6e9f769521480a623f897c0d59089b919fa4239":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","a6e9f769521480a623f897c0d59089b919fa4239"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}