{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","commits":[{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  private void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<Object>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        assert null != lastDoc.score : \"lastDoc has null score\";\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","sourceNew":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  private void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        assert null != lastDoc.score : \"lastDoc has null score\";\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","sourceOld":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  private void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<Object>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        assert null != lastDoc.score : \"lastDoc has null score\";\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25b6cbab4dc52657a3a562c0c3f2886c683954f1","date":1397859026,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","sourceNew":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  private void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","sourceOld":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  private void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        assert null != lastDoc.score : \"lastDoc has null score\";\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35d59689803f4ad27f96148bb7c7167e373c6770","date":1454297137,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","sourceNew":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  protected void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","sourceOld":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  private void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","sourceNew":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  protected void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","sourceOld":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  private void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#populateNextCursorMarkFromMergedShards(ResponseBuilder).mjava","sourceNew":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  protected void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        @SuppressWarnings({\"unchecked\"})\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","sourceOld":"  /**\n   * Inspects the state of the {@link ResponseBuilder} and populates the next \n   * {@link ResponseBuilder#setNextCursorMark} as appropriate based on the merged \n   * sort values from individual shards\n   *\n   * @param rb A <code>ResponseBuilder</code> that already contains merged \n   *           <code>ShardDocs</code> in <code>resultIds</code>, may or may not be \n   *           part of a Cursor based request (method will NOOP if not needed)\n   */\n  protected void populateNextCursorMarkFromMergedShards(ResponseBuilder rb) {\n\n    final CursorMark lastCursorMark = rb.getCursorMark();\n    if (null == lastCursorMark) {\n      // Not a cursor based request\n      return; // NOOP\n    }\n\n    assert null != rb.resultIds : \"resultIds was not set in ResponseBuilder\";\n\n    Collection<ShardDoc> docsOnThisPage = rb.resultIds.values();\n\n    if (0 == docsOnThisPage.size()) {\n      // nothing more matching query, re-use existing totem so user can \"resume\" \n      // search later if it makes sense for this sort.\n      rb.setNextCursorMark(lastCursorMark);\n      return;\n    }\n\n    ShardDoc lastDoc = null;\n    // ShardDoc and rb.resultIds are weird structures to work with...\n    for (ShardDoc eachDoc : docsOnThisPage) {\n      if (null == lastDoc || lastDoc.positionInResponse  < eachDoc.positionInResponse) {\n        lastDoc = eachDoc;\n      }\n    }\n    SortField[] sortFields = lastCursorMark.getSortSpec().getSort().getSort();\n    List<Object> nextCursorMarkValues = new ArrayList<>(sortFields.length);\n    for (SortField sf : sortFields) {\n      if (sf.getType().equals(SortField.Type.SCORE)) {\n        nextCursorMarkValues.add(lastDoc.score);\n      } else {\n        assert null != sf.getField() : \"SortField has null field\";\n        List<Object> fieldVals = (List<Object>) lastDoc.sortFieldValues.get(sf.getField());\n        nextCursorMarkValues.add(fieldVals.get(lastDoc.orderInShard));\n      }\n    }\n    CursorMark nextCursorMark = lastCursorMark.createNext(nextCursorMarkValues);\n    assert null != nextCursorMark : \"null nextCursorMark\";\n    rb.setNextCursorMark(nextCursorMark);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"25b6cbab4dc52657a3a562c0c3f2886c683954f1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["25b6cbab4dc52657a3a562c0c3f2886c683954f1","35d59689803f4ad27f96148bb7c7167e373c6770"],"35d59689803f4ad27f96148bb7c7167e373c6770":["25b6cbab4dc52657a3a562c0c3f2886c683954f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["35d59689803f4ad27f96148bb7c7167e373c6770"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["25b6cbab4dc52657a3a562c0c3f2886c683954f1"],"25b6cbab4dc52657a3a562c0c3f2886c683954f1":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","35d59689803f4ad27f96148bb7c7167e373c6770"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"35d59689803f4ad27f96148bb7c7167e373c6770":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}