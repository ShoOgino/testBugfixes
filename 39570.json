{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,MergeState).mjava","commits":[{"id":"8a16d06e7522604de20b2d758d9b9464bb30fe02","date":1327070101,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge, mergeState);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,MergeState).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge, mergeState);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge, mergeState);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32feb7c2c571b402d2e231bd8e3b6add4af6d6eb","date":1327773585,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,MergeState).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge, mergeState);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"78a55f24d9b493c2a1cecf79f1d78279062b545b":["8a16d06e7522604de20b2d758d9b9464bb30fe02","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"32feb7c2c571b402d2e231bd8e3b6add4af6d6eb":["78a55f24d9b493c2a1cecf79f1d78279062b545b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8a16d06e7522604de20b2d758d9b9464bb30fe02":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"78a55f24d9b493c2a1cecf79f1d78279062b545b":["32feb7c2c571b402d2e231bd8e3b6add4af6d6eb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["78a55f24d9b493c2a1cecf79f1d78279062b545b","cd5edd1f2b162a5cfa08efd17851a07373a96817","8a16d06e7522604de20b2d758d9b9464bb30fe02"],"32feb7c2c571b402d2e231bd8e3b6add4af6d6eb":[],"8a16d06e7522604de20b2d758d9b9464bb30fe02":["78a55f24d9b493c2a1cecf79f1d78279062b545b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["32feb7c2c571b402d2e231bd8e3b6add4af6d6eb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}