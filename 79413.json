{"path":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","commits":[{"id":"0cd90adb2be0ad7d69e4f6e26f0fab7675176721","date":1409252598,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see replicas [\"+replicasToCheck+\"] become active.\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e36353d7461af8d2329a78a71457cf8e3c1e88f","date":1411572107,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see replicas [\"+replicasToCheck+\"] become active.\");\n  }\n\n","sourceOld":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see replicas [\"+replicasToCheck+\"] become active.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see replicas [\"+replicasToCheck+\"] become active.\");\n  }\n\n","sourceOld":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see replicas [\"+replicasToCheck+\"] become active.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState();\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see replicas [\"+replicasToCheck+\"] become active.\");\n  }\n\n","sourceOld":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see replicas [\"+replicasToCheck+\"] become active.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState();\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","sourceOld":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState();\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see replicas [\"+replicasToCheck+\"] become active.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName);\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","sourceOld":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState();\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"21527799e803fb77d646c5612716d40a48a30335","date":1487775419,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName);\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(200L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 200L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","sourceOld":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName);\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(1000L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 1000L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName);\n    ClusterState cs = zkr.getClusterState();\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(200L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 200L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","sourceOld":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName);\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(200L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 200L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","bugFix":["0cd90adb2be0ad7d69e4f6e26f0fab7675176721"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName);\n    ClusterState cs = zkr.getClusterState();\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(200L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 200L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","sourceOld":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName);\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(200L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 200L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitToSeeReplicasActive(String,String,Set[String],int).mjava","sourceNew":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName);\n    ClusterState cs = zkr.getClusterState();\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Replica {} is currently {}\", replica.getName(), state);\n          }\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(200L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 200L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n    }\n  }\n\n","sourceOld":"  protected void waitToSeeReplicasActive(String testCollectionName, String shardId, Set<String> replicasToCheck, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName);\n    ClusterState cs = zkr.getClusterState();\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n\n      // wait to see all replicas are \"active\"\n      for (Replica replica : shard.getReplicas()) {\n        if (!replicasToCheck.contains(replica.getName()))\n          continue;\n\n        final Replica.State state = replica.getState();\n        if (state != Replica.State.ACTIVE) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + state);\n          allReplicasUp = false;\n        }\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(200L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 200L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see replicas \"+ replicasToCheck +\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo(testCollectionName));\n\n    log.info(\"Took {} ms to see replicas [{}] become active.\", timer.getTime(), replicasToCheck);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a219f1dcad1700e84807666bdbd2b573e8de7021":["6e36353d7461af8d2329a78a71457cf8e3c1e88f"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["21527799e803fb77d646c5612716d40a48a30335","344b0840364d990b29b97467bfcc766ff8325d11"],"344b0840364d990b29b97467bfcc766ff8325d11":["21527799e803fb77d646c5612716d40a48a30335"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"0cd90adb2be0ad7d69e4f6e26f0fab7675176721":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21527799e803fb77d646c5612716d40a48a30335":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["344b0840364d990b29b97467bfcc766ff8325d11"],"6e36353d7461af8d2329a78a71457cf8e3c1e88f":["0cd90adb2be0ad7d69e4f6e26f0fab7675176721"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"a219f1dcad1700e84807666bdbd2b573e8de7021":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"344b0840364d990b29b97467bfcc766ff8325d11":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","a966532d92cf9ba2856f15a8140151bb6b518e4b"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"0cd90adb2be0ad7d69e4f6e26f0fab7675176721":["6e36353d7461af8d2329a78a71457cf8e3c1e88f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0cd90adb2be0ad7d69e4f6e26f0fab7675176721"],"21527799e803fb77d646c5612716d40a48a30335":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","344b0840364d990b29b97467bfcc766ff8325d11"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["21527799e803fb77d646c5612716d40a48a30335"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6e36353d7461af8d2329a78a71457cf8e3c1e88f":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}