{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","commits":[{"id":"fbed9f780536d62957bf82cf6c87b75c5b4cd30b","date":1462731618,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55a4fb564f94e7d0f0dfce705d51533be9f1c22e","date":1462769458,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e66a459d38c1c4a2f97128433dab546f683a9fed","date":1462873476,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"717e5ceb2acae36d422ec75e5a4ce9fac40506e1","date":1501239603,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","sourceNew":null,"sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","sourceNew":null,"sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":4,"author":"Cao Manh Dat","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","sourceNew":null,"sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e","717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"55a4fb564f94e7d0f0dfce705d51533be9f1c22e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fbed9f780536d62957bf82cf6c87b75c5b4cd30b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e66a459d38c1c4a2f97128433dab546f683a9fed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"560c18d71dad43d675158783c3840f8c80d6d39c":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"fbed9f780536d62957bf82cf6c87b75c5b4cd30b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["560c18d71dad43d675158783c3840f8c80d6d39c"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"55a4fb564f94e7d0f0dfce705d51533be9f1c22e":["c304e97e7c1d472bc70e801b35ee78583916c6cd","717e5ceb2acae36d422ec75e5a4ce9fac40506e1","e66a459d38c1c4a2f97128433dab546f683a9fed","560c18d71dad43d675158783c3840f8c80d6d39c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e","e66a459d38c1c4a2f97128433dab546f683a9fed","fbed9f780536d62957bf82cf6c87b75c5b4cd30b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"e66a459d38c1c4a2f97128433dab546f683a9fed":[],"560c18d71dad43d675158783c3840f8c80d6d39c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fbed9f780536d62957bf82cf6c87b75c5b4cd30b":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e66a459d38c1c4a2f97128433dab546f683a9fed","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}