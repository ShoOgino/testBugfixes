{"path":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","commits":[{"id":"d8a3067239133ceb0117bc3d48356169cf03894f","date":1372268205,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public synchronized void closeIndexWriter(SolrCore core, boolean rollback)\n      throws IOException {\n    log.info(\"Closing IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"SolrCoreState already closed\");\n        }\n      }\n      \n      if (indexWriter != null) {\n        if (!rollback) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                + coreName, t);\n          }\n        } else {\n          try {\n            log.info(\"Rollback old IndexWriter... core=\" + coreName);\n            indexWriter.rollback();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                + coreName, t);\n          }\n        }\n      }\n      \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public synchronized void closeIndexWriter(SolrCore core, boolean rollback)\n      throws IOException {\n    log.info(\"Closing IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"SolrCoreState already closed\");\n        }\n      }\n      \n      if (indexWriter != null) {\n        if (!rollback) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                + coreName, t);\n          }\n        } else {\n          try {\n            log.info(\"Rollback old IndexWriter... core=\" + coreName);\n            indexWriter.rollback();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                + coreName, t);\n          }\n        }\n      }\n      \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void closeIndexWriter(SolrCore core, boolean rollback)\n      throws IOException {\n    log.info(\"Closing IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"SolrCoreState already closed\");\n        }\n      }\n      \n      if (indexWriter != null) {\n        if (!rollback) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Exception e) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                + coreName, e);\n          }\n        } else {\n          try {\n            log.info(\"Rollback old IndexWriter... core=\" + coreName);\n            indexWriter.rollback();\n          } catch (Exception e) {\n            SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                + coreName, e);\n          }\n        }\n      }\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void closeIndexWriter(SolrCore core, boolean rollback)\n      throws IOException {\n    log.info(\"Closing IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"SolrCoreState already closed\");\n        }\n      }\n      \n      if (indexWriter != null) {\n        if (!rollback) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                + coreName, t);\n          }\n        } else {\n          try {\n            log.info(\"Rollback old IndexWriter... core=\" + coreName);\n            indexWriter.rollback();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                + coreName, t);\n          }\n        }\n      }\n      \n    }\n  }\n\n","bugFix":["d8a3067239133ceb0117bc3d48356169cf03894f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void closeIndexWriter(SolrCore core, boolean rollback)\n      throws IOException {\n    log.info(\"Closing IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until it's out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"SolrCoreState already closed\");\n        }\n      }\n      \n      if (indexWriter != null) {\n        if (!rollback) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Exception e) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                + coreName, e);\n          }\n        } else {\n          try {\n            log.info(\"Rollback old IndexWriter... core=\" + coreName);\n            indexWriter.rollback();\n          } catch (Exception e) {\n            SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                + coreName, e);\n          }\n        }\n      }\n      \n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void closeIndexWriter(SolrCore core, boolean rollback)\n      throws IOException {\n    log.info(\"Closing IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"SolrCoreState already closed\");\n        }\n      }\n      \n      if (indexWriter != null) {\n        if (!rollback) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Exception e) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                + coreName, e);\n          }\n        } else {\n          try {\n            log.info(\"Rollback old IndexWriter... core=\" + coreName);\n            indexWriter.rollback();\n          } catch (Exception e) {\n            SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                + coreName, e);\n          }\n        }\n      }\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b","date":1439091488,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void closeIndexWriter(SolrCore core, boolean rollback)\n      throws IOException {\n    log.info(\"Closing IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until it's out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      try {\n        while (!writerFree) {\n          try {\n            writerPauseLock.wait(100);\n          } catch (InterruptedException e) {\n          }\n\n          if (closed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"SolrCoreState already closed\");\n          }\n        }\n\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n      } finally {\n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public synchronized void closeIndexWriter(SolrCore core, boolean rollback)\n      throws IOException {\n    log.info(\"Closing IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until it's out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"SolrCoreState already closed\");\n        }\n      }\n      \n      if (indexWriter != null) {\n        if (!rollback) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Exception e) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                + coreName, e);\n          }\n        } else {\n          try {\n            log.info(\"Rollback old IndexWriter... core=\" + coreName);\n            indexWriter.rollback();\n          } catch (Exception e) {\n            SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                + coreName, e);\n          }\n        }\n      }\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1adea4accc297f58fd9d8de3c820fd576eb0d396","date":1441292844,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#closeIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public void closeIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    lock(iwLock.writeLock());\n    changeWriter(core, rollback, false);\n    // Do not unlock the writeLock in this method.  It will be unlocked by the openIndexWriter call (see base class javadoc)\n  }\n\n","sourceOld":"  @Override\n  public synchronized void closeIndexWriter(SolrCore core, boolean rollback)\n      throws IOException {\n    log.info(\"Closing IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until it's out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      try {\n        while (!writerFree) {\n          try {\n            writerPauseLock.wait(100);\n          } catch (InterruptedException e) {\n          }\n\n          if (closed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n                \"SolrCoreState already closed\");\n          }\n        }\n\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n      } finally {\n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n\n  }\n\n","bugFix":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b","d8a3067239133ceb0117bc3d48356169cf03894f","8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1adea4accc297f58fd9d8de3c820fd576eb0d396":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d8a3067239133ceb0117bc3d48356169cf03894f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d8a3067239133ceb0117bc3d48356169cf03894f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["d8a3067239133ceb0117bc3d48356169cf03894f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1adea4accc297f58fd9d8de3c820fd576eb0d396"]},"commit2Childs":{"1adea4accc297f58fd9d8de3c820fd576eb0d396":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","d8a3067239133ceb0117bc3d48356169cf03894f"],"d8a3067239133ceb0117bc3d48356169cf03894f":["37a0f60745e53927c4c876cfe5b5a58170f0646c","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}