{"path":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","commits":[{"id":"e0f5e4b06eda9c2996435d90659faa1a8601d196","date":1329255071,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7523dd562634d9145b67eb4c8b3b3db2340532b","date":1330467618,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getOrdByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getOrdByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getOrdByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getOrdByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random()),\n        random().nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random().nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random().nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random(), fixedSize? fixedLength : 1 + random().nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random()));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getOrdByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        Random random = random();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getOrdByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random),\n        random.nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getOrdByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getOrdByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a470c93b2b0f8f51241f52705fc110a01f27ad2","date":1337969379,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random()),\n        random().nextFloat() * PackedInts.FAST);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random().nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random().nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random(), fixedSize? fixedLength : 1 + random().nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random()));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getOrdByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        Random random = random();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getOrdByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random()),\n        random().nextBoolean());\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random().nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random().nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random(), fixedSize? fixedLength : 1 + random().nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random()));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getOrdByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        Random random = random();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getOrdByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84dc6f07c86dcb7de2ae6e6bb6ec0d0c2e4da6ce","date":1358288854,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":null,"sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random()),\n        random().nextFloat() * PackedInts.FAST);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random().nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random().nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random(), fixedSize? fixedLength : 1 + random().nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random()));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getOrdByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        Random random = random();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getOrdByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":null,"sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n    DocValueHolder valueHolder = new DocValueHolder();\n    valueHolder.comp = COMP;\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    DocValuesConsumer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random()),\n        random().nextFloat() * PackedInts.FAST);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random().nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random().nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random(), fixedSize? fixedLength : 1 + random().nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      valueHolder.bytes = bytesRef;\n      w.add(2 * i, valueHolder);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random()));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getOrdByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        Random random = random();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getOrdByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e0f5e4b06eda9c2996435d90659faa1a8601d196":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["4a470c93b2b0f8f51241f52705fc110a01f27ad2","84dc6f07c86dcb7de2ae6e6bb6ec0d0c2e4da6ce"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["e0f5e4b06eda9c2996435d90659faa1a8601d196","b7523dd562634d9145b67eb4c8b3b3db2340532b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b7523dd562634d9145b67eb4c8b3b3db2340532b"],"b7523dd562634d9145b67eb4c8b3b3db2340532b":["e0f5e4b06eda9c2996435d90659faa1a8601d196"],"4a470c93b2b0f8f51241f52705fc110a01f27ad2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"84dc6f07c86dcb7de2ae6e6bb6ec0d0c2e4da6ce":["4a470c93b2b0f8f51241f52705fc110a01f27ad2"]},"commit2Childs":{"e0f5e4b06eda9c2996435d90659faa1a8601d196":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b7523dd562634d9145b67eb4c8b3b3db2340532b"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e0f5e4b06eda9c2996435d90659faa1a8601d196"],"b7523dd562634d9145b67eb4c8b3b3db2340532b":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["4a470c93b2b0f8f51241f52705fc110a01f27ad2"],"4a470c93b2b0f8f51241f52705fc110a01f27ad2":["d4d69c535930b5cce125cff868d40f6373dc27d4","84dc6f07c86dcb7de2ae6e6bb6ec0d0c2e4da6ce"],"84dc6f07c86dcb7de2ae6e6bb6ec0d0c2e4da6ce":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}