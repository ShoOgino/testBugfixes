{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#findAdjoiningPoints(Plane,GeoPoint).mjava","commits":[{"id":"d564e0296db7f80d73dd62b17710f61c85f38c50","date":1523483630,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#findAdjoiningPoints(Plane,GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"  /** Given a point on the plane and the ellipsoid, this method looks for a pair of adjoining points on either side of the plane, which are\n   * about MINIMUM_RESOLUTION away from the given point.  This only works for planes which go through the center of the world.\n   */\n  private GeoPoint[] findAdjoiningPoints(final Plane plane, final GeoPoint pointOnPlane) {\n    // Compute a normalized perpendicular vector\n    final Vector perpendicular = new Vector(plane, pointOnPlane);\n    // Compute two new points along this vector from the original\n    final GeoPoint pointA = planetModel.createSurfacePoint(pointOnPlane.x + perpendicular.x * Vector.MINIMUM_RESOLUTION,\n      pointOnPlane.y + perpendicular.y * Vector.MINIMUM_RESOLUTION,\n      pointOnPlane.z + perpendicular.z * Vector.MINIMUM_RESOLUTION);\n    final GeoPoint pointB = planetModel.createSurfacePoint(pointOnPlane.x - perpendicular.x * Vector.MINIMUM_RESOLUTION,\n      pointOnPlane.y - perpendicular.y * Vector.MINIMUM_RESOLUTION,\n      pointOnPlane.z - perpendicular.z * Vector.MINIMUM_RESOLUTION);\n    //System.out.println(\"Distance: \"+computeSquaredDistance(rval[0], pointOnPlane)+\" and \"+computeSquaredDistance(rval[1], pointOnPlane));\n    return new GeoPoint[]{pointA, pointB};\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61208df9977bdd3054d6b9792eb6a18be9d32837","date":1523626771,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#findAdjoiningPoints(Plane,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#findAdjoiningPoints(Plane,GeoPoint).mjava","sourceNew":"  /** Given a point on the plane and the ellipsoid, this method looks for a pair of adjoining points on either side of the plane, which are\n   * about MINIMUM_RESOLUTION away from the given point.  This only works for planes which go through the center of the world.\n   */\n  private GeoPoint[] findAdjoiningPoints(final Plane plane, final GeoPoint pointOnPlane) {\n    // Compute a normalized perpendicular vector\n    final Vector perpendicular = new Vector(plane, pointOnPlane);\n    // Compute two new points along this vector from the original\n    final GeoPoint pointA = planetModel.createSurfacePoint(pointOnPlane.x + perpendicular.x * DELTA_DISTANCE,\n      pointOnPlane.y + perpendicular.y * DELTA_DISTANCE,\n      pointOnPlane.z + perpendicular.z * DELTA_DISTANCE);\n    final GeoPoint pointB = planetModel.createSurfacePoint(pointOnPlane.x - perpendicular.x * DELTA_DISTANCE,\n      pointOnPlane.y - perpendicular.y * DELTA_DISTANCE,\n      pointOnPlane.z - perpendicular.z * DELTA_DISTANCE);\n    //System.out.println(\"Distance: \"+computeSquaredDistance(rval[0], pointOnPlane)+\" and \"+computeSquaredDistance(rval[1], pointOnPlane));\n    return new GeoPoint[]{pointA, pointB};\n  }\n\n","sourceOld":"  /** Given a point on the plane and the ellipsoid, this method looks for a pair of adjoining points on either side of the plane, which are\n   * about MINIMUM_RESOLUTION away from the given point.  This only works for planes which go through the center of the world.\n   */\n  private GeoPoint[] findAdjoiningPoints(final Plane plane, final GeoPoint pointOnPlane) {\n    // Compute a normalized perpendicular vector\n    final Vector perpendicular = new Vector(plane, pointOnPlane);\n    // Compute two new points along this vector from the original\n    final GeoPoint pointA = planetModel.createSurfacePoint(pointOnPlane.x + perpendicular.x * Vector.MINIMUM_RESOLUTION,\n      pointOnPlane.y + perpendicular.y * Vector.MINIMUM_RESOLUTION,\n      pointOnPlane.z + perpendicular.z * Vector.MINIMUM_RESOLUTION);\n    final GeoPoint pointB = planetModel.createSurfacePoint(pointOnPlane.x - perpendicular.x * Vector.MINIMUM_RESOLUTION,\n      pointOnPlane.y - perpendicular.y * Vector.MINIMUM_RESOLUTION,\n      pointOnPlane.z - perpendicular.z * Vector.MINIMUM_RESOLUTION);\n    //System.out.println(\"Distance: \"+computeSquaredDistance(rval[0], pointOnPlane)+\" and \"+computeSquaredDistance(rval[1], pointOnPlane));\n    return new GeoPoint[]{pointA, pointB};\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4417cae689ce0fc964a3546ded2b0ab6e374f1b0","date":1523635542,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#findAdjoiningPoints(Plane,GeoPoint).mjava","sourceNew":null,"sourceOld":"  /** Given a point on the plane and the ellipsoid, this method looks for a pair of adjoining points on either side of the plane, which are\n   * about MINIMUM_RESOLUTION away from the given point.  This only works for planes which go through the center of the world.\n   */\n  private GeoPoint[] findAdjoiningPoints(final Plane plane, final GeoPoint pointOnPlane) {\n    // Compute a normalized perpendicular vector\n    final Vector perpendicular = new Vector(plane, pointOnPlane);\n    // Compute two new points along this vector from the original\n    final GeoPoint pointA = planetModel.createSurfacePoint(pointOnPlane.x + perpendicular.x * DELTA_DISTANCE,\n      pointOnPlane.y + perpendicular.y * DELTA_DISTANCE,\n      pointOnPlane.z + perpendicular.z * DELTA_DISTANCE);\n    final GeoPoint pointB = planetModel.createSurfacePoint(pointOnPlane.x - perpendicular.x * DELTA_DISTANCE,\n      pointOnPlane.y - perpendicular.y * DELTA_DISTANCE,\n      pointOnPlane.z - perpendicular.z * DELTA_DISTANCE);\n    //System.out.println(\"Distance: \"+computeSquaredDistance(rval[0], pointOnPlane)+\" and \"+computeSquaredDistance(rval[1], pointOnPlane));\n    return new GeoPoint[]{pointA, pointB};\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d564e0296db7f80d73dd62b17710f61c85f38c50":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4417cae689ce0fc964a3546ded2b0ab6e374f1b0":["61208df9977bdd3054d6b9792eb6a18be9d32837"],"61208df9977bdd3054d6b9792eb6a18be9d32837":["d564e0296db7f80d73dd62b17710f61c85f38c50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4417cae689ce0fc964a3546ded2b0ab6e374f1b0"]},"commit2Childs":{"d564e0296db7f80d73dd62b17710f61c85f38c50":["61208df9977bdd3054d6b9792eb6a18be9d32837"],"4417cae689ce0fc964a3546ded2b0ab6e374f1b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"61208df9977bdd3054d6b9792eb6a18be9d32837":["4417cae689ce0fc964a3546ded2b0ab6e374f1b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d564e0296db7f80d73dd62b17710f61c85f38c50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}