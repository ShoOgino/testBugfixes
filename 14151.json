{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","commits":[{"id":"1072b8e47b50f1c4fb039e1f54a736f381d6f809","date":1438956441,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    Set<String> newLiveNodes;\n    try {\n      List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n      log.debug(\"Updating live nodes from ZooKeeper... ({})\", nodeList.size());\n      newLiveNodes = new HashSet<>(nodeList);\n    } catch (KeeperException.NoNodeException e) {\n      newLiveNodes = emptySet();\n    }\n    synchronized (getUpdateLock()) {\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d3726445f8e9a7d398466439f0f84b5bb329fdcc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7477015ee104ad8144fba06b9b0a8ea93aea50f8","date":1450790907,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    Set<String> newLiveNodes;\n    try {\n      List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n      LOG.debug(\"Updating live nodes from ZooKeeper... [{}]\", nodeList.size());\n      newLiveNodes = new HashSet<>(nodeList);\n    } catch (KeeperException.NoNodeException e) {\n      newLiveNodes = emptySet();\n    }\n    synchronized (getUpdateLock()) {\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    Set<String> newLiveNodes;\n    try {\n      List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n      log.debug(\"Updating live nodes from ZooKeeper... ({})\", nodeList.size());\n      newLiveNodes = new HashSet<>(nodeList);\n    } catch (KeeperException.NoNodeException e) {\n      newLiveNodes = emptySet();\n    }\n    synchronized (getUpdateLock()) {\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e6a62db2872d21ade436729a86feb50ddea1ee9","date":1455926998,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    Set<String> newLiveNodes;\n    try {\n      List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n      newLiveNodes = new HashSet<>(nodeList);\n    } catch (KeeperException.NoNodeException e) {\n      newLiveNodes = emptySet();\n    }\n    Set<String> oldLiveNodes;\n    synchronized (getUpdateLock()) {\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    Set<String> newLiveNodes;\n    try {\n      List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n      LOG.debug(\"Updating live nodes from ZooKeeper... [{}]\", nodeList.size());\n      newLiveNodes = new HashSet<>(nodeList);\n    } catch (KeeperException.NoNodeException e) {\n      newLiveNodes = emptySet();\n    }\n    synchronized (getUpdateLock()) {\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["d3726445f8e9a7d398466439f0f84b5bb329fdcc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3726445f8e9a7d398466439f0f84b5bb329fdcc","date":1460555680,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    Set<String> newLiveNodes;\n    try {\n      List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n      newLiveNodes = new HashSet<>(nodeList);\n    } catch (KeeperException.NoNodeException e) {\n      newLiveNodes = emptySet();\n    }\n    Set<String> oldLiveNodes;\n    synchronized (getUpdateLock()) {\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","bugFix":["1072b8e47b50f1c4fb039e1f54a736f381d6f809","2e6a62db2872d21ade436729a86feb50ddea1ee9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    Set<String> newLiveNodes;\n    try {\n      List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n      newLiveNodes = new HashSet<>(nodeList);\n    } catch (KeeperException.NoNodeException e) {\n      newLiveNodes = emptySet();\n    }\n    Set<String> oldLiveNodes;\n    synchronized (getUpdateLock()) {\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aac63b614f11eae7300a15a1ec9d8bee1e057e3b","date":1474972984,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c32a8448145a74a8902798f2e63e322827757ff2","date":1496834422,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener ->\n          listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes)));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"664ff2b928393480d9655010aa700656b0fcade0","date":1496842764,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener ->\n          listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes)));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener ->\n          listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes)));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener ->\n          listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes)));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      Set<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new HashSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    Set<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      log.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener ->\n          listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes)));\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      LOG.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener ->\n          listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      log.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener -> {\n        if (listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes))) {\n          removeLiveNodesListener(listener);\n        }\n      });\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      log.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener ->\n          listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes)));\n    }\n  }\n\n","bugFix":["c32a8448145a74a8902798f2e63e322827757ff2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLiveNodes(Watcher).mjava","sourceNew":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n      }\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener -> {\n        if (listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes))) {\n          removeLiveNodesListener(listener);\n        }\n      });\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh live_nodes.\n   */\n  private void refreshLiveNodes(Watcher watcher) throws KeeperException, InterruptedException {\n    synchronized (refreshLiveNodesLock) {\n      SortedSet<String> newLiveNodes;\n      try {\n        List<String> nodeList = zkClient.getChildren(LIVE_NODES_ZKNODE, watcher, true);\n        newLiveNodes = new TreeSet<>(nodeList);\n      } catch (KeeperException.NoNodeException e) {\n        newLiveNodes = emptySortedSet();\n      }\n      lastFetchedLiveNodes.set(newLiveNodes);\n    }\n\n    // Can't lock getUpdateLock() until we release the other, it would cause deadlock.\n    SortedSet<String> oldLiveNodes, newLiveNodes;\n    synchronized (getUpdateLock()) {\n      newLiveNodes = lastFetchedLiveNodes.getAndSet(null);\n      if (newLiveNodes == null) {\n        // Someone else won the race to apply the last update, just exit.\n        return;\n      }\n\n      oldLiveNodes = this.liveNodes;\n      this.liveNodes = newLiveNodes;\n      if (clusterState != null) {\n        clusterState.setLiveNodes(newLiveNodes);\n      }\n    }\n    if (oldLiveNodes.size() != newLiveNodes.size()) {\n      log.info(\"Updated live nodes from ZooKeeper... ({}) -> ({})\", oldLiveNodes.size(), newLiveNodes.size());\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Updated live nodes from ZooKeeper... {} -> {}\", oldLiveNodes, newLiveNodes);\n    }\n    if (!oldLiveNodes.equals(newLiveNodes)) { // fire listeners\n      liveNodesListeners.forEach(listener -> {\n        if (listener.onChange(new TreeSet<>(oldLiveNodes), new TreeSet<>(newLiveNodes))) {\n          removeLiveNodesListener(listener);\n        }\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","664ff2b928393480d9655010aa700656b0fcade0"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"d3726445f8e9a7d398466439f0f84b5bb329fdcc":["2e6a62db2872d21ade436729a86feb50ddea1ee9"],"2e6a62db2872d21ade436729a86feb50ddea1ee9":["7477015ee104ad8144fba06b9b0a8ea93aea50f8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"1072b8e47b50f1c4fb039e1f54a736f381d6f809":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["2e6a62db2872d21ade436729a86feb50ddea1ee9","d3726445f8e9a7d398466439f0f84b5bb329fdcc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","aac63b614f11eae7300a15a1ec9d8bee1e057e3b"],"c32a8448145a74a8902798f2e63e322827757ff2":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"560c18d71dad43d675158783c3840f8c80d6d39c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"aac63b614f11eae7300a15a1ec9d8bee1e057e3b":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"7477015ee104ad8144fba06b9b0a8ea93aea50f8":["1072b8e47b50f1c4fb039e1f54a736f381d6f809"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"664ff2b928393480d9655010aa700656b0fcade0":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","c32a8448145a74a8902798f2e63e322827757ff2"]},"commit2Childs":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"d3726445f8e9a7d398466439f0f84b5bb329fdcc":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"2e6a62db2872d21ade436729a86feb50ddea1ee9":["d3726445f8e9a7d398466439f0f84b5bb329fdcc","9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"1072b8e47b50f1c4fb039e1f54a736f381d6f809":["7477015ee104ad8144fba06b9b0a8ea93aea50f8"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","aac63b614f11eae7300a15a1ec9d8bee1e057e3b"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["c304e97e7c1d472bc70e801b35ee78583916c6cd","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c32a8448145a74a8902798f2e63e322827757ff2","560c18d71dad43d675158783c3840f8c80d6d39c","664ff2b928393480d9655010aa700656b0fcade0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1072b8e47b50f1c4fb039e1f54a736f381d6f809"],"c32a8448145a74a8902798f2e63e322827757ff2":["664ff2b928393480d9655010aa700656b0fcade0"],"560c18d71dad43d675158783c3840f8c80d6d39c":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"aac63b614f11eae7300a15a1ec9d8bee1e057e3b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7477015ee104ad8144fba06b9b0a8ea93aea50f8":["2e6a62db2872d21ade436729a86feb50ddea1ee9"],"664ff2b928393480d9655010aa700656b0fcade0":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}