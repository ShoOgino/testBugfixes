{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#ensureRegisteredSearcher(SolrCore).mjava","commits":[{"id":"e87998750c1408b8af3248e55cff794d51d37166","date":1501426220,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ensureRegisteredSearcher(SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Ensures that a searcher is registered for the given core and if not, waits until one is registered\n   */\n  private static void ensureRegisteredSearcher(SolrCore core) throws InterruptedException {\n    if (!core.getSolrConfig().useColdSearcher) {\n      RefCounted<SolrIndexSearcher> registeredSearcher = core.getRegisteredSearcher();\n      if (registeredSearcher != null) {\n        log.debug(\"Found a registered searcher: {} for core: {}\", registeredSearcher.get(), core);\n        registeredSearcher.decref();\n      } else  {\n        Future[] waitSearcher = new Future[1];\n        log.info(\"No registered searcher found for core: {}, waiting until a searcher is registered before publishing as active\", core.getName());\n        final RTimer timer = new RTimer();\n        RefCounted<SolrIndexSearcher> searcher = null;\n        try {\n          searcher = core.getSearcher(false, true, waitSearcher, true);\n          boolean success = true;\n          if (waitSearcher[0] != null)  {\n            log.debug(\"Waiting for first searcher of core {}, id: {} to be registered\", core.getName(), core);\n            try {\n              waitSearcher[0].get();\n            } catch (ExecutionException e) {\n              log.warn(\"Wait for a searcher to be registered for core \" + core.getName() + \",id: \" + core + \" failed due to: \" + e, e);\n              success = false;\n            }\n          }\n          if (success)  {\n            if (searcher == null) {\n              // should never happen\n              log.debug(\"Did not find a searcher even after the future callback for core: {}, id: {}!!!\", core.getName(), core);\n            } else  {\n              log.info(\"Found a registered searcher: {}, took: {} ms for core: {}, id: {}\", searcher.get(), timer.getTime(), core.getName(), core);\n            }\n          }\n        } finally {\n          if (searcher != null) {\n            searcher.decref();\n          }\n        }\n      }\n      RefCounted<SolrIndexSearcher> newestSearcher = core.getNewestSearcher(false);\n      if (newestSearcher != null) {\n        log.debug(\"Found newest searcher: {} for core: {}, id: {}\", newestSearcher.get(), core.getName(), core);\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ensureRegisteredSearcher(SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Ensures that a searcher is registered for the given core and if not, waits until one is registered\n   */\n  private static void ensureRegisteredSearcher(SolrCore core) throws InterruptedException {\n    if (!core.getSolrConfig().useColdSearcher) {\n      RefCounted<SolrIndexSearcher> registeredSearcher = core.getRegisteredSearcher();\n      if (registeredSearcher != null) {\n        log.debug(\"Found a registered searcher: {} for core: {}\", registeredSearcher.get(), core);\n        registeredSearcher.decref();\n      } else  {\n        Future[] waitSearcher = new Future[1];\n        log.info(\"No registered searcher found for core: {}, waiting until a searcher is registered before publishing as active\", core.getName());\n        final RTimer timer = new RTimer();\n        RefCounted<SolrIndexSearcher> searcher = null;\n        try {\n          searcher = core.getSearcher(false, true, waitSearcher, true);\n          boolean success = true;\n          if (waitSearcher[0] != null)  {\n            log.debug(\"Waiting for first searcher of core {}, id: {} to be registered\", core.getName(), core);\n            try {\n              waitSearcher[0].get();\n            } catch (ExecutionException e) {\n              log.warn(\"Wait for a searcher to be registered for core \" + core.getName() + \",id: \" + core + \" failed due to: \" + e, e);\n              success = false;\n            }\n          }\n          if (success)  {\n            if (searcher == null) {\n              // should never happen\n              log.debug(\"Did not find a searcher even after the future callback for core: {}, id: {}!!!\", core.getName(), core);\n            } else  {\n              log.info(\"Found a registered searcher: {}, took: {} ms for core: {}, id: {}\", searcher.get(), timer.getTime(), core.getName(), core);\n            }\n          }\n        } finally {\n          if (searcher != null) {\n            searcher.decref();\n          }\n        }\n      }\n      RefCounted<SolrIndexSearcher> newestSearcher = core.getNewestSearcher(false);\n      if (newestSearcher != null) {\n        log.debug(\"Found newest searcher: {} for core: {}, id: {}\", newestSearcher.get(), core.getName(), core);\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ensureRegisteredSearcher(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ensureRegisteredSearcher(SolrCore).mjava","sourceNew":"  /**\n   * Ensures that a searcher is registered for the given core and if not, waits until one is registered\n   */\n  private static void ensureRegisteredSearcher(SolrCore core) throws InterruptedException {\n    if (!core.getSolrConfig().useColdSearcher) {\n      RefCounted<SolrIndexSearcher> registeredSearcher = core.getRegisteredSearcher();\n      if (registeredSearcher != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Found a registered searcher: {} for core: {}\", registeredSearcher.get(), core);\n        }\n        registeredSearcher.decref();\n      } else  {\n        Future[] waitSearcher = new Future[1];\n        if (log.isInfoEnabled()) {\n          log.info(\"No registered searcher found for core: {}, waiting until a searcher is registered before publishing as active\", core.getName());\n        }\n        final RTimer timer = new RTimer();\n        RefCounted<SolrIndexSearcher> searcher = null;\n        try {\n          searcher = core.getSearcher(false, true, waitSearcher, true);\n          boolean success = true;\n          if (waitSearcher[0] != null)  {\n            if (log.isDebugEnabled()) {\n              log.debug(\"Waiting for first searcher of core {}, id: {} to be registered\", core.getName(), core);\n            }\n            try {\n              waitSearcher[0].get();\n            } catch (ExecutionException e) {\n              log.warn(\"Wait for a searcher to be registered for core {}, id: {} failed due to: {}\", core.getName(), core, e, e);\n              success = false;\n            }\n          }\n          if (success)  {\n            if (searcher == null) {\n              // should never happen\n              if (log.isDebugEnabled()) {\n                log.debug(\"Did not find a searcher even after the future callback for core: {}, id: {}!!!\", core.getName(), core);\n              }\n            } else  {\n              if (log.isInfoEnabled()) {\n                log.info(\"Found a registered searcher: {}, took: {} ms for core: {}, id: {}\", searcher.get(), timer.getTime(), core.getName(), core);\n              }\n            }\n          }\n        } finally {\n          if (searcher != null) {\n            searcher.decref();\n          }\n        }\n      }\n      RefCounted<SolrIndexSearcher> newestSearcher = core.getNewestSearcher(false);\n      if (newestSearcher != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Found newest searcher: {} for core: {}, id: {}\", newestSearcher.get(), core.getName(), core);\n        }\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Ensures that a searcher is registered for the given core and if not, waits until one is registered\n   */\n  private static void ensureRegisteredSearcher(SolrCore core) throws InterruptedException {\n    if (!core.getSolrConfig().useColdSearcher) {\n      RefCounted<SolrIndexSearcher> registeredSearcher = core.getRegisteredSearcher();\n      if (registeredSearcher != null) {\n        log.debug(\"Found a registered searcher: {} for core: {}\", registeredSearcher.get(), core);\n        registeredSearcher.decref();\n      } else  {\n        Future[] waitSearcher = new Future[1];\n        log.info(\"No registered searcher found for core: {}, waiting until a searcher is registered before publishing as active\", core.getName());\n        final RTimer timer = new RTimer();\n        RefCounted<SolrIndexSearcher> searcher = null;\n        try {\n          searcher = core.getSearcher(false, true, waitSearcher, true);\n          boolean success = true;\n          if (waitSearcher[0] != null)  {\n            log.debug(\"Waiting for first searcher of core {}, id: {} to be registered\", core.getName(), core);\n            try {\n              waitSearcher[0].get();\n            } catch (ExecutionException e) {\n              log.warn(\"Wait for a searcher to be registered for core \" + core.getName() + \",id: \" + core + \" failed due to: \" + e, e);\n              success = false;\n            }\n          }\n          if (success)  {\n            if (searcher == null) {\n              // should never happen\n              log.debug(\"Did not find a searcher even after the future callback for core: {}, id: {}!!!\", core.getName(), core);\n            } else  {\n              log.info(\"Found a registered searcher: {}, took: {} ms for core: {}, id: {}\", searcher.get(), timer.getTime(), core.getName(), core);\n            }\n          }\n        } finally {\n          if (searcher != null) {\n            searcher.decref();\n          }\n        }\n      }\n      RefCounted<SolrIndexSearcher> newestSearcher = core.getNewestSearcher(false);\n      if (newestSearcher != null) {\n        log.debug(\"Found newest searcher: {} for core: {}, id: {}\", newestSearcher.get(), core.getName(), core);\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ensureRegisteredSearcher(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ensureRegisteredSearcher(SolrCore).mjava","sourceNew":"  /**\n   * Ensures that a searcher is registered for the given core and if not, waits until one is registered\n   */\n  private static void ensureRegisteredSearcher(SolrCore core) throws InterruptedException {\n    if (!core.getSolrConfig().useColdSearcher) {\n      RefCounted<SolrIndexSearcher> registeredSearcher = core.getRegisteredSearcher();\n      if (registeredSearcher != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Found a registered searcher: {} for core: {}\", registeredSearcher.get(), core);\n        }\n        registeredSearcher.decref();\n      } else  {\n        @SuppressWarnings({\"rawtypes\"})\n        Future[] waitSearcher = new Future[1];\n        if (log.isInfoEnabled()) {\n          log.info(\"No registered searcher found for core: {}, waiting until a searcher is registered before publishing as active\", core.getName());\n        }\n        final RTimer timer = new RTimer();\n        RefCounted<SolrIndexSearcher> searcher = null;\n        try {\n          searcher = core.getSearcher(false, true, waitSearcher, true);\n          boolean success = true;\n          if (waitSearcher[0] != null)  {\n            if (log.isDebugEnabled()) {\n              log.debug(\"Waiting for first searcher of core {}, id: {} to be registered\", core.getName(), core);\n            }\n            try {\n              waitSearcher[0].get();\n            } catch (ExecutionException e) {\n              log.warn(\"Wait for a searcher to be registered for core {}, id: {} failed due to: {}\", core.getName(), core, e, e);\n              success = false;\n            }\n          }\n          if (success)  {\n            if (searcher == null) {\n              // should never happen\n              if (log.isDebugEnabled()) {\n                log.debug(\"Did not find a searcher even after the future callback for core: {}, id: {}!!!\", core.getName(), core);\n              }\n            } else  {\n              if (log.isInfoEnabled()) {\n                log.info(\"Found a registered searcher: {}, took: {} ms for core: {}, id: {}\", searcher.get(), timer.getTime(), core.getName(), core);\n              }\n            }\n          }\n        } finally {\n          if (searcher != null) {\n            searcher.decref();\n          }\n        }\n      }\n      RefCounted<SolrIndexSearcher> newestSearcher = core.getNewestSearcher(false);\n      if (newestSearcher != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Found newest searcher: {} for core: {}, id: {}\", newestSearcher.get(), core.getName(), core);\n        }\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Ensures that a searcher is registered for the given core and if not, waits until one is registered\n   */\n  private static void ensureRegisteredSearcher(SolrCore core) throws InterruptedException {\n    if (!core.getSolrConfig().useColdSearcher) {\n      RefCounted<SolrIndexSearcher> registeredSearcher = core.getRegisteredSearcher();\n      if (registeredSearcher != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Found a registered searcher: {} for core: {}\", registeredSearcher.get(), core);\n        }\n        registeredSearcher.decref();\n      } else  {\n        Future[] waitSearcher = new Future[1];\n        if (log.isInfoEnabled()) {\n          log.info(\"No registered searcher found for core: {}, waiting until a searcher is registered before publishing as active\", core.getName());\n        }\n        final RTimer timer = new RTimer();\n        RefCounted<SolrIndexSearcher> searcher = null;\n        try {\n          searcher = core.getSearcher(false, true, waitSearcher, true);\n          boolean success = true;\n          if (waitSearcher[0] != null)  {\n            if (log.isDebugEnabled()) {\n              log.debug(\"Waiting for first searcher of core {}, id: {} to be registered\", core.getName(), core);\n            }\n            try {\n              waitSearcher[0].get();\n            } catch (ExecutionException e) {\n              log.warn(\"Wait for a searcher to be registered for core {}, id: {} failed due to: {}\", core.getName(), core, e, e);\n              success = false;\n            }\n          }\n          if (success)  {\n            if (searcher == null) {\n              // should never happen\n              if (log.isDebugEnabled()) {\n                log.debug(\"Did not find a searcher even after the future callback for core: {}, id: {}!!!\", core.getName(), core);\n              }\n            } else  {\n              if (log.isInfoEnabled()) {\n                log.info(\"Found a registered searcher: {}, took: {} ms for core: {}, id: {}\", searcher.get(), timer.getTime(), core.getName(), core);\n              }\n            }\n          }\n        } finally {\n          if (searcher != null) {\n            searcher.decref();\n          }\n        }\n      }\n      RefCounted<SolrIndexSearcher> newestSearcher = core.getNewestSearcher(false);\n      if (newestSearcher != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Found newest searcher: {} for core: {}, id: {}\", newestSearcher.get(), core.getName(), core);\n        }\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e87998750c1408b8af3248e55cff794d51d37166"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["ad4957cde742defe6db19689abdc267c5d948066"],"ad4957cde742defe6db19689abdc267c5d948066":["e87998750c1408b8af3248e55cff794d51d37166"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"e87998750c1408b8af3248e55cff794d51d37166":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","e87998750c1408b8af3248e55cff794d51d37166"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad4957cde742defe6db19689abdc267c5d948066":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"e87998750c1408b8af3248e55cff794d51d37166":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","ad4957cde742defe6db19689abdc267c5d948066"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}