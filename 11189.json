{"path":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","commits":[{"id":"400558e34d57baf6a8e8c42d60fc1a87b5acb596","date":1405940665,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"/dev/null","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8249072f13ea4354ab7635c2d7a59cc682806dab","8c146731a64debc22c115bbf11ee1a060aa7ea02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq, f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new FilteredQuery(new MatchAllDocsQuery(),\n                        f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8249072f13ea4354ab7635c2d7a59cc682806dab","date":1429649774,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq, f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new FilteredQuery(new MatchAllDocsQuery(),\n                        f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq, f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new FilteredQuery(new MatchAllDocsQuery(),\n                        f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["400558e34d57baf6a8e8c42d60fc1a87b5acb596"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq.build(), f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new FilteredQuery(new MatchAllDocsQuery(),\n                        f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq, f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new FilteredQuery(new MatchAllDocsQuery(),\n                        f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq.build(), f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new FilteredQuery(new MatchAllDocsQuery(),\n                        f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d52e48927ca4ef3655a261f2230b968b6fdf3608","date":1444652107,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new LegacyIntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["8c146731a64debc22c115bbf11ee1a060aa7ea02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c146731a64debc22c115bbf11ee1a060aa7ea02","date":1457616596,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new LegacyIntField(\"id\", numDocs, Field.Store.YES));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["400558e34d57baf6a8e8c42d60fc1a87b5acb596","770342641f7b505eaa8dccdc666158bff2419109"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a076c3c721f685b7559308fdc2cd72d91bba67e5","date":1464168992,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        doc.add(new StringField(\"stringdv\", s, Field.Store.NO));\n        docValues.add(new BytesRef(s));\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new IntPoint(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    Map<String,UninvertingReader.Type> mapping = new HashMap<>();\n    mapping.put(\"stringdv\", Type.SORTED);\n    mapping.put(\"id\", Type.INTEGER_POINT);\n    final IndexReader r = UninvertingReader.wrap(writer.getReader(), mapping);\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n      missingIsNull = true;\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a076c3c721f685b7559308fdc2cd72d91bba67e5":["8c146731a64debc22c115bbf11ee1a060aa7ea02"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["8c146731a64debc22c115bbf11ee1a060aa7ea02","a076c3c721f685b7559308fdc2cd72d91bba67e5"],"400558e34d57baf6a8e8c42d60fc1a87b5acb596":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"83870855d82aba6819217abeff5a40779dbb28b4":["8c146731a64debc22c115bbf11ee1a060aa7ea02","0e121d43b5a10f2df530f406f935102656e9c4e8"],"770342641f7b505eaa8dccdc666158bff2419109":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["8c146731a64debc22c115bbf11ee1a060aa7ea02","0e121d43b5a10f2df530f406f935102656e9c4e8"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["8249072f13ea4354ab7635c2d7a59cc682806dab"],"1db68e96dd908fcd79ef809095822736aa601d08":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"d52e48927ca4ef3655a261f2230b968b6fdf3608":["1db68e96dd908fcd79ef809095822736aa601d08"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["400558e34d57baf6a8e8c42d60fc1a87b5acb596"],"8249072f13ea4354ab7635c2d7a59cc682806dab":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"8c146731a64debc22c115bbf11ee1a060aa7ea02":["770342641f7b505eaa8dccdc666158bff2419109"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0e121d43b5a10f2df530f406f935102656e9c4e8"]},"commit2Childs":{"a076c3c721f685b7559308fdc2cd72d91bba67e5":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"400558e34d57baf6a8e8c42d60fc1a87b5acb596":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"770342641f7b505eaa8dccdc666158bff2419109":["8c146731a64debc22c115bbf11ee1a060aa7ea02"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["1db68e96dd908fcd79ef809095822736aa601d08"],"1db68e96dd908fcd79ef809095822736aa601d08":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"d52e48927ca4ef3655a261f2230b968b6fdf3608":["770342641f7b505eaa8dccdc666158bff2419109"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["400558e34d57baf6a8e8c42d60fc1a87b5acb596"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["8249072f13ea4354ab7635c2d7a59cc682806dab"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"8249072f13ea4354ab7635c2d7a59cc682806dab":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"8c146731a64debc22c115bbf11ee1a060aa7ea02":["a076c3c721f685b7559308fdc2cd72d91bba67e5","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}