{"path":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","commits":[{"id":"e0aed040842b70826cfd518b076d58adcaede282","date":1395018675,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"standard\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//doc[./int[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2c10121be7f9dc2db5f9d4adc9ee6d30c6ad5ec","date":1398363135,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","sourceNew":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"standard\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"standard\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//doc[./int[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","sourceNew":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"standard\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"standard\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//doc[./int[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./int[@name='id']='1']\",\n            \"//doc[./int[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ff704ef91e9ae30ca59babb23ece85720701b60","date":1498684964,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","sourceNew":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"standard\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","sourceNew":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"standard\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","sourceNew":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"standard\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a91f19e3f7576973404e13b7ecfb8ae94f313921","date":1511358452,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","sourceNew":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQEx(\"don't parse subqueries\",\n        \"SyntaxError\",\n        sumLRF.makeRequest(\"_query_:\\\"{!prefix f=name v=smi}\\\"\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"don't parse subqueries\",\n        \"SyntaxError\",\n        sumLRF.makeRequest(\"{!prefix f=name v=smi}\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4aee4980038a10791618ea04e79233ce5cbf6607","date":1511366888,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestComplexPhraseQParserPlugin#test().mjava","sourceNew":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQEx(\"don't parse subqueries\",\n        \"SyntaxError\",\n        sumLRF.makeRequest(\"_query_:\\\"{!prefix f=name v=smi}\\\"\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"don't parse subqueries\",\n        \"SyntaxError\",\n        sumLRF.makeRequest(\"{!prefix f=name v=smi}\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void test() {\n    HashMap<String, String> args = new HashMap<String, String>();\n\n    args.put(QueryParsing.DEFTYPE, ComplexPhraseQParserPlugin.NAME);\n    args.put(CommonParams.FL, \"id\");\n\n    TestHarness.LocalRequestFactory sumLRF = h.getRequestFactory(\n            \"\", 0, 200, args);\n\n    assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n    assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n    assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n    assertU(commit());\n    assertU(optimize());\n\n    assertQ(\"Simple multi-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(req(\"q\", \"{!complexphrase} name:\\\"john smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//result[@numFound='1']\"\n    );\n\n\n    assertQ(\"wildcards and fuzzies are OK in phrases\",\n            sumLRF.makeRequest(\"name:\\\"j* smyth~\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"boolean logic works\",\n            sumLRF.makeRequest(\"name:\\\"(jo* -john) smith\\\"\"),\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='1']\"\n    );\n\n    assertQ(\"position logic works\",\n            sumLRF.makeRequest(\"name:\\\"jo*  smith\\\"~2\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='3']\"\n    );\n\n    assertQ(\"range queries supported\",\n            sumLRF.makeRequest(\"name:\\\"jo* [sma TO smz]\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"Simple single-term still works\",\n            sumLRF.makeRequest(\"name:\\\"john\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='3']\",\n            \"//result[@numFound='2']\"\n    );\n\n    assertQ(\"OR inside phrase works\",\n            sumLRF.makeRequest(\"name:\\\"(john johathon) smith\\\"\"),\n            \"//doc[./str[@name='id']='1']\",\n            \"//doc[./str[@name='id']='2']\",\n            \"//result[@numFound='2']\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["e0aed040842b70826cfd518b076d58adcaede282","f2c10121be7f9dc2db5f9d4adc9ee6d30c6ad5ec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4aee4980038a10791618ea04e79233ce5cbf6607":["28288370235ed02234a64753cdbf0c6ec096304a","a91f19e3f7576973404e13b7ecfb8ae94f313921"],"e0aed040842b70826cfd518b076d58adcaede282":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a91f19e3f7576973404e13b7ecfb8ae94f313921":["28288370235ed02234a64753cdbf0c6ec096304a"],"30c8e5574b55d57947e989443dfde611646530ee":["f2c10121be7f9dc2db5f9d4adc9ee6d30c6ad5ec","28288370235ed02234a64753cdbf0c6ec096304a"],"f2c10121be7f9dc2db5f9d4adc9ee6d30c6ad5ec":["e0aed040842b70826cfd518b076d58adcaede282"],"28288370235ed02234a64753cdbf0c6ec096304a":["f2c10121be7f9dc2db5f9d4adc9ee6d30c6ad5ec","5ff704ef91e9ae30ca59babb23ece85720701b60"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4aee4980038a10791618ea04e79233ce5cbf6607"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["f2c10121be7f9dc2db5f9d4adc9ee6d30c6ad5ec"]},"commit2Childs":{"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e0aed040842b70826cfd518b076d58adcaede282"],"4aee4980038a10791618ea04e79233ce5cbf6607":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e0aed040842b70826cfd518b076d58adcaede282":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","f2c10121be7f9dc2db5f9d4adc9ee6d30c6ad5ec"],"a91f19e3f7576973404e13b7ecfb8ae94f313921":["4aee4980038a10791618ea04e79233ce5cbf6607"],"30c8e5574b55d57947e989443dfde611646530ee":[],"f2c10121be7f9dc2db5f9d4adc9ee6d30c6ad5ec":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","30c8e5574b55d57947e989443dfde611646530ee","28288370235ed02234a64753cdbf0c6ec096304a","5ff704ef91e9ae30ca59babb23ece85720701b60"],"28288370235ed02234a64753cdbf0c6ec096304a":["4aee4980038a10791618ea04e79233ce5cbf6607","a91f19e3f7576973404e13b7ecfb8ae94f313921","30c8e5574b55d57947e989443dfde611646530ee"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}